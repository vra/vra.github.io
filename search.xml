<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Always blue——关于《硅谷》电视剧的一些想法</title>
    <url>/2019/12/16/always-blue/</url>
    <content><![CDATA[<h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><p>美剧硅谷完结了。<br>忘了从什么时候开始看的这部剧，只记得在研究生的那几年，和庆哥一起看过，周围貌似没有别的人在看。去年第五季等了很久，看完后以为没有下一季了，偶然在网上看到居然还有第六季，于是赶紧开始看，最后五六集实在是太精彩了，看得大呼过瘾。第七集，却又很伤感，那些演员们陪伴我们的欢笑时光，终究要结束了。</p>
<span id="more"></span>
<h2 id="Chater-2"><a href="#Chater-2" class="headerlink" title="Chater 2"></a>Chater 2</h2><p>为什么《硅谷》让我这么着迷呢，我想可能有这些原因。<br>首先是主角是一帮程序员，梦想着 ”Make the world a better place”, 这恰恰与许多人的想法一样。<br>另外很多程序员的日常梗被搬上屏幕，并且被夸张地演绎出来，极具喜感。<br>还有跌宕起伏的剧情，充满讽刺又倍感真实的场景。</p>
<h2 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h2><p>我总结了我感觉最搞笑的一些场景，作为对那些美好时光的纪念。</p>
<ol>
<li>大头当上了斯坦福大学校长，xswl</li>
<li>“This guy f*cks”</li>
<li>Tab和Space之争，其实还挺想Ritchard和那个FB的妹子在一起的，另外这是妹子的GitHub: <a href="https://github.com/Stitchpunk">https://github.com/Stitchpunk</a>，虽然是个fake帐号，不过已经1.9k follower了～</li>
<li>Jared 拿假枪打Ritchard屁股</li>
<li>Ritchard 踹门踹破了</li>
</ol>
<h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><p>彩蛋，一些技术细节和代码截屏</p>
<ol>
<li>Bill Gates 居然来客串了!</li>
<li>Boolmberg Emily Chang</li>
<li>伪纪录片</li>
</ol>
<h2 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h2><p>一些网站</p>
<ol>
<li>Hooli 官网： <a href="http://hooli.xyz/">http://hooli.xyz</a></li>
<li>Pied Piper 官网： <a href="http://www.piedpiper.com/">http://www.piedpiper.com</a></li>
</ol>
]]></content>
      <tags>
        <tag>杂项</tag>
        <tag>Programmer</tag>
      </tags>
  </entry>
  <entry>
    <title>argparse简要用法总结</title>
    <url>/2017/12/02/argparse-usage/</url>
    <content><![CDATA[<p><a href="https://docs.python.org/3/library/argparse.html">argparse</a> 是python自带的命令行参数解析包，可以用来方便地读取命令行参数，当你的代码需要频繁地修改参数的时候，使用这个工具可以将参数和代码分离开来，让你的代码更简洁，适用范围更广。<br>argparse使用比较简单，常用的功能可能较快地实现出来，下面我分几个步骤，<strong>以Python3为例</strong>，逐渐递增地讲述argparse的用法。  </p>
<span id="more"></span>

<h3 id="1-基本框架"><a href="#1-基本框架" class="headerlink" title="1. 基本框架"></a>1. 基本框架</h3><p>下面是使用argparse从命令行获取用户名，然后打印’Hello ‘+ 用户名，假设python文件名为<code>print_name.py</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file-name:print_name.py</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_parser</span>():</span></span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;Demo of argparse&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--name&#x27;</span>, default=<span class="string">&#x27;Great&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> parser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = get_parser()</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    name = args.name</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name))</span><br></pre></td></tr></table></figure>
<p>在命令行执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python print_name.py --name Wang</span><br><span class="line">Hello Wang</span><br></pre></td></tr></table></figure>
<p>上面的代码段中，我们显示引入了<code>argparse</code>包，然后通过<code>argparse.ArgumentParser</code>函数生成argparse对象，其中这个函数的<code>description</code>函数表示在命令行显示帮助信息的时候，这个程序的描述信息。之后我们通过对象的<code>add_argument</code>函数来增加参数。这里我们只增加了一个<code>--name</code>的参数，然后后面的<code>default</code>参数表示如果没提供参数，我们默认采用的值。即如果像下面这样执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python print_name.py </span><br></pre></td></tr></table></figure>
<p>则输出是:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ Hello Great</span><br></pre></td></tr></table></figure>
<p>最后我们通过argpaser对象的<code>parser_args</code>函数来获取所有参数<code>args</code>，然后通过<code>args.name</code>的方式得到我们设置的<code>--name</code>参数的值，可以看到这里argparse默认的参数名就是<code>--name</code>形式里面<code>--</code>后面的字符串。<br>整个流程就是这样，下面我们详细讲解<code>add_argument</code>函数的一些最常用的参数，使得你看完这个教程之后，能完成科研和工作中的大部分命令解析任务。  </p>
<h3 id="2-default：没有设置值情况下的默认参数"><a href="#2-default：没有设置值情况下的默认参数" class="headerlink" title="2. default：没有设置值情况下的默认参数"></a>2. <code>default</code>：没有设置值情况下的默认参数</h3><p>如同上例中展示的，default表示命令行没有设置该参数的时候，程序中用什么值来代替。</p>
<h3 id="3-required-表示这个参数是否一定需要设置"><a href="#3-required-表示这个参数是否一定需要设置" class="headerlink" title="3. required: 表示这个参数是否一定需要设置"></a>3. <code>required</code>: 表示这个参数是否一定需要设置</h3><p>如果设置了<code>required=True</code>,则在实际运行的时候不设置该参数将报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-name&#x27;</span>, required=<span class="literal">True</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>则运行下面的命令会报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python print_name.py</span><br><span class="line">usage: print_name.py [-h] --name NAME</span><br><span class="line">print_name.py: error: argument --name is required</span><br></pre></td></tr></table></figure>

<h3 id="4-type：参数类型"><a href="#4-type：参数类型" class="headerlink" title="4. type：参数类型"></a>4. <code>type</code>：参数类型</h3><p>默认的参数类型是str类型，如果你的程序需要一个整数或者布尔型参数，你需要设置<code>type=int</code>或<code>type=bool</code>，下面是一个打印平方的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#name: square.py</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_parser</span>():</span></span><br><span class="line">    parser = argparse.ArgumentParser(</span><br><span class="line">        description=<span class="string">&#x27;Calculate square of a given number&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-number&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = get_parser()</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    res = args.number ** <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;square of &#123;&#125; is &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(args.number, res))</span><br></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python square.py -number 5</span><br><span class="line">square of 5 is 25 </span><br></pre></td></tr></table></figure>

<h3 id="5-choices：参数值只能从几个选项里面选择"><a href="#5-choices：参数值只能从几个选项里面选择" class="headerlink" title="5. choices：参数值只能从几个选项里面选择"></a>5. <code>choices</code>：参数值只能从几个选项里面选择</h3><p>如下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file-name: choices.py</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_parser</span>():</span></span><br><span class="line">    parser = argparse.ArgumentParser(</span><br><span class="line">        description=<span class="string">&#x27;choices demo&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-arch&#x27;</span>, required=<span class="literal">True</span>, choices=[<span class="string">&#x27;alexnet&#x27;</span>, <span class="string">&#x27;vgg&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parser</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = get_parser()</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;the arch of CNN is &#x27;</span>.<span class="built_in">format</span>(args.arch))</span><br></pre></td></tr></table></figure>
<p>如果像下面这样执行会报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python choices.py -arch resnet</span><br><span class="line">usage: choices.py [-h] -arch &#123;alexnet,vgg&#125;</span><br><span class="line">choices.py: error: argument -arch: invalid choice: <span class="string">&#x27;resnet&#x27;</span> (choose from <span class="string">&#x27;alexnet&#x27;</span>, <span class="string">&#x27;vgg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>因为我们所给的<code>-arch</code>参数<code>resnet</code>不在备选的<code>choices</code>之中，所以会报错</p>
<h3 id="6-help：指定参数的说明信息"><a href="#6-help：指定参数的说明信息" class="headerlink" title="6. help：指定参数的说明信息"></a>6. <code>help</code>：指定参数的说明信息</h3><p>在现实帮助信息的时候，help参数的值可以给使用工具的人提供该参数是用来设置什么的说明，对于大型的项目，help参数和很有必要的，不然使用者不太明白每个参数的含义，增大了使用难度。<br>下面是个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file-name: help.py</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_parser</span>():</span></span><br><span class="line">    parser = argparse.ArgumentParser(</span><br><span class="line">        description=<span class="string">&#x27;help demo&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-arch&#x27;</span>, required=<span class="literal">True</span>, choices=[<span class="string">&#x27;alexnet&#x27;</span>, <span class="string">&#x27;vgg&#x27;</span>],</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;the architecture of CNN, at this time we only support alexnet and vgg.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = get_parser()</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;the arch of CNN is &#x27;</span>.<span class="built_in">format</span>(args.arch))</span><br></pre></td></tr></table></figure>
<p>在命令行加<code>-h</code>或<code>--help</code>参数运行该命令，获取帮助信息的时候，结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python help.py -h</span><br><span class="line">usage: help.py [-h] -arch &#123;alexnet,vgg&#125;</span><br><span class="line"></span><br><span class="line">choices demo</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>           show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  -arch &#123;alexnet,vgg&#125;  the architecture of CNN, at this time we only support</span><br><span class="line">                       alexnet and vgg.</span><br></pre></td></tr></table></figure>
<h3 id="7-dest：设置参数在代码中的变量名"><a href="#7-dest：设置参数在代码中的变量名" class="headerlink" title="7. dest：设置参数在代码中的变量名"></a>7. <code>dest</code>：设置参数在代码中的变量名</h3><p>argparse默认的变量名是<code>--</code>或<code>-</code>后面的字符串，但是你也可以通过<code>dest=xxx</code>来设置参数的变量名，然后在代码中用<code>args.xxx</code>来获取参数的值。</p>
<h3 id="8-nargs：-设置参数在使用可以提供的个数"><a href="#8-nargs：-设置参数在使用可以提供的个数" class="headerlink" title="8. nargs： 设置参数在使用可以提供的个数"></a>8. <code>nargs</code>： 设置参数在使用可以提供的个数</h3><p>使用方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-name&#x27;</span>, nargs=x)</span><br></pre></td></tr></table></figure>
<p>其中<code>x</code>的候选值和含义如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">值  含义</span><br><span class="line">N   参数的绝对个数（例如：3）</span><br><span class="line"><span class="string">&#x27;?&#x27;</span>   0或1个参数</span><br><span class="line"><span class="string">&#x27;*&#x27;</span>   0或所有参数</span><br><span class="line"><span class="string">&#x27;+&#x27;</span>   所有，并且至少一个参数</span><br></pre></td></tr></table></figure>
<p>如下例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file-name: nargs.py</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_parser</span>():</span></span><br><span class="line">    parser = argparse.ArgumentParser(</span><br><span class="line">        description=<span class="string">&#x27;nargs demo&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-name&#x27;</span>, required=<span class="literal">True</span>, nargs=<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = get_parser()</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    names = <span class="string">&#x27;, &#x27;</span>.join(args.name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello to &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(names))</span><br></pre></td></tr></table></figure>
<p>执行命令和结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python nargs.py -name A B C</span><br><span class="line">Hello to A, B, C</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<ol>
<li><a href="http://blog.xiayf.cn/2013/03/30/argparse/">http://blog.xiayf.cn/2013/03/30/argparse/</a></li>
<li><a href="https://docs.python.org/3/library/argparse.html">https://docs.python.org/3/library/argparse.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>加速国内访问 Arxiv 论文的一些方法</title>
    <url>/2020/03/01/arxiv-speedup/</url>
    <content><![CDATA[<p>arxiv 的 PDF 下载速度很慢，下面是一些加速方法。</p>
<h2 id="命令行直接下载"><a href="#命令行直接下载" class="headerlink" title="命令行直接下载"></a>命令行直接下载</h2><p>我们知道可以用<code>wget</code>命令下载一些网络文件， 不过arxiv 上的论文使用<code>wget</code>下载时需要加参数<code>--user-agent=Lynx</code>，速度才能较快，下面是使用的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --user-agent=Lynx https://arxiv.org/pdf/1911.05722.pdf</span><br></pre></td></tr></table></figure>
<p>上述命令需要在Linux或者WSL的命令行中执行。</p>
<h2 id="修改网址"><a href="#修改网址" class="headerlink" title="修改网址"></a>修改网址</h2><p>一种方法是将<code>https://arxiv.org</code>改成 <code>http://xxx.itp.ac.cn</code>，后面内容不变，速度飞快。<br>还有一种方式是将<code>https://arxiv.org</code>改成<code>http://cn.arxiv.org</code>，后面网址内容不变，不过这个方法有时候并不work，因此推荐上一种方法。</p>
<p>更多方法可以参考知乎上的<a href="https://www.zhihu.com/question/58912862">这个问题</a>。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>back-to-landscape——博客迁移记录2021</title>
    <url>/2021/09/04/back-to-landscape/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>2019年的时候，写了一篇<a href="https://vra.github.io/2019/02/27/mv-to-next/">博客</a>来记录博客历史的迁移记录，这两年又经过工作变化、硬盘损坏，博客也是几经变迁。</p>
<p>尝试了基于Go的hugo框架，总体美观度和Hexo还是没法比，因此还是切换回了Hexo，换用了默认的landscape主题，重心放到有效的内容的记录上。评论系统还是采用valine，而在landscape下，设置valine还比Next复杂一些，我从<a href="http://hypo1986.com/blog/2019/06/10/hexo-landscape-add-valine/">这里</a> 看到除了配置landscape项目，还需要在ejs文件里面设置，这里记录下。</p>
<span id="more"></span>

<h2 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h2><p>修改主题config 文件 <code>HEXO_ROOT/themes/landscape/_config.yml</code>, 添加下面内容:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># valine comment system. https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># if you want use valine,please set this value is true</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="string">wwwwweirowjreojwreoz</span> <span class="comment"># leancloud application app id</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="string">weiojwoerjoerj#</span> <span class="string">leancloud</span> <span class="string">application</span> <span class="string">app</span> <span class="string">key</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># valine mail notify (true/false) https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># valine verify code (true/false)</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># comment list page size</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># gravatar style https://valine.js.org/#/avatar</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">zh-cn</span> <span class="comment"># i18n: zh-cn/en</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">欢迎留言交流~~</span> <span class="comment"># valine comment input placeholder(like: Please leave your footprints )</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment">#valine comment header info</span></span><br></pre></td></tr></table></figure>
<p>appid 和 appkey 从 leancloud 网站获取.</p>
<p>修改ejs文件<code>HEXO_ROOT/themes/landscape/layout/_partial/after-footer.ejs</code>，添加下面内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span>(theme.valine.enable &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey)&#123; %&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/valine/dist/Valine.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> GUEST_INFO = [<span class="string">&#x27;nick&#x27;</span>,<span class="string">&#x27;mail&#x27;</span>,<span class="string">&#x27;link&#x27;</span>];</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> guest_info = <span class="string">&#x27;&lt;%= theme.valine.guest_info %&gt;&#x27;</span>.split(<span class="string">&#x27;,&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span> GUEST_INFO.indexOf(item) &gt; -<span class="number">1</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> notify = <span class="string">&#x27;&lt;%= theme.valine.notify %&gt;&#x27;</span> == <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> verify = <span class="string">&#x27;&lt;%= theme.valine.verify %&gt;&#x27;</span> == <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">new</span> Valine(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">el</span>: <span class="string">&#x27;.vcomment&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">notify</span>: notify,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">verify</span>: verify,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">appId</span>: <span class="string">&quot;&lt;%= theme.valine.appid %&gt;&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">appKey</span>: <span class="string">&quot;&lt;%= theme.valine.appkey %&gt;&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">placeholder</span>: <span class="string">&quot;&lt;%= theme.valine.placeholder %&gt;&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">pageSize</span>: <span class="string">&#x27;&lt;%= theme.valine.pageSize %&gt;&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">avatar</span>: <span class="string">&#x27;&lt;%= theme.valine.avatar %&gt;&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">lang</span>: <span class="string">&#x27;&lt;%= theme.valine.lang %&gt;&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">visitor</span>: <span class="string">&#x27;true&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<p>修改<code>HEXO_ROOT/themes/landscape/layout/_partial/article.ejs</code> 文件，最后添加下面内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (!index &amp;&amp; post.comments &amp;&amp; theme.valine.enable &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey)&#123; %&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;comments&quot;</span> <span class="attr">class</span>=<span class="string">&quot;vcomment&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>




]]></content>
      <tags>
        <tag>总结</tag>
        <tag>迁移记录</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Begin Again</title>
    <url>/2018/10/21/begin-agin-2018/</url>
    <content><![CDATA[<p>自从今年七月份工作后，就一直没有更新过博客，之前坚持了一年多的每个月写一篇博客的记录也被打断了，一方面是因为工作太忙了，另一方面是因为自己做的都是一些项目相关的东西，没什么可以写的，只有论文分享比较合适，不过我也没有看太多论文……这周末将之前的MarkDown文件整理了下，将七牛云上没法访问的图片迁移到了Hexo项目的<code>img</code>目录下（具体做法可以参考<a href="https://github.com/qiniu/qshell/issues/188#issuecomment-430862857">这里</a>），因为GitHub的学生优惠也到期了，没法创建私有仓库，所以以后会将blog的源文件托管到GitLab.com上，一切准备妥当，Begin Again!</p>
]]></content>
      <tags>
        <tag>总结</tag>
        <tag>迁移记录</tag>
      </tags>
  </entry>
  <entry>
    <title>博客迁移记录</title>
    <url>/2015/06/02/blog-transfer-record/</url>
    <content><![CDATA[<p>前几天，我把原先部署在科大lug服务器上的wordpress<a href="http://vra.blog.ustc.edu.cn/">博客</a>迁移到了github上，也就是现在这个网站。</p>
<h2 id="2015-7-31日更新"><a href="#2015-7-31日更新" class="headerlink" title="2015-7-31日更新"></a>2015-7-31日更新</h2><p>前一段时间，我的Ubuntu系统突然出现问题，开机进入系统后，只显示桌面，侧边烂和其他内容都不显示，重启好几次也没用，这时候啥都干不了了，系统里面的内容也没法备份。没办法我就重装了个Debian系统，而原先系统的内容全部丢失T_T，连同我的保存在本地的markdown格式的博客内容。  </p>
<p>我原本以为github上也许有md格式的博客内容，然而并没有，只有转化为<code>html</code>格式的内容。所以我只能从html文件里面手动恢复出md格式的文件，然后再贴到网上，这几乎花费了我一整天的时间，所以以后要吸取教训，要么进行备份，要么采用多站共同部署的方法（如在gitcafe上同样部署一份博客内容），保证内容不丢失。</p>
<span id="more"></span>

<h2 id="首先推广下我们学校的LUG服务"><a href="#首先推广下我们学校的LUG服务" class="headerlink" title="首先推广下我们学校的LUG服务,:)"></a>首先推广下我们学校的LUG服务,:)</h2><p>中科大LUG协会主页：<a href="http://lug.ustc.edu.cn/">http://lug.ustc.edu.cn</a>由校园里技术实力很强的一些学生和已经离校工作或去别的地方深造的技术大牛组成，为本校学生和外校人员提供了许多很有用的服务，包括<a href="http://mirrors.ustc.edu.cn/">开源软件镜像网站mirrors</a>,Linux 虚拟主机<a href="http://freeshell.ustc.edu.cn/">freeshell</a>，<a href="https://blog.ustc.edu.cn/">科大博客</a>，代码托管站点<a href="https://gitlab.lug.ustc.edu.cn/">gitlab</a>等等。这些服务的主机主要是靠学校提供或实验室捐赠，大多都比较老旧，而且维护人员都是边进行学业边维护的。在如此艰难的情境下还是为我们提供了高质量的服务，真的很感谢USTC LUG的同学们！</p>
<h2 id="wordpress博客的一些问题"><a href="#wordpress博客的一些问题" class="headerlink" title="wordpress博客的一些问题"></a>wordpress博客的一些问题</h2><p>我在使用科大博客的时候，发现了一些wordpress存在的问题，而且由于我对网站开发这方面不是很懂，所以没法解决，每次都用很笨的办法搞定，很浪费时间，有的时候也没法可想。我遇到的问题有下面几个</p>
<ol>
<li>HTML转义字符的问题<br>在博客中的代码段的标签符号，如&lt;，&gt;，&amp;都会被转义为相应的标记。被这个问题困扰了很久，但都没找到好的解决方法。</li>
<li>使用markdown插件编辑代码时，``` 标记转化为代码的时候总是会多出来一个` ，代码段看起来很丑。</li>
<li>wordpress插件和主题经常需要更新，比较烦。。。</li>
</ol>
<p>wordpress是动态博客框架，而我的博客内容大多是一些平时学习总结，做个静态的博客即可，既加快了访问速度，又省去了wordpress庞大的框架。</p>
<h2 id="结缘Hexo"><a href="#结缘Hexo" class="headerlink" title="结缘Hexo"></a>结缘Hexo</h2><p>在这学期的LuG小聚活动中，有一次有一个同学讲了关于静态博客Hexo的内容，发现Hexo优点多多，框架轻巧，部署简单，界面美观，而且有插件能方便地迁入或迁出。于是渐渐地，心向往之。</p>
<h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>前几天我打算写点关于Sublime Text编辑器使用总结的博客，在wordpress里面写的时候，上面提到的问题又困扰我来了，没办法，我试着在网上找了些在github上部署hexo的资料，尝试这把博客内容都迁移到github上。</p>
<ol>
<li>将Hexo部署到github上</li>
<li>通过插件将wordpress内容迁移过来</li>
<li>调整迁移过程中出现问题的博客内容</li>
<li>换了一个pacman的主题</li>
<li>又换了个jacman的主题，由心灵手巧、多才多艺的女票设计了博客的logo</li>
</ol>
<p>于是，这个网站就建好了～</p>
<h2 id="hexo的问题"><a href="#hexo的问题" class="headerlink" title="hexo的问题"></a>hexo的问题</h2><p>Hexo的博客内容都是以markdown文件保存在本地，所以就没法在别的系统或环境下修改博客了。我尝试了修改github.io的respository内容，但都会在下次在本地部署时被覆盖掉，所以对于使用双系统的情况，就没法在多处修改博客内容了。</p>
]]></content>
      <tags>
        <tag>博客备忘</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11新特性概览</title>
    <url>/2017/01/09/c-11-summary/</url>
    <content><![CDATA[<p>今天买的《C++ Primer 第五版》到了，这一版本一个比较好的地方是。在开始的目录里面列出来了全书中涉及到的C++11新特性的地方，标明了页码，可以直接到对应的页面去看新特性的东西。于是我对照书上的例子，写了一些简单的示例，用来大概的了解C++11的新特性，总结在这里，以后可以查查。</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">100</span>;&#125; <span class="comment">// constexpr function, compiler will convert it to inline function </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(initializer_list&lt;<span class="keyword">int</span>&gt; li)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func with &quot;</span> &lt;&lt; li.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;elements&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ll = <span class="number">64</span>; <span class="comment">//long long: 64 bit at least</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2. list initialization</span></span><br><span class="line">	<span class="keyword">int</span> a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> bb&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3. nullptr, a new literal</span></span><br><span class="line">	<span class="keyword">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="comment">//equals to </span></span><br><span class="line">	<span class="keyword">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> *p3 = <span class="literal">NULL</span>;<span class="comment">// must include &lt;cstdlib&gt; first</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4. constexpr</span></span><br><span class="line">	<span class="keyword">constexpr</span> <span class="keyword">int</span> ci = <span class="number">30</span>;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="keyword">float</span> cf = ci * <span class="number">0.2</span>;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="keyword">int</span> sz = <span class="built_in">size</span>(); <span class="comment">// it&#x27;s ok to initialize a constexpr value using constexpr function</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//5. alias declaration</span></span><br><span class="line">	<span class="keyword">using</span> my_int = <span class="keyword">int</span>;</span><br><span class="line">	my_int i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> vi = vector&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">	vi v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> it = vector&lt;<span class="keyword">int</span>&gt;::iterator;</span><br><span class="line">	<span class="keyword">for</span> (it it_i = v.<span class="built_in">begin</span>(); it_i != v.<span class="built_in">end</span>(); ++it_i) &#123;</span><br><span class="line">		cout &lt;&lt; *it_i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//6. auto</span></span><br><span class="line">	<span class="keyword">auto</span> aa = <span class="number">3</span>; <span class="comment">// compiler will infer that a&#x27;s type is int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//7.decltype</span></span><br><span class="line">	<span class="keyword">decltype</span>(i) id1 = <span class="number">0</span>; <span class="comment">// id1 has the same type with i</span></span><br><span class="line">	<span class="keyword">decltype</span>((i)) id2 = id1; <span class="comment">// <span class="doctag">NOTE:</span> (var) returns reference! so id2 is a reference to id1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//7. in-class initializer </span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	struct my_struct &#123;</span></span><br><span class="line"><span class="comment">		int i = 0;</span></span><br><span class="line"><span class="comment">		int b = 2;</span></span><br><span class="line"><span class="comment">		string s;</span></span><br><span class="line"><span class="comment">	&#125;;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//8. range for</span></span><br><span class="line">	string hello = <span class="string">&quot;hello, world!&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> c : hello) &#123;</span><br><span class="line">		cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//9. vector of vector, no space anymore!</span></span><br><span class="line">	<span class="comment">//before:</span></span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; vv1; </span><br><span class="line">	<span class="comment">//now:</span></span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; vv2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//10. cbegin, cend, return const_iterator don&#x27;t care if container is const</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vi10 = &#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">54</span>&#125;;</span><br><span class="line">	<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; cvi10 = &#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">54</span>&#125;;</span><br><span class="line">	<span class="keyword">auto</span> it10 = vi10.<span class="built_in">cbegin</span>(); <span class="comment">// it10: const_iterator type</span></span><br><span class="line">	<span class="keyword">auto</span> cit10 = cvi10.<span class="built_in">cbegin</span>(); <span class="comment">// cit10: const_iterator type</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//11. begin and end of pointer, included in &lt;iterator&gt;</span></span><br><span class="line">	<span class="keyword">int</span> ia[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="built_in">begin</span>(ia);</span><br><span class="line">	<span class="keyword">int</span> *e = <span class="built_in">end</span>(ia);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//12. initializer_list</span></span><br><span class="line">	<span class="built_in">func</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//13. trailing return type</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	auto func(int i) -&gt; int(*)[10];</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//14. =default: don&#x27;t replace default initializer function</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	class A &#123;</span></span><br><span class="line"><span class="comment">		public:</span></span><br><span class="line"><span class="comment">		A() = default;</span></span><br><span class="line"><span class="comment">	&#125;;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//15. delegating constructor</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	class A &#123;</span></span><br><span class="line"><span class="comment">	  public:</span></span><br><span class="line"><span class="comment">		A(int i, float f, double d):ii(i), ff(f), dd(d) &#123;&#125;</span></span><br><span class="line"><span class="comment">		A(int i, float f): A(i, f, 0) &#123;&#125;</span></span><br><span class="line"><span class="comment">		A(int i): A(i, 0, 0) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  private:</span></span><br><span class="line"><span class="comment">		int ii;</span></span><br><span class="line"><span class="comment">		float ff;</span></span><br><span class="line"><span class="comment">		double dd;</span></span><br><span class="line"><span class="comment">	&#125;;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//16. array </span></span><br><span class="line">	array&lt;<span class="keyword">int</span>, 3&gt; a1 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">auto</span> aa1 = a1.<span class="built_in">begin</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//17.forward_list</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//18. emplace</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//19. shrink_to_fit</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//20. to_string</span></span><br><span class="line">	<span class="keyword">int</span> i20 = <span class="number">233</span>;</span><br><span class="line">	string s20 = <span class="built_in">to_string</span>(i20);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//21. lambda </span></span><br><span class="line">	<span class="keyword">auto</span> f211 = [] () &#123;<span class="keyword">return</span> <span class="number">23</span>;&#125;;</span><br><span class="line">	<span class="keyword">auto</span> f212 = [i20]() &#123;<span class="keyword">return</span> i20 &gt; <span class="number">20</span>;&#125;;</span><br><span class="line">	<span class="keyword">auto</span> f213 = [i20]() -&gt; <span class="keyword">int</span> &#123;<span class="keyword">if</span>(i20&gt; <span class="number">20</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//22. bind, included in &lt;functional&gt;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	int f(int a, int b) &#123;</span></span><br><span class="line"><span class="comment">		return a&gt;b ? a : b;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	auto g = bind(f, _1, 10);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//23. unordered associative container, managed by hash</span></span><br><span class="line">	<span class="comment">//including unordered_map, unordered_set, unordered_multimap, unordered_multiset</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//24. smart pointer,including shared_ptr, unique_ptr, weak_ptr</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//25. rvalue reference</span></span><br><span class="line">	<span class="keyword">int</span> i25 = <span class="number">42</span>; </span><br><span class="line">	<span class="keyword">int</span> &amp;&amp; rr = i25*<span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ERROR: variable is lvalue</span></span><br><span class="line">	<span class="comment">//int &amp;&amp;rr2 = rr;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//26. std::move</span></span><br><span class="line">	<span class="keyword">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//27. noexcept,use for moving copy or moving operator</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//28. reference qualifier</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	class A&#123;</span></span><br><span class="line"><span class="comment">	  public:</span></span><br><span class="line"><span class="comment">	  	A sorted() &amp;&amp;; //rvalue reference</span></span><br><span class="line"><span class="comment">		A sorted() &amp;; //lvalue reference</span></span><br><span class="line"><span class="comment">	&#125;;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//29. function template, included in &lt;functional&gt;</span></span><br><span class="line">	<span class="comment">//function&lt;int(int, int)&gt; f1 = add; //add is a function declared before</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//30. explicit conversion operator</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	class A &#123;</span></span><br><span class="line"><span class="comment">		explicit operator int() const &#123;return val;&#125;;</span></span><br><span class="line"><span class="comment">	&#125;;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//31. final to prevent inherit</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Last</span> <span class="keyword">final</span> &#123;</span>&#125;; <span class="comment">// Last can&#x27;t be a basic class</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//32.override: override virtual functions in parents class</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//33. tuple</span></span><br><span class="line">	tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; tt&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	<span class="keyword">auto</span> tt1 = get&lt;<span class="number">0</span>&gt;(tt);</span><br><span class="line">	<span class="keyword">auto</span> tt2 = get&lt;<span class="number">1</span>&gt;(tt);</span><br><span class="line">	<span class="keyword">auto</span> tt3 = get&lt;<span class="number">2</span>&gt;(tt);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>我关注的一些独立技术博客</title>
    <url>/2021/08/21/blog-list/</url>
    <content><![CDATA[<p>这里列出了我平时关注的一些技术博客列表，希望给看到这个页面的你一些新的知识来源：</p>
<ol>
<li><a href="https://ruanyifeng.com/">https://ruanyifeng.com/</a> 阮一峰的网络日志，应该不需要我介绍他是谁了吧</li>
<li><a href="https://ring0.me/">https://ring0.me/</a> 科大师兄的网站</li>
<li><a href="http://blog.devtang.com/">http://blog.devtang.com/</a> </li>
<li><a href="https://www.yejianye.com/">https://www.yejianye.com/</a></li>
<li><a href="https://ewind.us/">https://ewind.us/</a></li>
<li><a href="https://www.barretlee.com/entry/">https://www.barretlee.com/entry/</a></li>
<li><a href="https://www.hahack.com/">https://www.hahack.com/</a></li>
</ol>
<p>另外发现，最近大家不怎么更新自己的博客了，至于为什么，我想了几个可能的原因。</p>
<p>一个是缺少来自用户的反馈，或者激励。大部分博客，来自读者的反馈少，不像知乎，微信公众号，有方便及时的用户反馈和激励（点赞，在看，收藏)，反馈少对作者写作的积极性应该还是很有很大影响的。</p>
<p>另一个是写博客还是有一定成本的。自己搭建的博客，需要自己维护环境，不像公众号和知乎，打开网页就能写，实时保存草稿。</p>
<p>在中文互联网越来越碎片化和圈地化的今天，希望独立的技术博客能给我们带来新的思路，新的启发，新的激动人心的东西。</p>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>C3D Usage Summary</title>
    <url>/2016/03/03/c3d-use/</url>
    <content><![CDATA[<p><a href="https://github.com/facebook/C3D">C3D</a> is a deep learning tool which is modified version of BVLC <a href="https://github.com/BVLC/caffe">caffe</a> to support 3D convolution and pooling. it was released by Facebook. In the field of human action recognition, C3D feature of video clip is the state-of-the-art feature. In this blog, I write some notes for using this tool in practice.  </p>
<span id="more"></span>
<h2 id="1-Compile-C3D"><a href="#1-Compile-C3D" class="headerlink" title="1. Compile C3D"></a>1. Compile C3D</h2><ol>
<li><p>Clone C3D from github:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/facebook/</span>C3D.git</span><br></pre></td></tr></table></figure></li>
<li><p>Compile it:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">cp <span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span>config.example <span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span>config</span><br><span class="line">#adapt makefile according <span class="keyword">to</span> configuration <span class="keyword">of</span> your machine, <span class="keyword">for</span> example, change atblas <span class="keyword">to</span> mkl</span><br><span class="line">make all -j <span class="number">32</span> </span><br></pre></td></tr></table></figure>
<p>  <code>-j 32</code> means use 32 cores to compile it in parallel.</p>
</li>
</ol>
<pre><code>When something goes wrong, search the Internet, find a solution and update your makefile.    
</code></pre>
<ol start="3">
<li>Test whether the compilation is finished correctly.  <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#assume you are at C3D root directory right now  </span></span><br><span class="line"><span class="attribute">cd</span> examples/c<span class="number">3</span>d_feature_extraction  </span><br><span class="line"><span class="comment">#download trained sport1m caffemodel from net  </span></span><br><span class="line"><span class="attribute">sh</span> c<span class="number">3</span>d_sport<span class="number">1</span>m_feature_extraction_frm.sh  </span><br></pre></td></tr></table></figure>
<pre><code> If the command above runs correctly, your compilation is successful!  
</code></pre>
</li>
</ol>
<h2 id="2-Use-C3D-to-extract-feature-of-UCF101-video-dataset"><a href="#2-Use-C3D-to-extract-feature-of-UCF101-video-dataset" class="headerlink" title="2. Use C3D to extract feature of UCF101 video dataset"></a>2. Use C3D to extract feature of UCF101 video dataset</h2><ol>
<li>Get the dataset and write list files<br> First download UCF101 dataset from <a href="http://crcv.ucf.edu/data/UCF101.php">http://crcv.ucf.edu/data/UCF101.php</a>, and then write list files. Since C3D can read video clips and frames of videos, you can write input list file and output list file in both way. For frame format, you need  to transform video to frames firstly, I use ffmpeg to do this job:</li>
</ol>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">ffmpeg -<span class="selector-tag">i</span> &quot;/path/<span class="selector-tag">to</span>/<span class="selector-tag">video</span>&quot; &quot;/path/<span class="selector-tag">to</span>/frm/dir/%<span class="number">06</span>d<span class="selector-class">.jpg</span>&quot;</span><br></pre></td></tr></table></figure>
<pre><code> The input list file contains the paths to video clips or frames, the output list file contains the path where to save the features.

 The format of input list file is like this:  

 `&lt;string_path&gt; &lt;starting_frame&gt; &lt;label&gt;`  

 for example, `/home/yunfeng/dataset/ucf101/ucf101_frm/YoYo/v_YoYo_g23_c01/ 1 100`  
 **NOTE: for video clip, `starting_frame` starts from 0, but for frames, it starts from 1.**  

 the format of output list file is like this:  
 `&lt;output_folder&gt;`  
 for example, `/output/c3d/YoYo//v_YoYo_g23_c01/000001`  
</code></pre>
<ol start="2">
<li>Create output directory YOURSElF<br> <strong>NOTE: C3D does not create directories in output list file, you must create them yourself.</strong>   There is a simple way: since we have path to target directory in output list file, we can use it:  </li>
</ol>
 <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">#assume you are at C3D root directory <span class="keyword">right</span> now</span><br><span class="line"><span class="number">1</span>. <span class="keyword">cd</span> examples/c3d_feature_extraction</span><br><span class="line"><span class="number">2</span>. <span class="keyword">cp</span> prototxt/output_list_prefix.txt create_dir.<span class="keyword">sh</span></span><br><span class="line"><span class="number">3</span>. <span class="keyword">vi</span> create_dir.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<pre><code> In vi, do two steps to change diretories to shell commands:
</code></pre>
 <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">:<span class="number">0</span>,<span class="variable">$s</span><span class="regexp">/\/\d\+/</span>\<span class="regexp">//g</span> <span class="comment"># remove the number at the end of each line.</span></span><br><span class="line">:<span class="number">0</span>,<span class="variable">$s</span><span class="regexp">/output/m</span>kdir -p output/g <span class="comment"># add `mkdir -p` command at the head of each line.</span></span><br></pre></td></tr></table></figure>
<pre><code> then run the command to create directories:
</code></pre>
 <figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sh</span> create_dir.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>Use tools to extract features<br> After finishing first step, you need to write a prototxt file. Fortunately, there is a example file in the directory: <code>prototxt/c3d_sport1m_feature_extractor_frm.prototxt</code>, you can adapt it to have right access to input list file.  </li>
</ol>
<pre><code> We use tool named `extract_image_features.bin` in `build/tools` directory to extract features, the usage of it is 
</code></pre>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> extract_image_features.bin <span class="tag">&lt;<span class="name">feature_extractor_prototxt_file</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">c3d_pre_trained_model</span>&gt;</span> <span class="tag">&lt;<span class="name">gpu_id</span>&gt;</span> <span class="tag">&lt;<span class="name">mini_batch_size</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">number_of_mini_batches</span>&gt;</span> <span class="tag">&lt;<span class="name">output_prefix_file</span>&gt;</span> <span class="tag">&lt;<span class="name">feature_name1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">feature_name2</span>&gt;</span> ... </span><br></pre></td></tr></table></figure>
<pre><code> We can use command below to extract feature:
</code></pre>
 <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">GLOG_logtosterr</span>=<span class="number">1</span> ../../build/tools/extract_image_features.bin</span><br><span class="line"><span class="attribute">prototxt</span>/c<span class="number">3</span>d_sport<span class="number">1</span>m_feature_extractor_frm.prototxt </span><br><span class="line"><span class="attribute">conv3d_deepnetA_sport1m_iter_1900000</span> <span class="number">0</span> <span class="number">50</span> <span class="number">1</span> </span><br><span class="line"><span class="attribute">prototxt</span>/output_list_prefix.txt fc<span class="number">7</span>­<span class="number">1</span> fc<span class="number">6</span>­<span class="number">1</span> prob </span><br></pre></td></tr></table></figure>
<p> After extraction of feature, we can use matlab code in <code>script</code> subdirectory of <code>example/c3d_feature_extraction</code> to do further job. There are two matlab files in <code>script</code>, <code>read_binary_blob.m</code>, <code>read_binary_blob_preserve_shape.m</code>. There are used to transform features into binary blob data, We can use these two functions for further analysis of features.</p>
<h2 id="3-Train-3D-convolution-neural-network"><a href="#3-Train-3D-convolution-neural-network" class="headerlink" title="3. Train 3D convolution neural network"></a>3. Train 3D convolution neural network</h2><p>Since C3D is a fork of <a href="http://github.com/bvlc/caffe.git">Caffe</a>, which is a fast open framework for deep learning, We can use C3D to train deep networks. You can train from scratch or fine-tune C3D on your own dataset.</p>
<ol>
<li>   Train from scratch</li>
</ol>
<pre><code> C3D offers some useful shell scripts to simplify our job, we can read the scripts and adapt it according our tasks.

 **NOTE: you must adapt the shell scripts to ensure that every parameter is correct for your task!**

the schedule of training from scratch is(assuming we are training on ucf101):
</code></pre>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#assume you are at C3D root directory right now</span></span><br><span class="line">1. <span class="built_in">cd</span> examples/c3d_train_ucf101</span><br><span class="line">2. sh create_volume_means.sh <span class="comment"># compute the mean file of your dataset</span></span><br><span class="line">3. sh train_ucf101.sh <span class="comment"># train from scratch </span></span><br><span class="line">4. test_ucf101.sh <span class="comment"># test the accuracy of training</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Fine-Tune on C3D First you have to download pretrained model, then you can do fine-tuning like this:</li>
</ol>
 <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#assume you are at C3D root directory right now</span></span><br><span class="line"><span class="attribute">1</span>. cd examples/c<span class="number">3</span>d_finetuning</span><br><span class="line"><span class="attribute">2</span>. sh ucf<span class="number">101</span>_finetuning.sh</span><br><span class="line"><span class="attribute">3</span>. sh ucf<span class="number">101</span>_testing.sh</span><br></pre></td></tr></table></figure>


<h2 id="4-Classify-C3D-feature-using-SVM"><a href="#4-Classify-C3D-feature-using-SVM" class="headerlink" title="4.Classify C3D feature using SVM"></a>4.Classify C3D feature using SVM</h2><p>After extracting features for batchs in each video using C3D tools, in orde to use SVM to classify the videos, we must get a descriptor for each video. We average the c3d features for each video, i.e., sum up those 4096 dimension’s data and calculate the mean of them. I use matlab code below to do this job(using offered funtion <code>read_binary_blob</code>):</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[]</span>= <span class="title">read_ucf101_c3d_feat</span><span class="params">(output_list_relative)</span></span></span><br><span class="line"><span class="comment">% Read c3d features (fc6) for videos in ucf101 dataset.</span></span><br><span class="line"><span class="comment">% For each video, average all its features and get a video descriptor.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% rather than fileread, importdata save each line separetely.</span></span><br><span class="line">    dir_list = importdata(output_list_relative);</span><br><span class="line"></span><br><span class="line">    dim_feat = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(dir_list, <span class="number">1</span>)</span><br><span class="line">        dir_str = char(dir_list(<span class="built_in">i</span>));</span><br><span class="line">        feat_files = dir([dir_str, <span class="string">&#x27;/*.fc6-1&#x27;</span>]);</span><br><span class="line">        num_feat = <span class="built_in">length</span>(feat_files);</span><br><span class="line">        feat = <span class="built_in">zeros</span>(num_feat, dim_feat);</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span> : num_feat</span><br><span class="line">            feat_path = strcat(dir_str, <span class="string">&#x27;/&#x27;</span>, feat_files(<span class="built_in">j</span>).name);</span><br><span class="line">            [~, feat(<span class="built_in">j</span>,:)] = read_binary_blob(feat_path);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        avg_feat = <span class="built_in">mean</span>(feat, <span class="number">1</span>);</span><br><span class="line">        avg_feat_double = double(avg_feat);</span><br><span class="line">        fID = fopen(strcat(dir_str, <span class="string">&#x27;/c3d.fc6&#x27;</span>), <span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">		<span class="comment">% libsvm requires that input data must be double</span></span><br><span class="line">        fwrite(fID, avg_feat_double, <span class="string">&#x27;double&#x27;</span>);</span><br><span class="line">        fclose(fID);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>The input parameter is the file each line is a relative path to each video frames from the location of script. for example:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">..<span class="regexp">/output/</span>c3d<span class="regexp">/ApplyEyeMakeup/</span>v_ApplyEyeMakeup_g01_c01</span><br></pre></td></tr></table></figure>
<p>It takes about ten minutes to run this script.  </p>
<p>When use libsvm to classify video features, there are two phases: training and testing. The declaration of training and testing functions are: </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">model = libsvmtrain(train_label_vector, train_data_matrix, options);</span><br><span class="line">[label, accuracy, prob] = libsvmpredict(test_label_vector, test_data_matrix, model, options);</span><br></pre></td></tr></table></figure>
<p><code>train_label_vector</code> is a m by 1 vector, each element is a double value. <code>train_data_matrix</code> is a m by n matrix, each row is the data of one video. It is similar for predicting function.  </p>
<p>In order to construct input data in right way, I write several  wrapper functions for training and testing, which is more convenient to running:</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% create_svm_input_data.m</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[data_matrix]</span> = <span class="title">create_svm_input_data</span><span class="params">(output_list_train)</span></span></span><br><span class="line"><span class="comment">% read the c3d feature(fc6) for each video, construct libsvm format data.</span></span><br><span class="line"></span><br><span class="line">    dim_feat = <span class="number">4096</span>;</span><br><span class="line">    dir_list = importdata(output_list_train);</span><br><span class="line">    num_train_video = <span class="built_in">size</span>(dir_list, <span class="number">1</span>);</span><br><span class="line">    data_matrix = <span class="built_in">zeros</span>(num_train_video, dim_feat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : num_train_video</span><br><span class="line">        feat_path = strcat(char(dir_list(<span class="built_in">i</span>)), <span class="string">&#x27;/c3d.fc6&#x27;</span>);</span><br><span class="line">        fid = fopen(feat_path, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">        data = fread(fid, <span class="string">&#x27;double&#x27;</span>);</span><br><span class="line">        fclose(fid);</span><br><span class="line"></span><br><span class="line">        normed_data = data / norm(data);</span><br><span class="line">        data_matrix(<span class="built_in">i</span>, :) = normed_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>The <code>output_list_train</code> is the file contains relative path to each video directory. like:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">../output/c3d/YoYo/v_YoYo_g07_c02</span><br></pre></td></tr></table></figure>
<p>And then there is the file to train svm:</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% train_ucf101.m</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[model]</span> = <span class="title">train_ucf101</span><span class="params">(label_file_path, data_file_path, varargin)</span></span></span><br><span class="line">    label_int = load(label_file_path);</span><br><span class="line">    label_double = double(label_int);</span><br><span class="line">    data = create_svm_input_data(data_file_path);</span><br><span class="line">    model = libsvmtrain(label_double, data, varargin&#123;:&#125;);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>The <code>label_file_path</code> is the complete path to the file contains all training labels, including the file name, for example, <code>label_file_path</code> can be:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/data/foo/training_label.txt</span><br></pre></td></tr></table></figure>
<p>And each line in <code>training_label.txt</code> contains only one label, for example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># training_label.txt</span></span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>There is the matlab file to test svm:</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% test_ucf101.m</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[label, accuracy, predict_prob]</span> = <span class="title">test_ucf101</span><span class="params">(test_label_path, test_data_path, model, varargin)</span></span></span><br><span class="line">    label_int = load(test_label_path);</span><br><span class="line">    label_double = double(label_int);</span><br><span class="line">    label_size = <span class="built_in">size</span>(label_double)</span><br><span class="line">    data = create_svm_input_data(test_data_path);</span><br><span class="line">    data_size = <span class="built_in">size</span>(data)</span><br><span class="line">    [label, accuracy, predict_prob] = libsvmpredict(label_double, data, model, varargin&#123;:&#125;);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>Note we can use <code>varagin</code> to pass parameters from a wrapper function to an internal function.</p>
<h2 id="5-Reference"><a href="#5-Reference" class="headerlink" title="5.Reference"></a>5.Reference</h2><ol>
<li><a href="https://docs.google.com/document/d/1-QqZ3JHd76JfimY4QKqOojcEaf5g3JS0lNh-FHTxLag/edit">C3D User Guide</a>.</li>
<li><a href="https://www.csie.ntu.edu.tw/~cjlin/libsvm/">LIBSVM</a>.</li>
</ol>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
        <tag>Caffe</tag>
      </tags>
  </entry>
  <entry>
    <title>caffe compilation troubleshooting</title>
    <url>/2016/04/13/caffe-compile/</url>
    <content><![CDATA[<h2 id="Issue-1"><a href="#Issue-1" class="headerlink" title="Issue 1"></a>Issue 1</h2><p>When I compile caffe toolkit(actually, a caffe fork: lisa-caffe-public), I always encounter some errors like:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Tab found; better use space</span><br><span class="line">Line should be &lt;= 80 characters</span><br><span class="line">Missing space before ( <span class="keyword">in</span> <span class="keyword">if</span>( </span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>At the beginning, I thought these warnings  were caused by gcc/g++, so I googled but found few result about this question.<br>Then I read the manual of gcc. In the manual, I found some useful information:</p>
<ol>
<li>   Adding <code>-Wall</code> parameter after <code>gcc</code> will display all warning information.</li>
<li><pre><code>Adding `-w` parameter will turn off all warning information.    
</code></pre>
</li>
<li><pre><code>Adding `-Wstring` will display warning information about `string`.  For example, if `-Wfloat-equal` is set, then it will warn if floating-point values are used in equality comparisons.
</code></pre>
</li>
<li>   Adding <code>-Wno-string</code> will not display warning information about <code>string</code>. For example, if <code>-Wno-div-by-zero</code>, then it will not warn if integer division by zero.</li>
</ol>
<p>So I try to review Makefile of caffe and comment some lines, but the warning information remain. The knowledge is useful, but can’t solve my problem.<br>After searching and searching, I finally found that it’s <a href="https://github.com/google/styleguide/tree/gh-pages/cpplint">cpplint</a> that caused errors. Cpplint is automated checker to make sure a C++ file follows Google’s C++ style guide. So I checked the Makefile, and find a line like this:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">EVERYTHING_TARGETS := all py$(PROJECT) <span class="built_in">test</span> warn lint</span><br></pre></td></tr></table></figure>
<p>Explain: <code>EVERYTHING_TARGETS</code> is target of command <code>make everything</code>. When compile caffe, we can just type <code>make everything</code> then gcc will do everything for us, including <code>make all</code>, <code>make test</code>, <code>make warn</code>, <code>make lint</code>.<br>So finally I got the simplest solution: just remove <code>lint</code> from this line and recompiled it. This time everything went well.</p>
<h2 id="Issue-2"><a href="#Issue-2" class="headerlink" title="Issue 2"></a>Issue 2</h2><p>When I train network using lisa-caffe-public, I encounter error:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Unknown layer <span class="built_in">type</span>: Python</span><br></pre></td></tr></table></figure>
<p>I searched about this question and found the answer <a href="https://github.com/rbgirshick/fast-rcnn/issues/31">here</a>: <strong>uncomment WITH__PYTHON_LAYER: =1 in Makefile.config and recompile it.</strong><br>lisa-caffe-public is a fork of fast-rcnn, which is a fork of original caffe of BVLC. The developer of fast-rcnn use <code>Python layer</code> in his implementation and lisa’s caffe fork inherits it. In order to run the network correctly, we must use the flag when compiling the source code.  </p>
<h2 id="Issue-3"><a href="#Issue-3" class="headerlink" title="Issue 3"></a>Issue 3</h2><p>Error message like this:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal error: caffe/proto/caffe.pb.h: No such file or directory</span><br></pre></td></tr></table></figure>
<p>caffe.pb.h is a header file generated by Google Protocol Buffer. <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/">Here</a> is a tutorial about it.  We must first generate it use commands below:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ protoc src/caffe/proto/caffe.proto --cpp_out=.</span><br><span class="line">$ mkdir include/caffe/proto</span><br><span class="line">$ mv src/caffe/proto/caffe.pb.h include/caffe/proto</span><br></pre></td></tr></table></figure>
<p>Then compile again and we have the question solved.<br>Reference from <a href="https://github.com/NVIDIA/DIGITS/issues/105">here</a></p>
<h2 id="Issue-4"><a href="#Issue-4" class="headerlink" title="Issue 4"></a>Issue 4</h2><p>Error message like this:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Check failed: proto.SerializeToOstream(&amp;output)</span><br></pre></td></tr></table></figure>
<p>This error happens when write snapshot to disk. There are three reasons that cause this error:</p>
<ol>
<li>The writing directory doesn’t exist</li>
<li>You have to permission to write in the directory</li>
<li>The target disk is full </li>
</ol>
<p>You can check these 3 aspects.<br>Reference: <a href="https://github.com/BVLC/caffe/issues/1394">https://github.com/BVLC/caffe/issues/1394</a></p>
<h2 id="Issue-5"><a href="#Issue-5" class="headerlink" title="Issue 5"></a>Issue 5</h2><p>When use <a href="https://github.com/rbgirshick/fast-rcnn">fast R-CNN</a>, got error like this:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Floating point exception(core dumped).</span><br></pre></td></tr></table></figure>
<p>It’s like something about box size. the solution is add <code>filter_roidb</code> function in <code>lib/fast_rcnn/train.py</code> file, like <a href="https://github.com/rbgirshick/py-faster-rcnn/blob/d66cc2bff142ca07f521db06ca3e9e10dbc8df20/lib/fast_rcnn/train.py#L127">here</a>.<br>Reference: <a href="https://github.com/rbgirshick/py-faster-rcnn/issues/159">https://github.com/rbgirshick/py-faster-rcnn/issues/159</a></p>
<h2 id="Issue-6"><a href="#Issue-6" class="headerlink" title="Issue 6"></a>Issue 6</h2>]]></content>
      <tags>
        <tag>Caffe</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>关闭Caffe和TensorFlow运行时的日志输出</title>
    <url>/2017/12/11/caffe-tensorflow-log/</url>
    <content><![CDATA[<p>简言之2条命令即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在命令行下</span></span><br><span class="line"><span class="comment"># Caffe</span></span><br><span class="line">$ GLOG_minloglevel=2 caffe-command</span><br><span class="line"><span class="comment"># Tensorflow</span></span><br><span class="line">$ TF_CPP_MIN_LOG_LEVEL=3 tensorflow-command</span><br></pre></td></tr></table></figure>
<p>或者在python文件中，<strong>import caffe或tensorflow之前</strong>，执行如下的语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Python文件中</span></span><br><span class="line"><span class="comment"># Caffe</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.envrion[<span class="string">&#x27;GLOG_minloglevel&#x27;</span>] = <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tensorflow</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.envrion[<span class="string">&#x27;TF_CPP_MIN_LOG_LEVEL&#x27;</span>] = <span class="string">&#x27;3&#x27;</span></span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ol start="0">
<li><a href="https://stackoverflow.com/questions/29788075/setting-glog-minloglevel-1-to-prevent-output-in-shell-from-caffe">https://stackoverflow.com/questions/29788075/setting-glog-minloglevel-1-to-prevent-output-in-shell-from-caffe</a></li>
<li><a href="http://littlewhite.us/archives/157">http://littlewhite.us/archives/157</a></li>
<li><a href="https://stackoverflow.com/questions/38073432/how-to-suppress-verbose-tensorflow-logging">https://stackoverflow.com/questions/38073432/how-to-suppress-verbose-tensorflow-logging</a></li>
</ol>
]]></content>
      <tags>
        <tag>Caffe</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>在ctypes的C共享库中调用Python函数</title>
    <url>/2022/10/04/callback-in-ctypes/</url>
    <content><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p><a href="https://docs.python.org/3/library/ctypes.html">ctypes</a> 是Python标准库中提供的外部函数库，可以用来在Python中调用动态链接库或者共享库中的函数，比如将使用大量循环的代码写在C语言中来进行提速，因为Python代码循环实在是太慢了。大致流程是通过 ctypes 来调用C函数，先将Python类型的对象转换为C的类型，在C函数中做完计算，返回结果到Python中。这个过程相对是比较容易的。</p>
<p>现在有个更复杂的情况，我想要在C代码中调用Python中的某些函数来完成C代码的计算，比如在C代码的sort函数中，采用Python中定义的函数来进行大小判断。这个在Python中定义的函数在 ctypes 中称为回调函数 (callback function)。也就是说需要把Python函数当作变量传给C语言，想想还是有些难度。 但调查以后发现 ctypes 提供了 <code>CFUNCTYPE</code>来方便地进行回调函数定义，而C语言本身也是支持函数指针的，因此这个功能实现还算简单，具体展开如下。</p>
<span id="more"></span>

<h3 id="2-一个最简单例子"><a href="#2-一个最简单例子" class="headerlink" title="2. 一个最简单例子"></a>2. 一个最简单例子</h3><p>先从最简单例子开始，跑通整体流程。假设我们有个回调函数，判断int类型的输入是不是大于0，那么可以在C语言这么写:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// my_lib.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> (*function_ptr)(<span class="keyword">int</span>) , <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> function_ptr(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个文件内容很简单，我们定义了一个C函数<code>foo</code>，它调用Python传过来的回调函数，直接返回结果。</p>
<p>这里使用了C语言的函数指针类型，<code>int (function_ptr)(int)</code>中函数指针变量名是<code>function_ptr</code>, 返回值类型是前面的int，参数类型是后面的int。</p>
<p>我们在C语言里面只是简单地调用了Python传过来的函数指针，并直接将结果返回，实际使用时其实是需要在Python函数算完后，利用输出进行更多操作，否则直接在Python里面计算函数就可以了，没必要传函数到C，算法结果再返回给Python。</p>
<p>使用下面的命令来将上述C文件编程成共享库<code>my_lib.so</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -shared -o my_lib.so my_lib.c</span><br></pre></td></tr></table></figure>
<p>这个命令会在当前目录下会生成<code>my_lib.so</code>。</p>
<p>然后在Python文件中定义这个回调函数的具体实现，以及调用共享库<code>my_lib.so</code>中定义的<code>foo</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file name: ctype_callback_demo.py</span></span><br><span class="line"><span class="keyword">import</span> ctypes <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> cdll</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义回调函数</span></span><br><span class="line"><span class="meta">@c.CFUNCTYPE(<span class="params">c.c_int, c.c_int</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback_func</span>(<span class="params">a</span>):</span></span><br><span class="line">    res = <span class="built_in">int</span>(a &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 载入共享库</span></span><br><span class="line">    lib = cdll.LoadLibrary(<span class="string">&#x27;./my_lib.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 调用共享库中的foo函数</span></span><br><span class="line">    res = lib.foo(callback_func, a)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; &gt; 0 = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(a, res))</span><br></pre></td></tr></table></figure>
<p>所有 magic 的事情都被 ctypes 这个库给做了，留给我们的都是比较简单的接口。</p>
<p><code>@c.CFUNCTYPE</code> 这个装饰器就是用来声明回调函数的，装饰器的第一个参数是函数的返回类型，第二个参数开始，就是回调函数自己的参数的类型。如果回调函数没有返回值，那<code>@c.CFUNCTYPE</code>后面的第一个参数设置为<code>None</code>。</p>
<p>然后执行这个Python脚本，可以得到下面的输出:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python ctype_callback_demo.py</span><br><span class="line">2 &gt; 0 = 1</span><br></pre></td></tr></table></figure>

<h3 id="3-Numpy-ndarray-类型的参数如何使用"><a href="#3-Numpy-ndarray-类型的参数如何使用" class="headerlink" title="3. Numpy.ndarray 类型的参数如何使用"></a>3. Numpy.ndarray 类型的参数如何使用</h3><p>ctypes 对 Python原生类型支持是没问题的，但我们还会经常用到Numpy的ndarray对象，它们该如何转换为C语言可以识别的类型呢？因为跨语言的类型转换不对的话，结果就会有问题。</p>
<p>Numpy 提供了 numpy.ndarray.ctypes 属性，可以来完成这个操作。</p>
<p>比如C文件中，需要一个float 指针类型的输入:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// my_lib.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> (*function_ptr)(<span class="keyword">float</span>*) , <span class="keyword">float</span>* a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">function_ptr</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要将Numpy.ndarray对象进行转换，传给C函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取C的float指针类型</span></span><br><span class="line">c_float_p = ctypes.POINTER(ctypes.c_float)</span><br><span class="line"></span><br><span class="line">data = np.random.rand(<span class="number">3</span>, <span class="number">3</span>).astype(np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将np.ndarray 对象的类型转换为C的float指针类型</span></span><br><span class="line">data_p = data.ctypes.data_as(c_float_p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用共享库中的foo函数</span></span><br><span class="line">my_lib.foo(data_p)</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://docs.python.org/3/library/ctypes.html#callback-functions">https://docs.python.org/3/library/ctypes.html#callback-functions</a></li>
<li><a href="https://stackoverflow.com/questions/3195660/how-to-use-numpy-array-with-ctypes">https://stackoverflow.com/questions/3195660/how-to-use-numpy-array-with-ctypes</a></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>用Python将图片转换为base64字符串</title>
    <url>/2022/10/07/convert-image-to-base64/</url>
    <content><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>无他，这篇博文记录一下利用Python将OpenCV图片转换为base64字符串并在网页上进行展示的过程，权当备忘。可在<a href="https://github.com/vra/image-to-base64">这里</a>查看源码。</p>
<span id="more"></span>

<h3 id="2-Show-the-code"><a href="#2-Show-the-code" class="headerlink" title="2. Show the code"></a>2. Show the code</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_to_base64</span>(<span class="params">img_path</span>):</span></span><br><span class="line">    img = cv2.imread(img_path)</span><br><span class="line"></span><br><span class="line">    _, buffer = cv2.imencode(<span class="string">&#x27;.jpg&#x27;</span>, img)</span><br><span class="line">    text = base64.b64encode(buffer).decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_html_file</span>(<span class="params">text, file_name</span>):</span></span><br><span class="line">    html_pattern = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;img src=&quot;data:image/png;base64,&#123;&#125;&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;/html&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    html = html_pattern.<span class="built_in">format</span>(text)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img_path = <span class="string">&#x27;data/cat.jpg&#x27;</span></span><br><span class="line">    html_file_name = <span class="string">&#x27;data/show_img.html&#x27;</span></span><br><span class="line"></span><br><span class="line">    text = img_to_base64(img_path)</span><br><span class="line">    create_html_file(text, html_file_name)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>HTML</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 彩色命令行输出</title>
    <url>/2019/09/10/colorful-logging/</url>
    <content><![CDATA[<p>效果：<br><img src="/imgs/coloredlogs-demo.png"><br>下面描述如何来实现。</p>
<span id="more"></span>

<p>安装coloredlogs:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install --user coloredlogs</span><br></pre></td></tr></table></figure>

<p>就可以了，使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> coloredlogs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FIELD_STYLES = <span class="built_in">dict</span>(</span><br><span class="line">    asctime=<span class="built_in">dict</span>(color=<span class="string">&#x27;green&#x27;</span>),</span><br><span class="line">    hostname=<span class="built_in">dict</span>(color=<span class="string">&#x27;magenta&#x27;</span>),</span><br><span class="line">    levelname=<span class="built_in">dict</span>(color=<span class="string">&#x27;green&#x27;</span>, bold=coloredlogs.CAN_USE_BOLD_FONT),</span><br><span class="line">    filename=<span class="built_in">dict</span>(color=<span class="string">&#x27;magenta&#x27;</span>),</span><br><span class="line">    name=<span class="built_in">dict</span>(color=<span class="string">&#x27;blue&#x27;</span>),</span><br><span class="line">    threadName=<span class="built_in">dict</span>(color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">LEVEL_STYLES = <span class="built_in">dict</span>(</span><br><span class="line">    debug=<span class="built_in">dict</span>(color=<span class="string">&#x27;green&#x27;</span>),</span><br><span class="line">    info=<span class="built_in">dict</span>(color=<span class="string">&#x27;cyan&#x27;</span>),</span><br><span class="line">    warning=<span class="built_in">dict</span>(color=<span class="string">&#x27;yellow&#x27;</span>),</span><br><span class="line">    error=<span class="built_in">dict</span>(color=<span class="string">&#x27;red&#x27;</span>),</span><br><span class="line">    critical=<span class="built_in">dict</span>(color=<span class="string">&#x27;red&#x27;</span>, bold=coloredlogs.CAN_USE_BOLD_FONT)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;tos&#x27;</span>)</span><br><span class="line">coloredlogs.install(</span><br><span class="line">    level=<span class="string">&quot;DEBUG&quot;</span>,</span><br><span class="line">    fmt=<span class="string">&quot;[%(levelname)s] [%(asctime)s] [%(filename)s:%(lineno)d] %(message)s&quot;</span>,</span><br><span class="line">    level_styles=LEVEL_STYLES,</span><br><span class="line">    field_styles=FIELD_STYLES)</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&#x27;This is Debug mode&#x27;</span>)</span><br><span class="line">logger.info(<span class="string">&#x27;This is info mode&#x27;</span>)</span><br><span class="line">logger.warn(<span class="string">&#x27;This is warn mode&#x27;</span>)</span><br><span class="line">logger.error(<span class="string">&#x27;This is error mode&#x27;</span>)</span><br><span class="line">logger.critical(<span class="string">&#x27;This is critical mode&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
        <tag>coloredlogs</tag>
      </tags>
  </entry>
  <entry>
    <title>Caffe中lmdb和leveldb格式数据的读取</title>
    <url>/2017/10/01/caffe-lmdb-leveldb/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Caffe里面的一种数据存储和读取方式是使用数据库格式，将数据保存到特定的一个数据库文件中，然后在代码里面整个读入这个数据库文件。Caffe支持的数据库格式包括lmdb和leveldb，可能很多人是因为caffe才知道这两个库的，但其实这两个库也是非常出名的工具。下面就展示下在Caffe里面用Python接口调用生成的LMDB或者LEVELDB格式的文件的代码吧。</p>
<span id="more"></span>
<h3 id="LMDB-操作方式"><a href="#LMDB-操作方式" class="headerlink" title="LMDB 操作方式"></a>LMDB 操作方式</h3><p>具体方式见如下代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lmdb</span><br><span class="line">env = lmdb.<span class="built_in">open</span>(<span class="string">&#x27;pool5-lmdb&#x27;</span>, readonly=<span class="literal">True</span>)</span><br><span class="line">txn = env.begin()</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> txn.cursor():</span><br><span class="line">	<span class="built_in">print</span> k,v</span><br><span class="line"></span><br><span class="line">cur = txn.cursor()</span><br><span class="line">k, v = cur.item()</span><br><span class="line"><span class="built_in">print</span> k,v</span><br><span class="line">v = txn.get(k)</span><br><span class="line"><span class="built_in">print</span> v</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">&#x27;/data2/yunfeng/caffe20161019/python/&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> caffe</span><br><span class="line">datum = caffe.proto.caffe_pb2.Datum()</span><br><span class="line">datum.ParseFromString(v)</span><br><span class="line"><span class="built_in">print</span> datum.label, datum.channels, datum.width, datum.height</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = caffe.io.datum_to_array(datum)</span><br><span class="line"><span class="built_in">print</span> data.shape</span><br></pre></td></tr></table></figure>

<h3 id="LEVELDB-操作方式："><a href="#LEVELDB-操作方式：" class="headerlink" title="LEVELDB 操作方式："></a>LEVELDB 操作方式：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> leveldb</span><br><span class="line">db = leveldb.LevelDB(<span class="string">&#x27;pool5-leveldb&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> db.RangeIter():</span><br><span class="line">	<span class="built_in">print</span> k,v</span><br><span class="line"></span><br><span class="line">v = db.Get(k)</span><br><span class="line">db.Put(<span class="string">&#x27;new_key&#x27;</span>, <span class="string">&#x27;new_value&#x27;</span>)</span><br><span class="line">db.Delete(<span class="string">&#x27;new_key&#x27;</span>)</span><br><span class="line"></span><br><span class="line">batch = leveldb.WriteBatch();</span><br><span class="line">batch.Put(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">batch.Put(<span class="string">&#x27;hello again&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">batch.Delete(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">db.Write(batch, sync = <span class="literal">True</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">&#x27;/data2/yunfeng/caffe20161019/python/&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> caffe</span><br><span class="line">datum = caffe.proto.caffe_pb2.Datum()</span><br><span class="line">datum.ParseFromString(v)</span><br><span class="line"><span class="built_in">print</span> datum.label, datum.channels, datum.width, datum.height</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = caffe.io.datum_to_array(datum)</span><br><span class="line"><span class="built_in">print</span> data.shape</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Caffe</tag>
        <tag>lmdb</tag>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习总结3——动态创建对象及其撤销</title>
    <url>/2015/01/25/cpp-new-and-delete/</url>
    <content><![CDATA[<p>这里的动态创建对象，特指在程序中通过new命令创建对象；而撤销，特指通过delete命令来删除对象并释放其内存空间。</p>
<h2 id="new和delete的基本用法"><a href="#new和delete的基本用法" class="headerlink" title="new和delete的基本用法"></a>new和delete的基本用法</h2><p><code>new</code>命令会在堆区域分配创建一个对象，而后返回此对象的地址。<br><code>delete</code>命令会释放指针指向的对象所占用的内存空间，而此后指针指向的地址是没有意义的，为了避免错误，一般来说，应该在delete后立即将指针置为NULL。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi=<span class="keyword">new</span> <span class="keyword">int</span>;    <span class="comment">//动态创建对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pi;    <span class="comment">//删除动态创建对象</span></span><br><span class="line"></span><br><span class="line">pi=<span class="literal">NULL</span>;    <span class="comment">//将指针置为NULL</span></span><br></pre></td></tr></table></figure>

<p>注意：<code>delete</code>命令只能用来释放由<code>new</code>获得的指针，而且<code>new</code>得到的指针必须通过<code>delete</code>释放掉，否则会有内存泄漏的问题。</p>
<span id="more"></span>

<h2 id="动态创建对象的默认初始化"><a href="#动态创建对象的默认初始化" class="headerlink" title="动态创建对象的默认初始化"></a>动态创建对象的默认初始化</h2><p>用<code>new</code>创建的对象的默认初始化规则与局部变量的初始化规则相同，即：对内置类型，不进行初始化；对于类类型变量，用默认构造函数进行初始化。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>    //类定义</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyClass</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>()    <span class="comment">//默认构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;MyClass-默认构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *pi=<span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;*pi=&quot;</span>&lt;&lt;*pi&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	MyClass *pClass=<span class="keyword">new</span> MyClass;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序运行结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">*pi=<span class="number">-842150451</span></span><br><span class="line"></span><br><span class="line">MyClass-默认构造函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可见对pi 没有进行初始化，对pClass调用了MyClass类的默认构造函数。所以对于内置类型，用new申请变量时必须进行初始化，否则其指向的值是未知的。</p>
<h2 id="new-int-or-new-int-？"><a href="#new-int-or-new-int-？" class="headerlink" title="new int; or new int(); ？"></a>new int; or new int(); ？</h2><p>这两种形式，有没有区别？哪一种对？到底该用哪一种呢？一开始我也搞不清楚，慢慢查查才明白其中区别。</p>
<p>new int()这种形式叫值初始化（value-initialize），与动态创建的不同：对于内置类型，动态创建不会对其进行初始化；而值初始化会进行初始化。对于类类型变量，两种形式都会调用默认构造函数，所以没有区别。</p>
<p>如下例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>    //类定义</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyClass</span>();</span><br><span class="line">	~<span class="built_in">MyClass</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>()    <span class="comment">//默认构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;MyClass-默认构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass::~<span class="built_in">MyClass</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *p1=<span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *p2=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *p3=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;*p1=&quot;</span>&lt;&lt;*p1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;*p2=&quot;</span>&lt;&lt;*p2&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;*p3=&quot;</span>&lt;&lt;*p3&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	MyClass *pClass1=<span class="keyword">new</span> MyClass;</span><br><span class="line"></span><br><span class="line">	MyClass *pClass2=<span class="keyword">new</span> <span class="built_in">MyClass</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete 动态创建对象</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> pClass2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> pClass1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> p3;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> p1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*p1=<span class="number">-842150451</span></span><br><span class="line"></span><br><span class="line">*p2=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">*p3=<span class="number">23</span></span><br><span class="line"></span><br><span class="line">MyClass-默认构造函数</span><br><span class="line"></span><br><span class="line">MyClass-默认构造函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由结果可推得上述结论。</p>
<p>对内置类型，建议使用值初始化，可以使用特定的值对其进行初始化，如上例中p3的初始化。对于类类型，一般用第一种。</p>
<h2 id="delete-or-delete-？"><a href="#delete-or-delete-？" class="headerlink" title="delete or delete[] ？"></a>delete or delete[] ？</h2><p>其实这两者的区别是很明显的， 前者是释放一个位置，而后者是释放一个数组，一段位置。在使用delete[]时，编译器会获取被释放对象new时申请的数据大小size，然后全部释放size个数据。可以认为，用new申请的，用delete释放；用new[]申请的，用delete[]释放。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *pi=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> *pf=<span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">	string *pstring=<span class="keyword">new</span> string[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> pi;    <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span>[] pf;    <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> pstring;    <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面例子中，pstring释放的格式是错误的，相当于是只释放了pstring[0],后面的127个对象都没有被正确释放。</p>
<h2 id="指针数组与指针的指针"><a href="#指针数组与指针的指针" class="headerlink" title="指针数组与指针的指针"></a>指针数组与指针的指针</h2><p>指针数组的每个成员是指针，相当于是一系列指针的集合；而指针的指针就是字面意思所表示的，指向指针的指针。</p>
<p>这两者其实是有关系的：因为数组名相当于一个指针，所以指针数组可以看作指针的指针+特定内存空间。某些情况下，两者可以混用。</p>
<p>举个例子:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STUDENT_NUM=<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>    //<span class="title">Student</span>结构体定义</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Student **ppStudent=<span class="keyword">new</span> Student*[STUDENT_NUM];    <span class="comment">//指针数组，ppStudent是指针的指针</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;STUDENT_NUM;i++)  <span class="comment">//初始化每个指针</span></span><br><span class="line">	&#123;</span><br><span class="line">		ppStudent[i]=<span class="keyword">new</span> Student;</span><br><span class="line"></span><br><span class="line">		ppStudent[i]-&gt;number=i;</span><br><span class="line"></span><br><span class="line">		ppStudent[i]-&gt;age=<span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//delete </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;STUDENT_NUM;i++)    <span class="comment">//释放每个指针所指的空间</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> ppStudent[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span>[] ppStudent;    <span class="comment">//释放指针的指针</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到ppStudent是指针的指针，但其初始化时却用的时指针的数组。</p>
<p><strong>很容易忽略的一点是：在释放时忘记释放每个ppStudent[i]。为了避免这种错误，可以强制性地对应new[]和delete[]，new和delete，有new[]必有对应的delete[]，有new必有对应的delete。</strong></p>
<h2 id="单向链表的创建和释放"><a href="#单向链表的创建和释放" class="headerlink" title="单向链表的创建和释放"></a>单向链表的创建和释放</h2><p>链表的动态创建和释放也很容易犯错，写程序时需要多关注有关new和delete的细节部分。<br>下面是一个不带头结点的链表的动态创建和释放：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line"></span><br><span class="line">	Node* next;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Node *list=<span class="keyword">new</span> Node;    <span class="comment">//不带头结点的链表</span></span><br><span class="line"></span><br><span class="line">	list-&gt;data=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	list-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造链表</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">1000000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		Node *pNode=list;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(pNode-&gt;next!=<span class="literal">NULL</span>)    <span class="comment">//找到链表尾巴</span></span><br><span class="line">		&#123;</span><br><span class="line">			pNode=pNode-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pNode-&gt;next=<span class="keyword">new</span> Node;    <span class="comment">//在尾部增加新节点</span></span><br><span class="line"></span><br><span class="line">		pNode-&gt;next-&gt;data=i;</span><br><span class="line"></span><br><span class="line">		pNode-&gt;next-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除链表</span></span><br><span class="line">	<span class="keyword">if</span>(list!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(list-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Node *p=list;</span><br><span class="line"></span><br><span class="line">			list=list-&gt;next;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">delete</span> p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习总结</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习总结2——C++内存模型</title>
    <url>/2015/01/25/cpp-memory-mode/</url>
    <content><![CDATA[<p>为了更直观的理解这部分内容，使用如下的程序实例进行说明：</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="number">3.1415926</span>;    <span class="comment">//常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> out=<span class="number">0</span>;    <span class="comment">//静态全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;    <span class="comment">//初始化了的全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j;    <span class="comment">//未初始化的全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> count;    <span class="comment">//静态局部变量</span></span><br><span class="line"></span><br><span class="line">	count++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i=count % <span class="number">10</span>;    <span class="comment">//局部变量</span></span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;count % 10=&quot;</span>&lt;&lt;i&lt;&lt;endl;    <span class="comment">//&quot;count % 10=&quot;为字符串常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;    <span class="comment">//局部变量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *pi=&amp;i;    <span class="comment">//局部变量</span></span><br><span class="line"></span><br><span class="line">	*pi=*pi+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;i=&quot;</span>&lt;&lt;i&lt;&lt;endl;    <span class="comment">//&quot;i=&quot;为字符串常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> out=<span class="number">2</span>;    <span class="comment">//静态局部变量</span></span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;out=&quot;</span>&lt;out&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func2</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中我尽量表现了各种情况，虽然写得很不合理…</p>
<p>先给出C++内存的一个模型图：</p>
<p><img src="/uploads/2015/01/C-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png"></p>
<p>对于一个C++程序，内存区域分六个部分：依次是<code>rodata</code>区，<code>text</code>区，<code>data</code>区，<code>bss</code>区，<code>heap</code>区和<code>stack</code>区。</p>
<p>其中<code>rodata</code>区和<code>text</code>区在加载时会合并到一个段中，该段称为常量区，该区域的内容只允许读，不允许修改；</p>
<p><code>data</code>区和<code>bss</code>区在加载时合并到一个段中，该段被称为全局区，其中的内容，对程序来说，是可读可写的。</p>
<p>每个区的详细说明如下。</p>
<h2 id="rodata"><a href="#rodata" class="headerlink" title="rodata"></a>rodata</h2><p><code>rodata</code>是<code>read only data</code>的缩写，只读区域，像上面程序中的pi和常量字符串”count % 10=”和”i=”都保存在该区域。</p>
<h2 id="text"><a href="#text" class="headerlink" title="text"></a>text</h2><p><code>text</code>区保存程序编译链接后生成的机器代码。当调用函数时，会将该区域的机器代码加载到栈中执行。</p>
<p>因为<code>rodata</code>区和<code>text</code>区在程序运行过程中都是不能修改的，所以在程序启动时，这两个区域又被放到一个叫做常量区的箱子中，并且在箱子外面贴上”不许修改”的标签，以防该区域的内容被修改。</p>
<h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p><code>data</code>中存放已经初始化的 全局变量和被声明为static的局部变量。像上面程序中的全局语句“static int out=0;”，“int i=1;”以及main函数中的“static int out=2;”，这些语句定义的变量都已经被初始化，所以存放在data区。注意我这里给全局静态变量和局部静态变量起了相同的名字，都叫out，但在main函数里面输出的out=2，说明虽然都是在data区，但编译和链接过程中全局变量和局部变量的标识还是不同的，编译器不会因为名字相同而混淆两者。</p>
<h2 id="bss"><a href="#bss" class="headerlink" title="bss"></a>bss</h2><p><code>bss</code>是block started by symbol的缩写，该区域存放未初始化的 全局变量和被声明为static的局部变量。在加载时该区域的值会被全部设置为0（对算术类型）或NULL（对指针类型）。上面程序中的全局语句“int j;”和func1中的语句“static int count;”中定义的j和count都在<code>bss</code>区。</p>
<p>为什么要区分初始化和未初始呢？是为了节省空间。实际上，在目标文件中，未初始化的全局变量和声明为static的局部变量不占有任何空间，只是保存了在运行时它们要占的空间的大小。在运行时开辟同样大小的空间，然后将其全部置为0。所以<code>bss</code>区也被戏称为“Better Save Space”。</p>
<p>因为<code>data</code>区和<code>bss</code>区中保存的都是全局变量和静态局部变量（跟全局变量性质一致），所以在程序启动时，这两个区域又被放到一个叫做全局区的箱子中，这个箱子中的内容是可读可写的。</p>
<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p>堆区用来存放程序运行过程中动态分配的内存。像new和malloc就在该区域上申请内存空间。该区域内存的管理必须由程序写作者来负责，也就是如果通过new或malloc申请了一块内存，在程序结束时必须通过delete或free来释放相应的内存。new和delete的内容我后面会仔细说明。</p>
<p>因为该区域可以由用户来申请，申请大小视情况而定，通常很不一致，所以很容易造成该区域内存的碎片化。</p>
<p>堆内存的大小很大，一般来讲，在32位系统下，可以达到4G，所以通常不会溢出。</p>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>栈区保存函数的参数和函数内声明的变量，但声明为static的局部变量除外。栈具有后进先出的特点，很适合函数的一层层调用，所以函数调用时的变量都保存到该区中。上面程序中的main函数和func1,func2中的非static类型的变量在调用时都会加载到该区域。</p>
<p>栈的大小是很有限的，在Visual Studio中，默认的栈大小是1M，超过1M就会出现“stack overflow”的错误，可以通过修改默认设置来提高栈大小。</p>
]]></content>
      <categories>
        <category>学习总结</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习总结1——几个基本概念</title>
    <url>/2015/01/24/cpp-concepts/</url>
    <content><![CDATA[<p>最近我在做毕设。写程序的时候，总是被C++里面的指针搞得头昏脑胀。刚开始的时候还有些浮躁，不想静下心来仔细看看指针使用的细节。过了几天发现只在Visual Studio里面调试怎么也搞不定，只好硬着头皮，重新学习指针的用法。在看书和看别人写的博客后，感觉学到了许多新的东西，不光是关于指针，还有其他一些以前我不太清楚的内容。这些知识如果不常用或不记录下来的话，肯定会忘掉的，所以我就把它们都写下来，避免以后犯同样的错误。</p>
<span id="more"></span>

<h2 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h2><h3 id="声明-declaration"><a href="#声明-declaration" class="headerlink" title="声明(declaration)"></a>声明(declaration)</h3><p>声明用于向编译器表明变量，函数或类的类型和名字，并不会为其申请存储空间，只是向程序表明了这个对象的存在。变量声明格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;    <span class="comment">//变量声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;      <span class="comment">//函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>;</span>   <span class="comment">//类的声明</span></span><br></pre></td></tr></table></figure>

<p>注意：语句<code> int i;</code>是定义，在前面加了“extern”关键字后才是声明。</p>
<p>声明不会分配存储空间，所以同一个对象可以声明多次。</p>
<h3 id="定义-definition"><a href="#定义-definition" class="headerlink" title="定义(definition)"></a>定义(definition)</h3><p>变量定义会为其分配存储空间，函数定义则必须给出函数实现的细节，类的定义需要指定类的成员，类函数的实现等等。定义也是一种声明（平时我们说的“声明”，特指那些不是定义的声明）。定义格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;    <span class="comment">//变量定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>    <span class="comment">//函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>            //类的定义</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set_a</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;m_a=a;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">get_a</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_a;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在一个程序中，每个对象只能定义一次。如果多次定义，会出现<strong>重复定义（redefinition）</strong>的错误。</p>
<p>如果声明时有初始化式，则该声明也是定义。根据“定义只能由一次，声明可以有多次”的规则，有如下例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi=<span class="number">3.14159</span>;    <span class="comment">//ok:definition</span></span><br><span class="line"></span><br><span class="line">doulbe pi;                   <span class="comment">//error: redefinition of pi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi;            <span class="comment">//ok:declaration of pi;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi=<span class="number">3.14</span>;       <span class="comment">//error: redefinition of pi</span></span><br></pre></td></tr></table></figure>

<p>仔细理解上述4个语句，应该就会对声明和定义有个比较清楚的概念。</p>
<h2 id="初始化和赋值"><a href="#初始化和赋值" class="headerlink" title="初始化和赋值"></a>初始化和赋值</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化指<strong>创建对象的时候</strong>给它赋初始值。如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age=<span class="number">22</span>;      </span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> height;</span><br></pre></td></tr></table></figure>

<p>则age为经过初始化的变量，height为未初始化的变量。指针类型变量的初始化过程如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p_age = &amp;age;    <span class="comment">//initation of p_age</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>** pp_age = &amp;p_age; <span class="comment">//initation of pp_age</span></span><br></pre></td></tr></table></figure>

<p>指针的初始化很容易犯错，像下面的错误我就犯过很多次：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* pi;</span><br><span class="line"></span><br><span class="line">    *pi=<span class="number">23</span>;           <span class="comment">//错误：pi未初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span>* pf=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pf=<span class="number">3.4</span>;          <span class="comment">//错误：pf指向不合法内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* pc=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    pc= &amp;c;            <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中，pi未进行初始化，所以pi指向的是未知的内存区域，在编译会出错。像pi这样，指向内存区域不确定或无意义的指针称为“野指针”。</p>
<p>pf虽然经过了初始化，但指向的是内存空间的0位置，而不是指向一个float型变量的内存区域，所以运行时会出错，如下所示：</p>
<p><img src="/uploads/2015/01/error_pointer_no_initation.png"></p>
<p>pc的使用方式则是合法的。</p>
<p>指针还可以用于new和delete语句，后面会进行描述。</p>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>赋值指擦除对象的当前值并用新值来代替。可以认为，初始化就是给变量第一次赋值的过程。<strong>对于未初始化的变量，除了用作赋值操作的左操作数，用于其他用途都是没有意义的。</strong></p>
<h2 id="系统默认初始化规则"><a href="#系统默认初始化规则" class="headerlink" title="系统默认初始化规则"></a>系统默认初始化规则</h2><p>所谓系统默认初始化规则，就是在声明变量时未对其进行初始化的情况下，编译器对其赋值的一套规则。对于内置类型和类类型，规则不同；对于函数内变量和函数外变量，定义规则也不同。</p>
<h3 id="内置类型变量"><a href="#内置类型变量" class="headerlink" title="内置类型变量"></a>内置类型变量</h3><p>内置类型指int，float，char和void等基本类型（在C++中，string不是内置类型）。对于内置类型，如果在函数中定义，则系统不对其进行自动赋值；如果在函数外定义（即全局变量），则将其初始化为0（这里的“0”对不同的类型有不同的意义：对int变量，为整数0，对char变量，为‘’）。建议对每个内置类型的变量都显式地初始化。</p>
<p>对全局变量和局部变量的默认初始化规则不同，归根结底是因为它们保存的位置不同。全局变量保存在全局数据区，该区域的变量在编译时会自动初始化；对于局部变量，系统启动时不会为其开辟内存空间，只有当它所在的函数被调用时，才在栈中建立函数数据空间。变量如果没有显式初始化，则其值为随机值。很重要的一点是：永远不要依赖随机值。</p>
<h3 id="类类型变量"><a href="#类类型变量" class="headerlink" title="类类型变量"></a>类类型变量</h3><p>对于类类型变量，不论其是在函数内还是函数外定义，只要有默认构造函数，则系统就会自动调用其默认构造函数，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string out;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string in;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为string类有默认构造函数，所以out和in都被自动初始化为””。</p>
<p>如果没有默认构造函数，则定义时必须提供显式的初始化式。因为C++中类会自动地增加一个默认构造函数，所以这种情况比较少见。</p>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p>1.《C++ Primer第4版》</p>
<p>2.<a href="http://www.cprogramming.com/declare_vs_define.html">Declare vs Define in C and C++</a></p>
]]></content>
      <categories>
        <category>学习总结</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title>cool-certificate, 一个好玩的证书生成工具</title>
    <url>/2016/04/07/cool-certificate/</url>
    <content><![CDATA[<p>前几天同学发过来一张无人机驾驶证的照片，瞬间觉得很高大上，仔细一询问，原来是用软件生成的图片，网址是：<a href="http://wx.znl.cn/app/index.php?i=120&amp;c=entry&amp;id=1&amp;do=index&amp;m=bi_pic">http://wx.znl.cn/app/index.php?i=120&amp;c=entry&amp;id=1&amp;do=index&amp;m=bi_pic</a>。 当访问该网站的时候，用户输入用户名，然后就生成包含用户名的驾照照片。我接着想能不能自己做一个类似这样的东西呢，经过思考发现，其实操作比较简单，即将用户姓名写入到图像上的合适位置即可。因为我之前已经有一些用Python 的Django框架做小的网站的经验，而且Python PIL模块可以完成这个任务，所以我立即想到， 能不能结合两者，建立一个网站，让用户输入姓名，然后将用户姓名传入到后台，后台调用PIL函数，将名字写到图片的相应位置上，然后返回给用户呢？经过思考我发现这种思路是可行的，而且工作量貌似也不是很大，所以今天早上开始做了做，在无人机驾照的基础上又增加了2个有趣的证件：潜水证和超级帅哥证，今晚终于作出了一个粗糙的结果（网站页面使用了原始和简单的HTML标签），可以在<a href="http://115.28.30.25:8001/">这里</a>访问。代码已经上传到<a href="https://github.com/vra/cool_certificate">github上</a>了。下面记下来实现过程中的一些思考。</p>
<span id="more"></span>

<h2 id="整体实现流程"><a href="#整体实现流程" class="headerlink" title="整体实现流程"></a>整体实现流程</h2><ol>
<li>   用Django实现网站前端和后端，展示页面给用户，读取用户输入</li>
<li>   当用户输入后，利用POST方法返回用户名到服务器端</li>
<li>   对特定的证件和已给的用户，利用PIL中的ImageFont模块来在证件照片的相应用户名空当处写上用户名,然后保存处理后的图片。用户名应该写在哪里需要手工确定（我用Windows 的画图工具中找到具体的位置坐标）</li>
<li>   将生成的图片返回给网站页面</li>
</ol>
<h2 id="实现的一些细节问题"><a href="#实现的一些细节问题" class="headerlink" title="实现的一些细节问题"></a>实现的一些细节问题</h2><h3 id="将文字写到图片上"><a href="#将文字写到图片上" class="headerlink" title="将文字写到图片上"></a>将文字写到图片上</h3><p>这里使用PIL（Python Image Library）来做，利用了其中的ImageFont模块，核心的代码段如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = Image.<span class="built_in">open</span>(img_path)                                                                                                                                                   draw = ImageDraw.Draw(img)                                                                                                                                               </span><br><span class="line">   font = ImageFont.truetype(font_path, font_size)                                                                                                                          </span><br><span class="line">   <span class="comment">#<span class="doctag">NOTE:</span> django get parameter as unicode, so don&#x27;t need to encode to unicode.                                                                                                  draw.text(word_pos, name, word_color, font=font)                                                                                                                         </span></span><br><span class="line">   img.save(out_img_path)                                       </span><br></pre></td></tr></table></figure>
<p>One things you must notice is that Django return stirng in the unicode format, so you dont’t have to do <code>unicode(name, &#39;utf-8&#39;)</code> anymore.<br>用户输入姓名时，生成包含姓名的证件图片，保存在本地。<br>在实际操作中发现，有些字体不支持部分中文，所以我在网上下了<code>Aria Unicode</code>字体，经测试发现能显示所有中文字体。  </p>
<h3 id="Django返回处理图片的格式"><a href="#Django返回处理图片的格式" class="headerlink" title="Django返回处理图片的格式"></a>Django返回处理图片的格式</h3><p>我最初想的是用户点击确定按钮后，跳转到新的页面，在这个页面上单独显示处理后的照片，所以response类型设置成<code>image/jpeg</code>即可。但实际操作中出现问题，只返回照片似乎有一些问题，所以我修改实现，在传给Template的时候，传递一个参数<code>done</code>, 如果当前没有增加用户姓名，则该值为0,否则为1。在Template中，如果值为0,则展示未处理的模板图片;如果值为1,则显示处理后的图片。</p>
<h3 id="静态文件目录的设置"><a href="#静态文件目录的设置" class="headerlink" title="静态文件目录的设置"></a>静态文件目录的设置</h3><p>Django将CSS,JS和Image图片都看作静态文件，推荐在app目录下建立<code>static</code>目录来保存这些文件。这里需要进行一定的设置，将保存模板图片和生成图片的目录<code>imgs</code>增加到<code>static</code>目录下，设置代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in settings.py</span></span><br><span class="line">SITE_ROOT = os.path.join(os.path.abspath(os.path.dirname(__file__)),<span class="string">&#x27;&#x27;</span>)                                                                                                      </span><br><span class="line">STATIC_ROOT = os.path.join(SITE_ROOT,<span class="string">&#x27;static&#x27;</span>)                                                                                                                               </span><br><span class="line">STATIC_URL = <span class="string">&#x27;/static/&#x27;</span>                                                                                                                                                      </span><br><span class="line">                                                                                                                                                                             </span><br><span class="line"><span class="comment">#最后关键部分需要添加上STATICFILE_DIRS的配置                                                                                                                                 </span></span><br><span class="line">STATICFILES_DIRS = (                                                                                                                                                         </span><br><span class="line">    (<span class="string">&quot;css&quot;</span>, os.path.join(STATIC_ROOT,<span class="string">&#x27;css&#x27;</span>)),                                                                                                                                </span><br><span class="line">    (<span class="string">&quot;js&quot;</span>, os.path.join(STATIC_ROOT,<span class="string">&#x27;js&#x27;</span>)),                                                                                                                                  </span><br><span class="line">    (<span class="string">&quot;imgs&quot;</span>, os.path.join(STATIC_ROOT,<span class="string">&#x27;imgs&#x27;</span>)),                                                                                                                              </span><br><span class="line">)                                              </span><br></pre></td></tr></table></figure>
<p>经过这样设置，在调用<code>imgs</code>目录下的图片时就可以这样调用了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;img src = <span class="string">&quot;&#123;% static &quot;</span>imgs/feiji.jpg<span class="string">&quot;%&#125;&quot;</span>&gt; </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>图像处理</tag>
        <tag>工具</tag>
        <tag>PIL</tag>
      </tags>
  </entry>
  <entry>
    <title>从Python传递参数到C++</title>
    <url>/2022/03/20/cpp-read-binary-file-from-python/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>有些场景下，需要将Python里面计算得到的参数或者结果传入到C++来进行工程部署。一个常见问题是，Python该以什么格式 (二进制还是文本) 保存这些参数，然后从C++代码里面来读取呢，各有什么优劣？这里我们简单实验一下，并写一些趁手的代码，供查阅。</p>
<span id="more"></span>

<h2 id="二进制格式和文本格式对比"><a href="#二进制格式和文本格式对比" class="headerlink" title="二进制格式和文本格式对比"></a>二进制格式和文本格式对比</h2><p>假设我们有一组参数是存储在Numpy的<code>ndarray</code>格式中的，为了在C++中使用，我们需要保存它们到硬盘的文件中。一般有两种保存方法：二进制文件保存和文本文件保存。</p>
<p>假设我们有一个1024x1024的浮点型参数待保存：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params = np.random.rand(<span class="number">1024</span>, <span class="number">1024</span>).astype(<span class="string">&#x27;float32&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>二进制保存很简单，直接调用Numpy的<code>tofile</code>文件即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params.tofile(<span class="string">&quot;params.bin&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果用文本文件保存，有两种保存方式，分别为调用<code>savetxt</code>函数和将每个值转换为<code>str</code>并用分隔符分开依次存入文件:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文本文件保存方式1</span></span><br><span class="line">np.savetxt(<span class="string">&quot;params_1.txt&quot;</span>, params)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文本文件保存方式2</span></span><br><span class="line">delimiter = <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;params_2.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> params:</span><br><span class="line">        f.write(<span class="built_in">str</span>(p) + delimiter)</span><br></pre></td></tr></table></figure>
<p>猜猜看这三种情况分别大小是多少？</p>
<p>结论如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4.0M params.bin</span><br><span class="line">25M params_1.txt</span><br><span class="line">11M params_2.txt</span><br></pre></td></tr></table></figure>
<p>可以看到，二进制格式存储空间是最小的，分别是两种文本形式存储空间的16%和36%，存储压缩比例还是比较明显的。</p>
<p>因此推荐以二进制形式存储, 存储脚本简单总结如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># rand默认格式是float64，我们使用float32就可以</span></span><br><span class="line">params = np.random.rand(<span class="number">1024</span>, <span class="number">1024</span>).astype(<span class="string">&quot;float32&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉平成一维，为了在C++里面方便处理</span></span><br><span class="line">params = params.flatten()</span><br><span class="line"></span><br><span class="line">params.tofile(<span class="string">&quot;params.bin&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="C-读取二进制文件"><a href="#C-读取二进制文件" class="headerlink" title="C++ 读取二进制文件"></a>C++ 读取二进制文件</h2><p>C++ 去读二进制的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_binary</span><span class="params">(<span class="keyword">const</span> std::string &amp;file_path, <span class="keyword">float</span> *data, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  std::ifstream in_file;</span><br><span class="line">  in_file.<span class="built_in">open</span>(file_path, std::ios::binary | std::ios::in);</span><br><span class="line">  in_file.<span class="built_in">read</span>((<span class="keyword">char</span> *)data, size * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>));</span><br><span class="line">  in_file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string file_path = <span class="string">&quot;params.bin&quot;</span>;</span><br><span class="line">  <span class="keyword">int</span> size = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用stack上空间来创建数组，有大小限制，不推荐</span></span><br><span class="line">  <span class="comment">// float params[size];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用new来构建heap上空间, 无大小限制，但需要自己释放内存</span></span><br><span class="line">  <span class="keyword">float</span> *params = <span class="keyword">new</span> <span class="keyword">float</span>[size];</span><br><span class="line">  <span class="built_in">read_binary</span>(file_path, params, size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印前10个参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    std::cout &lt;&lt; params[i] &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>[] params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意新建数组的时候，有在栈上或者堆上构建两种方式，栈上构建有大小限制，如果数组维度太大就会报错，如下面的代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行会报错:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ g++ stack_over.cpp &amp;&amp; ./a.out</span><br><span class="line">[1]    89415 segmentation fault  ./a.out</span><br></pre></td></tr></table></figure>
<p>因此推荐用堆上创建数组，详见上述代码的注释。</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的RAII到底指的是什么</title>
    <url>/2022/05/19/cpp-raii/</url>
    <content><![CDATA[<p>RAII，全称 Resource Acquisition Is Initialization，中文翻译为资源获取即初始化。这是C++中一个比较不直观的术语，而RAII的缩写也时不时遇到，总给人一种很高深但不易掌握的感觉。实际上查了资料后发现，RAII这个技术的含义其实比较明确，这里简单汇总一下从资料中的得到的知识点。</p>
<span id="more"></span>

<h2 id="什么是资源"><a href="#什么是资源" class="headerlink" title="什么是资源"></a>什么是资源</h2><p>这里的资源 (Resource) 是C++编程中的一个概念，表示哪些不能无限申请的变量（常有明确的含义），比如一段内存，数据库句柄，Socket，打开的文件，线程等。<br>个人理解，一般的内置类型变量如<code>int</code> 变量不算是资源。</p>
<h2 id="为什么要设计-RAII-这项技术？"><a href="#为什么要设计-RAII-这项技术？" class="headerlink" title="为什么要设计 RAII 这项技术？"></a>为什么要设计 RAII 这项技术？</h2><p>简单来说，RAII 这项技术的目的是将资源的生命周期绑定到某个对象（Object）上。对象，一般情况是某个类的示例。这么做有下面几个好处：</p>
<ol>
<li>保证资源在使用的时候已经进行了初始化，避免访问未初始化的内存地址而crash</li>
<li>保证资源在程序正常退出的时候进行了释放，避免未释放导致的内存泄漏</li>
<li>保证资源在运行出错的时候也能被正常释放</li>
</ol>
<h2 id="具体如何实现RAII？"><a href="#具体如何实现RAII？" class="headerlink" title="具体如何实现RAII？"></a>具体如何实现RAII？</h2><p>RAII 的实现可以总结为：</p>
<ul>
<li>将每个资源封装到一个类中，类的构造函数获取资源，如果获取资源失败，则抛出一个异常。</li>
<li>类的解构函数释放资源，并且保证不抛出异常，因此保证资源的释放是没问题的</li>
</ul>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>从<a href="https://docs.microsoft.com/en-us/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?redirectedfrom=MSDN&view=msvc-170">这里</a>拿过来的一个例子:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">widget</span>(<span class="keyword">const</span> <span class="keyword">int</span> size) &#123; data = <span class="keyword">new</span> <span class="keyword">int</span>[size]; &#125; <span class="comment">// 资源获取</span></span><br><span class="line">    ~<span class="built_in">widget</span>() &#123; <span class="keyword">delete</span>[] data; &#125; <span class="comment">// 资源释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionUsingWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">widget <span class="title">w</span><span class="params">(<span class="number">1000000</span>)</span></span>;   <span class="comment">// lifetime automatically tied to enclosing scope</span></span><br><span class="line">                        <span class="comment">// constructs w, including the w.data member</span></span><br><span class="line">    w.<span class="built_in">do_something</span>();</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// automatic destruction and deallocation for w and w.data</span></span><br></pre></td></tr></table></figure>
<p>这里<code>widget</code>就是一个RAII类，它将<code>data</code>这个资源绑定到类上面，在构造和析构函数里面进行资源获取和释放。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://en.cppreference.com/w/cpp/language/raii">https://en.cppreference.com/w/cpp/language/raii</a></li>
<li><a href="https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii?answertab=scoredesc#tab-top">https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii?answertab=scoredesc#tab-top</a></li>
<li><a href="https://docs.microsoft.com/en-us/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?redirectedfrom=MSDN&amp;view=msvc-170">https://docs.microsoft.com/en-us/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?redirectedfrom=MSDN&amp;view=msvc-170</a></li>
</ol>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 耗时统计代码片段</title>
    <url>/2021/09/04/cpp-time-count/</url>
    <content><![CDATA[<p>C++ 耗时统计代码片段</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::chrono::milliseconds ms;</span><br><span class="line"><span class="keyword">using</span> clk = std::chrono::system_clock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_my_work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// work code here</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> begin_time = clk::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">do_my_work</span>();</span><br><span class="line">	<span class="keyword">auto</span> end_time = clk::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> duration_nn = std::chrono::duration_cast&lt;ms&gt;(end_time - begin_time);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;timecost: &quot;</span> &lt;&lt; (<span class="keyword">double</span>)duration_nn.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>总结</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Cygwin环境下查看远程服务器的图片</title>
    <url>/2020/03/01/cygwin-open-gui/</url>
    <content><![CDATA[<p>Linux系统下，<code>SSH -X</code>能够将 ssh 连接到的远程服务器上的图形化显示转发到本地，因此可以方便地查看服务器上的结果。不过在Cygwin下，使用<code>ssh -X</code>选项并不work。</p>
<p>调查后发现是需要用Cygwin的安装文件安装<code>xorg-server</code> 和 <code>xinit</code>这两个包，然后在一个终端执行<code>startxwin</code>，一直开着，在别的终端进行ssh连接与显示，发现就可以了。</p>
<p>另外发现Cygwin的一个缺点是，每次安装包都得重新运行一遍安装文件，还是没有<code>apt</code>来得方便，所以后面试试能否用WSL替代Cygwin来工作。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://unix.stackexchange.com/a/227937">https://unix.stackexchange.com/a/227937</a></li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Cygwin</tag>
      </tags>
  </entry>
  <entry>
    <title>Cygwin 使用rsync 报错解决</title>
    <url>/2020/03/01/cygwin-rsync/</url>
    <content><![CDATA[<p>在 Cygwin 下使用<code>rsync</code>时，报下面的错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync: connection unexpectedly closed (0 bytes received so far) [receiver] </span><br><span class="line">rsync error: error <span class="keyword">in</span> rsync protocol data stream (code 12) at io.c(600) [receiver=3.0.5]</span><br><span class="line">rsync: connection unexpectedly closed (0 bytes received so far) [sender]</span><br><span class="line">rsync error: error <span class="keyword">in</span> rsync protocol data stream (code 12) at io.c(610) [sender=3.0.8]</span><br></pre></td></tr></table></figure>
<p>由于<code>rsync</code>是通过<code>ssh</code>工具来传数据的，通过<code>which ssh</code> 查看，发现使用的是 Windows 自带的 SSH，所以报错，因此用 Cygwin 的安装程序重新安装<code>openssh</code>包，再打开终端，默认使用的<code>ssh</code>就变成 Cygwin 下的了，此时使用<code>rsync</code>命令就不再报错了。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Cygwin</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的string_view</title>
    <url>/2021/01/23/cpp-summary-stringview/</url>
    <content><![CDATA[<p>C++17标准库里面引入了轻量级的只读字符串表示类型<code>string_view</code>，用来替代<code>const char*</code> 和<code>const string&amp;</code>，在传入函数的时候减小内存开销(因为<code>string_view</code>类只包含字符串的指针和字符串的长度值，开销小于<code>string</code>类型)。</p>
<span id="more"></span>

<p><code>string_view</code> 定义在头文件<code>&lt;string_view&gt;</code>中。</p>
<p>具体来说，C++17里面引入了模板类<code>basic_string_view</code>类，而<code>string_view</code>是针对<code>char</code>特化的类，如头文件中所表示的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> string_view = basic_string_view&lt;<span class="keyword">char</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> u8string_view = basic_string_view&lt;<span class="keyword">char8_t</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> u16string_view = basic_string_view&lt;<span class="keyword">char16_t</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> u32string_view = basic_string_view&lt;<span class="keyword">char32_t</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> wstring_view   = basic_string_view&lt;<span class="keyword">wchar_t</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>可以看到针对不同类型的字符数组，都有对应的只读view。<br>顺便提一下，上述代码中用到的<code>using</code>用法是C++11引入的类型重定义（type alias)，可以给类型和函数起别名，下面是官方给的示例用法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// type alias, identical to</span></span><br><span class="line"><span class="comment">// typedef std::ios_base::fmtflags flags;</span></span><br><span class="line"><span class="keyword">using</span> flags = std::ios_base::fmtflags;</span><br><span class="line"><span class="comment">// the name &#x27;flags&#x27; now denotes a type:</span></span><br><span class="line">flags fl = std::ios_base::dec;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// type alias, identical to</span></span><br><span class="line"><span class="comment">// typedef void (*func)(int, int);</span></span><br><span class="line"><span class="keyword">using</span> func = <span class="built_in"><span class="keyword">void</span></span> (*) (<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// the name &#x27;func&#x27; now denotes a pointer to function:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">func f = example;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// alias template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">using</span> ptr = T*; </span><br><span class="line"><span class="comment">// the name &#x27;ptr&lt;T&gt;&#x27; is now an alias for pointer to T</span></span><br><span class="line">ptr&lt;<span class="keyword">int</span>&gt; x;</span><br></pre></td></tr></table></figure>

<p><code>string_view</code> 使用方法与<code>string</code>一样，而且可以由<code>string</code>类型对象相互初始化，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string_view <span class="title">sv1</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">s1</span><span class="params">(sv1)</span></span>;</span><br><span class="line"><span class="function">std::string_view <span class="title">sv2</span><span class="params">(s1)</span></span>;</span><br></pre></td></tr></table></figure>

<p>实际测试发现，相同的字符串，<code>string_view</code> 对象的大小确实比<code>string</code>对象要小，比如下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::string_view <span class="title">sv1</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">std::string <span class="title">s1</span><span class="params">(sv1)</span></span>;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;size of string_view: &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(sv1) &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;size of string: &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s1) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在32位的机器下(x86)，输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">size of string_view: 8</span><br><span class="line">size of string: 28</span><br></pre></td></tr></table></figure>
<p>因为<code>string_view</code> 只包含一个指向字符串的指针(*)和一个表示数组大小的整型数值(<code>int</code>)，因此总大小是4+4=8。而<code>string</code>是容器类型，内部结构我不太清楚，看输出整体是要比<code>string_view</code>大挺多的。</p>
<p>如果想在C++11的环境下使用C++17才引入的<code>string_view</code>，可以使用谷歌推出的<a href="https://github.com/abseil/abseil-cpp">absl库</a>，这个库在C++11的环境下实现了很多C++14，17甚至20里面才提出的新特性，可以尝试一下。</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>C++17</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian 下搭建Discuz!论坛</title>
    <url>/2014/12/14/debian-discuz/</url>
    <content><![CDATA[<p><a href="http://www.discuz.net/">Discuz!</a>是一个用PHP编写的论坛框架,像<a href="http://bt.neu6.edu.cn/" title="六维">六维</a>以及我们学校少年班学院的<a href="https://gewu.ustc.edu.cn/">格物致知论坛</a>都是搭建在Discuz!上面的,看论坛页面左下角,都写着”Powered by Discuz!_xxx”,_其中xxx表示Discuz!的版本号.因为我们实验室师兄用内网搭建了个服务器管理的论坛,而且我之前也尝试过搭建wordpress博客(详细过程可以看我<a href="https://vra.blog.ustc.edu.cn/debian-wordpress/">这篇博客</a>)而且成功了(其实没什么技术含量….),估计这个过程也差不多,所以我就想试试Discuz!能否搞定.但我们学校有规定,不能用freeshell搭建网络论坛的,所以我就在我电脑上试着搞搞Discuz!玩玩.</p>
<span id="more"></span>

<p><img src="/uploads/2014/12/Selection_0201.png"></p>
<p>整个过程大概分为两部分,第一部分就是搭建LAMP整个框架,第二部分就是在LAMP基础上配置Discuz!.</p>
<p>其实LAMP框架是最核心的东西,有了这个框架,其实我们完全不用什么wordpress和Discuz!,只要你可以写后端的PHP程序和前端的HTML,CSS,JS这些代码,完全可以自己写网站或论坛等.而wordpress,Discuz!给了不会或者写不好代码的人一个简易的搭博客和搭论坛的方式,大大简化了步骤,缩短了开发时间.</p>
<p>搭建LAMP的过程我已经在<a href="https://vra.blog.ustc.edu.cn/debian-wordpress/">搭wordpress的博客</a>里面写了,也可以访问<a href="https://wiki.debian.org/LaMp">debian的wiki.</a>下面我着重陈述配置Discuz!的部分.</p>
<p>1.下载Discuz!压缩文件:</p>
<p>下载地址为:<a href="http://www.discuz.net/thread-3570835-1-1.html">http://www.discuz.net/thread-3570835-1-1.html</a>.有简体和繁体的GBK和UTF8版本,可以根据自己需要下载相应版本.</p>
<p>2.将下载的Discuz!压缩文件解压:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip /path/to/Discuz_XXX_XX_XXX.zip</span><br></pre></td></tr></table></figure>

<p>其中/path/to/要改为到压缩包的路径,Discuz_XXX_XX_XXX.zip要改为你下载的压缩包的名字.</p>
<p>3.将解压后的upload文件夹复制到apache2的默认网页目录(/var/www/)下的forum下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /var/www/forum</span><br><span class="line">cp -R upload /var/www/forum</span><br></pre></td></tr></table></figure>

<p>4.修改forum目录下的子目录的访问权限:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/www/forum</span><br><span class="line">sudo chmod -R 777 config data uc_client uc_server</span><br></pre></td></tr></table></figure>

<p>经过简单的几步操作,我们就可以开始Discuz!的配置了.</p>
<p>5.Discuz!数据库配置:</p>
<p>在浏览器中输入<a href="http://localhost/forum,%E5%B0%B1%E4%BC%9A%E5%87%BA%E7%8E%B0Discuz!%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B5%E9%9D%A2">http://localhost/forum,就会出现Discuz!的配置页面</a>:</p>
<p><img src="/uploads/2014/12/Selection_013.png"></p>
<p>然后我们一步一步来安装.</p>
<p>a.首先在这个页面选择我同意按钮,就会到1.开始安装页面:</p>
<p><img src="/uploads/2014/12/Selection_014.png"></p>
<p>b.如果之前修改了forum子目录的权限的话,这一步是没问题的.如果有问题,请检查你的chmod那个命令执行了没有.没问题的话,按页面底部的下一步按钮,就到2.设置运行环境页面:</p>
<p><img src="/uploads/2014/12/Selection_015.png"></p>
<p>这一步选择默认即可.下一步就到了3.安装数据库页面了:</p>
<p><img src="/uploads/2014/12/Selection_016.png"></p>
<p>这一步就是配置数据库,设置管理员信息.要注意的是管理员密码是必须填的,也是管理员登录这个论坛的passwd.填好之后下一步,就到了4.安装数据库:</p>
<p><img src="/uploads/2014/12/Selection_017.png"></p>
<p>可以看到,这一步就是执行上一步表中所填的内容,即在MySQL数据库中创建数据库,创建表格,执行初始化操作等等.安装完成后就到了这个页面:</p>
<p><img src="/uploads/2014/12/Selection_018.png"></p>
<p>看到右下角一行小字:”您的论坛已安装完成,点此访问”了吗?,点击这个按钮,就可以看到你的论坛了!</p>
<p>下面是我发了一个帖子的页面:</p>
<p><img src="/uploads/2014/12/Selection_019.png"></p>
<p>至此,Discuz!搭建就完成了.</p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>在Debian下搭建基于Apache-Php-MySQL的wordpress博客</title>
    <url>/2014/12/13/debian-wordpress/</url>
    <content><![CDATA[<p>wordpress是一个流行的博客搭建框架,为不会html,css和js的人提供了搭建博客的便捷方式.我这里是在我的笔记本上搭建了一个wordpress博客,这里把详细的搭建过程写出来.</p>
<span id="more"></span>
<p>我的系统信息如下:</p>
<p><a href="/uploads/2014/12/Selection_001.png"><img src="/uploads/2014/12/Selection_001.png" alt="Selection_001"></a></p>
<p>具体的操作过程如下描述.</p>
<p>1.安装apache2服务器</p>
<p><a href="/uploads/2014/12/Selection_003.png"><img src="/uploads/2014/12/Selection_003.png" alt="Selection_003"></a></p>
<p>其中apache2-doc是apache服务器的说明和配置文件,libapache2-mod-php5是apache的php模块库文件.</p>
<p>安装成功后,重启apache2服务器,</p>
<p><a href="/uploads/2014/12/Selection_0012.png"><img src="/uploads/2014/12/Selection_0012.png" alt="Selection_001"></a></p>
<p>此时在浏览器地址栏里面输入<a href="http://localhost,则会看到如下的页面,提示我们apache2服务器已经安装成功/">http://localhost,则会看到如下的页面,提示我们apache2服务器已经安装成功</a>.</p>
<p>&nbsp;</p>
<p><a href="/uploads/2014/12/Selection_0021.png"><img src="/uploads/2014/12/Selection_0021.png" alt="Selection_002"></a></p>
<p>2.关于apache2的配置信息:</p>
<p>a.apache2的配置文件目录是/etc/apache2.在debian下,配置文件被打散分到了该目录下的几个子文件夹中.可以看该目录下的文件:</p>
<p><a href="/uploads/2014/12/Selection_002.png"><img src="/uploads/2014/12/Selection_002.png" alt="Selection_002"></a></p>
<p>其中apache2.conf 是主配置文件,该目录下还有ports.conf文件用来配置服务器的监听端口.此外mod-enabled和sites-enabled和conf-enabled子目录下分别有一个.conf文件,详细的配置说明可以看相应的说明.</p>
<p>b.apache2安装时会创建一个叫做www-data的用户,所有apache相关的进程都由该用户来启动执行.可以在浏览器里面访问localhost的时候,用top命令查看:</p>
<p><a href="/uploads/2014/12/Selection_0031.png"><img src="/uploads/2014/12/Selection_0031.png" alt="Selection_003"></a></p>
<p>上图中第5条记录即为apache2服务器的进程开销情况.</p>
<p>c.apache2的默认网页和脚本存放目录为/var/www/html,在该目录下存放的网页(除了index页面)都可以通过<a href="http://localhost/filename%E8%AE%BF%E9%97%AE%E5%88%B0,%E5%A6%82%E8%AF%A5%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%9C%89%E4%B8%AAaboutme.html,%E5%88%99%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E8%BE%93%E5%85%A5http://localhost/aboutme.html%E8%AE%BF%E9%97%AE">http://localhost/filename访问到,如该目录下有个aboutme.html,则可以在浏览器里输入http://localhost/aboutme.html访问</a>.</p>
<p>3.安装php:</p>
<p><a href="/uploads/2014/12/Selection_007.png"><img src="/uploads/2014/12/Selection_007.png" alt="Selection_007"></a></p>
<p>其中php5-mysql是php和mysql数据库的接口,为了使用mysql数据库必须安装这个包.</p>
<p>安装完成后,可以通过如下方法检查php的安装是否成功:</p>
<p>a.在/var/www/html目录下,编写如下内容的文件phpinfo.php:</p>
<pre>&lt;?php phpinfo(); ?&gt;</pre>
<p>然后在浏览器中访问该页面:<a href="http://localhost/phpinfo.php,%E5%A6%82%E6%9E%9C%E5%87%BA%E7%8E%B0%E5%A6%82%E4%B8%8B%E9%A1%B5%E9%9D%A2,%E5%88%99%E8%AF%B4%E6%98%8Ephp%E5%AE%89%E8%A3%85%E5%B7%B2%E7%BB%8F%E6%88%90%E5%8A%9F">http://localhost/phpinfo.php,如果出现如下页面,则说明php安装已经成功</a>.</p>
<p><a href="/uploads/2014/12/Selection_008.png"><img src="/uploads/2014/12/Selection_008.png" alt="Selection_008"></a></p>
<p>往下拉一下网页右侧滚动条,就可以看到下面是php支持的各个模块和组件.看起来相当多.</p>
<p>4.安装mysql:</p>
<p><a href="/uploads/2014/12/Selection_009.png"><img src="/uploads/2014/12/Selection_009.png" alt="Selection_009"></a></p>
<p>安装完成后,刷新刚才的phpinfo页面,往下拉到中间位置的时候,可以看到mysql和mysqli,说明msyql也已经安装成功了.</p>
<p><a href="/uploads/2014/12/Selection_010.png"><img src="/uploads/2014/12/Selection_010.png" alt="Selection_010"></a></p>
<p>&nbsp;</p>
<p>5.下载wordpress压缩文件:</p>
<p>访问<a href="http://cn.wordpress.org,如下图所示.在右侧中间位置有压缩包供下载,点击下载即可/">http://cn.wordpress.org,如下图所示.在右侧中间位置有压缩包供下载,点击下载即可</a>.</p>
<p><a href="/uploads/2014/12/Selection_011.png"><img src="/uploads/2014/12/Selection_011.png" alt="Selection_011"></a></p>
<p>也可复制该链接地址,用wget下载(感觉好像用wget下载比较快):</p>
<p><a href="/uploads/2014/12/Selection_012.png"><img src="/uploads/2014/12/Selection_012.png" alt="Selection_012"></a></p>
<p>下载后解压该文件:</p>
<p><a href="/uploads/2014/12/Selection_0131.png"><img src="/uploads/2014/12/Selection_0131.png" alt="Selection_013"></a></p>
<p>解压后的文件放在wordpress文件夹下,可以看看里面的内容:</p>
<p><a href="/uploads/2014/12/Selection_0041.png"><img src="/uploads/2014/12/Selection_0041.png" alt="Selection_004"></a></p>
<p>可以看到大多都是以wp开头的文件或文件夹,这些文件夹保存了配置博客的脚本和展示给访问者的页面框架,而其他的信息则保存在数据库中.</p>
<p>因为我们默认的网页存放目录是/var/www/html,所以要将该文件夹内文件移动到该目录下才生效,所以执行如下移动操作:</p>
<pre>mv -R wordpress /var/www/html</pre>
<p>该操作会用wordpress目录替换原来的html目录.</p>
<p>现在在浏览器中打开<a href="http://localhost,就会看到开始wordpress的配置的页面了/">http://localhost,就会看到开始wordpress的配置的页面了</a>:</p>
<p><a href="/uploads/2014/12/Selection_0161.png"><img src="/uploads/2014/12/Selection_0161.png" alt="Selection_016"></a></p>
<p>然后按照步提示,在mysql创建相应的wordpress数据库,整个博客就算搭建完成了!</p>
<p>下面是我搭建的博客(随便从网上抄了点内容…):</p>
<p><a href="/uploads/2014/12/Selection_0171.png"><img src="/uploads/2014/12/Selection_0171.png" alt="Selection_017"></a></p>
<p>(-完-)</p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习总结4——类型转换</title>
    <url>/2015/03/31/cpp-type-cast/</url>
    <content><![CDATA[<p>在写程序的时候有时会遇到类型转换的问题，而这些问题的解答每次都记不住，每次都得上网查找，经常下来，也觉得很浪费时间。所以这里我把C语言和C++里面一些常用的类型转换方式写下来，一方面为了以后查找方便，另一方面也是希望通过敲一遍能尽可能地记住转换的思路。所有这些转换的代码我已经放到了<a href="https://github.com/vra/cast-utilities">github</a>上，或许可以帮到你。</p>
<span id="more"></span>


<h2 id="几种字符串之间的转换"><a href="#几种字符串之间的转换" class="headerlink" title="几种字符串之间的转换"></a>几种字符串之间的转换</h2><h3 id="字符串类型介绍"><a href="#字符串类型介绍" class="headerlink" title="字符串类型介绍"></a>字符串类型介绍</h3><p>这里说的“字符串”包括<code>string</code>，’wstring’，’CString’。<code>string</code>是C++里面默认的字符串表示形式,<code>string</code>的实现使用了容器的概念，所以<code>string</code>类对象也有<code>begin()</code>，<code>end()</code>这些迭代方法。’wstring’ 是保存宽字符（wide character，C++中有wchar_t类型来表示宽字符）的字符串。字符串常量在初始化’wstring’类型对象时，前面要加“L”，用以表明是宽字符串。’CString’是Windows平台下的特定的字符串，在MFC程序中使用广泛，但也可以在非MFC程序中使用，只要包括相应的头文件即可:’CString’在afx.h中定义，所以只需在程序中include &lt;afx.h&gt;就可以使用’CString’啦。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _AFXDLL _AFXDLL_H_ <span class="comment">//注意：必须写在afx.h之前</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afx.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str_exampe = “This is oridnary string”;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意：字符串常量前面要加L</span></span><br><span class="line">    wstring wstr_exampe = L”This is wide string”;</span><br><span class="line"></span><br><span class="line">    CString cstr_example = “This is Cstring”;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要强调的是，_AFXDLL的定义必须写在#include&lt;afx.h&gt;之前，否则会出现_AFXDLL未定义的错误。</p>
<h3 id="转换代码"><a href="#转换代码" class="headerlink" title="转换代码"></a>转换代码</h3><p>CString 可以用来表示所有字符，根据字符编码的不同，可以表示宽字符或者非宽字符。Windows使用了LPCTSTR来表示你的字符是否使用了UNICODE, 如果你的程序定义了UNICODE或者其他相关的宏，那么这个字符或者字符串将被作为UNICODE字符串，否则就是标准的ANSI字符串。贴代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _AFXDLL XXX <span class="comment">//注意：必须写在afx.h之前</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afx.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1-1.string to wstring</span></span><br><span class="line">    string name = “Aldex”;</span><br><span class="line">    <span class="function">wstring <span class="title">w_name</span><span class="params">(name.begin(), name.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1-2\. wstring to string</span></span><br><span class="line">    wstring w_name2 =L”Smitch Hill”;</span><br><span class="line">    <span class="function">string <span class="title">name2</span><span class="params">(w_name2.begin(), w_name2.end())</span></span>;</span><br><span class="line">    cout &lt;&lt; name2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2-1.string to CString</span></span><br><span class="line">    string name3 = “Cook Book”;</span><br><span class="line">    <span class="function">CString <span class="title">c_name3</span><span class="params">(name3.c_str())</span></span>;</span><br><span class="line">    cout &lt;&lt; c_name3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2-2.CString to string</span></span><br><span class="line">    CString c_name4 = “Malon Balendo”;</span><br><span class="line">    string name4 = (LPCTSTR)c_name4;</span><br><span class="line">    cout &lt;&lt; name4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3-1.wstring to CString</span></span><br><span class="line">    wstring w_name5 = L”Odlely Herben”;</span><br><span class="line">    CString c_name5 = w_name5.<span class="built_in">c_str</span>();</span><br><span class="line">    cout &lt;&lt; c_name5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3-2.Cstring to wstring</span></span><br><span class="line">    CString c_name6 = “Jephp Phoo”;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//in ANSI build</span></span><br><span class="line">    wstring w_name6 =<span class="built_in">CStringW</span>(c_name6);</span><br><span class="line">    <span class="comment">//in Unicode build</span></span><br><span class="line">    wstring w_name6 = c_name6;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要强调的是，从CString转换到wstring时，需要根据当前项目的编码方式来决定该用哪种转换方法（我在VS里面试了一下，默认是ANSI 环境）。</p>
<h2 id="字符数组和字符串之间的转换"><a href="#字符数组和字符串之间的转换" class="headerlink" title="字符数组和字符串之间的转换"></a>字符数组和字符串之间的转换</h2><h3 id="const-char-和char-之间转换（const-wchar-t-与-wchar-t-类似）"><a href="#const-char-和char-之间转换（const-wchar-t-与-wchar-t-类似）" class="headerlink" title="const char* 和char*之间转换（const wchar_t* 与 wchar_t* 类似）"></a>const char* 和char*之间转换（const wchar_t* 与 wchar_t* 类似）</h3><p>由于指针和数组相似的性质，下面统一用指针来陈述。</p>
<p><code>const char*</code> 是常字符数组，相比<code>char*</code>，其内容是不可变的，所以从<code>char*</code> 到<code>const char*</code>是“从宽到窄”，正常可以进行，甚至不需要类型转换；而从<code>const char*</code> 到<code>char*</code>则是“从窄到宽”，转换被认为是不正常的，所以如果需要这样的转换，请先考虑程序设计是否有问题。当然，转换方式还是有的：可以用<code>strdup</code> 或者<code>_strdup</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1-1.char* to const char*</span></span><br><span class="line">    <span class="keyword">char</span>* arr_name =“Hello, Blub Bulb “;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* c_arr_name = arr_name;</span><br><span class="line">    <span class="built_in">printf</span>(“%s”, c_arr_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1-2.const char* to char</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* c_arr_name2 = “Android Lollipop”;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* arr_name2 = _strdup(c_arr_name2); <span class="comment">//ISO C++ onformant name</span></span><br><span class="line">    <span class="keyword">char</span>* arr_name2 = <span class="built_in">strdup</span>(c_arr_name2); <span class="comment">//The Posix name</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(“%s”, arr_name2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="char-和wchar-t-之间的转换"><a href="#char-和wchar-t-之间的转换" class="headerlink" title="char*和wchar_t*之间的转换"></a>char*和wchar_t*之间的转换</h3><p><code>char*</code>和<code>wchar_t*</code>之间的转换我很少用到，这里还是从网上找了出来，列举如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2-1.char* to wchar_t*</span></span><br><span class="line">    <span class="keyword">char</span>* arr_name = “Hulu Gulu”;</span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="built_in">strlen</span>(arr_name) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">wchar_t</span>* w_arr_name = <span class="keyword">new</span> <span class="keyword">wchar_t</span>[size];</span><br><span class="line">    <span class="built_in">mbstowcs</span>(w_arr_name, arr_name, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2-2\. wchar_t* to char*</span></span><br><span class="line">    <span class="keyword">wchar_t</span>* w_arr_name2 = L”Big Ben”;</span><br><span class="line">    <span class="keyword">char</span>* arr_name2 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">wcslen</span>(w_arr_name2)]; <span class="comment">// wcslen用来求宽体字符数组的长度</span></span><br><span class="line">    <span class="built_in">wcstombs</span>(arr_name2, w_arr_name2, <span class="built_in">wcslen</span>(w_arr_name2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="char-和-string的转换（wchar-t-和-wstring转换同理）"><a href="#char-和-string的转换（wchar-t-和-wstring转换同理）" class="headerlink" title="char* 和 string的转换（wchar_t* 和 wstring转换同理）"></a>char* 和 string的转换（wchar_t* 和 wstring转换同理）</h3><p><code>char*</code> 转化为<code>string</code>时会进行默认类型转换，即不需要显式地转换。而<code>string</code>转换为<code>const char*</code> 比较容易，要转换为<code>char*</code>比较麻烦，要进行内存的复制，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3-1.char* to string</span></span><br><span class="line">    <span class="keyword">char</span>* arr_name = “This is my name”;</span><br><span class="line">    <span class="function">string <span class="title">name</span><span class="params">(arr_name)</span></span>;</span><br><span class="line">    cout &lt;&lt; arr_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3-2.string to char*</span></span><br><span class="line">    string name2 = “Hoop Hope”;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换为const char* 类型</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* c_arr_name2 = name2.<span class="built_in">c_str</span>();   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换为char*类型</span></span><br><span class="line">    <span class="keyword">char</span>* arr_name2 = <span class="keyword">new</span> <span class="keyword">char</span>[name2.<span class="built_in">length</span>() + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(arr_name2, name2.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="wchar-t-和string，char-和wstring之间的转换"><a href="#wchar-t-和string，char-和wstring之间的转换" class="headerlink" title="wchar_t*和string，char* 和wstring之间的转换"></a>wchar_t*和string，char* 和wstring之间的转换</h3><p>这一类的转换我没遇到过，但我想利用前面的这些转换方法，通过使用一个中间格式，可以完成转换，所以就再没有查这部分的转换。</p>
<h2 id="字符串和别的数据类型之间的转换"><a href="#字符串和别的数据类型之间的转换" class="headerlink" title="字符串和别的数据类型之间的转换"></a>字符串和别的数据类型之间的转换</h2><p>这部分总结下字符串类型和int，float这些类型转换时的一些方法。</p>
<h3 id="char-和int，float类型转换"><a href="#char-和int，float类型转换" class="headerlink" title="char* 和int，float类型转换"></a>char* 和int，float类型转换</h3><p>这方面有三种选择：<code>atoi</code>（对float类型是<code>atof</code>）， <code>sscanf</code>和<code>strtol</code>（对float类型，是<code>strtof</code>）。<a href="http://stackoverflow.com/questions/3420629/convert-string-to-integer-sscanf-or-atoi">StackOverFlow上的这个回答</a>详细的解释了三者的区别，总体来说<code>atoi</code>速度最快，但出错时没有提示，<code>sscanf</code>可以通过类似<code>scanf</code>的方式来读取，<code>strtol</code>最安全，错误提示也多，但默认是将<code>char*</code> 转换为<code>long int</code>(函数名的含义：<code>str to long</code>)。三种代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//1-1.char* to int</span></span><br><span class="line">     <span class="keyword">char</span>* arr_number = “<span class="number">2015</span>”;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//a.use atoi</span></span><br><span class="line">     <span class="keyword">int</span> number1 = <span class="built_in">atoi</span>(arr_number);</span><br><span class="line">     cout &lt;&lt; number1&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//b.use sscanf</span></span><br><span class="line">     <span class="keyword">int</span> number2;</span><br><span class="line">     <span class="built_in">sscanf</span>(arr_number, “%d”, &amp;number2);</span><br><span class="line">     cout &lt;&lt; number2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//c.use strtol</span></span><br><span class="line">     <span class="keyword">char</span>* pEnd; <span class="comment">//用以指向末尾位置</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> number3 = <span class="built_in">strtol</span>(arr_number, &amp;pEnd, <span class="number">0</span>);<span class="comment">//最后一个参数表示从char*的第几个位置开始读取</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//1-2.int to char*</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> time = <span class="number">2345</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//a.use itoa</span></span><br><span class="line">     <span class="keyword">char</span>* arr_time;</span><br><span class="line">     <span class="built_in">itoa</span>(time, arr_time, <span class="number">0</span>);<span class="comment">//最后一个参数表示从int的第几个位置开始读取</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//b.use sprintf</span></span><br><span class="line">     <span class="keyword">char</span>* arr_time2;</span><br><span class="line">     <span class="built_in">sprintf</span>(arr_time2, “%d”, time);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="string-和int，float类型之间的转换"><a href="#string-和int，float类型之间的转换" class="headerlink" title="string 和int，float类型之间的转换"></a>string 和int，float类型之间的转换</h3><p><code>string</code>和<code>int</code>，<code>float</code>之间的转换要用到 <code>stringstream</code>，或者<code>ostringstream</code>和<code>istringstream</code>。  </p>
<p>区别是<code>stringstream</code>既可以传入，也可以传出，所以既可以将<code>string</code>转化为<code>int</code>或<code>float</code>，也可以将<code>int</code>或<code>float</code>转换为<code>string</code>；而<code>ostringstream</code>只能输出<code>string</code>，所以只能将<code>int</code>或<code>float</code>转换为<code>string</code>，<code>istringstream</code>刚好反过来了。  </p>
<p>总的来说<code>stringstream</code>是双向的，而<code>i/ostringstream</code>是单向的。相应地，<code>wstring</code>和<code>int</code>/<code>float</code> 可以通过<code>wstring</code>或者<code>wostringstream</code>和<code>wistringstream</code>来转换。 </p>
<p>注意需要包含<code>sstream</code>头文件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//2-1.string to int</span></span><br><span class="line">     string str_age = “<span class="number">73</span>”;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//a.use stringstream</span></span><br><span class="line">     <span class="function">stringstream <span class="title">s</span><span class="params">(str_age)</span></span>;</span><br><span class="line">     <span class="keyword">int</span> age;</span><br><span class="line">     s &gt;&gt; age;</span><br><span class="line">     cout &lt;&lt; age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//b.use istringstream</span></span><br><span class="line">     <span class="function">istringstream <span class="title">is</span><span class="params">(str_age)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> age2;</span><br><span class="line">     is &gt;&gt; age2;</span><br><span class="line">     cout &lt;&lt; age2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//2-2.int to string</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//a.use stringstream</span></span><br><span class="line">     <span class="keyword">int</span> year = <span class="number">2015</span>;</span><br><span class="line">     stringstream s2;</span><br><span class="line">     s2 &lt;&lt; year;</span><br><span class="line">     string str_year;</span><br><span class="line">     s2 &gt;&gt; str_year;</span><br><span class="line">     cout &lt;&lt; str_year &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//b.use ostringstream</span></span><br><span class="line">     ostringstream os;</span><br><span class="line">     os &lt;&lt; year;</span><br><span class="line">     string str_year2 = os.<span class="built_in">str</span>();</span><br><span class="line">     cout &lt;&lt; str_year2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p>基本都是StackOverFlow的链接……</p>
<p>1.<a href="http://stackoverflow.com/questions/2573834/c-convert-string-or-char-to-wstring-or-wchar-t">http://stackoverflow.com/questions/2573834/c-convert-string-or-char-to-wstring-or-wchar-t</a></p>
<p>2.<a href="http://stackoverflow.com/questions/4804298/how-to-convert-wstring-into-string">http://stackoverflow.com/questions/4804298/how-to-convert-wstring-into-string</a></p>
<p>3.<a href="http://stackoverflow.com/questions/15333259/c-stdwstring-to-stdstring-quick-and-dirty-conversion-for-use-as-key-in">http://stackoverflow.com/questions/15333259/c-stdwstring-to-stdstring-quick-and-dirty-conversion-for-use-as-key-in</a></p>
<p>4.<a href="http://stackoverflow.com/questions/11821491/converting-string-to-cstring-in-c">http://stackoverflow.com/questions/11821491/converting-string-to-cstring-in-c</a></p>
<p>5.<a href="http://stackoverflow.com/questions/2041241/convert-cstring-to-stdwstring">http://stackoverflow.com/questions/2041241/convert-cstring-to-stdwstring</a></p>
<p>6.<a href="http://stackoverflow.com/questions/258050/how-to-convert-cstring-and-stdstring-stdwstring-to-each-other">http://stackoverflow.com/questions/258050/how-to-convert-cstring-and-stdstring-stdwstring-to-each-other</a></p>
<p>7.<a href="http://stackoverflow.com/questions/6117270/mfc-stdstring-vs-cstring">http://stackoverflow.com/questions/6117270/mfc-stdstring-vs-cstring</a></p>
<p>8.<a href="http://stackoverflow.com/questions/2041241/convert-cstring-to-stdwstring">http://stackoverflow.com/questions/2041241/convert-cstring-to-stdwstring</a></p>
<p>9.<a href="http://stackoverflow.com/questions/2259544/is-wchar-t-needed-for-unicode-support">http://stackoverflow.com/questions/2259544/is-wchar-t-needed-for-unicode-support</a></p>
<p>10.<a href="http://baike.baidu.com/view/998109.htm">http://baike.baidu.com/view/998109.htm</a></p>
]]></content>
      <categories>
        <category>学习总结</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建自己的Git服务器</title>
    <url>/2017/04/19/deploy-git/</url>
    <content><![CDATA[<p>相信很多人都对GitHub和GitLab很熟悉了，这些基于Git版本控制的在线代码托管平台由于丰富的内容，简洁的操作和集成一体化以及风靡全球了。今天我好奇，想了解下如何搭建自己的Git服务器，于是查了一些资料，记录下整个的流程。<br><img src="/imgs/git_logo.png"></p>
<span id="more"></span>
<h3 id="为什么要用自己的Git服务器？"><a href="#为什么要用自己的Git服务器？" class="headerlink" title="为什么要用自己的Git服务器？"></a>为什么要用自己的Git服务器？</h3><p>想了想，有下面的优势：</p>
<ol>
<li>免费的私有仓库</li>
<li>完全的对项目的控制</li>
<li>了解GitHub和GitLab等背后的运作原理</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol>
<li>一台可以通过域名或网址访问的服务器</li>
<li>服务器上安装有ssh, git等工具，可以通过下面命令来安装:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install  openssh git</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="创建git用户"><a href="#创建git用户" class="headerlink" title="创建git用户"></a>创建git用户</h3><p>为了访问的便捷，我们使用git用户的身份来创建代码仓库，当然任何用户都是可以的，只不过在git clone的时候，将git@server改成别的用户名即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo adduser git</span><br></pre></td></tr></table></figure>

<h3 id="上传公钥"><a href="#上传公钥" class="headerlink" title="上传公钥"></a>上传公钥</h3><p>为了git clone 仓库的时候免去输入git用户密码的烦恼，我们这里发送客户端的用户的ssh公钥到git用户的<code>~/.ssh/authorized_keys</code>文件，具体执行下面这条命令即可:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i git@114.215.66.43</span><br></pre></td></tr></table></figure>

<h3 id="修改git用户的登录权限"><a href="#修改git用户的登录权限" class="headerlink" title="修改git用户的登录权限"></a>修改git用户的登录权限</h3><p>因为git用户是专门用来上传代码的，所以禁用git用户的登录权限，将git用户的登录shell改为<code>/usr/bin/git-shell</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/passwd </span><br><span class="line"><span class="comment"># change shell of git to /usr/bin/git-shell</span></span><br></pre></td></tr></table></figure>

<h3 id="创建裸仓库"><a href="#创建裸仓库" class="headerlink" title="创建裸仓库"></a>创建裸仓库</h3><p>因为git仓库不需要再服务器上更新，而是通过远程push进行更新，所以我们建立一个裸仓库即可，裸仓库即没有项目代码而只有git元数据的仓库，注意裸仓库后缀都是git。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su -l git</span><br><span class="line">mkdir -p ~/src/my-repo.git</span><br><span class="line">git init --bare my-repo.git</span><br></pre></td></tr></table></figure>
<p>这样服务器端的操作就完成了。</p>
<h3 id="客户端操作"><a href="#客户端操作" class="headerlink" title="客户端操作"></a>客户端操作</h3><p>客户端就按正常的git 操作来克隆刚才创建的仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@114.215.66.43:/home/git/src/my-repo.git</span><br></pre></td></tr></table></figure>
<p>后面就跟正常的操作完全一样了，演示一个简单的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-repo</span><br><span class="line"><span class="built_in">echo</span> README &gt;&gt; README</span><br><span class="line">git add README</span><br><span class="line">git commit -m <span class="string">&quot;add README&quot;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11新特性：default和delete</title>
    <url>/2016/01/17/default-deleted/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>今早在美国的本科室友问了我下面的C++代码是什么意思：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  _CV_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CV_H</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cv</span>&#123;</span></span><br><span class="line">	<span class="built_in">cv</span>(<span class="keyword">const</span> cv&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	cv&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> cv&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cv</span>(cv&amp;&amp;);</span><br><span class="line">	cv&amp; <span class="keyword">operator</span>=(cv&amp;&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>什么，<code>delete</code>居然还有这种神奇的用法？我确实以前没看过。所以我跑到实验室，自己查了些资料，大概明白这些代码是个什么意思了，所以记录下来。  </p>
<span id="more"></span>
<h2 id="default和delete"><a href="#default和delete" class="headerlink" title="default和delete"></a>default和delete</h2><p>在C++03的标准里面，如果程序代码里面没有写默认构造函数(像<code>cv();</code>)、复制构造函数、复制赋值函数(像<code>cv cv2=cv1;</code>)和析构函数，则编译器会自动添加这些函数。当程序里面写了构造函数的时候，编译器就不会自动添加默认构造函数了。<br>那如果我想让一个类的实例不能通过复制构造函数来生成，该怎么办呢？一般的方法是将复制构造函数和复制赋值函数声明为<code>private</code>，而且不去具体实现它们，这样就达到了目的。<br>但这样做其实是很tricky的方式，相当于利用c++的一些特性碰巧来实现，总感觉不是正确的方法。<br>C++11里面可以用<code>default</code>来指定使用默认的构造函数，而且可以通过<code>delete</code>来显式地禁止一些方法，如复制构造函数和复制赋值操作，如下例： </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NonCopyable</span>&#123;</span></span><br><span class="line">	<span class="built_in">NonCopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">NonCopyable</span>(<span class="keyword">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	NonCopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个例子里面，第一条语句是强制编译器生成默认构造函数作为struct的构造函数；第2、3条语句就是显式地禁用复制构造函数和复制赋值函数。  </p>
<h2 id="move-constructor"><a href="#move-constructor" class="headerlink" title="move constructor"></a>move constructor</h2><p>既然禁止了复制构造函数，那么如果想通过已经生成的类的实例来初始化一个同类的实例，要怎么操作呢？显然，<code>cv cv2(cv1)</code>和<code>cv cv2=cv1;</code>是不可以用的了，因为复制构造函数已经被禁止了。<br>C++11新定义了一个叫做<code>move constructor</code>的构造函数，签名方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">class_name</span>(class_name &amp;&amp;);</span><br><span class="line">class_name&amp; <span class="keyword">operator</span>=(class_name &amp;&amp;);</span><br></pre></td></tr></table></figure>
<p>调用时这样用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">class_name c1;</span><br><span class="line">class_name c2=std::<span class="built_in">move</span>(c1);</span><br><span class="line"><span class="function">class_name <span class="title">c3</span><span class="params">(std:move(c1))</span></span>;</span><br></pre></td></tr></table></figure>
<p>所谓<code>move</code>，我的理解就是类似于指针一样的概念，move生成的新的实例和原先的实例是由同一个指针指向的，即实际上是同一个实例。而且<code>&amp;&amp;</code>这个符号让人联想到了<code>**</code>，可能也是这个意思吧。<br>这就是这个新特性的简单介绍，感觉应用场合不是很多，可能是我还没搞懂的原因吧。<br>看了<a href="http://blog.csdn.net/luotuo44/article/details/46779063">这篇博客</a>,发现这个新特性还是很强大的啊～还是too young。<br>从<a href="https://msdn.microsoft.com/en-us/library/hh567368.aspx#defaultedanddeleted">这里</a>看到，vs2012里面还不支持这个特性，vs2013才开始支持。在g++中，可以通过使用<code>-std=c++11</code>来启用这个特性(我用的是g++4.9.2,默认是开启的)。  </p>
<p>参考链接:<br><a href="http://blog.csdn.net/pongba/article/details/1684519">http://blog.csdn.net/pongba/article/details/1684519</a><br><a href="https://en.wikipedia.org/wiki/C%2B%2B11#Explicitly_defaulted_and_deleted_special_member_functions">https://en.wikipedia.org/wiki/C%2B%2B11#Explicitly_defaulted_and_deleted_special_member_functions</a><br><a href="http://en.cppreference.com/w/cpp/language/move_constructor">http://en.cppreference.com/w/cpp/language/move_constructor</a><br><a href="http://stackoverflow.com/questions/7421825/c11-features-in-visual-studio-2012">http://stackoverflow.com/questions/7421825/c11-features-in-visual-studio-2012</a><br><a href="http://stackoverflow.com/questions/6077143/disable-copy-constructor">http://stackoverflow.com/questions/6077143/disable-copy-constructor</a></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title>全世界最准确的翻译DeepL到底有多强? 一个有意思的例子</title>
    <url>/2022/05/21/deepl-showoff/</url>
    <content><![CDATA[<ul>
<li>Deep Learning</li>
<li>Translator</li>
</ul>
<p>在知乎上偶然看到了一个基于深度学习的翻译器DeepL，实际体验了一下，确实发现比Google Translate, 百度翻译等工具好用，因此最近抛弃了之前的翻译工具，开始往DeepL切换，毕竟在阅读英文内容的过程中还是有很多单词和词组的意思不了解。最近在阅读DeepMind的一篇文章的时候，看到一段有意思的话，对比了一下，发现DeepL真的比竞品厉害，更加加速了我抛弃之前工具的速度。具体什么例子呢，如下细说。</p>
<span id="more"></span>

<h2 id="一个有意思的例子"><a href="#一个有意思的例子" class="headerlink" title="一个有意思的例子"></a>一个有意思的例子</h2><p>在阅读DeepMind的<a href="https://www.deepmind.com/blog/from-lego-competitions-to-deepminds-robotics-lab">这篇文章</a>的时候，我发现了有一个段落里面的一句话有点看不懂，具体如下：</p>
<blockquote>
<p>My afternoons are a mix of meetings, coding and – now that most people are back in the office – an impromptu chat or two. That’s one of my favourite parts of being in the office – the random catch-ups and whiteboard sessions that help me learn and move quickly. From there I’ll take a quick snack break, and if the weather is nice, head to the balcony to catch up on some of my favourite US sports podcasts (<strong>I still haven’t made the switch from football to <em>football</em></strong>). Then I’ll code a little while longer.</p>
</blockquote>
<p>截图如下：<br><img src="/imgs/quote.png" alt="段落"></p>
<p>这里前情提要是这样的：这个科学家是个英国人，在美国读了大学，在谷歌工作了一些时间后transfer到DeepMind了。这里提到一些每日活动安排，前面说到他会看一会最喜欢的美国体育播客，然后就是红色框里面的那句<code>I still haven’t made the switch from football to football</code>，这里我没看懂，两个football是什么意思呢？依稀记得英语课上说够football有不同的含义，但不知道具体是什么。</p>
<p>因此我动用了翻译工具，结果如下。</p>
<p>谷歌翻译的结果:<br><img src="/imgs/google_translate.jpg" alt="google_translate"></p>
<p>百度翻译的结果：<br><img src="/imgs/baidu_translate.jpg" alt="baidu_translate"></p>
<p>看来那句话这几个翻译器都没看懂，让我也看得一头雾水。</p>
<p>然后尝试了一下DeepL，结果出乎意料:<br><img src="/imgs/deepl_translate.jpg" alt="deepl_translate"><br>谜题解开了，这里前面的<code>football</code>是美式英语，意思是橄榄球，而后面的<code>football</code>是英式英语表达，意思是足球，这也契合了前面说的看美国体育的播客的说法，DeepL估计是从上下文推断出来的，别的翻译器看来还是在理解文本上差一些。</p>
<p>至此我对DeepL的敬畏又增加了几分。</p>
<h2 id="一个疑问"><a href="#一个疑问" class="headerlink" title="一个疑问"></a>一个疑问</h2><p>看了下DeepL网站的介绍，确实做了很多创新。但我在想，像谷歌怎么厉害的公司，也有财力和物力来做相同的事情，为什么他们没有做或者说做不到跟DeepL那么好呢？</p>
]]></content>
  </entry>
  <entry>
    <title>检测Python代码中没有用到的函数和变量</title>
    <url>/2021/11/07/detect-unused-function-and-variable-in-python/</url>
    <content><![CDATA[<p>在重构Python代码的时候，需要统计有哪些函数和变量没有用到，搜索后发现一个简单的工具<a href="https://pypi.org/project/vulture/">vulture</a>，可以完成这个功能。 </p>
<p>操作也很简单, pip 安装包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install vulture</span><br></pre></td></tr></table></figure>

<p>检测代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vulture tester.py</span><br></pre></td></tr></table></figure>

<p>输出大概是这样:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tester.py:19: unused import <span class="string">&#x27;time&#x27;</span> (90% confidence)</span><br><span class="line">tester.py:181: unused variable <span class="string">&#x27;raw_img&#x27;</span> (100% confidence)</span><br><span class="line">tester.py:300: unused method <span class="string">&#x27;run_on_video&#x27;</span> (60% confidence)</span><br><span class="line">tester.py:403: unused method <span class="string">&#x27;render_results&#x27;</span> (60% confidence)</span><br></pre></td></tr></table></figure>
<p>可以看到，每一行是一个检测结果，包含文件名称，行数，检测结果以及检测的置信度，可以根据这个输出来重构代码。</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol>
<li><a href="https://stackoverflow.com/questions/693070/how-can-you-find-unused-functions-in-python-code">https://stackoverflow.com/questions/693070/how-can-you-find-unused-functions-in-python-code</a></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>detectron2 使用总结</title>
    <url>/2020/03/14/detectron2-usage/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>detectron2 大部分代码都需要GPU</li>
<li>detectron2 主要是用于检测和分割的代码框架，像分类这种任务的代码暂时没有</li>
<li>官方示例有一些是基于Colab的，需要科学上网才能访问<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip install -U torch==1.4+cu100 torchvision==0.5+cu100 -f https://download.pytorch.org/whl/torch_stable.html</span><br><span class="line">sudo pip install cython pyyaml==5.1 --ingnore-installed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 cocoapi</span></span><br><span class="line">sudo pip install -U <span class="string">&#x27;git+https://github.com/cocodataset/cocoapi.git#subdirectory=PythonAPI&#x27;</span></span><br></pre></td></tr></table></figure>
其中cocoapi 需要从GitHub下载代码，如果安装太慢，可以先clone下代码，再进<code>PythonAPI</code>子目录，运行<code>setup.py</code>安装:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/cocodataset/cocoapi.git</span><br><span class="line"><span class="built_in">cd</span> cocoapi/PythonAPI</span><br><span class="line">sudo python3 setup.py install</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="安装-detectron2"><a href="#安装-detectron2" class="headerlink" title="安装 detectron2"></a>安装 detectron2</h3><p>这里直接安装编译好的二进制文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip install detectron2 -f https://dl.fbaipublicfiles.com/detectron2/wheels/cu100/index.html</span><br></pre></td></tr></table></figure>
<p>如果文件下载太慢或者超时，可以手动在浏览器里面下载好文件，再用下面的命令安装（假设下载的<code>whl</code>文件是<code>xxx.whl</code>):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip install xxx.whl</span><br></pre></td></tr></table></figure>
<p>安装完后，打开 Python 命令行，执行下面的命令，如果不报错，说明安装成功：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> detectron2</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>为了测试，需要下载 detectron2 的源代码，基于 <code>demo/demo.py</code> 进行简单的测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/facebookresearch/detectron2</span><br><span class="line">python3  detectron2/demo/demo.py --config-file detectron2/configs/COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x.yaml --input ~/test.jpg --opts MODEL.WEIGHTS  detectron2://COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x/137849600/model_final_f10217.pkl</span><br></pre></td></tr></table></figure>
<p><strong>注意上述代码需要在 detectron2 的 git 仓库外面执行，否则会报错。</strong><br>测试时输入支持单张图片、多张图片、单个图片文件夹、网络摄像头以及视频文件，每种情况参数设置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单张图片</span></span><br><span class="line">--input test.jpg</span><br><span class="line"><span class="comment"># 多张图片</span></span><br><span class="line">--input test1.jpg test2.jpg test3.jpg</span><br><span class="line"><span class="comment"># 单个图片文件夹</span></span><br><span class="line">--input imgs/*.jpg</span><br><span class="line"><span class="comment"># 网络摄像头</span></span><br><span class="line">--webcame</span><br><span class="line"><span class="comment"># 视频文件</span></span><br><span class="line">--video-input test.mp4</span><br></pre></td></tr></table></figure>

<p>``–opts MODEL.WEIGHTS<code>表示测试用的模型参数，可以是一个本地目录，也可以是一个</code>detectron2://`开头的一个模型路径，这时会先下载模型到本地再测试:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用本地的模型参数</span></span><br><span class="line">--opts MODEL.WEIGHTS ./model_final_f10217.pkl</span><br><span class="line"><span class="comment"># 使用网络模型地址</span></span><br><span class="line">--opts MODEL.WEIGHTS ./model_final_f10217.pkl</span><br></pre></td></tr></table></figure>
<p>模型的名字可以在 <a href="https://github.com/facebookresearch/detectron2/blob/master/MODEL_ZOO.md">Model Zoo</a> 查看。</p>
<h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>训练代码参考 <code>tools/train_net.py</code>，目前Detection看。</p>
<h3 id="一些代码分析"><a href="#一些代码分析" class="headerlink" title="一些代码分析"></a>一些代码分析</h3><ol>
<li>DefaultTrainer 是针对目前常用的Detection设置而写的一个类，为了不用修改太多就直接复现最佳结果。但另一方面，由于有比较多的假设情况，因此通用性有所降低</li>
<li>SimpleTrainer 是 DefaultTrainer 的父类，限制条件更少，对于做新的研究任务，作者推荐继承 SimpleTrainer 来修改</li>
<li>代码支持多机多卡多进程，基于 Pytorch 的多级多卡代码写了一些wrapper</li>
<li>代码注释很完善，而且其中很多是给用户怎么基于现在代码进行修改来跑新的网络、做新的任务，有些地方说的很细致，这一点很棒</li>
</ol>
<h3 id="一些资源"><a href="#一些资源" class="headerlink" title="一些资源"></a>一些资源</h3><ol>
<li><a href="https://detectron2.readthedocs.org/">文档</a></li>
<li><a href="https://github.com/facebookresearch/detectron2">Git 仓库</a></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
        <tag>总结</tag>
        <tag>Deep Learning</tag>
        <tag>Computer Vision</tag>
        <tag>Detection</tag>
        <tag>Segmentation</tag>
        <tag>Detectron2</tag>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>设备文件,分区和文件系统辨析</title>
    <url>/2014/12/15/devices-partition-filesystem/</url>
    <content><![CDATA[<p>在写上一篇博客时,我发现我没搞清楚块设备(block device),分区(partion)和文件系统(filesystem)这几个概念之间的关系,今早查了一些资料才慢慢理解了它们之间的关系,所以我想写出来,看看我能不能将一个问题描述清楚.下面我依次描述设备文件,分区和文件系统这三个概念.</p>
<span id="more"></span>

<h2 id="设备文件-Device-file"><a href="#设备文件-Device-file" class="headerlink" title="设备文件(Device file)"></a>设备文件(Device file)</h2><p>在类Unix操作系统中,有”<a href="http://en.wikipedia.org/wiki/Everything_is_a_file">一切皆文件(everything is a file)”的思想</a>,当然硬件设备也不例外.在这个思想下,打印机,CD碟片,硬盘,输入输出硬件都被视为一个文件,而这些被视为文件的物理介质就可以称为设备文件.物理介质分为字符设备和块设备,详细的含义见下.除了物理介质,Unix操作系统还有一类设备文件,叫伪设备,这三类设备文件的具体含义是:</p>
<h3 id="字符设备-Character-devices"><a href="#字符设备-Character-devices" class="headerlink" title="字符设备(Character devices)"></a>字符设备(Character devices)</h3><p>每次与系统传输数据时,只传输一个字符.没有缓冲区,系统直接从物理设备读取字符.常用于流设备的通信.因为没有缓存,所以只能顺序读取字符,不支持随机读取.像串口和键盘就是字符设备.</p>
<h3 id="块设备-Block-devices"><a href="#块设备-Block-devices" class="headerlink" title="块设备(Block devices)"></a>块设备(Block devices)</h3><p>与字符设备相反,块设备每次与系统传输数据时,是以块(Block)的方式来传输的.由于以块来读取,所以需要一定读取时间,故常设有缓存区,支持随机读取.常见的块设备有硬盘,CD-ROM驱动器和闪存等.</p>
<h3 id="伪设备-Pseudo-devices"><a href="#伪设备-Pseudo-devices" class="headerlink" title="伪设备(Pseudo-devices)"></a>伪设备(Pseudo-devices)</h3><p>前面两种设备文件是物理设备,而伪设备则不是,它们通常是为操作系统提供特定的功能而存在的.常见的伪设备有:</p>
<p><code>/dev/null</code>:接受和丢弃所有输入,即吞下输入,然后什么都不做.</p>
<p><code>/dev/zero</code>:产生联系的NULL字符串流,用c语言表示就是”\0\0\0\0\0”</p>
<p><code>/dev/random</code>:产生一个随机的字符串流</p>
<p><code>/dev/full</code>:模拟一个已经装满了内容的设备</p>
<p>这些伪设备有什么用呢?在实际中,如果巧妙使用这些伪设备的话,可以提高工作效率,像命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=testzero count=1024 bs=1024</span><br></pre></td></tr></table></figure>

<p>就会创建一个大小为1024的,文件名为testzero的空文件.</p>
<p>上面就是设备文件的大概内容.在Linux 下,设备文件都在<code>/dev</code>目录下,并且有特定的前缀,可以看看:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /dev</span><br><span class="line">$ ls</span><br><span class="line"></span><br><span class="line">audio            dvd        loop2            network_throughput  sda5      tty11  tty27  tty42  tty58    v4l         vcsa4</span><br><span class="line">autofs           dvdrw      loop3            null                sda6      tty12  tty28  tty43  tty59    vboxdrv     vcsa5</span><br><span class="line">block            fb0        loop4            port                sdb       tty13  tty29  tty44  tty6     vboxdrvu    vcsa6</span><br><span class="line">bsg              fd         loop5            ppp                 sg0       tty14  tty3   tty45  tty60    vboxnetctl  vcsa7</span><br><span class="line">btrfs-control    full       loop6            psaux               sg1       tty15  tty30  tty46  tty61    vboxusb     vfio</span><br><span class="line">bus              fuse       loop7            ptmx                sg2       tty16  tty31  tty47  tty62    vcs         vga_arbiter</span><br><span class="line">cdrom            gpmctl     loop-control     pts                 shm       tty17  tty32  tty48  tty63    vcs1        vhci</span><br><span class="line">cdrw             hidraw0    mapper           random              snapshot  tty18  tty33  tty49  tty7     vcs2        vhost-net</span><br><span class="line">char             hpet       mcelog           rfkill              snd       tty19  tty34  tty5   tty8     vcs3        video0</span><br><span class="line">console          hugepages  media0           rtc                 sr0       tty2   tty35  tty50  tty9     vcs4        watchdog</span><br><span class="line">core             initctl    mei              rtc0                stderr    tty20  tty36  tty51  ttyS0    vcs5        watchdog0</span><br><span class="line">cpu              input      mem              rts51x0             stdin     tty21  tty37  tty52  ttyS1    vcs6        xconsole</span><br><span class="line">cpu_dma_latency  kmsg       mixer            sda                 stdout    tty22  tty38  tty53  ttyS2    vcs7        zero</span><br><span class="line">cuse             kvm        mixer1           sda1                tty       tty23  tty39  tty54  ttyS3    vcsa</span><br><span class="line">disk             <span class="built_in">log</span>        mqueue           sda2                tty0      tty24  tty4   tty55  uhid     vcsa1</span><br><span class="line">dri              loop0      net              sda3                tty1      tty25  tty40  tty56  uinput   vcsa2</span><br><span class="line">dsp              loop1      network_latency  sda4                tty10     tty26  tty41  tty57  urandom  vcsa3</span><br></pre></td></tr></table></figure>
<p>可以看到有很多的设备文件,前面提到的<code>/dev/null</code>等伪设备也在里面.</p>
<p>对特定类型的设备有特定的前缀,如对硬盘,前缀是<code>sd</code>,如<code>sda</code>就是第一块硬盘.对终端设备,前缀是<code>tty</code>.</p>
<p>像我们的笔记本,一般只有一块硬盘,也就是只有一个块设备,我们可以将所有内容都存在这个设备上,像日志文件,<code>/home</code>下面的文件都平等的存放,谁东西多就多占点空间.</p>
<p>但这样有个问题,由于日志文件占地方会比较大,如果有一天,将整个设备占满之后,其他文件就没有地方放了,整个系统就没法再正常运转下去了.所有就产生了这种方案:将一块设备划分成好几个部分,比如日志文件放一个部分,<code>/home</code>文件放另一个部分,相互隔离开.如果日志文件占满了,别的空间还能正常使用,所以分区解决了上述问题.</p>
<p>还有如果你想装双系统,如果不分区,两个操作系统混在一起,可能会发生很多意外,所以分区显得很有必要.</p>
<h2 id="分区-Partition"><a href="#分区-Partition" class="headerlink" title="分区(Partition)"></a>分区(Partition)</h2><p>从上面我们可以看到,分区其实就像把一个硬盘分成了好几份,就跟把一个大蛋糕切成好几块,一人一块一样.其实从前面的/dev目录下的设备文件我们可以看到,<code>sda</code>这个设备被分成了6个分区,分别是<code>sda1</code>,<code>sda2</code>,….<code>sda6</code>.就像有些动物通过撒尿来标记自己领地的边界一样,块设备也有特定的标记分区边界的文件,那就是分区表.分区表就像契约一样,规定了硬盘的前多少个空间分给分区1,后面多少空间分给分区2,等等.可以通过<code>fdisk</code>指令来查看分区详情:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo fdisk -l</span><br><span class="line">Disk /dev/sda: 750.2 GB, 750156374016 bytes</span><br><span class="line">255 heads, 63 sectors/track, 91201 cylinders, total 1465149168 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</span><br><span class="line">Disk identifier: 0x5be4a3f9</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1            2048      718847      358400    7  HPFS/NTFS/exFAT</span><br><span class="line">/dev/sda2          718848   409602047   204441600    7  HPFS/NTFS/exFAT</span><br><span class="line">/dev/sda3       409602048   819202047   204800000    7  HPFS/NTFS/exFAT</span><br><span class="line">/dev/sda4      1268469758  1465147391    98338817    5  Extended</span><br><span class="line">Partition 4 does not start on physical sector boundary.</span><br><span class="line">/dev/sda5      1346594816  1465147391    59276288   83  Linux</span><br><span class="line">/dev/sda6   *  1268469760  1346594815    39062528   83  Linux</span><br><span class="line"></span><br><span class="line">Partition table entries are not <span class="keyword">in</span> disk order</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>前面是硬盘的物理信息,如大小,有多少个柱面等等.后面是各个分区的开始位置,结束位置,包含多少个Blocks,系统类型等信息.</p>
<p>分区完成后,我们就可以在不同的分区上干不同的事情了.我把<code>sda2</code>标记为C盘,把<code>sda3</code>标记为D盘,把Linux的根目录挂载在<code>sda6</code>上,把<code>/home</code>目录挂载在<code>sda5</code>上,大家互相不再干扰,和谐共处.</p>
<h2 id="文件系统-Filesystem"><a href="#文件系统-Filesystem" class="headerlink" title="文件系统(Filesystem)"></a>文件系统(Filesystem)</h2><p>在Windows下,我们格式化U盘的时候,会让你选择格式化为FAT16,FAT3或者NTFS等,那么这些东西又是什么东西呢?这些东西就是不同的文件系统格式.</p>
<p>文件系统是一种存储和组织计算机数据的方法,通过文件系统,我们可以使用简单的方式来对物理介质执行操作.比如,没有文件系统,如果我要删除一个文件,那么我就得先找到它在硬盘上的哪个扇区,哪个柱面,然后删除它.有了文件系统,我可以用图形化的界面按<code>Shift</code>+<code>Delete</code>删除.这些简便都是文件系统的功劳.如果说分区这个概念是物理上的概念的话,那么文件系统就是纯粹的逻辑上的概念了.</p>
<p>不同的系统支持的文件系统不同,</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Windows:FAT16,FAT32,NTFS等</span><br><span class="line">Linux:ext1,ext2,ext3,ext4,NTFS,ISO9660等</span><br><span class="line">Mac OS X:HFS,HFS+</span><br></pre></td></tr></table></figure>

<p>如何查看各个分区的文件系统呢?可以用<code>blkid</code>命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo blkid</span><br><span class="line"></span><br><span class="line">/dev/sda1: LABEL=<span class="string">&quot;M-gM-3M-;M-gM-;M-^_M-dM-?M-^]M-gM-^UM-^Y&quot;</span> UUID=<span class="string">&quot;9ED61632D6160B63&quot;</span> TYPE=<span class="string">&quot;ntfs&quot;</span> PARTUUID=<span class="string">&quot;5be4a3f9-01&quot;</span> </span><br><span class="line">/dev/sda2: UUID=<span class="string">&quot;908265F98265E466&quot;</span> TYPE=<span class="string">&quot;ntfs&quot;</span> PARTUUID=<span class="string">&quot;5be4a3f9-02&quot;</span> </span><br><span class="line">/dev/sda3: UUID=<span class="string">&quot;98B6FE61B6FE3EF6&quot;</span> TYPE=<span class="string">&quot;ntfs&quot;</span> PARTUUID=<span class="string">&quot;5be4a3f9-03&quot;</span> </span><br><span class="line">/dev/sda5: UUID=<span class="string">&quot;7c4b5af9-599b-4052-aeb1-5dbd78f4d8e8&quot;</span> TYPE=<span class="string">&quot;ext4&quot;</span> PARTUUID=<span class="string">&quot;5be4a3f9-05&quot;</span> </span><br><span class="line">/dev/sda6: UUID=<span class="string">&quot;22b1037f-6c5e-46d0-b965-44cc42313795&quot;</span> TYPE=<span class="string">&quot;ext4&quot;</span> PARTUUID=<span class="string">&quot;5be4a3f9-06&quot;</span> </span><br></pre></td></tr></table></figure>

<p>可以看到,<code>/dev/sda1</code>,<code>/dev/sda2</code>和<code>/dev/sda3</code>是ntfs文件系统,<code>/dev/sda5</code>和<code>/dev/sda6</code>是ext4文件系统.(/dev/sda4去哪了呢?…)</p>
<p>最后用一个图来总结一下:</p>
<p><img src="/uploads/2014/12/filesystem.png" alt="filesystem"></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>将现有的Web前端项目生成导入到Django的Template</title>
    <url>/2015/10/10/django-template-generate/</url>
    <content><![CDATA[<p>实际项目中，会遇到这样的问题：没有使用任何服务器端框架的前端代码，即包含html网页文件，也包含js和css的代码，如何将这些现有的项目做最少的修改而引入到Django框架中呢？Django官网上给出了解决方法，使用<code>static</code>目录来存放<code>css</code>和<code>js</code>代码（虽然<code>js</code>是动态代码，但Django将其与<code>css</code>等同为<code>静态</code>代码，因为在后端看来，前端代码是静态的），然后在<code>html</code>文件里面，将原先的<code>href</code>引用改为通过<code>static</code>目录来引用。可以看<a href="https://docs.djangoproject.com/en/1.8/howto/static-files/">这里</a>，但里面讲的不是很清楚，我在查了一些资料后才搞定这个问题，所以这里写个总结来总结总结。  </p>
<span id="more"></span>

<h2 id="修改配置文件，增加static相关目录"><a href="#修改配置文件，增加static相关目录" class="headerlink" title="修改配置文件，增加static相关目录"></a>修改配置文件，增加<code>static</code>相关目录</h2><p>在配置文件<code>settings.py</code>里面，增加<code>STATIC_ROOT</code>，<code>STATIC_URL</code>和<code>STATICFILES_DIRS</code>变量，使得程序在执行时知道从哪里读取配置文件：  </p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">SITE_ROOT = os.path.join(os.path.abspath(os.path.dirname(__file__)),<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">STAIC_ROOT = os.path.join(SITE_ROOT,<span class="string">&#x27;static&#x27;</span>)</span><br><span class="line">STATIC_URL = <span class="string">&#x27;/static/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最后关键部分需要添加上STATICFILE_DIRS的配置</span></span><br><span class="line">STATICFILES_DIRS = (</span><br><span class="line">    (<span class="string">&quot;css&quot;</span>, os.path.join(STATIC_ROOT,<span class="string">&#x27;css&#x27;</span>)),</span><br><span class="line">    (<span class="string">&quot;js&quot;</span>, os.path.join(STATIC_ROOT,<span class="string">&#x27;js&#x27;</span>)),</span><br><span class="line">    (<span class="string">&quot;images&quot;</span>, os.path.join(STATIC_ROOT,<span class="string">&#x27;images&#x27;</span>)),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>上面代码中，为了更容易地表示<code>STATIC_ROOT</code>的值，先获取了<code>SITE_ROOT</code>的值。<br>注意：这个设置只能在<code>DEBUG=True</code>，即处于开发状态的的时候才有用，实际生产环境中的配置还有些区别。  </p>
<h2 id="在app里面创建static目录"><a href="#在app里面创建static目录" class="headerlink" title="在app里面创建static目录"></a>在app里面创建<code>static</code>目录</h2><p>在相应的app里面创建好<code>static</code>目录，然后将现有项目的<code>css</code>和<code>js</code>目录拷贝到该目录下。 至于<code>html</code>文件，则放在相应的<code>templates</code>目录下。 </p>
<h2 id="修改html文件里面的href引用"><a href="#修改html文件里面的href引用" class="headerlink" title="修改html文件里面的href引用"></a>修改<code>html</code>文件里面的<code>href</code>引用</h2><p>因为原先项目中，对于<code>Javascript</code>和<code>CSS</code>代码的引用都是通过相对目录来引用的，例如：  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../css/bootstrap.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../css/jquery.fullPage.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而在Django里面，需要对相对目录进行修改，将其改为通过<code>static</code>来引用的方式，也很简单：  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">** &#123;% load staticfiles %&#125;**</span><br><span class="line">&#123;% endraw %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> &#123;% <span class="attr">raw</span> %&#125; <span class="attr">href</span>=<span class="string">&quot;&#123;% static &quot;</span><span class="attr">css</span>/<span class="attr">bootstrap.css</span>&quot; %&#125;&quot; &#123;% <span class="attr">endraw</span> %&#125;&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> &#123;% <span class="attr">raw</span> %&#125; <span class="attr">href</span>=<span class="string">&quot;&#123;% static &quot;</span><span class="attr">css</span>/<span class="attr">jquery.fullPage.css</span>&quot; %&#125;&quot;&gt;</span> &#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到主要有2处修改：<br> 1.增加了 `{% load staticfiles %}` 语句，其中staticfiles是Django自带的库，`{% %}` 是Django的模板语法。这条语句表示导入staticfiles模块。<br> 2. 将href中的引用修改为 `href="{% static "subfolder/filename" %}"` 的格式，也很好理解，相当于文件引用路径是<code>static</code> + <code>subfolder/filename</code>，即通过前面<code>settings.py</code>里面设置的<code>static</code>目录来寻找<code>css</code>和<code>js</code>文件。  </p>
<h2 id="页面跳转的问题"><a href="#页面跳转的问题" class="headerlink" title="页面跳转的问题"></a>页面跳转的问题</h2><p>还遇到了一些问题，比如说在现成的前端项目中，我们要跳转到别的网页，我们可以这样写：   </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;something.html&quot;</span>&gt;</span>Something<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但在Django里面，却要改为：  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/something/&quot;</span>&gt;</span>Something<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>否则会跳转出错。</p>
]]></content>
  </entry>
  <entry>
    <title>在Apache上部署Django项目</title>
    <url>/2016/07/19/django-apache-deploy/</url>
    <content><![CDATA[<h3 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h3><p>Django是一个基于Python的web开发框架，在实际生产环境中部署的时候，还需要用Apache容器来部署。这里记录下如何在Debian系统中用Aapche和<a href="https://pypi.python.org/pypi/mod_wsgi">mod_wsgi模块</a>来部署Django项目。</p>
<span id="more"></span>
<h3 id="1-系统信息"><a href="#1-系统信息" class="headerlink" title="1.系统信息"></a>1.系统信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ uname -a  </span><br><span class="line">Linux iZ284ov0vfwZ 3.2.0-4-amd64 <span class="comment">#1 SMP Debian 3.2.81-1 x86_64 GNU/Linux  </span></span><br><span class="line">$ lsb_release -a  </span><br><span class="line">No LSB modules are available.  </span><br><span class="line">Distributor ID: Debian  </span><br><span class="line">Description:    Debian GNU/Linux 7.11 (wheezy) </span><br><span class="line">Release:        7.11  </span><br><span class="line">Codename:       wheezy  </span><br><span class="line">$ sudo apachectl -v  </span><br><span class="line">Server version: Apache/2.2.22 (Debian)  </span><br><span class="line">Server built:   Aug 18 2015 09:49:50  </span><br></pre></td></tr></table></figure>
<p><strong>我用的是Debian发行版，Apache的配置与别的发行版有较大不同，这里以Debian为例进行说明，别的发行版需要进行一定的修改。</strong></p>
<h3 id="2-安装Django和Apache"><a href="#2-安装Django和Apache" class="headerlink" title="2. 安装Django和Apache"></a>2. 安装Django和Apache</h3><p>Django可以通过如下命令安装:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip install Django==1.9.0 <span class="comment">#设置版本号为1.9.0</span></span><br></pre></td></tr></table></figure>
<p> Apache通过不同发行版的包管理命令安装。在debian下，是:<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br></pre></td></tr></table></figure></p>
<h3 id="3-安装mod-wsgi模块"><a href="#3-安装mod-wsgi模块" class="headerlink" title="3. 安装mod_wsgi模块"></a>3. 安装mod_wsgi模块</h3><p>mod_wsgi可以通过pip安装，但是需要提前在系统安装<code>apache-dev</code>包，但是在Debian发行版上，这个包名叫<code>apache2-prefork-dev</code>，详情参考<a href="http://stackoverflow.com/a/16869017/2932001">这里</a>。通过如下命令安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apache2-prefork-dev</span><br></pre></td></tr></table></figure>
<p>此外，还需要安装<code>python-dev</code>包，如果要使用python3,则需要安装<code>python3-dev</code>包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-dev</span><br><span class="line"><span class="comment"># 如果要使用python3，则安装如下包</span></span><br><span class="line"><span class="comment">#sudo apt-get install python3-dev</span></span><br></pre></td></tr></table></figure>
<p>然后pip 安装mod_wsgi:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip install mod_wsgi</span><br></pre></td></tr></table></figure>
<p>此外也可以自己编译mod_wsgi：首先从<a href="https://github.com/GrahamDumpleton/mod_wsgi/releases">这里</a>下载文件包，然后解压，编译。假设版本是4.5.3，全部命令如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/GrahamDumpleton/mod_wsgi/archive/4.5.3.tar.gz  </span><br><span class="line">tar -xvf 4.5.3.tar.gz  </span><br><span class="line"><span class="built_in">cd</span> mod_wsgi-4.5.3  </span><br><span class="line">./configure  </span><br><span class="line">make  </span><br><span class="line">sudo make install  </span><br></pre></td></tr></table></figure>
<p>如果要使用python3,则<code>./configure</code>那条命令改为<code>./configure --with-python=/usr/bin/python3.4</code>。<br>如果没有报错，那么mod_wsgi就编译好了!<br><strong>编译好后，会在apache的模块目录<code>/usr/lib/apache2/modules/</code>生成mod_wsgi.so文件。</strong></p>
<h3 id="4-Apache配置文件目录结构"><a href="#4-Apache配置文件目录结构" class="headerlink" title="4.Apache配置文件目录结构"></a>4.Apache配置文件目录结构</h3><p>Apache的配置文件目录是<code>/etc/apache2</code>，该目录下的文件结构如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|-- apache2.conf</span><br><span class="line">|-- conf-available</span><br><span class="line">|-- conf-enabled</span><br><span class="line">|-- envvars</span><br><span class="line">|-- magic</span><br><span class="line">|-- mods-available</span><br><span class="line">|-- mods-enabled</span><br><span class="line">|-- ports.conf</span><br><span class="line">|-- sites-available</span><br><span class="line">`-- sites-enabled</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中<code>apache2.conf</code>是主配置文件，里面包括系统的设置，如Timeout的时长、Log的等级和格式等。<code>ports.conf</code>文件配置了监听的端口号，以及是否启用SSL。<code>envvars</code>和<code>magic</code>里面设置了一些环境变量相关的东西，我没怎么看过。<br>剩下的6个目录两两一对，<code>availabel</code>文件夹里面是所有的配置，而<code>enabled</code>目录里面则是启用的配置。而<code>conf</code>、<code>mods</code>和<code>sites</code>可以分别通过命令<code>a2enconf</code>、<code>a2enmod</code>、<code>a2ensite</code>来启用，启用后会在<code>enabled</code>目录下生成一个软链接，指向<code>available</code>目录下的同名文件。<br>在<code>apache2.conf</code>这个文件最后，是一些<code>IncludeOptional</code> 语句，用来将<code>conf-enabled</code>、<code>mods-enabled</code>、<code>sites-enabled</code>目录下的配置文件包含到主配置文件中。这样的好处是每个配置文件配置一个条目，比较清晰明了,易于查错。    </p>
<h3 id="5-启用wsgi模块"><a href="#5-启用wsgi模块" class="headerlink" title="5. 启用wsgi模块"></a>5. 启用wsgi模块</h3><p>我们需要在<code>mods-available</code>目录下新建<code>mod_wsgi</code>的load文件，具体操作如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/apache2/mod-available  </span><br><span class="line">sudo <span class="built_in">echo</span> <span class="string">&quot; LoadModule wsgi_module /usr/lib/apache2/modules/mod_wsgi.so&quot;</span> &gt;&gt; wsgi.load  </span><br><span class="line">sudo a2enmod wsgi <span class="comment"># 启用wgsi配置</span></span><br><span class="line">sudo service apache2 restart <span class="comment"># 重启Apache2服务</span></span><br></pre></td></tr></table></figure>

<h3 id="6-托管Django站点"><a href="#6-托管Django站点" class="headerlink" title="6. 托管Django站点"></a>6. 托管Django站点</h3><p>假设Django项目的<code>wsgi.py</code>文件的路径是<code>/home/yunfeng/Dev/git/mysite/mysite/wsgi.py</code>，我们需要下面几步来完成Apache对Django项目的托管：</p>
<h4 id="1-修改Django项目中的wsgi-py和settings-py文件"><a href="#1-修改Django项目中的wsgi-py和settings-py文件" class="headerlink" title="1. 修改Django项目中的wsgi.py和settings.py文件"></a>1. 修改Django项目中的<code>wsgi.py</code>和<code>settings.py</code>文件</h4><p>修改<code>wsgi.py</code>文件，增加如代码中说明的那几行：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;                                                                                                                                                           </span></span><br><span class="line"><span class="string">WSGI config for travel_record project.                                                                                                                        </span></span><br><span class="line"><span class="string">                                                                                                                                                              </span></span><br><span class="line"><span class="string">It exposes the WSGI callable as a module-level variable named ``application``.                                                                                </span></span><br><span class="line"><span class="string">                                                                                                                                                              </span></span><br><span class="line"><span class="string">For more information on this file, see                                                                                                                        </span></span><br><span class="line"><span class="string">https://docs.djangoproject.com/en/1.9/howto/deployment/wsgi/                                                                                                  </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>                                                                                                                                                           </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os                                                                                                                                                     </span><br><span class="line"></span><br><span class="line"><span class="comment">## 增加下面这几行</span></span><br><span class="line"><span class="keyword">import</span> sys                                                                                                                                                    </span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> dirname, abspath                                                                                                                    </span><br><span class="line"><span class="keyword">from</span> django.core.wsgi <span class="keyword">import</span> get_wsgi_application                                                                                                             </span><br><span class="line">PROJECT_DIR = dirname(dirname(abspath(__file__)))                                                                                                             </span><br><span class="line">sys.path.insert(<span class="number">0</span>, PROJECT_DIR)                                                                                                                               </span><br><span class="line">                                                                                                                                                              </span><br><span class="line"><span class="comment">#os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;travel_record.settings&quot;)                                                                                    </span></span><br><span class="line">os.environ[<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>] = <span class="string">&quot;travel_record.settings&quot;</span>                                                                                               </span><br><span class="line"><span class="comment">## 增加结束</span></span><br><span class="line">                                                                                                                                                              </span><br><span class="line">application = get_wsgi_application()       </span><br></pre></td></tr></table></figure>
<p>增加的这几行代码做了2件事：1.将Django项目的的路径加入到系统路径中，使得Apache服务器可以找到<code>wsgi.py</code>文件；2. 修改<code>os.environ</code>的值，使得多个Django项目同时被Apache托管的时候不会出现串扰的问题。<br>接下来修改<code>settings.py</code>文件，主要修改的地方有3个：</p>
<ol>
<li>将<code>DEBUG=True</code>改为<code>DEBUG=False</code></li>
<li>将<code>ALLOWEND_HOSTS</code>里面写上服务器的访问域名或IP地址</li>
<li>将<code>TEMPALTES</code>中的<code>DIRS</code>改写成指向模板目录的绝对路径<br>Django项目里面需要修改的就这2个文件，下面的内容都是在<code>/etc/apache2</code>目录下进行操作。  </li>
</ol>
<h4 id="2-在-etc-apache2-sites-available目录下增加网站的配置文件"><a href="#2-在-etc-apache2-sites-available目录下增加网站的配置文件" class="headerlink" title="2. 在/etc/apache2/sites-available目录下增加网站的配置文件"></a>2. 在/etc/apache2/sites-available目录下增加网站的配置文件</h4><p>参照该目录下的<code>000-default.conf</code>和Django的教程，写出配置文件mysite.conf如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  &lt;VirtualHost *:8000&gt;                                                                                                                                         </span><br><span class="line">    ErrorLog <span class="variable">$&#123;APACHE_LOG_DIR&#125;</span>/error.log                                                                                                                      </span><br><span class="line">    CustomLog <span class="variable">$&#123;APACHE_LOG_DIR&#125;</span>/access.log combined                                                                                                           </span><br><span class="line">                                                                                                                                                              </span><br><span class="line">    WSGIScriptAlias / /home/yunfeng/Dev/git/mysite/mysite/wsgi.py                                                                               </span><br><span class="line"></span><br><span class="line">    Alias /static/ /home/yunfeng/Dev/git/mysite/mysite/static/                                                                                  </span><br><span class="line">    Alias /media/ /home/yunfeng/Dev/git/mysite/mysite/media/                                                                                  </span><br><span class="line"></span><br><span class="line">    &lt;Directory /home/yunfeng/Dev/git/mysite/mysite&gt;                                                                                             </span><br><span class="line">        &lt;Files wsgi.py&gt;                                                                                                                                       </span><br><span class="line">    		Order deny,allow  </span><br><span class="line">    		Allow from all  </span><br><span class="line">        &lt;/Files&gt;                                                                                                                                              </span><br><span class="line">    &lt;/Directory&gt;                                                                                                                                              </span><br><span class="line"></span><br><span class="line">    &lt;Directory /home/yunfeng/Dev/git/mysite/mysite/static/&gt;                                                                                     </span><br><span class="line">    	Order deny,allow  </span><br><span class="line">    	Allow from all  </span><br><span class="line">    &lt;/Directory&gt;                                                                                                                                              </span><br><span class="line">	</span><br><span class="line">    &lt;Directory /home/yunfeng/Dev/git/mysite/mysite/static/&gt;                                                                                     </span><br><span class="line">    	Order deny,allow  </span><br><span class="line">    	Allow from all  </span><br><span class="line">    &lt;/Directory&gt;                                                                                                                                              </span><br><span class="line">&lt;/VirtualHost&gt;       </span><br></pre></td></tr></table></figure>
<p>整个配置文件是包含在<code>VirtualHost</code>的尖括号里面的一些设置，尖括号开始的地方，<code>*:8000</code>表示你希望的项目监听的端口号。<br><code>ErrorLog</code>和<code>CustomLog</code>设置错误日志和访问日志的路径和格式。<br><code>WSGIScriptAlias</code>设置wsgi文件的路径，<code>Alias</code>语句托管网站的<code>static</code>和<code>media</code>目录。<br>然后是<code>&lt;Directory&gt;</code>标签，用来设置文件和目录的访问权限。<strong>注意对于版本小于2.4的Apache，需要将<code>&lt;Directory&gt;</code>标签中的<code>Order deny,allow</code>和<code>Allow from all</code>改为<code>Require all granted</code>。</strong><br>修改完后，执行下面的命令启用这个网站:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo a2ensite mysite.conf</span><br></pre></td></tr></table></figure>

<h4 id="3-修改-etc-apache2目录下的ports-conf文件"><a href="#3-修改-etc-apache2目录下的ports-conf文件" class="headerlink" title="3. 修改/etc/apache2目录下的ports.conf文件"></a>3. 修改/etc/apache2目录下的ports.conf文件</h4><p>增加针对新建站点的端口号的监听：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Listen 80</span><br><span class="line"><span class="comment">#增加下面这条语句</span></span><br><span class="line">Listen 8000</span><br></pre></td></tr></table></figure>

<p>执行完这3个步骤后，就可以重启Apache服务器，访问站点了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service apache2 restart</span><br></pre></td></tr></table></figure>
<p>访问站点，如果出现错误的话，可以在Django项目的<code>settings.py</code>中启用DEBUG模式，查看输出，进行相应的修改。</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Apache</tag>
        <tag>Web编程</tag>
      </tags>
  </entry>
  <entry>
    <title>doctest 用法简介</title>
    <url>/2021/02/02/doctest-intro/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://docs.python.org/3/library/doctest.html">doctest</a> 是 python 系统库中用于交互式会话例子测试的工具，用于搜索以 <code>&gt;&gt;&gt;</code> 开头的语句，并且将其作为Python命令，对结果进行测试。</p>
<p>这个工具可以方便地用于检测自己写的库是否有bug，例如某些函数功能可能发生改变，借此工具可以方便地对代码中的示例语句进行测试。</p>
<span id="more"></span>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>假如我们有一个 Python 脚本 <code>foo.py</code>, 其中有一些 <code>&gt;&gt;&gt;</code> 命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file name: foo.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">My square function.</span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>a = my_square(4)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>b = my_square(3)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>a + b</span></span><br><span class="line"><span class="string">25</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_square</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">return</span> num * num</span><br></pre></td></tr></table></figure>
<p>为了测试我们的 docstring 中的示例用法（即以<code>&gt;&gt;&gt;</code> 开头的命令）是否跟代码实现相符合，可以使用下面的命令来操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m doctest foo.py</span><br></pre></td></tr></table></figure>
<p>没有报错的话默认是没有输出的，如果要看中间的执行信息，可以增加 <code>-v</code> 参数:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m doctest -v foo.py</span><br></pre></td></tr></table></figure>
<p>另外针对只有运行命令记录，没有 python 语句的情况，可以把把命令记录保存到 <code>.txt</code> 文件中，然后使用同样的调用命令。例如把下面的内容保存到 <code>foo.txt</code> 文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a, b = 2, 3</span><br><span class="line">&gt;&gt;&gt; a+b</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>那么就可以使用下面的命令调用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m doctest -v foo.txt</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Trying:</span><br><span class="line">    a, b = 2, 3</span><br><span class="line">Expecting nothing</span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    a+b</span><br><span class="line">Expecting:</span><br><span class="line">    5</span><br><span class="line">ok</span><br><span class="line">1 items passed all tests:</span><br><span class="line">   2 tests <span class="keyword">in</span> foo.txt</span><br><span class="line">2 tests <span class="keyword">in</span> 1 items.</span><br><span class="line">2 passed and 0 failed.</span><br><span class="line">Test passed.</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>doctest</code> 会对文件中的每一行进行读取，然后计算期望的值和实际的值是否一样，如果不一样就会报错。例如我们尝试修改上面的 <code>foo.txt</code> 为下面的内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a, b = 2, 3</span><br><span class="line">&gt;&gt;&gt; a+b</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>即故意把2+3的结果修改为6，执行 <code>doctest</code> 命令，结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Trying:</span><br><span class="line">    a, b = 2, 3</span><br><span class="line">Expecting nothing</span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    a+b</span><br><span class="line">Expecting:</span><br><span class="line">    6</span><br><span class="line">**********************************************************************</span><br><span class="line">File <span class="string">&quot;foo.txt&quot;</span>, line 2, <span class="keyword">in</span> foo.txt</span><br><span class="line">Failed example:</span><br><span class="line">    a+b</span><br><span class="line">Expected:</span><br><span class="line">    6</span><br><span class="line">Got:</span><br><span class="line">    5</span><br><span class="line">**********************************************************************</span><br><span class="line">1 items had failures:</span><br><span class="line">   1 of   2 <span class="keyword">in</span> foo.txt</span><br><span class="line">2 tests <span class="keyword">in</span> 1 items.</span><br><span class="line">1 passed and 1 failed.</span><br><span class="line">***Test Failed*** 1 failures.</span><br></pre></td></tr></table></figure>
<p>可以看到，测试出错了，而且出错的详细信息也列出来了。</p>
<p>另一种使用的方法是在 python 脚本中增加 <code>doctest.testmod()</code> 函数调用，方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file-name: foo.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">example usage:</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>a, b = 2, 3</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>a+b</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></table></figure>
<p>使用下面的命令来执行脚本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 foo.py -v</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Trying:</span><br><span class="line">    a, b = 2, 3</span><br><span class="line">Expecting nothing</span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    a+b</span><br><span class="line">Expecting:</span><br><span class="line">    5</span><br><span class="line">ok</span><br><span class="line">1 items passed all tests:</span><br><span class="line">   2 tests <span class="keyword">in</span> __main__</span><br><span class="line">2 tests <span class="keyword">in</span> 1 items.</span><br><span class="line">2 passed and 0 failed.</span><br><span class="line">Test passed.</span><br></pre></td></tr></table></figure>
<p>对于 <code>.txt</code> 文件的测试，使用 <code>doctest.testfile()</code> 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> doctest</span><br><span class="line">doctest.testfile(<span class="string">&quot;example.txt&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="一些使用注意点"><a href="#一些使用注意点" class="headerlink" title="一些使用注意点"></a>一些使用注意点</h2><ol>
<li><code>&gt;&gt;&gt;</code> 缩进多个层次对结果没有影响，<code>doctest</code> 测试之前会对每行前面的空格进行删除。</li>
<li>doctest 也可以对Error 进行测试，如果想要测试各种特殊case导致的错误的话，doctest是个不错的工具</li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>天空</title>
    <url>/2014/06/07/e5-a4-a9-e7-a9-ba/</url>
    <content><![CDATA[<p>关于天空我有两段记忆特别深刻，一个是在某个秋天，爷爷，云亮和我去地里拉玉米秆时，我看到的傍晚的天空，还有一个是在初三从杜家塄上搬到渭河边后，每天傍晚，吃过饭后，在院子中闲坐时的天空。</p>
<p>我向天空望了望，看到了天上稀疏的云彩，被风扯成丝带状。天空比以往时候都要清澈，仿佛秋天的风拂去了平日里飘在天幕下的灰尘，而今可以看到一尘不染的真正的天空。秋天的风略微有些冷，太阳也还未下山，向这片川道里投下最后的光。</p>
<p>&nbsp;</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
  </entry>
  <entry>
    <title>学习总结-开篇</title>
    <url>/2014/10/19/e5-ad-a6-e4-b9-a0-e6-80-bb-e7-bb-93-e5-bc-80-e7-af-87/</url>
    <content><![CDATA[<p>一直以来我都没有很好的写作习惯，但随着本科学习即将结束，我越来越觉得学习过程中认真总结，整理思路然后清晰的将整个过程写出来是非常有必要的。而且这也不是很容易，因为要将一个东西给别人讲清楚对我来说有一定挑战。不管怎么说还是要开始这个博客的写作了，希望我能坚持写，写到老。</p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
  </entry>
  <entry>
    <title>秋天的诗</title>
    <url>/2014/10/19/e7-a7-8b-e5-a4-a9-e7-9a-84-e8-af-97/</url>
    <content><![CDATA[<p>震落了清晨满披着的露珠，<br>伐木声丁丁地飘出幽谷。<br>放下饱食过稻香的镰刀，<br>用背篓来装竹篱间肥硕的瓜果。<br>秋天栖息在农家里。<br>向江面的冷雾撒下圆圆的网，<br>收起青鳊鱼似的乌桕叶的影子。<br>芦蓬上满载着白霜，<br>轻轻摇着归泊的小桨。<br>秋天游戏在渔船上。<br>草野在蟋蟀声中更寥阔了。<br>溪水因枯涸见石更清洌了。<br>牛背上的笛声何处去了，<br>那满流着夏夜的香与热的笛孔？<br>秋天梦寐在牧羊女的眼里。</p>
<p>——–秋天，何其芳</p>
<p>每年到秋天都会想起这首初中学的诗，虽然在城市里、在校园里没有农人家，没有渔船更无牧羊女，只有银杏叶渐渐变黄而摇落，晚樱树的叶子经霜变红变黄而色彩斑斓。</p>
<p>&nbsp;</p>
<p><a href="/uploads/2014/10/7427ea21079d13a655072d.jpg"><img src="/uploads/2014/10/7427ea21079d13a655072d.jpg" alt="7427ea21079d13a655072d"></a></p>
]]></content>
      <categories>
        <category>四季风物</category>
      </categories>
  </entry>
  <entry>
    <title>数字永存的一些想法</title>
    <url>/2022/03/27/eternal-life/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>自古以来，人类就在思考自己与自然的关系，思考短暂人生与永恒时空的对比。从《论语》中的”子在川上曰，逝者如斯夫，不舍昼夜“，再到苏轼在《赤壁赋》中的“哀吾生之须臾，羡长江之无穷“，都体现了古代智者对人生的生老病死的思考。在漫长的历史中，只有少部分知识精英的思考和言论被记录下来，而大部分人们身上发生的故事，则在历史长河中湮灭了。一个例子是，我连我曾祖父之前的祖先的叫什么名字都不知道。</p>
<p>另一方面，随着互联网的出现，人类在数字世界里面记录着生活中的一切，朋友圈里面的自拍，与家人朋友的合影，快手上的短视频等等，在记录生活的同时，有意或无意地构建着自己的数字人生。当一个人在现实生活中去世后，他在数字世界里面的资产，包括图片，视频，音频都还存在（但这种存在不是永久的，可能因为保存这些资产的公司的经营而消失），某种程度上是永生在数字世界里。但目前的形式还没有明确的数字空间与真实空间的界限，拍摄的内容也都是2D的，除了观看，没法进行更多的交互。而随着苹果等大公司积极地推动AR技术，虚拟Avatar等技术也越来越成熟，大家也更能接受虚拟的主播，虚拟的歌手，虚拟的朋友。</p>
<p>随着渲染技术、AI技术以及硬件技术的不断发展，元宇宙的概念被越来越多的人所了解。不管是应用于何种场景，在元宇宙的概念里，现实生活中的人有对应的数字化身。这个数字化身是数字永存的一个核心。</p>
<p>设想这样一个场景，当一个人在世时构建好完美的3D数字化身，包括穿着的衣服重建，长相，发音，步态识别，以及最重要的，对于问题的思考方式和回应方式，那么在他去世后，当有亲友来到他的纪念室时，通过计算机技术，可以渲染出跟真实长相一样的ta，也能智能地回答问题，甚至声音都一样，那ta可以就算永生了。</p>
<p>为什么要设想这样一个场景呢？一个想法时想让人类的存在都能被记录，被看见，因为每个人身上都有值得后人纪念记录都闪光点和独有的故事。另一个想法是给后来人一个认清自己从哪里来的机会，避免出现三代以上，一字未知的现象。最后还是希望每个人有重新回忆亲人的机会。</p>
<h2 id="设想的场景"><a href="#设想的场景" class="headerlink" title="设想的场景"></a>设想的场景</h2><p>设想的场景如下。每个人有一个包含自己数字资产的U盘，由家人保存。同时有专门的数字形象进行展示的场所（比如叫数字永存展览馆），可以进行数字资产的重建和展示。当家人想要了解ta的生活的时候，可以拿着U盘去数字永存展览馆，对ta进行重建，观看他在生活中某天画的画，和家人在一起的画面，劳动的场景，以及对生活的思考。同时结合3D地球重建，可以看ta开车去玩时的路两边的风景，去乐山大佛时的大佛在他身旁展示出来。另外可以告诉他最近的新闻，他也会以他的方式来进行回复，和你一起讨论。</p>
<h2 id="涉及的技术"><a href="#涉及的技术" class="headerlink" title="涉及的技术"></a>涉及的技术</h2><p>这个场景涉及到的技术其实现在都有一些技术实现了一部分，但距离满足上述的场景还估计有至少有数十年的路要走。具体来说，有下面的子任务：</p>
<ul>
<li>听力和发音重建，听力包括能否听得懂方言，普通话，英语等，发音包括口音</li>
<li>人体重建：包括不同年龄段的头发重建，人脸重建，身体重建，微表情重建</li>
<li>衣物重建：每个时代有不同的服饰风格，每个人有自己喜欢的衣服，穿过的衣服，也需要重建，才足够真实</li>
<li>步态识别与重建：每个人走路也是不同的，只有步态重建好了，与数字形象沟通时才足够有真实感</li>
<li>知识体系重建：了解哪些知识，擅长哪些方面</li>
<li>思维习惯重建：面对一个问题，ta会怎么回复，这些需要通过日常的对话来重建</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之这是一个有点难，有点意义，但可能也会面临很多问题的事情。结合元宇宙，以及最近看的Upload电视剧，和今早一篇微信文章想到的一些点，这里把它记录下来，作为人生的一点思考，一个小的脚注。</p>
]]></content>
      <tags>
        <tag>数字空间</tag>
        <tag>技术畅想</tag>
      </tags>
  </entry>
  <entry>
    <title>fly.io 使用指南</title>
    <url>/2022/10/06/fly-io-tutorial/</url>
    <content><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>最近看技术论坛，发现提到 <a href="https://fly.io/">fly.io</a> 的次数越来越多了。 fly.io 是一个容器化的部署平台，只需要一个<code>Dockerfile</code>文件就能部署代码到fly.io 的服务器上，同时还自动生成域名。其他的好处多多，我根据自己体验，我总结成了下面的这些条：</p>
<p>有免费使用的额度。不填写信用卡信息可以创建一个App，完全不收费；填写信用卡信息后每月有一定额度的免费流量，超过额度会额外收费。所以想做个小demo完全可以不填信用卡试用。</p>
<p>自动生成域名。比如你创建一个名字叫<code>my_demo</code>的App，那么部署完成后，就会生成<code>my_demo.fly.dev</code>的域名，可以全球访问，不用自己单独买域名了。</p>
<p>可以 SSH 连接进入服务器。部署完成后，可以通过<code>flyctl ssh console</code> 命令登录部署的服务器，所以相当于你有了一台免费的VPS，可以做你想做的任何事情。</p>
<p>部署简单，采用<code>flyctl</code> 命令集合统一部署;支持各种语言的各种框架来搭建部署环境，能自动识别当前目录下代码所采用的是哪个框架，自动部署。</p>
<p>下面简单记录一下使用的流程和一些教程里面没提及的使用命令。</p>
<span id="more"></span>

<h3 id="2-部署一个应用"><a href="#2-部署一个应用" class="headerlink" title="2. 部署一个应用"></a>2. 部署一个应用</h3><p>这里以Python 的 Flask 框架为例，进行部署的步骤总结，其实fly.io支持很多框架，可以在<a href="https://fly.io/docs/speedrun/">这里</a>查看。</p>
<h4 id="2-1-安装-flyctl"><a href="#2-1-安装-flyctl" class="headerlink" title="2.1 安装 flyctl"></a>2.1 安装 flyctl</h4><p>首先需要安装 flyctl 这个工具：<br>Mac:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install flyctl</span><br></pre></td></tr></table></figure>
<p>Linux:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L https://fly.io/install.sh | sh</span><br></pre></td></tr></table></figure>
<p>Windows:<br>在Powershell中运行下面的命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iwr https://fly.io/install.ps1 -useb | iex</span><br></pre></td></tr></table></figure>
<p>如果执行<code>flyctl version</code> 不报错，就说明安装成功了。</p>
<p><strong>一个小技巧，flyctl还有个alias fly，敲起来更简短些。</strong></p>
<p>安装这个工具是一次性的，后面不需要再操作</p>
<h4 id="2-2-创建并登录账号"><a href="#2-2-创建并登录账号" class="headerlink" title="2.2 创建并登录账号"></a>2.2 创建并登录账号</h4><p>创建账号:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fly auth signup</span><br></pre></td></tr></table></figure>
<p>会打开网页，选择自己要创建账号的方式，GitHub账号或者邮箱等。</p>
<p>创建完成后登录账号:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fly auth login</span><br></pre></td></tr></table></figure>

<h4 id="2-3-先在本地将Flask-demo跑起来"><a href="#2-3-先在本地将Flask-demo跑起来" class="headerlink" title="2.3 先在本地将Flask demo跑起来"></a>2.3 先在本地将Flask demo跑起来</h4><p>这里采用 fly.io 提供的Flask demo 代码，先在本地跑起来:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/fly-apps/python-hellofly-flask</span><br><span class="line"><span class="built_in">cd</span> python-hellofly-flask</span><br><span class="line">python -m venv flask-env</span><br><span class="line"><span class="built_in">source</span> flask-env/bin/activate</span><br><span class="line">python -m pip install -r requirements.txt</span><br><span class="line">FLASK_APP=hellofly flask run</span><br></pre></td></tr></table></figure>
<p>然后访问<code>http://127.0.0.1:5000</code> 就能看到网站，说明本地搭建成功了。</p>
<h3 id="2-4-部署到-fly-io"><a href="#2-4-部署到-fly-io" class="headerlink" title="2.4 部署到 fly.io"></a>2.4 部署到 fly.io</h3><p>在当前目录下，执行<code>fly launch</code>，进入交互式界面创建App:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flyctl launch</span><br><span class="line">Creating app <span class="keyword">in</span> /Users/username/project/demo/flyio_demo/python-hellofly-flask</span><br><span class="line">Scanning <span class="built_in">source</span> code</span><br><span class="line">Detected a Python app</span><br><span class="line">Using the following build configuration:</span><br><span class="line">        Builder: paketobuildpacks/builder:base</span><br><span class="line">? Overwrite <span class="string">&quot;/Users/username/project/demo/flyio_demo/python-hellofly-flask/Procfile&quot;</span>? No</span><br><span class="line">? App Name (leave blank to use an auto-generated name): treehole</span><br><span class="line">Automatically selected personal organization: username</span><br><span class="line">? Select region: hkg (Hong Kong, Hong Kong)</span><br><span class="line">Created app treehole <span class="keyword">in</span> organization personal</span><br><span class="line">Wrote config file fly.toml</span><br><span class="line">? Would you like to <span class="built_in">set</span> up a Postgresql database now? No</span><br><span class="line">We have generated a simple Procfile <span class="keyword">for</span> you. Modify it to fit your needs and run <span class="string">&quot;fly deploy&quot;</span> to deploy your application.</span><br></pre></td></tr></table></figure>
<p>然后执行<code>flyctl deploy</code> 来将Appb部署到 fly.io 的服务器上:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flyctl deploy</span><br></pre></td></tr></table></figure>

<p>执行成功后，可以用<code>flyctl open</code>来打开浏览器，访问自己部署的App，网址是<code>appname.fly.dev</code>。</p>
<p>如果后面有源码或者配置的修改，可以多次执行<code>flyctl deploy</code>，会生成新的版本v0，v1, v2依次往下，往fly.io上部署。</p>
<p>接下来就是修改你的Flask源代码，完成更复杂有真正意义的功能了。</p>
<h4 id="2-5-别的有用的flyctl-命令"><a href="#2-5-别的有用的flyctl-命令" class="headerlink" title="2.5 别的有用的flyctl 命令"></a>2.5 别的有用的flyctl 命令</h4><p>查看App状态: <code>flyctl status</code><br>查看App信息: <code>flyctl info</code><br>查看App列表: <code>flyctl apps list</code><br>查看App的IP: <code>flyctl ips list</code><br>销毁某个App: <code>flyctl apps destroy &lt;appname&gt;</code></p>
<h3 id="3-登录部署机器"><a href="#3-登录部署机器" class="headerlink" title="3. 登录部署机器"></a>3. 登录部署机器</h3><p>机器部署完成后，可以通过<code>flyctl ssh console</code>来登录机器，登录后就跟普通Linux机器的使用是一样的了，可以随意探索。</p>
<h3 id="4-复制部署机器上的文件到本地"><a href="#4-复制部署机器上的文件到本地" class="headerlink" title="4. 复制部署机器上的文件到本地"></a>4. 复制部署机器上的文件到本地</h3><p>在一个终端输入下面的命令来代理端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fly proxy 10022:22</span><br></pre></td></tr></table></figure>
<p>然后保持上面的终端打开，在另一个终端输入下面的命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -P 10022 root@localhost:/path/of/file/on/vm  /path/on/<span class="built_in">local</span></span><br></pre></td></tr></table></figure>
<p>修改文件的路径就能将文件复制过来</p>
<h3 id="5-一点感想"><a href="#5-一点感想" class="headerlink" title="5.一点感想"></a>5.一点感想</h3><p>当demo部署服务成功后，却不知道能做什么真正有意义的事情，或许缺少的不是工具，而是真正产生价值的点子。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>fly.io</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>余忆童稚时--开篇</title>
    <url>/2013/12/11/e4-bd-99-e5-bf-86-e7-ab-a5-e7-a8-9a-e6-97-b6-e5-bc-80-e7-af-87/</url>
    <content><![CDATA[<p>我最近时常想起一些小时候——也就是从我出生到我离开家乡去县城读初中之前——的事情，不知道是何缘由，或许是因为最近几年奶奶，爷爷和姥姥的相继离世吧。</p>
<p>想起这些事我总是觉得有必要将它们记录下来，尽管它们一直在我的脑海里不会丢掉，但我更喜欢文字记录下的那种字字句句的真实的存在，所以呢，我打算在科大博客上写一系列的回忆童年的日志，当作对奶奶，爷爷和外婆的纪念。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
  </entry>
  <entry>
    <title>git 提交文件中的部分修改</title>
    <url>/2022/06/17/git-add-part-of-a-file/</url>
    <content><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在 Git 提交一个文件的时候，有时候会在同一个文件中，包含两个不同功能的修改，或者一个功能完成了，而别的部分还没有完善不应该进入代码库，这时候如果使用<code>git add file-name</code>的话，会将这个文件中的所有更新都提交，达不到上述的需求。针对这种场景，git 提供了更细粒度的提交命令<code>git add -p</code>，可以分部分提交一个文件中的更新代码块，实测能满足常见的需求。这里简要记录一下如何使用这个命令。</p>
<span id="more"></span>

<h2 id="2-实现命令"><a href="#2-实现命令" class="headerlink" title="2. 实现命令"></a>2. 实现命令</h2><h3 id="2-1-原理解释"><a href="#2-1-原理解释" class="headerlink" title="2.1 原理解释"></a>2.1 原理解释</h3><p>git 中用”hunk”来表示一个文件中邻近区域中的代码修改块，比如用<code>git diff</code> 查看修改时，两个<code>@@</code>符号分割的一个区域就是一个hunk，其中行首是<code>-</code>，颜色为红色的为删去的行，而行首为<code>+</code>，颜色为绿色的为增加的行。<br><img src="/imgs/git_add_part/git_hunk_vis.jpg" alt="git_hunk_vis"></p>
<p>需要注意的是，git有一套默认的将文件中所有修改分成不同hunk的机制，但我们也可以将默认机制分的太大的hunk分割为多个小的hunk，这样能更精确地控制提交的粒度。</p>
<p>部分提交文件修改的原理简单来说是将所有的修改分成不同的hunk，通过对每个hunk来进行是否提交的判断，从而完成我们的需求。具体命令下面详细讲述。</p>
<h3 id="2-2-命令详解"><a href="#2-2-命令详解" class="headerlink" title="2.2 命令详解"></a>2.2 命令详解</h3><p><code>git add -p filename</code>就可以进入交互式的操作界面，所有的操作在该界面完成，其中<code>-p</code>是patch的缩写。界面如下:<br><img src="/imgs/git_add_part/git_part_add_2.jpg"><br>这里会自动载入第一个hunk，显示了修改的代码行，最底下一行显示了这是8个hunk里面的第一个，然后有一些选项让我们选择，这时候输入<code>?</code>，按会车会显示help信息:<br><img src="/imgs/git_add_part/git_part_add_2.jpg"></p>
<p>所有命令的含义如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">y - 将当前的hunk进行提交</span><br><span class="line">n - 不提交当前hunk</span><br><span class="line">q - 退出交互式界面，不提交当前hunk以及后面的所有hunk</span><br><span class="line">a - 提交当前hunk以及后面的所有hunk</span><br><span class="line">d - 不提交当前hunk以及后面的所有hunk，效果与q一样，也会退出交互式界面</span><br><span class="line">g - 选择一个hunk并跳转过去，输入后会列出所有hunk的编号，输入编号就跳转到对应的hunk</span><br><span class="line">/ - 输入一个正则表达式，选择一个包含搜索词的hunk进行跳转</span><br><span class="line">j - 暂时不确定是否保存当前hunk，跳转到下一个没确定的hunk</span><br><span class="line">J - 暂时不确定是否保存当前hunk，跳转到下一个hunk</span><br><span class="line">e - 手动修改hunk块的内容，将`-` 开头的行替换为 ` `则不会删去这行，删除`+`为首的行则不提交这个新增，以`<span class="comment">#`开始的行会被忽略</span></span><br><span class="line">? - 显示帮助信息 </span><br></pre></td></tr></table></figure>

<p>详细阅读上面的说明，结合实际的操作，就能掌握这个命令的所有用法。</p>
<p>简单来说，使用<code>y</code>来提交当前hunk，使用<code>n</code>来忽略当前hunk，如果hunk代码块太大，输入<code>s</code>会将其分割为小的hunk，在上面继续操作，hunk间上下跳转用vim的快捷键<code>k</code> 和<code>j</code>，要退出则输入<code>q</code>。</p>
<h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><ol>
<li><a href="https://stackoverflow.com/questions/1085162/commit-only-part-of-a-file-in-git">https://stackoverflow.com/questions/1085162/commit-only-part-of-a-file-in-git</a></li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>总结</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下通过修改fstab来自动挂载Windows 分区</title>
    <url>/2014/12/14/fstab-automount-windows-partitions/</url>
    <content><![CDATA[<p>我电脑装的是Windows和Linux双系统,以前在Linux下,要打开Windows系统的C盘或D盘,总是要输入密码,很麻烦,而且麻烦了很长时间.</p>
<p>后来有一天浩哥看到了,说可以在Linux开机时自动挂载Windows分区,修改<code>/etc/fstab</code>这个文件,可以采用每个分区的UUID.后来校长也看到了我每次麻烦的操作,说是确实可以搞,而且他已经搞定了.我想我也得搞搞了.</p>
<span id="more"></span>

<p>fstab文件位于<code>/etc</code>目录下，是一个多文件系统的信息描述文件,应用程序不能修改它,而它的维护和修改任务则需要系统管理员来完成.每个分区在fstab中表示为一行,一行有6个域(field),每个域用空格或tab键隔开.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/fstab: static file system information.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use `blkid` to print the universally unique identifier for a</span></span><br><span class="line"><span class="comment"># device; this may be used with UUID= as a more robust way to name devices</span></span><br><span class="line"><span class="comment"># that works even if disks are added and removed. See fstab(5).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># file    mount    type    options    dump    pass             </span></span><br><span class="line"><span class="comment"># / was on /dev/sda6 during installation</span></span><br><span class="line">UUID=22b1037f-6c5e-46d0-b965-44cc42313795 /             ext4       errors=remount-ro  0 1</span><br><span class="line"><span class="comment"># /home was on /dev/sda5 during installation</span></span><br><span class="line">UUID=7c4b5af9-599b-4052-aeb1-5dbd78f4d8e8 /home         ext4        defaults          0 2</span><br><span class="line">/dev/sr0                                  /media/cdrom0 udf,iso9660 user,noauto       0 0</span><br><span class="line">devpts                                    /dev/pts      devpts      defaults          0 0</span><br></pre></td></tr></table></figure>

<p>可以看到,6个域名称分别是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file    mount    <span class="built_in">type</span>    options    dump    pass </span><br></pre></td></tr></table></figure>

<p>而且Linux系统分区已经挂载好了,所以我们接下来只要添加Windows分区就可以了。<br>6个域详细介绍如下:</p>
<p>###1.file system:<br>表示将要挂载的分区的块设备名称.注意这个设备也可以是远程设备,比如说是远程服务器上的某个设备.对于本地设备,该域格式可以是<code>/dev/cdrom</code>,<code>LABEL=&lt;label&gt;</code>,或者<code>UUID=&lt;uuid&gt;</code>三者之一；对于远程文件系统,格式为<host>:<dir>,如 freeshell.ustc.edu.cn:/.远端设备格式好写,对于本地设备,如何获取UUID 号和LABEL呢?我们要挂载的C盘是<code>/dev/sdb1</code>还是<code>/dev/sda5</code>呢?这个可以用<code>blkid</code>命令查看:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo blkid</span><br><span class="line">/dev/sda1: LABEL=<span class="string">&quot;M-gM-3M-;M-gM-;M-^_M-dM-?M-^]M-gM-^UM-^Y&quot;</span> UUID=<span class="string">&quot;9ED61632D6160B63&quot;</span> TYPE=<span class="string">&quot;ntfs&quot;</span> PARTUUID=<span class="string">&quot;5be4a3f9-01&quot;</span> </span><br><span class="line">/dev/sda2: UUID=<span class="string">&quot;908265F98265E466&quot;</span> TYPE=<span class="string">&quot;ntfs&quot;</span> PARTUUID=<span class="string">&quot;5be4a3f9-02&quot;</span> </span><br><span class="line">/dev/sda3: UUID=<span class="string">&quot;98B6FE61B6FE3EF6&quot;</span> TYPE=<span class="string">&quot;ntfs&quot;</span> PARTUUID=<span class="string">&quot;5be4a3f9-03&quot;</span> </span><br><span class="line">/dev/sda5: UUID=<span class="string">&quot;7c4b5af9-599b-4052-aeb1-5dbd78f4d8e8&quot;</span> TYPE=<span class="string">&quot;ext4&quot;</span> PARTUUID=<span class="string">&quot;5be4a3f9-05&quot;</span> </span><br><span class="line">/dev/sda6: UUID=<span class="string">&quot;22b1037f-6c5e-46d0-b965-44cc42313795&quot;</span> TYPE=<span class="string">&quot;ext4&quot;</span> PARTUUID=<span class="string">&quot;5be4a3f9-06&quot;</span> </span><br></pre></td></tr></table></figure>
<p>我们知道,Windows的文件系统格式是ntfs(new technology file system),从上面的输出中我们可以知道,要挂载的Windows分区是<code>/dev/sda2</code>和<code>/dev/sda3</code>.因为这两个分区没有LABEL,所有就没法采用<code>LABEL=&lt;label&gt;</code>的方式来表示第一个域了.所以我们要挂载的两块Windows分区的第一个域可以这样写:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#C盘</span></span><br><span class="line">/dev/sda2</span><br><span class="line"><span class="comment">#D盘</span></span><br><span class="line">/dev/sda3</span><br></pre></td></tr></table></figure>
<p>或者:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#C盘 </span></span><br><span class="line">UUID=908265F98265E466 </span><br><span class="line"><span class="comment">#D盘 </span></span><br><span class="line">UUID=98B6FE61B6FE3EF6</span><br></pre></td></tr></table></figure>

<p>###2.mount point:</p>
<p>即挂载点,使用过mount命令的同学应该明白这个域是干什么的,简单来说就是将物理的存储盘在Linux系统中找一个点放置下来,相当于在Linux文件树上找一个点,将物理存储对应到这个点上.挂载在这个点后,所有对该点的操作都会写入到对应的物理存储中.在最顶上的挂载例子中,我们看到UUID=22b1037f-6c5e-46d0-b965-44cc42313795(从<code>blkid</code>命令结果可以看出,该分区是<code>/dev/sda6</code>)的物理存储挂载到了/目录(Linux系统根目录),也就是说/目录下面的所有东西都写入到该分区中(/home目录除外),同理,所有/home目录下的内容都写入到UUID=7c4b5af9-599b-4052-aeb1-5dbd78f4d8e8(从<code>blkid</code>命令结果可以看出,该分区是<code>/dev/sda5</code>)的分区中  </p>
<p>那么,我们要把C盘和D盘挂载到哪里呢?我是这样做的: a.先查看没有自动挂载Windows分区之前,手动挂载时,系统会把C盘和D盘挂载到哪,结果如下:<code>/media/wang</code>(wang是我的用户名),C盘被命名为908265F98265E466,D盘被命名为98B6FE61B6FE3EF6,即其相应的UUID. b.所以我想,可能是挂载到<code>/media</code>目录下的任意一个子目录下吧, 所以我将该域分别设置为<code>/media/c</code>和<code>/media/d</code>,综合前两个域,应该写成:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#C盘</span></span><br><span class="line">/dev/sda2 /media/c</span><br><span class="line"><span class="comment">#D盘</span></span><br><span class="line">/dev/sda3 /media/d</span><br></pre></td></tr></table></figure>
<p>或者:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#C盘 </span></span><br><span class="line">UUID=908265F98265E466 /media/c</span><br><span class="line"><span class="comment">#D盘 </span></span><br><span class="line">UUID=98B6FE61B6FE3EF6 /media/d</span><br></pre></td></tr></table></figure>

<p>###3.type<br>即文件系统的格式,像Linux下常用的 ext,ext1,ext2,ext3,Windows下常用的fat16,fat32,ntfs等.可以根据blkid命令的结果来写该域.根据<code>blkid</code>的结果, 我们要挂载的C盘和D盘的文件系统格式为ntfs,所以前三个域都确定了,有如下写法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#C盘</span></span><br><span class="line">/dev/sda2 /media/c ntfs</span><br><span class="line"><span class="comment">#D盘</span></span><br><span class="line">/dev/sda3 /media/d ntfs</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#C盘 </span></span><br><span class="line">UUID=908265F98265E466 /media/c ntfs</span><br><span class="line"><span class="comment">#D盘 </span></span><br><span class="line">UUID=98B6FE61B6FE3EF6 /media/d ntfs</span><br></pre></td></tr></table></figure>

<p>###4.option:</p>
<p>选项,该域表示挂载的时候的一些选项,主要有6个选项,每个选项用逗号隔开,下面详细说明每个选项的含义:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">default:使用默认选项</span><br><span class="line">noauto:当执行mount -a(即挂载全部文件系统,开机时会执行此命令)时忽略此条记录,也就是跟没写进fstab一样</span><br><span class="line">user:允许特定的用户来挂载,如user=bob,则只能允许bob这个用户来挂载</span><br><span class="line">owner:允许物理设备的拥有者来挂载</span><br><span class="line">comment:为fstab维护程序提供一些说明</span><br><span class="line">nofail:在挂载失败后,忽略此错误,继续往下执行</span><br></pre></td></tr></table></figure>

<p>因为我们没有特殊要求,所以就选default.所以前四个域可以写成这样子:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#C盘</span></span><br><span class="line">/dev/sda2 /media/c ntfs default</span><br><span class="line"><span class="comment">#D盘</span></span><br><span class="line">/dev/sda3 /media/d ntfs default</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#C盘 </span></span><br><span class="line">UUID=908265F98265E466 /media/c ntfs default</span><br><span class="line"><span class="comment">#D盘 </span></span><br><span class="line">UUID=98B6FE61B6FE3EF6 /media/d ntfs default</span><br></pre></td></tr></table></figure>

<p>###5.dump</p>
<p>dump这个命令执行备份操作,该域为0,表示执行dump操作时忽略该分区,如果为1,则表示执行dump时也会备份该分区.因为我们没有备份的需求,所以该域设置为0,所以前五个域为:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#C盘</span></span><br><span class="line">/dev/sda2 /media/c ntfs default 0</span><br><span class="line"><span class="comment">#D盘</span></span><br><span class="line">/dev/sda3 /media/d ntfs default 0</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#C盘 </span></span><br><span class="line">UUID=908265F98265E466 /media/c ntfs default 0</span><br><span class="line"><span class="comment">#D盘 </span></span><br><span class="line">UUID=98B6FE61B6FE3EF6 /media/d ntfs default 0</span><br></pre></td></tr></table></figure>

<p>###6.pass:<br>不是passwd的pass,而是系统重启时检查分区正常与否时,该分区的检查顺序.根目录所在分区passno是1,其他分区为2.如果设置为0,则表示不检查.我们的C盘和D盘不想让Linux检查,所以设置为0.所以综合以上步骤,我们可以写出下面的完整的两条记录:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#C盘</span></span><br><span class="line">/dev/sda2 /media/c ntfs default 0 0</span><br><span class="line"><span class="comment">#D盘</span></span><br><span class="line">/dev/sda3 /media/d ntfs default 0 0</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#C盘 </span></span><br><span class="line">UUID=908265F98265E466 /media/c ntfs default 0 0</span><br><span class="line"><span class="comment">#D盘 </span></span><br><span class="line">UUID=98B6FE61B6FE3EF6 /media/d ntfs default 0 0</span><br></pre></td></tr></table></figure>

<p>按理来说这两种形式都可以的,将任一种形式的两条记录添加到fstab文件中,重新启动系统,下次打开Windows系统的分区时,应该就不需要输入密码了. 但正如前面提到的,使用UUID的方式更健壮些,比如有的移动硬盘或U盘,拔下来再次插入的时候<code>/dev/sda</code>的编号可能会变,但其对应的UUID不会变,所以使用UUID会省下许多麻烦,推荐使用UUID形式.</p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>git log 修改提交日期显示格式</title>
    <url>/2022/03/26/git-change-log-date-format/</url>
    <content><![CDATA[<p>git log 默认显示的日期格式是欧美形式的，使用起来不太习惯，还得在大脑中进行一次转换，有点费脑。后来发现有办法可以修改日期显示格式，在git仓库下执行下面的命令即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config log.date iso</span><br></pre></td></tr></table></figure>
<p>如果要对所有的git仓库都起作用，添加<code>--global</code>选项即可。</p>
<p>另外输入<code>git config</code> 按tab键，可以显示所有的配置选项。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 删除远程分支</title>
    <url>/2022/04/10/git-delete-branch/</url>
    <content><![CDATA[<p>Git可以方便地删除本地的某个分支。具体操作是：</p>
<ol>
<li>切换到别的分支</li>
<li>执行<code>git branch -d &lt;name-of-branch-to-delete&gt;</code></li>
</ol>
<p>比如我想删除当前的<code>dev-tmp</code>分支:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git branch -d dev-tmp</span><br></pre></td></tr></table></figure>

<p>上面的命令只删除了本地的分支，如果要删除远端的分支，该怎么操作呢？答案是用带有<code>--delete</code>选项的<code>git push</code>命令，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin --delete dev-tmp</span><br></pre></td></tr></table></figure>
<p>可以删除远端的<code>dev-tmp</code>分支。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git禁止大文件提交到仓库中</title>
    <url>/2019/03/10/git-reject-large-file-when-commit/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Git提交的时候，有的时候很容易将目录下的非源代码的文件（如二进制文件、模型等）提交到Git仓库里，给后续的使用造成麻烦。那么有没有一种方法来限制提交到Git的文件的大小呢，答案是Yes，下面我来大概介绍下吧。</p>
<span id="more"></span>
<p>原理是利用Git的<a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90">钩子</a>来在<code>commit</code>之前执行一个脚本，在这个脚本里对提交的文件大小进行检查。</p>
<p>具体操作是：修改仓库下的<code>.git/hooks/pre-commit</code>为如下内容（如果没有这个文件请新建）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">hard_limit=$(git config hooks.filesizehardlimit)</span><br><span class="line">soft_limit=$(git config hooks.filesizesoftlimit)</span><br><span class="line">: <span class="variable">$&#123;hard_limit:=10000000&#125;</span> <span class="comment"># 10M</span></span><br><span class="line">: <span class="variable">$&#123;soft_limit:=1000000&#125;</span> <span class="comment"># 1M</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">list_new_or_modified_files</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    git diff --staged --name-status|sed -e <span class="string">&#x27;/^D/ d; /^D/! s/.\s\+//&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">unmunge</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">local</span> result=<span class="string">&quot;<span class="variable">$&#123;1#\&quot;&#125;</span>&quot;</span></span><br><span class="line">    result=<span class="string">&quot;<span class="variable">$&#123;result%\&quot;&#125;</span>&quot;</span></span><br><span class="line">    env <span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$result</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">check_file_size</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    n=0 </span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">read</span> -r munged_filename</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        f=<span class="string">&quot;<span class="subst">$(unmunge <span class="string">&quot;<span class="variable">$munged_filename</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">        h=$(git ls-files -s <span class="string">&quot;<span class="variable">$f</span>&quot;</span>|cut -d<span class="string">&#x27; &#x27;</span> -f 2)</span><br><span class="line">        s=$(git cat-file -s <span class="string">&quot;<span class="variable">$h</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$s</span>&quot;</span> -gt <span class="variable">$hard_limit</span> ]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            env <span class="built_in">echo</span> -E 1&gt;&amp;2 <span class="string">&quot;ERROR: hard size limit (<span class="variable">$hard_limit</span>) exceeded: <span class="variable">$munged_filename</span> (<span class="variable">$s</span>)&quot;</span></span><br><span class="line">            n=$((n+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$s</span>&quot;</span> -gt <span class="variable">$soft_limit</span> ]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            env <span class="built_in">echo</span> -E 1&gt;&amp;2 <span class="string">&quot;WARNING: soft size limit (<span class="variable">$soft_limit</span>) exceeded: <span class="variable">$munged_filename</span> (<span class="variable">$s</span>)&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    [ <span class="variable">$n</span> -eq 0 ] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list_new_or_modified_files | check_file_size</span><br></pre></td></tr></table></figure>
<p>这里设置了<code>soft_limit</code>和<code>hard_limit</code>，默认的大小分别是1M和10M，当提交的某个文件超过1M时，会显示警告；当超过10M时，会显示错误，导致commit失败。</p>
<p>此外，可以通过<code>git config</code>命令来设置<code>soft_limit</code>和<code>hard_limit</code>的值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config hooks.filesizehardlimit 20000000</span><br><span class="line">git config hooks.filesizesoftlimit 2000000</span><br></pre></td></tr></table></figure>
<p>请根据自己的使用情况酌情修改具体的数值。</p>
<p>需要注意的是，<code>.git</code>目录下的文件Git是没有跟踪的，因此在别的电脑或目录下<code>git clone</code>仓库后，<code>pre-commit</code>文件并不会被自动clone进来，需要手动添加。</p>
<p>我在<a href="https://gist.github.com/vra/ae91ade1e15ce31b42f6366a91d1ac17">GitHub Gist</a>上提交了这个文件，有需要的小伙伴可以直接下载使用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://stackoverflow.com/questions/39576257/how-to-limit-file-size-on-commit">https://stackoverflow.com/questions/39576257/how-to-limit-file-size-on-commit</a></li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>总结</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 从别的分支复制文件或目录</title>
    <url>/2021/09/25/git-copy-from-another-branch/</url>
    <content><![CDATA[<p>有时候我们需要从别的分支复制文件或者目录，这里总结一些简单的命令供查看。</p>
<span id="more"></span>

<p>假设我们的当前分支为<code>branch1</code>, 想要复制文件或者目录的分支为<code>branch2</code>, 两个分支下文件结构是不同的，具体如下：<br>branch1: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── README.md</span><br><span class="line">├── cpp</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   └── test.hpp</span><br><span class="line">│   └── src</span><br><span class="line">│       └── test.cpp</span><br><span class="line">└── python</span><br><span class="line">    └── setup.py</span><br></pre></td></tr></table></figure>
<p>branch2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── README.md</span><br><span class="line">└── java</span><br><span class="line">    └── test.java</span><br><span class="line">    └── main.java</span><br></pre></td></tr></table></figure>

<p>假设我们当前在<code>branch1</code>, 目录为仓库根目录，想要复制<code>branch2</code> 的 java/test.java` 到当前目录，执行下面的语句:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout branch2 -- java/test.java</span><br></pre></td></tr></table></figure>
<p><strong>⚠️注意：这里还是会创建一个<code>java</code>目录，而不是把<code>test.java</code>放到根目录下。</strong></p>
<p>如果当前进入了<code>cpp</code> 子目录，后面的路径也需要改成相对路径:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout branch2 -- ../java/test.java</span><br></pre></td></tr></table></figure>
<p>如果想要复制整个目录，也是一样的:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout branch2 -- java</span><br></pre></td></tr></table></figure>
<p>此外还可以利用提交的hash值来复制文件，这样就会复制当次提交时候的文件内容:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 941b6dd java/test.java</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<ol>
<li><a href="https://www.tutsway.com/how-to-copy-file-or-folder-from-one-branch-to-another-in-git.php">https://www.tutsway.com/how-to-copy-file-or-folder-from-one-branch-to-another-in-git.php</a></li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>总结</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git log 常见参数总结</title>
    <url>/2022/03/26/git-log/</url>
    <content><![CDATA[<h2 id="0-概述"><a href="#0-概述" class="headerlink" title="0. 概述"></a>0. 概述</h2><p>git log 是查看git提交记录的一个命令，它有非常多的控制参数和选项，合理使用的话，可以达到任何的精准控制目的。这里列一些日常使用可能会用到的用法，全部的用法，请在命令行<code>git help log</code>查看。</p>
<span id="more"></span>

<h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h2><h3 id="1-1-无参数"><a href="#1-1-无参数" class="headerlink" title="1.1. 无参数"></a>1.1. 无参数</h3><p>使用<code>git log</code>，会从新到旧显示所有的提交记录，按<code>j</code>往下翻页，按<code>k</code>往上翻页, 按<code>q</code>退出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit 869cc0a22aea80d34f0728e184842bdea42fe43b (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Merge: 78aaac39 2e872840</span><br><span class="line">Author: Johan Mabille &lt;johan.mabille@gmail.com&gt;</span><br><span class="line">Date:   2021-04-10 02:29:06 +0200</span><br><span class="line"></span><br><span class="line">    Merge pull request <span class="comment">#2353 from JohanMabille/chunk</span></span><br><span class="line"></span><br><span class="line">    Refactoring of xchunked_view</span><br><span class="line"></span><br><span class="line">commit 2e872840a7ebc3e4e8b0f84cbae39360503243b1</span><br><span class="line">Author: Johan Mabille &lt;johan.mabille@gmail.com&gt;</span><br><span class="line">Date:   2021-04-09 16:59:16 +0200</span><br><span class="line"></span><br><span class="line">    One xchunk_iterator to rule them all</span><br><span class="line"></span><br><span class="line">commit 42fc49080522c94ea784541b53ef302ccb0344c0</span><br><span class="line">Author: Johan Mabille &lt;johan.mabille@gmail.com&gt;</span><br><span class="line">Date:   2021-04-08 22:40:14 +0200</span><br><span class="line"></span><br><span class="line">    Refactoring of xchunked_view</span><br><span class="line"></span><br><span class="line">	....</span><br></pre></td></tr></table></figure>
<p>通过增加<code>-&lt;n&gt;</code>选项来显示最近n次的提交记录，如<code>git log -2</code>仅显示最近的2次提交；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit 869cc0a22aea80d34f0728e184842bdea42fe43b (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Merge: 78aaac39 2e872840</span><br><span class="line">Author: Johan Mabille &lt;johan.mabille@gmail.com&gt;</span><br><span class="line">Date:   2021-04-10 02:29:06 +0200</span><br><span class="line"></span><br><span class="line">    Merge pull request <span class="comment">#2353 from JohanMabille/chunk</span></span><br><span class="line"></span><br><span class="line">    Refactoring of xchunked_view</span><br><span class="line"></span><br><span class="line">commit 2e872840a7ebc3e4e8b0f84cbae39360503243b1</span><br><span class="line">Author: Johan Mabille &lt;johan.mabille@gmail.com&gt;</span><br><span class="line">Date:   2021-04-09 16:59:16 +0200</span><br><span class="line"></span><br><span class="line">    One xchunk_iterator to rule them all</span><br></pre></td></tr></table></figure>

<p>此外如果想显示每次提交代码修改的地方，可以增加<code>-p</code>参数:</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">commit 869cc0a22aea80d34f0728e184842bdea42fe43b (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Merge: 78aaac39 2e872840</span><br><span class="line">Author: Johan Mabille &lt;johan.mabille@gmail.com&gt;</span><br><span class="line">Date:   2021-04-10 02:29:06 +0200</span><br><span class="line"></span><br><span class="line">    Merge pull request #2353 from JohanMabille/chunk</span><br><span class="line"></span><br><span class="line">    Refactoring of xchunked_view</span><br><span class="line"></span><br><span class="line">commit 2e872840a7ebc3e4e8b0f84cbae39360503243b1</span><br><span class="line">Author: Johan Mabille &lt;johan.mabille@gmail.com&gt;</span><br><span class="line">Date:   2021-04-09 16:59:16 +0200</span><br><span class="line"></span><br><span class="line">    One xchunk_iterator to rule them all</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/include/xtensor/xchunked_array.hpp b/include/xtensor/xchunked_array.hpp</span></span><br><span class="line"><span class="comment">index ed4003d0..23a843ec 100644</span></span><br><span class="line"><span class="comment">--- a/include/xtensor/xchunked_array.hpp</span></span><br><span class="line"><span class="comment">+++ b/include/xtensor/xchunked_array.hpp</span></span><br><span class="line"><span class="meta">@@ -126,10 +128,16 @@</span> namespace xt</span><br><span class="line">         template &lt;class S&gt;</span><br><span class="line">         const_stepper stepper_end(const S&amp; shape, layout_type) const noexcept;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-        const shape_type&amp; chunk_shape() const;</span></span><br><span class="line"><span class="addition">+        const shape_type&amp; chunk_shape() const noexcept;</span></span><br><span class="line"><span class="addition">+        size_type grid_size() const noexcept;</span></span><br><span class="line"><span class="addition">+        const shape_type&amp; grid_shape() const noexcept;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">         chunk_storage_type&amp; chunks();</span><br><span class="line">         const chunk_storage_type&amp; chunks() const;</span><br><span class="line"></span><br><span class="line"><span class="addition">+        chunk_iterator_type chunk_begin();</span></span><br><span class="line"><span class="addition">+        chunk_iterator_type chunk_end();</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-显示统计信息"><a href="#1-2-显示统计信息" class="headerlink" title="1.2. 显示统计信息"></a>1.2. 显示统计信息</h3><p>增加<code>--stat</code>选项可以显示某次提交文件的修改信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit 869cc0a22aea80d34f0728e184842bdea42fe43b (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Merge: 78aaac39 2e872840</span><br><span class="line">Author: Johan Mabille &lt;johan.mabille@gmail.com&gt;</span><br><span class="line">Date:   2021-04-10 02:29:06 +0200</span><br><span class="line"></span><br><span class="line">    Merge pull request <span class="comment">#2353 from JohanMabille/chunk</span></span><br><span class="line"></span><br><span class="line">    Refactoring of xchunked_view</span><br><span class="line"></span><br><span class="line">commit 2e872840a7ebc3e4e8b0f84cbae39360503243b1</span><br><span class="line">Author: Johan Mabille &lt;johan.mabille@gmail.com&gt;</span><br><span class="line">Date:   2021-04-09 16:59:16 +0200</span><br><span class="line"></span><br><span class="line">    One xchunk_iterator to rule them all</span><br><span class="line"></span><br><span class="line"> include/xtensor/xchunked_array.hpp  |  45 ++++++++++-</span><br><span class="line"> include/xtensor/xchunked_assign.hpp | 246 +++++++++++++++++++++++++++++++++++++++++++++-------------</span><br><span class="line"> include/xtensor/xchunked_view.hpp   | 164 +++++++++++----------------------------</span><br><span class="line"> 3 files changed, 280 insertions(+), 175 deletions(-)</span><br></pre></td></tr></table></figure>

<h3 id="1-3-过滤选项"><a href="#1-3-过滤选项" class="headerlink" title="1.3. 过滤选项"></a>1.3. 过滤选项</h3><p>默认所有的提交都显示，如果我们想搜索某段时间或某个人的提交记录，该怎么办呢？git提供了详细的命令来进行过滤，下面详细举例说明。</p>
<h4 id="1-3-1-过滤作者"><a href="#1-3-1-过滤作者" class="headerlink" title="1.3.1. 过滤作者"></a>1.3.1. 过滤作者</h4><p>通过<code>--author</code>选项可以只显示某个人的提交记录，以这个仓库为例，下面的写法（FirstName，LastName, Email, FirstName + LastName, FirstName + LastName + Email）都可以:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --author=Johan</span><br><span class="line">git <span class="built_in">log</span> --author=Mabille</span><br><span class="line">git <span class="built_in">log</span> --author=johan.mabille@gmail.com</span><br><span class="line">git <span class="built_in">log</span> --author=<span class="string">&quot;Johan Mabille&quot;</span></span><br><span class="line">git <span class="built_in">log</span> --author=<span class="string">&quot;Johan Mabille &lt;johan.mabille@gmail.com&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="1-3-2-过滤代码关键字"><a href="#1-3-2-过滤代码关键字" class="headerlink" title="1.3.2. 过滤代码关键字"></a>1.3.2. 过滤代码关键字</h4><p>通过<code>-S&lt;keyword&gt;</code>的形式可以搜索代码中增加或删除<code>keyword</code>的提交记录，比如<code>git log -Sxchunked_array</code>就会显示所有关于<code>xchunked_array</code>关键字的提交。结合前面的<code>-p</code>和<code>-&lt;n&gt;</code>参数，我们能很好的达到我们的搜索目的，比如只显示最近两次提交中关键词的修改内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -Sxchunked_array -p -2</span><br></pre></td></tr></table></figure>
<h4 id="1-3-3-过滤提交信息中的关键字"><a href="#1-3-3-过滤提交信息中的关键字" class="headerlink" title="1.3.3. 过滤提交信息中的关键字"></a>1.3.3. 过滤提交信息中的关键字</h4><p>此外还可以利用<code>--grep</code>选项来对commit内容进行过滤，比如我们想搜索所有包含<code>fix</code>的提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --grep fix</span><br></pre></td></tr></table></figure>
<h4 id="1-3-4-过滤日期"><a href="#1-3-4-过滤日期" class="headerlink" title="1.3.4. 过滤日期"></a>1.3.4. 过滤日期</h4><p>另一个很有用的选项是根据日期来过滤提交。日期过滤有好多形式，比如今年以来的提交，最近一周的提交，git提供了详细的控制命令，具体如下表:</p>
<table>
<thead>
<tr>
<th>关键词</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>after=<xxx></td>
<td>从xxx到现在的所有提交</td>
<td>after=”2020-01-01”</td>
</tr>
<tr>
<td>since=<xxx></td>
<td>从xxx到现在的所有提交，与after同义</td>
<td>since=”2020-01-01”</td>
</tr>
<tr>
<td>before=<xxx></td>
<td>xxx之前的所有提交</td>
<td>before=”2020-01-01”</td>
</tr>
<tr>
<td>until=<xxx></td>
<td>xxx之前的所有提交，与before同义</td>
<td>until=”2020-01-01”</td>
</tr>
</tbody></table>
<p>日期格式如下：</p>
<table>
<thead>
<tr>
<th>时间格式</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>YYYY-MM-DD</td>
<td>到某个具体日期的提交</td>
<td>since=2020-01-01</td>
</tr>
<tr>
<td>n.minute</td>
<td>n分钟内的提交</td>
<td>since=3.minute</td>
</tr>
<tr>
<td>n.hour</td>
<td>n小时内的提交</td>
<td>since=3.hour</td>
</tr>
<tr>
<td>n.day</td>
<td>n天内的提交</td>
<td>since=3.day</td>
</tr>
<tr>
<td>n.week</td>
<td>n周内的提交</td>
<td>since=3.week</td>
</tr>
<tr>
<td>n.month</td>
<td>n个月内的提交</td>
<td>since=3.month</td>
</tr>
<tr>
<td>n.year</td>
<td>n年内的提交</td>
<td>since=1.year</td>
</tr>
<tr>
<td>组合</td>
<td>上述形式的组合</td>
<td>since=1.year,10.month</td>
</tr>
</tbody></table>
<p>比如要显示2天内的所有提交，可以用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=2.day</span><br></pre></td></tr></table></figure>

<h2 id="2-显示格式调整"><a href="#2-显示格式调整" class="headerlink" title="2. 显示格式调整"></a>2. 显示格式调整</h2><p>默认的显示格式比较松散，一次提交占的空间太大，有没有办法显示地更紧凑呢？是有的，可以通过<code>--format=oneline</code>来设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">869cc0a22aea80d34f0728e184842bdea42fe43b (HEAD -&gt; master, origin/master, origin/HEAD) Merge pull request <span class="comment">#2353 from JohanMabille/chunk</span></span><br><span class="line">2e872840a7ebc3e4e8b0f84cbae39360503243b1 One xchunk_iterator to rule them all</span><br><span class="line">42fc49080522c94ea784541b53ef302ccb0344c0 Refactoring of xchunked_view</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>这下每条记录在一行显示，包括提交hash串，commit信息。</p>
<p>那么 git 支持哪些format参数呢，总结下来如下表：</p>
<table>
<tr><th>格式名称</th><th>格式说明</th></tr>

<tr><td><pre>oneline</pre></td><td>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">hash</span>&gt; &lt;title-line&gt;</span><br></pre></td></tr></table></figure>
</td></tr>

<tr><td><pre>short</pre></td><td>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit &lt;<span class="built_in">hash</span>&gt;</span><br><span class="line">Author: &lt;author&gt;</span><br><span class="line"></span><br><span class="line">&lt;title-line&gt;</span><br></pre></td></tr></table></figure>
</td></tr>


<tr><td><pre>medium</pre></td><td>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit &lt;<span class="built_in">hash</span>&gt;</span><br><span class="line">Author: &lt;author&gt;</span><br><span class="line">Date:   &lt;author-date&gt;</span><br><span class="line"></span><br><span class="line">&lt;title-line&gt;</span><br><span class="line"></span><br><span class="line">&lt;full-commit-message&gt;</span><br></pre></td></tr></table></figure>
</td></tr>


<tr><td><pre>full</pre></td><td>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit &lt;<span class="built_in">hash</span>&gt;</span><br><span class="line">Author: &lt;author&gt;</span><br><span class="line">Commit: &lt;committer&gt;</span><br><span class="line"></span><br><span class="line">&lt;title-line&gt;</span><br><span class="line"></span><br><span class="line">&lt;full-commit-message&gt;</span><br></pre></td></tr></table></figure>
</td></tr>


<tr><td><pre>fuller</pre></td><td>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit &lt;<span class="built_in">hash</span>&gt;</span><br><span class="line">Author:     &lt;author&gt;</span><br><span class="line">AuthorDate: &lt;author-date&gt;</span><br><span class="line">Commit:     &lt;committer&gt;</span><br><span class="line">CommitDate: &lt;committer-date&gt;</span><br><span class="line"></span><br><span class="line">&lt;title-line&gt;</span><br><span class="line"></span><br><span class="line">&lt;full-commit-message&gt;</span><br></pre></td></tr></table></figure>
</td></tr>

<tr><td><pre>reference</pre></td><td>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;abbrev-hash&gt; (&lt;title-line&gt;, &lt;short-author-date&gt;)</span><br></pre></td></tr></table></figure>
</td></tr>

<tr><td><pre>email</pre></td><td>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">From &lt;<span class="built_in">hash</span>&gt; &lt;date&gt;</span><br><span class="line">From: &lt;author&gt;</span><br><span class="line">Date: &lt;author-date&gt;</span><br><span class="line">Subject: [PATCH] &lt;title-line&gt;</span><br><span class="line"></span><br><span class="line">&lt;full-commit-message&gt;</span><br></pre></td></tr></table></figure>
</td></tr>
</table>

<p>还有一些别的选项，可以访问<a href="https://git-scm.com/docs/git-log#_pretty_formats">这里</a>详细了解。</p>
<h2 id="3-自定义显示"><a href="#3-自定义显示" class="headerlink" title="3. 自定义显示"></a>3. 自定义显示</h2><p>上述命令在某些情况下可能并不能满足我们的需求，比如<code>--format=oneline</code>选项没有显示提交时间。因此我们需要自定义log显示的方式。git提供了对commit信息中各部分的描述符号，可以让我们方便地自定义log显示。</p>
<p>下面列出了常见的选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>全称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>%cd</td>
<td>commit date</td>
<td>提交日期</td>
</tr>
<tr>
<td>%H</td>
<td>Hash</td>
<td>commit 的完整哈希串</td>
</tr>
<tr>
<td>%h</td>
<td>hash</td>
<td>commit 的简短哈希串</td>
</tr>
<tr>
<td>%an</td>
<td>author name</td>
<td>提交者名字</td>
</tr>
<tr>
<td>%ae</td>
<td>author email</td>
<td>提交者邮箱</td>
</tr>
<tr>
<td>%s</td>
<td>message</td>
<td>提交信息</td>
</tr>
</tbody></table>
<p>利用这些描述符，我们可以定制log显示格式，比如<code>git log --format=&quot;%cd|%h|%an|%ae|%s&quot;</code> 就是显示提交日期，commit简短hash，提交者的名字和邮箱，以及提交内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2022-03-23 09:52:22 +0100|b2e23d05|Johan Mabille|johan.mabille@gmail.com|Merge pull request <span class="comment">#2497 from spectre-ns/master</span></span><br><span class="line">2022-03-18 20:59:53 -0300|a5a70449|spectre-ns|dahubley@hotmail.ca|Updated C++20 option <span class="keyword">for</span> visual studio builds C++2a no longer a valid std option.</span><br><span class="line">2022-03-18 10:59:57 +0100|f603205a|Johan Mabille|johan.mabille@gmail.com|Merge pull request <span class="comment">#2496 from JohanMabille/adapt_doc</span></span><br></pre></td></tr></table></figure>

<h2 id="4-命令组合"><a href="#4-命令组合" class="headerlink" title="4. 命令组合"></a>4. 命令组合</h2><p>git log最强大的地方在于可以组合上述所有的选项，大大缩小搜索范围，能更方便地定位到想要的提交。例如我通过下面的命令，可以将搜索范围从3711条缩小到6条：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有提交记录，共3177条</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline |wc</span><br><span class="line">3177   19594  159959</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加搜索过滤，只剩6条</span></span><br><span class="line">$ git <span class="built_in">log</span> --since=<span class="string">&quot;2020-01-01&quot;</span> --until=<span class="string">&quot;2020-02-01&quot;</span> --grep fix --oneline</span><br><span class="line">af5cc6c4 Merge pull request <span class="comment">#1904 from BioDataAnalysis/emmenlau_tiny_variable_name_fix</span></span><br><span class="line">0f3caa37 benchmark/CMakeLists.txt: fixed a tiny spelling mistake</span><br><span class="line">218dcbe7 Merge pull request <span class="comment">#1902 from kolibri91/fix_warning</span></span><br><span class="line">38cb9617 Merge pull request <span class="comment">#1886 from wolfv/fix_reshape_return</span></span><br><span class="line">31cbd6d2 Merge pull request <span class="comment">#1880 from wolfv/fix_older_cmake</span></span><br><span class="line">f363e9d1 fix older cmak</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git合并另一个分支的某个文件到当前分支</title>
    <url>/2022/08/14/git-merge-file-from-another-branch/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>使用Git时，有时候不同分支的文件是不同步的，因此如果想要把别的分支的文件改动应用到当前分支，应该怎么操作呢？如果两边都有更新，该如何选择合并呢？这篇小文会对不同情形下的合并进行一个简单的介绍。</p>
<span id="more"></span>

<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>假设我们当前在分支<code>branch1</code>, 需要将分支<code>branch2</code>上的<code>a.py</code>合并到当前分支。<br>根据<a href="https://vra.github.io/2021/09/25/git-copy-from-another-branch">之前写的这篇文章</a>，我们可以这么操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout branch2 -- a.py</span><br></pre></td></tr></table></figure>
<h2 id="两边都存在文件"><a href="#两边都存在文件" class="headerlink" title="两边都存在文件"></a>两边都存在文件</h2><p>现在换一个情况，假设分支<code>branch1</code>和<code>branch2</code>都有文件<code>a.py</code>，且分支<code>branch1</code>上的文件包含在<code>branch2</code>的内容里，那么采用上面的命令也还是可以的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout branch2 -- a.py</span><br></pre></td></tr></table></figure>

<p>另外如果只想合并<code>branch2</code>上的文件的一部分更新到<code>branch1</code>，可以在<code>chekcout</code>后面增加<code>-p</code>或者<code>--patch</code>选项，交互式地选择要合并过来的代码块:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -p branch2 -- a.py</span><br></pre></td></tr></table></figure>
<p>交互式地操作命令同<code>git add -p</code>，可以参考<a href="https://vra.github.io/2022/06/17/git-add-part-of-a-file/">这里的文章</a>。</p>
<p>更复杂的情况是，分支<code>branch1</code>也有同名文件，且也有更新，如果直接使用<code>git checkout</code>的话，分支<code>branch2</code>上的文件会替代本地的文件，且没有任何提示（毕竟cheeckout的含义就是切换到某个分支）。因此为了保持本地的更新，需要增加<code>-p</code>选项。</p>
<p>这时候，会出现一种情况，本地的更新和远程的更新被放到一个块(hunk)里面，只能保留其中一个，此时就需要更精细的操作，在交互式环境中采用<code>e</code>命令来手动对hunk进行更新，去掉或增加代码的<code>+</code>或者<code>-</code>，具体可以参考<a href="https://stackoverflow.com/a/6290646">这个回答</a></p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>删除Git仓库中的大文件</title>
    <url>/2018/05/20/git-remove-large-file/</url>
    <content><![CDATA[<p>Git是用来管理源代码的一个工具，很多时候，我们不想让Git来跟踪较大的二进制文件。但是如果不小心将某个文件加入到Git的缓存区后，不管后面怎么删除这个大文件，Git始终都保存有这个文件的历史记录，因此项目会很大。拿下面例子来说，我们有个500M的文件<code>cnn.model</code>，通过下面的命令加入到git暂存区或提交到远端（提交时自动执行git gc命令，生成pack文件）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add cnn.model</span><br><span class="line">$ git commit -m <span class="string">&quot;add file cnn.model&quot;</span></span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure>
<p>经过这步操作，用<code>du -sh .</code>命令查看项目大小的话，发现足足有1000多M，因为本地文件<code>cnn.model</code>以及<code>.git</code>目录中的object也有一份这个文件的记录。<br>即使使用<code>git rm</code>命令删除当前的<code>cnn.model</code>文件，<code>.git</code>目录中还是记录有这个大文件的记录，因此后面别人clone这个项目后，项目还是很大。因此这里需要使用<code>git filter-branch</code>命令来删除<code>.git</code>目录中的文件记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git filter-branch --index-filter <span class="string">&#x27;git rm -r --cached --ignore-unmatch &lt;file/dir&gt;&#x27;</span> -- --all</span><br></pre></td></tr></table></figure>
<p>这是在你已知大文件的名字和目录情况下的删除过程。如果过了很久或者是有很多大文件，我们需要有一系列的命令来找出大文件，然后对其进行过滤。下面详细阐述整个过程。</p>
<span id="more"></span>

<h2 id="识别出大文件对象"><a href="#识别出大文件对象" class="headerlink" title="识别出大文件对象"></a>识别出大文件对象</h2><p>Git中会对大文件进行打包，生成git pack格式的<code>.pack</code>文件以及对应的同名的<code>.idx</code>文件，存放在<code>.git/object/pack</code>目录中。通常来说，Git仓库的大文件都是<code>.pack</code>格式的，存放在这个目录中。  </p>
<p>我们可以使用<code>git verify-pack -v &lt;SHA-1-code&gt;.idx</code>命令来查看打包文件<code>*.pack</code>的内容，如下面是该命令的一个示例输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git verify-pack -v .git/objects/pack/pack-2a54c6297dea8fa7feaa30b9738459765bb369a5.idx </span><br><span class="line">e18ab3d3c2bd2132c65c321dfa8e369756e61326 commit 177 123 12</span><br><span class="line">518876ca5a6f11241e71619a8d677f56863f3e2f blob   6170464 6115358 135</span><br><span class="line">a9ab211dafe06646f182a6f791627f3baf8dd02f tree   44 54 6115493</span><br><span class="line">non delta: 3 objects</span><br><span class="line">.git/objects/pack/pack-2a54c6297dea8fa7feaa30b9738459765bb369a5.pack: ok</span><br></pre></td></tr></table></figure>
<p>可以看到这个pack压缩包中有3个文件，对应输出的2-4行，每行的格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SHA-1 <span class="built_in">type</span> size size-in-packfile offset-in-packfile</span><br></pre></td></tr></table></figure>
<p>因此我们可以根据每行的第3项的值，即文件的大小对压缩包中的文件进行排序，然后根据大小排序找出大文件。具体的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git verify-pack -v .git/objects/pack/&lt;SHA-1-code&gt;.idx | sort -k 3 -n |tail -n 20</span><br></pre></td></tr></table></figure>
<p>上述命令会对对应的压缩文件进行分析，找出其中最大的20个文件。下面是一个示例输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git verify-pack -v .git/objects/pack/pack-318f6bd223ffc6f1cd5675946e9fe7fe11bbaa16.idx | sort -k 3 -n |tail -n 20</span><br><span class="line">18c8efee82a9088820da7b742047a1039e78c2f7 blob   8510 2439 481190</span><br><span class="line">a2b1d917c473e4bbd95d7b35bf01fc16e03e9bfc blob   10780 3355 4354</span><br><span class="line">be6f843c0c6aace758b2657d6c143218b4506544 blob   10923 2158 516005</span><br><span class="line">180ce52e5fc4a1dc2aa304d01a16305bf61c3b1b blob   11186 1223 518163</span><br><span class="line">16ee0f99c0cedd18a93d0bcbf8e37eae2c97d8b4 blob   13025 3549 488959</span><br><span class="line">fac08c493bc1bb4f603d606ac229446a8e0aac04 blob   13595 7857 53828 1 11900fd25b384500e3248576a624e24b67133834</span><br><span class="line">ffe06ba2393aeaba8aa43a634ff0f76394e80aef blob   24063 3100 466731</span><br><span class="line">8203b8c755cc96f3959c79212ae6b45e016e5492 blob   27626 10859 392665 1 ab395d21c693443302aecad6566dd8fb756a40c4</span><br><span class="line">26140b3267d8a81a7e2f3ba72d32dbc63ebd0be3 blob   29333 10427 403524 2 8203b8c755cc96f3959c79212ae6b45e016e5492</span><br><span class="line">222b644716ff079e4a55a151f23d9c98319f1493 blob   29551 12303 454428 1 48db793a769f3d5865a2c6a67519aaeb2cfed8d3</span><br><span class="line">50a2cd63d7e9a38e057943abece20bd32724227d blob   30168 12908 441520 1 48db793a769f3d5865a2c6a67519aaeb2cfed8d3</span><br><span class="line">04423baf437c3ac7252d001f5113322ec5328402 blob   32074 11800 42028 1 11900fd25b384500e3248576a624e24b67133834</span><br><span class="line">9f0eaf7e016a0833a60113270c86db80ed41c385 blob   54208 24360 107858 1 11900fd25b384500e3248576a624e24b67133834</span><br><span class="line">a5fa94cead7a74652e41bf92ad7e9b330d496014 blob   84612 14134 61685</span><br><span class="line">3dbb3684ac8c2009ad2a8e40f24f7475d9a8c1b2 blob   98788 32039 75819 1 11900fd25b384500e3248576a624e24b67133834</span><br><span class="line">ab395d21c693443302aecad6566dd8fb756a40c4 blob   142360 11036 381629</span><br><span class="line">11900fd25b384500e3248576a624e24b67133834 blob   200923 31670 10358</span><br><span class="line">48db793a769f3d5865a2c6a67519aaeb2cfed8d3 blob   398805 27569 413951</span><br><span class="line">bb0319cbbe1760601316c35629009ae2a0ef2fdc blob   460738 148159 233470 1 705d521f9a03ec7ce061653afaf664ab32724dac</span><br><span class="line">705d521f9a03ec7ce061653afaf664ab32724dac blob   1268611 100610 132218</span><br></pre></td></tr></table></figure>
<p>其中每行是一个Git的对象（Object)。</p>
<h2 id="找出Git对象对应的文件名"><a href="#找出Git对象对应的文件名" class="headerlink" title="找出Git对象对应的文件名"></a>找出Git对象对应的文件名</h2><p>由于上述步骤得到的Git对象只有一长串的SHA-1的值，而没有具体的对应的在文件系统中的文件名字，因此我们需要找出Git对象对应的文件名。<br>我们可以使用<code>git rev-list &lt;commit-id&gt;</code>来达到此功能。 这个命令用来显示某次提交前的所有的提交对象（commit object），而加了<code>--objects</code>则用来显示某次提交时所有的Git对象。使用<code>--all</code>则显示所有的提交，而不是某次特定的提交下的对象信息。因此用下面的命令可以查看Git对象和对应的文件路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rev-list --objects --all |grep &lt;SHA-1-code&gt;</span><br></pre></td></tr></table></figure>
<p>以上个步骤中输出的最后一个文件为例，执行这条的命令（注意SHA-1的值只用输入前6位即可）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rev-list --objects --all |grep 705d52</span><br><span class="line">705d521f9a03ec7ce061653afaf664ab32724dac data/model-400M.caffemodel</span><br></pre></td></tr></table></figure>
<p>可以看出，这个Git对象对应的文件路径是<code>data/model-4000M.caffemodel</code>。</p>
<h2 id="找出修改这个文件的所有commit"><a href="#找出修改这个文件的所有commit" class="headerlink" title="找出修改这个文件的所有commit"></a>找出修改这个文件的所有commit</h2><p>我们需要从commit历史中找到所有修改该文件的commit然后修改这些commit。这里我们使用<code>git log</code>来操作，具体如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=online -- &lt;file-name&gt;</span><br></pre></td></tr></table></figure>
<p>以<code>data/model-400M.caffemodel</code>文件为例，这个命令的具体形式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline -- data/model-400M.caffemodel</span><br><span class="line">32a9f5f8136c9b011d785bdd08dd24cd0e1d0d1b first commit</span><br></pre></td></tr></table></figure>

<h2 id="重写所有修改这个文件的提交"><a href="#重写所有修改这个文件的提交" class="headerlink" title="重写所有修改这个文件的提交"></a>重写所有修改这个文件的提交</h2><p>找到所有修改这个对象的commit后，我们找到最早的修改，然后使用<code>git filter-branch</code>命令来操作，具体如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git filter-branch --index-filter <span class="string">&#x27;git rm --cached --ignore-unmatch data/model-400M.caffemodel&#x27;</span> -- 32a9f5 </span><br></pre></td></tr></table></figure>
<p>也可以将这步和上面一步合在一起，直接从所有提交中删除这个对象：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git filter-branch --index-filter <span class="string">&#x27;git rm --cached --ignore-unmatch data/model-400M.caffemodel&#x27;</span> -- --all</span><br></pre></td></tr></table></figure>
<p>必要的时候，需要用<code>-f</code>选项来强制地进行删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git filter-branch -f --index-filter <span class="string">&#x27;git rm --cached --ignore-unmatch data/model-400M.caffemodel&#x27;</span> -- --all</span><br></pre></td></tr></table></figure>

<h2 id="删除引用并重新打包"><a href="#删除引用并重新打包" class="headerlink" title="删除引用并重新打包"></a>删除引用并重新打包</h2><p>这里需要删除<code>.git/refs</code>目录下的一些引用文件并重新打包，具体命令如下，比较固定：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rm -Rf .git/refs/original</span><br><span class="line">$ rm -Rf .git/logs</span><br><span class="line">$ git gc</span><br></pre></td></tr></table></figure>
<p>之后可以用<code>du -sh </code>等命令查看项目目录的大小。<br>如果<code>git push</code>提示冲突的话，需要用<code>git push -f</code>命令来强制推送代码到远端。虽然不建议用<code>-f</code>选项，但是特殊情况特殊处理~</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>Pro Git 第9.7.3节</li>
<li><a href="https://stackoverflow.com/questions/19573031/cant-push-to-github-because-of-large-file-which-i-already-deleted">https://stackoverflow.com/questions/19573031/cant-push-to-github-because-of-large-file-which-i-already-deleted</a></li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU并行计算和CUDA编程(1)-CPU体系架构概述</title>
    <url>/2015/09/12/gpu-programming-1/</url>
    <content><![CDATA[<p>今天和实验室同学去听了周斌老师讲的《GPU并行计算和CUDA程序开发及优化》（课程主页：<a href="http://acsa.ustc.edu.cn/HPC2015/nvidia/">http://acsa.ustc.edu.cn/HPC2015/nvidia/</a>），觉得老师讲得非常清晰，举了很多恰当的例子，将复杂的计算机中的情景和术语准确地描述成了简单的生活中的场景，使学生很容易就理解了。而我在今天的课程中也学到了很多东西，我想趁热打铁记下来，以后看起来更方便点。 </p>
<p>CPU是串行处理器，而GPU是并行处理器。CPU适合处理通用型的问题，如指令执行和数值计算并重，相当于是一个”通才”；而GPU适合运算密集和高度并行的任务，相当于是一个”专才”，将数值并行运算速度发挥到极致。在讨论GPU之前，先来看看CPU的体系架构的一些内容。 </p>
<span id="more"></span>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>CPU的指令分3类，分别是算术、访存和控制。算术包括加减乘除等操作（在计算机中转化为加或乘来做），访存表示对数据寄存器进行读写，控制表示跳转，分支等操作。  </p>
<p>CPU程序的最优化目标是：</p>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
<p>$$\frac{cycle}{instruction}\times\frac{seconds}{cycle}$$<br>其中前一项是每条指令执行的时钟周期数，简称为CPI（Cycle Per Instruction)，后一项即时钟周期。 </p>
<p>CPU的指令顺序是取指-&gt;译码-&gt;执行-&gt;访存-&gt;写回。  </p>
<p>为了提高程序执行的效率，CPU里面采用了流水线的设计，将一个任务分割成多个任务片段，在同一时刻，每个任务片段可能处理不同的指令。注意：我们说CPU是串行处理器，是从宏观的角度来说的，底层的流水线实现实际是并行的。此外，流水线使得单个指令的执行周期变长了，因为增加了任务时间段的切割，可能会增加额外的时间开销，但从整体上来讲，效率显然是提高了。 </p>
<h2 id="流水线存在的一些问题"><a href="#流水线存在的一些问题" class="headerlink" title="流水线存在的一些问题"></a>流水线存在的一些问题</h2><p>流水线中，可能会出现停滞（stall）的问题，就是对某个任务片段，前面的指令已经执行完了，而后面的指令还没有传过来，出现了停滞。 </p>
<p>另外一个问题是可能存在分支，使得流水线不能正常地高速执行了。为了解决分支的问题，提出了两种方法，一种是分支预测（branch prediction），另一种是分支断定（branch predication）。 </p>
<p>分支预测就是根据历史记录或基于全局记录来进行预测下一步需要执行哪条命令，然后减少分支的开销。分支预测能达到90%的准确率，但是增加了额外的硬件电路设计上的面积（因为需要记录历史分支数据，需要增加额外的存储器件），也可能会增加延迟。 </p>
<p>分支断定就是类似与每次都将所有可能的下一条执行尝试一遍，避免了分支预测。可以这样认为：分支断定就像switch语句，每个选项都进行比较，而分支预测就相当于if/else语句，需要使用分支预测器。 </p>
<p>为了提升IPC（CPI的倒数），CPU又使用了超标量的方法，即增加流水线的宽度，相当于同时执行好几条流水线，这样效率又提高了，当然也是以增加芯片面积为代价的。 </p>
<h2 id="指令调度"><a href="#指令调度" class="headerlink" title="指令调度"></a>指令调度</h2><p>因为有些指令之间是有依赖关系的，比如A指令是把加的结果写入到R1,B指令是读取R1中的数，所以B指令必须等A指令完成之后才能来执行。一般来讲，Read—After-Write（RAW）模式的语句之间有依赖关系，而别的，像WAW,WAR都是没依赖关系的。<br>为了解决指令依赖的问题，提出了2种方案：1是寄存器重命名，即将涉及冲突的寄存器重命名为不同的寄存器，就解决了依赖问题；2是乱序执行，即将所有指令放到一个重拍缓冲区（ROB，Recorder Buffer）中，根据一定的算法，重新执行各语句，使得各语句之间无依赖关系。 </p>
<h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><p>CPU的缓存机制利用了1.时间临近性和空间临近性。</p>
<h2 id="CPU内部的并行性"><a href="#CPU内部的并行性" class="headerlink" title="CPU内部的并行性"></a>CPU内部的并行性</h2><p>CPU内部也有并行计算，体现在下面3个层次：</p>
<ol>
<li>指令级，如超标量就是通过增加流水线达到并行效果。</li>
<li>数据级，如矢量运算。如下面代码：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	C[i] = A[i] + B[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 执行的时候可以通过矢量运算，将循环运算并行地计算，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">C[<span class="number">0</span>] = A[<span class="number">0</span>] + B[<span class="number">0</span>];</span><br><span class="line">C[<span class="number">1</span>] = A[<span class="number">1</span>] + B[<span class="number">1</span>];</span><br><span class="line">C[<span class="number">2</span>] = A[<span class="number">2</span>] + B[<span class="number">2</span>];</span><br><span class="line">C[<span class="number">3</span>] = A[<span class="number">3</span>] + B[<span class="number">3</span>];</span><br><span class="line">C[<span class="number">4</span>] = A[<span class="number">4</span>] + B[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>线程级别的并行。每个CPU有1-2个活动线程。</li>
</ol>
<h2 id="多核相关"><a href="#多核相关" class="headerlink" title="多核相关"></a>多核相关</h2><p>CPU多核之间，只共享最后一级缓存。<br>多核之间数据的访问安全等问题，需要有：</p>
<ol>
<li>锁</li>
<li>一致性： 谁的数据是正确的</li>
<li>同一性： 哪个数据是正确的</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>尽管在IEEE的规范中，浮点数使用64bit空间来存储，但在CPU中，浮点数的精度是拓展到80bit来计算的，所以CPU中浮点数精度比GPU（64bit）中要高。 </p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>GPU</tag>
        <tag>CUDA</tag>
        <tag>计算机视觉</tag>
        <tag>并行计算</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用总结</title>
    <url>/2017/05/24/git-tutorial/</url>
    <content><![CDATA[<p>我一直觉得Git是一个很有用的工具，但是要熟练地掌握其各个功能，还是挺不容易的。我之前打算在实验室分享一下Git的使用，所以写了个PPT，现在放到这里，希望对大家游泳，也希望我自己在遗忘掉某些功能的时候，能来这里查查。另外显示PDF的Hexo插件是<a href="https://github.com/superalsrk/hexo-pdf">hexo-pdf</a>。</p>
<span id="more"></span>
<p>如果内嵌的PDF加载较慢的话，请访问<a href="/imgs/git_tutorial.pdf">这里</a>。</p>
<div class="pdf-container" data-target="../../../../pdf/git_tutorial.pdf" data-height="500px"></div>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git显示文件首次被跟踪的日期</title>
    <url>/2022/03/26/git-show-first-added-time/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在使用Git的时候，想要显示某个文件首次被跟踪的时间，可以用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --format=%ad /path/to/file |tail -1</span><br></pre></td></tr></table></figure>
<p>管道操作前的命令是以默认日期格式显示所有包含这个文件的所有提交记录，从上往下依次为最新的最早的提交。管道操作后面的命令是提取前面的输出中最后一条记录，即最早的提交，这正是我们需要的。</p>
<p>各种关于git log的用法，参考上一篇博文。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>初探Grunt</title>
    <url>/2015/07/04/grunt-configure/</url>
    <content><![CDATA[<p>最近打算学习一些web编程的知识，今天学习了Grunt这个工具的用法，这里简要地对学习的知识点进行个总结。</p>
<h2 id="1-Grunt是什么"><a href="#1-Grunt是什么" class="headerlink" title="1. Grunt是什么"></a>1. Grunt是什么</h2><p>Grunt网站上的副标题是”The Javascript Task Runner”，是用来实现Javascript编程自动化的一个工具，类似<code>make</code>工具体系。只要设置好<code>Gruntfile</code>（类比<code>Makefile</code>），就可以使用<code>grunt</code>命令来自动执行javascript代码的清理、重新生成等任务。Grunt生态圈里面有大量的插件，Grunt工具就是使用这些插件来实现自动化。</p>
<span id="more"></span>

<h2 id="2-如何安装Grunt"><a href="#2-如何安装Grunt" class="headerlink" title="2. 如何安装Grunt"></a>2. 如何安装Grunt</h2><p>Grunt通过<code>npm</code>命令来安装，所以需要首先安装npm。npm是nodejs package manager的缩写，是nodejs的包管理工具。在新版的nodejs里面默认包含了npm，所以只需要安装最新班的nodejs即可，访问nodejs官方网站下载最新版的nodejs。<br>之后通过npm安装<code>grunt-cli</code>，即Grunt command line interface。为了在所有目录下都可以使用grunt命令，需要加-g参数，指令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g grunt-cli</span><br></pre></td></tr></table></figure>

<p>注意：有的发行版在使用<code>npm</code>命令时需要root权限，前面要加<code>sudo</code>命令。<br>其实安装完grunt-cli后，并没有安装grunt。这里面的原理大概是这样的：grunt-cli只用来寻找通过nodejs的<code>require</code>工具(或在package.json的dependencies)已经安装好的本地的grunt,然后执行之。可以看源代码查看工作原理。</p>
<h2 id="3-使用Grunt工具前需要准备哪些东西"><a href="#3-使用Grunt工具前需要准备哪些东西" class="headerlink" title="3. 使用Grunt工具前需要准备哪些东西"></a>3. 使用Grunt工具前需要准备哪些东西</h2><p>按理来说，使用<code>grunt</code>命令，只需要有个<code>Gruntfile</code>就可以了，但是上文提到，grunt task runner需要在每个项目中单独安装，所以还得有个保存项目元数据的<code>package.json</code>文件。</p>
<p>在每个nodejs项目中，都有个<code>package.json</code>文件来保存这个项目的名称、版本、依赖库等元数据。</p>
<p><code>package.json</code>可以使用命令<code>npm init</code>交互式地生成。在生成该文件后，可以使用<code>npm install</code>在当前项目目录下安装依赖库。</p>
<p>此外，在项目目录下安装工具库并使用<code>--save-dev</code>或<code>--save</code>参数，可以将安装的工具自动加入到该项目的依赖库中。其中<code>--save</code>命令将安装的工具名称和版本号加入到<code>dependencie</code>部分，<code>--save-dev</code>则加到<code>devDependencies</code>部分。如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install grunt --save-dev</span><br></pre></td></tr></table></figure>

<p>将安装grunt task runner 并将其名称和版本号自动加入到<code>devDependencies</code>部分。</p>
<p><code>Gruntfile</code>是<code>Gruntfile.js</code>(Javascript语言格式)和<code>Gruntfile.coffee</code>(CoffeeScript格式)之一,类似Make工具体系中的<code>Makefile</code>，用来保存配置信息，是Grunt工具的最主要文件。<br>下面是一个Gruntfile的示例格式，详细格式和说明请参阅官方文档。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  grunt.initConfig(&#123;</span><br><span class="line">    <span class="attr">jshint</span>: &#123;</span><br><span class="line">      <span class="attr">files</span>: [<span class="string">&#x27;Gruntfile.js&#x27;</span>, <span class="string">&#x27;src/**/*.js&#x27;</span>, <span class="string">&#x27;test/**/*.js&#x27;</span>],</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">globals</span>: &#123;</span><br><span class="line">          <span class="attr">jQuery</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>: &#123;</span><br><span class="line">      <span class="attr">files</span>: [<span class="string">&#x27;&lt;%= jshint.files %&gt;&#x27;</span>],</span><br><span class="line">      <span class="attr">tasks</span>: [<span class="string">&#x27;jshint&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  grunt.loadNpmTasks(<span class="string">&#x27;grunt-contrib-jshint&#x27;</span>);</span><br><span class="line">  grunt.loadNpmTasks(<span class="string">&#x27;grunt-contrib-watch&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  grunt.registerTask(<span class="string">&#x27;default&#x27;</span>, [<span class="string">&#x27;jshint&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-如何运行Grunt"><a href="#4-如何运行Grunt" class="headerlink" title="4. 如何运行Grunt"></a>4. 如何运行Grunt</h2><p>在<code>Gruntfile</code>写好之后，运行<code>grunt</code>命令，就会自动执行<code>Gruntfile</code>里面的语句了。so easy 是不是～</p>
]]></content>
      <tags>
        <tag>Web编程</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU并行计算和CUDA编程(2)-GPU体系架构概述</title>
    <url>/2015/09/12/gpu-programming-2/</url>
    <content><![CDATA[<h2 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h2><p>并行计算的定义： 应用多个计算资源来解决<strong>同一个计算问题</strong></p>
<h3 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h3><ol>
<li>Flynn矩阵：<br>SISD(Single Instruction Single Data),<br>SIMD(Single Instruction Multiple Data),<br>MISD(Multiple Instruction Single Data),<br>MIMD(Multiple Instruction Multiple Data),<br>由 SISD,SIMD，MISD，MIMD组成的矩阵就是Flynn矩阵。从前往后，4种结构越来越复杂。 </li>
<li>共享存储和分布式存储   </li>
<li>通信和同步  </li>
<li>加速比，并行开销，拓展性</li>
</ol>
<span id="more"></span>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script> 
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<h3 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h3><p>  $$1. speed rate = \frac{1}{1-P} $$<br>其中P是可以并行的部分，即加速比与任务中不可并行部分的大小成正比，如果完全不可并行，即P = 0，则speed rate = 1，即不加速；如果完全可以并行，即P = 1, 则$speed rate = \infty$, 即加速无穷大倍。<br>  $$2. speed rate = \frac{1}{\frac{P}{N} + S} $$<br> 其中N是处理器个数，P是可以并行的部分，S是不可以并行，只能串行的部分。可以看到，当N趋近无穷时，speed rate 只取决于S，即不可并行部分是系统的瓶颈所在。 </p>
<h2 id="GPU结构"><a href="#GPU结构" class="headerlink" title="GPU结构"></a>GPU结构</h2><p>CPU和GPU的内部结构的对比图如下：<br><img src="/imgs/cpu_gpu_schema.gif"><br>图中绿色的为ALU（运算逻辑单元，Arithmetic Logic Unit）, 可以看出GPU相比CPU，多了很多ALU，而且ALU占据了内部空间的绝大部分，所以可以看出GPU是对运算很强调的芯片。</p>
<p>下图是一个GPU核的结构，图中所有8个ALU共用一个指令单元Fetch/Decode, 而Ctx则是每个ALU独有的存储上下文，所以，只是一种SIMD结构。<br><img src="/imgs/gpu-core.png"></p>
<h3 id="分支问题"><a href="#分支问题" class="headerlink" title="分支问题"></a>分支问题</h3><p>由于每个ALU的Ctx不同，所以有可能会出现分支，这时候8个ALU的指令可能会出现分叉，即各自走了不同的路，没法共享同一个指令了，这种结构就会失效。为了解决这个问题，将所有可能出现的分支用<code>if/else</code>来表示，让每个ALU都进行判断，如下图所示：<br><img src="/imgs/gpu-branch.jpg"></p>
<p>从图中我们可以看到，每个ALU都进行了<code>if/else</code>的判断，有的ALU走了<code>if</code>部分，有的ALU走了<code>else</code>部分，这样8个ALU就可以共用一个Fetch/Decode单元了。但因为每个ALU都要进行判断，所以做了一部分无用功，牺牲了部分性能，性能最差的时候只有1/8的有用功，即只有1个ALU选择<code>if</code>或选择<code>else</code>，其他7个ALU都做了无用功，性能只有1/8。  </p>
<!--
### 停滞问题（Stall）
在GPU处理问题的过程中，可能有的指令需要从别的地方读取数据，比较好似
-->
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>GPU</tag>
        <tag>CUDA</tag>
        <tag>计算机视觉</tag>
        <tag>并行计算</tag>
      </tags>
  </entry>
  <entry>
    <title>Amax K40 Linux GPU服务器重装记录</title>
    <url>/2017/07/21/install-amax-k40/</url>
    <content><![CDATA[<p>因为这台GPU服务器闲置了很久，经过这两天的安装，现在基本能用了。整个过程其实挺坎坷的，因此记录下此次安装过程中遇到的坑，后面好参考。服务器从原先的OpenSuse换成了Ubuntu 16.04 LTS 发行版。  </p>
<span id="more"></span>

<h3 id="安装系统遇到的问题"><a href="#安装系统遇到的问题" class="headerlink" title="安装系统遇到的问题"></a>安装系统遇到的问题</h3><p>安装系统整个流程是这样的：</p>
<ol>
<li>下载Ubuntu镜像，从科大的源上下载</li>
<li>制作启动U盘，采用软碟通来制作</li>
<li>插入U盘到机器，进入BIOS设置，选择Legacy模式，并将U盘的启动顺序放在最前面</li>
<li>启动从U盘启动，进入安装Ubuntu的图形界面，进行重新划分盘然后在盘上安装系统</li>
<li>安装好后，重启系统，拔掉U盘，进入BIOS，调整硬盘<code>ST2000*</code>的启动顺序，使之排在最前面</li>
</ol>
<p>其中遇到两个问题。第一个问题是在上述3步骤的时候，选择Legacy还是UEFI。这里Legacy表示选择经典的BIOS启动，BIOS简单来说就是主板上一块固话的flash芯片，它在开机后会最先启动，然后按照里面写好的步骤把主要硬件挨个检查一遍，然后去硬盘找引导程序，然后把引导权交给它，然后就进系统了。UEFI则是一种新的启动方式，Legacy的启动方式要用MBR磁盘格式，UEFI启动方式要用GPT磁盘格式。<strong>如果你安装系统时候用的是Legacy，进入系统时选择UEFI则会报错，反过来也是，因此要保持装系统和进系统时两者的一致。</strong> <strong>我们的机器是因为比较老旧，所以只支持Legacy，所以选择的时候选择Legacy。</strong><br>第二个问题是在上述第4步中划分盘的时候，底下的” device for bootloader installation”这个输入框该如何选择。刚开始我们选择了划分好的某个分区，如/dev/sdd1，但是有问题，安装后总有错。后来查看网上的资料，发现都是采用没加下标的盘符，如/dev/sdd。<strong>因此在划分盘的时候，在盘开始的位置留一些空间，然后这里选择没下标的盘符，如/dev/sdd，即可。</strong>   </p>
<h3 id="挂载硬盘的问题"><a href="#挂载硬盘的问题" class="headerlink" title="挂载硬盘的问题"></a>挂载硬盘的问题</h3><p>安装好系统后，默认挂载的只有装系统时候的那块盘上的分区，像别的硬盘上的分区如果要开启自动挂载的话，需要在/etc/fstab里面写入记录。<br>fstab的记录的格式是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># format &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;, for example,</span></span><br><span class="line">/dev/sdc /data2 ext4  defaults 0 0</span><br></pre></td></tr></table></figure>
<p>其中细节可以参考我写的<a href="https://vra.github.io/2014/12/14/fstab-automount-windows-partitions/">这篇博客</a>。其中type这个参数不好确定，需要用<code>blkid</code>命令来查看，如下面两种格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo blkid</span><br><span class="line">/dev/sda1: UUID=<span class="string">&quot;d0dbd540-305b-493d-b42b-f9d92f3388d7&quot;</span> TYPE=<span class="string">&quot;ext4&quot;</span></span><br><span class="line">/dev/sda2: UUID=<span class="string">&quot;9a9946ab-43b4-454a-9993-b59fb4860139&quot;</span> TYPE=<span class="string">&quot;ext4&quot;</span></span><br><span class="line">/dev/sda3: UUID=<span class="string">&quot;479416ea-cbf0-42ef-9f19-827f0524128a&quot;</span> TYPE=<span class="string">&quot;swap&quot;</span></span><br><span class="line">/dev/sdb1: UUID=<span class="string">&quot;89e6c107-62bd-4e7a-807d-5b5024f272b5&quot;</span> TYPE=<span class="string">&quot;ext4&quot;</span></span><br><span class="line">/dev/sdc: UUID=<span class="string">&quot;117d0fa5-cffb-45ff-8758-9dc23063bcf8&quot;</span> TYPE=<span class="string">&quot;ext2&quot;</span></span><br><span class="line">/dev/sdd: UUID=<span class="string">&quot;887d5d9a-fbb3-4036-ad97-11b072cff277&quot;</span> TYPE=<span class="string">&quot;ext4&quot;</span></span><br><span class="line">/dev/sde: UUID=<span class="string">&quot;61ae41de-1fca-4d4e-bdb3-e45f8d9777ec&quot;</span> TYPE=<span class="string">&quot;ext3&quot;</span></span><br><span class="line">/dev/sdf: UUID=<span class="string">&quot;5d23d7a7-b572-4973-846c-7cf23d1a915f&quot;</span> TYPE=<span class="string">&quot;ext4&quot;</span></span><br><span class="line">/dev/sdg: UUID=<span class="string">&quot;088ccdbd-ad9d-4bf1-994c-7bd11b714c7a&quot;</span> TYPE=<span class="string">&quot;ext4&quot;</span></span><br><span class="line">$ sudo blkid -o value -s TYPE /dev/sda1</span><br><span class="line">ext4</span><br></pre></td></tr></table></figure>
<p>知道这个参数之后，就修改/etc/fstab，增加要挂载的硬盘分区，然后重启即可。<strong>主要挂载如果参数有错的话，开机启动会报错，进入安全模式，须将其修改后再启动。所以备份原先的fstab是很有必要的。</strong>  </p>
<h3 id="Caffe编译过程中HDF5库路径的问题"><a href="#Caffe编译过程中HDF5库路径的问题" class="headerlink" title="Caffe编译过程中HDF5库路径的问题"></a>Caffe编译过程中HDF5库路径的问题</h3><p>在Ubuntu 16.04中，HDF5文件的lib目录不在系统默认的/usr/local/lib或/usr/lib目录下，而是在<code>/usr/lib/x86_64-linux-gnu/hdf5/serial</code>目录下，所以在Caffe的Makefile.config中的<code>LIBRARY_DIRS</code>那行后面增加<code> /usr/lib/x86_64-linux-gnu /usr/lib/x86_64-linux-gnu/hdf5/serial</code>。同理，其include目录也不在标准目录，而是在<code>/usr/include/hdf5/serial</code>目录，因此也需要将其加入到<code>INCLUDE_DIRS</code>这一行，因此这两行的最终结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">93 <span class="comment"># Whatever else you find you need goes here.</span></span><br><span class="line">94 INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/<span class="built_in">local</span>/include /usr/include/hdf5/serial</span><br><span class="line">95 LIBRARY_DIRS := $(PYTHON_LIB) /usr/<span class="built_in">local</span>/lib /usr/lib /usr/lib/x86_64-linux-gnu /usr/lib/x86_64-linux-gnu/hdf5/serial</span><br></pre></td></tr></table></figure>
<p>修改后再重新编译Caffe即可。</p>
<h3 id="cuDNN6-0和tensorflow"><a href="#cuDNN6-0和tensorflow" class="headerlink" title="cuDNN6.0和tensorflow"></a>cuDNN6.0和tensorflow</h3><p>在尝试用pip安装tensorflow的时候，安装后执行<code>import tensorflow as tf</code>的时候，报错，说是找不到cuddnn.so.5，可是pip安装的是用cuDNN5.*编译的二进制文件，也即当前pypi仓库里面是用的cuDNN5.0。为了能用cuDNN 6.0加速性能，我决定自己编译Tensorflow。之前在Ubuntu 14.04上编译过一次，但由于包太老，bazel安装出现问题。这次编译没错，安装<a href="https://www.tensorflow.org/install/install_sources">官方文档</a>来操作即可。  </p>
<h3 id="VNC-显示不全的问题"><a href="#VNC-显示不全的问题" class="headerlink" title="VNC 显示不全的问题"></a>VNC 显示不全的问题</h3><p>这个问题现在还没解决，但是基本可以使用了，只不过在VNC界面打开Terminal的时候会报错，而打开Xterm却没问题，网上找了些资料也没好的解决方法。因此这里先把目前的操作记录下来吧。  </p>
<h4 id="使用Gnome界面"><a href="#使用Gnome界面" class="headerlink" title="使用Gnome界面"></a>使用Gnome界面</h4><p>需要安装一下Gnome图像界面的包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install --no-install-recommends ubuntu-desktop gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal</span><br></pre></td></tr></table></figure>
<p>然后编辑~/.vnc/xstartup文件，修改为如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following two lines for normal desktop:</span></span><br><span class="line"><span class="comment"># unset SESSION_MANAGER</span></span><br><span class="line"><span class="comment"># exec /etc/X11/xinit/xinitrc</span></span><br><span class="line"></span><br><span class="line">[ -x /etc/vnc/xstartup ] &amp;&amp; <span class="built_in">exec</span> /etc/vnc/xstartup</span><br><span class="line">[ -r <span class="variable">$HOME</span>/.Xresources ] &amp;&amp; xrdb <span class="variable">$HOME</span>/.Xresources</span><br><span class="line">xsetroot -solid grey</span><br><span class="line">vncconfig -iconic &amp;</span><br><span class="line">x-terminal-emulator -geometry 80x24+10+10 -ls -title <span class="string">&quot;<span class="variable">$VNCDESKTOP</span> Desktop&quot;</span> &amp;</span><br><span class="line">x-window-manager &amp;</span><br><span class="line"></span><br><span class="line">gnome-panel &amp;</span><br><span class="line">gnome-settings-daemon &amp;</span><br><span class="line">metacity &amp;</span><br><span class="line">nautilus -n &amp;</span><br><span class="line">gnome-terminal &amp;</span><br></pre></td></tr></table></figure>
<p>然后关掉之前的VNC连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vncserver -<span class="built_in">kill</span> :1</span><br></pre></td></tr></table></figure>
<p>重新设置新的连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vncserver -geometry 1840x1020 :1</span><br></pre></td></tr></table></figure>
<p>然后再客户端连接服务器，查看是否有问题</p>
<h4 id="安装xfce桌面"><a href="#安装xfce桌面" class="headerlink" title="安装xfce桌面"></a>安装xfce桌面</h4><p>这时候需要安装如下的桌面显示包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install xfce4 xfce4-goodies</span><br></pre></td></tr></table></figure>
<p>然后将~/.vnc/xstartup修改为如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">xrdb <span class="variable">$HOME</span>/.Xresources</span><br><span class="line">startxfce4 &amp;</span><br></pre></td></tr></table></figure>
<p>然后执行和上面同样的kill掉旧连接，建立新连接。</p>
<h3 id="设置静态IP"><a href="#设置静态IP" class="headerlink" title="设置静态IP"></a>设置静态IP</h3><p>服务器重装后，IP地址改变了，但是我们还是希望大家使用熟悉的IP地址，所以需要设置一个静态IP地址。这里实现的步骤如下：<br>先是执行<code>sudo ifconfig</code>来查看以太网网卡的名称，因为后面要用到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ifconfig</span><br><span class="line">enp4s0f0  Link encap:Ethernet  HWaddr 0c:c4:7a:32:6e:42</span><br><span class="line">          inet addr:192.168.134.200  Bcast:192.168.104.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: 2101:da0:d800:1454:725e:fb01:5ef8:16a5/64 Scope:Global</span><br><span class="line">          inet6 addr: 2101:da0:d800:1454:2234:4e15:e803:59b9/64 Scope:Global</span><br><span class="line">          inet6 addr: fe80::ec4:7aff:fe34:2e42/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:1764153 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1086158 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:2514858243 (2.5 GB)  TX bytes:398311453 (398.3 MB)</span><br><span class="line">          Memory:c7020000-c703ffff</span><br><span class="line"></span><br><span class="line">enp4s0f1  Link encap:Ethernet  HWaddr 0c:c4:7a:04:6e:43</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line">          Memory:c7000000-c701ffff</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:1836 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1836 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1</span><br><span class="line">          RX bytes:246069 (246.0 KB)  TX bytes:246069 (246.0 KB)</span><br></pre></td></tr></table></figure>
<p>可以看到其中有3个网络接口，第三个<code>lo</code>应该是本地loop接口，不是网卡，前两个，可以看到第一个数据流量大，而第二个数据流量都是0，所以确定网卡名称为enp4s0f0。然后编辑<code>/etc/network/interfaces</code>文件，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># interfaces(5) file used by ifup(8) and ifdown(8)</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto enp4s0f0</span><br><span class="line">iface enp4s0f0 inet static</span><br><span class="line">address 192.168.134.234</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.134.254</span><br><span class="line">dns-nameservers 202.38.64.1 202.141.176.93</span><br></pre></td></tr></table></figure>
<p>其中<code>enp4s0f0</code>根据你的上条命令的结果自行调整。<br>修改完后，执行下面的命令重启网络服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart networking.service</span><br></pre></td></tr></table></figure>
<p>之后重启系统，就会发现IP已经变为你期望的静态IP。  </p>
<h3 id="MatLab-安装"><a href="#MatLab-安装" class="headerlink" title="MatLab 安装"></a>MatLab 安装</h3><p>MatLab安装现在还没完成，但已经有一些地方值得记录下来。<br>先是从学校正版软件中心下载ISO文件，然后解压文件，放在某个目录下，修改其中的installer_inputer,主要修改下面这些地方：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">destinationFolder=/usr/<span class="built_in">local</span>/R2017a</span><br><span class="line">fileInstallationKey=xxxx-xxxx-...</span><br><span class="line">agreeToLicense=yes</span><br><span class="line">outputFile=/tmp/mathworks_yunfeng.log</span><br><span class="line">mode=silent</span><br><span class="line">licensePath=/data/public/2017a/network.lic</span><br></pre></td></tr></table></figure>
<p><strong>注意最后一个参数，注释的例子里面都是写的<code>.dat</code>文件，很误导人，其实在这里写成到<code>network.lic</code>的绝对路径即可。</strong><br>然后退出MatLab目录，在别的目录执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ./data/public/R2017a_glnxa64_dvd1/install -inputFile /data/public/R2017a_glnxa64_dvd1/installer_input.txt</span><br></pre></td></tr></table></figure>
<p>这里有个问题，2017a是分2个ISO文件的，一个文件执行完后，另一个文件怎么插入呢？网上有ISO文件编译时的说明，但是想想貌似不可行，以后再试试。  </p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>总结</tag>
        <tag>GPU</tag>
        <tag>Amax</tag>
        <tag>BIOS</tag>
        <tag>UEFI</tag>
        <tag>VNC</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>你不应该知道的知识之如何安装老版本的Python</title>
    <url>/2019/09/07/install-old-version-of-python/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>由于某些奇怪的原因（如项目中要用某个用Python3.4编译的库），你可能需要安装官方停止支持的Python版本（如Python2.5, Python2.6, Python3.3, Python 3.4或者更老的版本），<br>直接通过<code>sudo apt install python3.4</code>是没法安装的，因为Ubuntu 16.04移除了对Python3.4的支持。<br>作为不应该知道的知识的一部分，这里详细记录下在Ubuntu 16.04下安装旧版本的Python的方式，如果在2029年，因项目你需要安装Python3.4，或许本文可以帮到你。</p>
<span id="more"></span>

<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>为了使用<code>add-apt-repository</code>，需要先安装下面的包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>增加<code>deadsnakes</code> PPA (名字好评)<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:deadsnakes/ppa</span><br></pre></td></tr></table></figure></li>
<li>使用<code>apt</code>安装pythonx.y:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install python3.4</span><br></pre></td></tr></table></figure>
如果需要安装<code>libpython3.4</code>，可以使用类似下面的命令：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install libpython3.4 libpython3.4-dev libpython3.4-minimal</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>你不应该知道的知识之如何在Ubuntu 16.04上安装Pip2</title>
    <url>/2019/09/07/install-pip2/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虽然2020年官方就不支持Python2系列了，不过有时你还是会用到Python2，这时候为了安装某个包(如numpy)，你需要<code>pip2</code>。而<code>pip2</code>一般比较新的系统是没带的。下面记录如何安装它。</p>
<span id="more"></span>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>很简单，两行命令搞定：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line">sudo python2.7 get-pip.py</span><br></pre></td></tr></table></figure>
<p>使用时输入<code>pip2</code>即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip2 -V</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Ubuntu</tag>
        <tag>Pip</tag>
      </tags>
  </entry>
  <entry>
    <title>从源代码编译安装tmux</title>
    <url>/2019/10/11/install-tmux-from-source/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>为了使用新版tmux的特性，需要在Ubuntu 16.04上安装高版本的tmux，没有找到现成的ppa，因此搜到了一个从源代码安装的脚本，这里记录下来。</p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>tmux的源代码在GitHub上，地址是 <a href="https://github.com/tmux/tmux">https://github.com/tmux/tmux</a>，可以在Release页面下载源代码然后进行编译，已编译tmux 2.9为例，具体操作如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y libevent-dev libncurses-dev make automake</span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">wget https://github.com/tmux/tmux/archive/2.9.tar.gz</span><br><span class="line">tar xvzf 2.9.tar.gz</span><br><span class="line"><span class="built_in">cd</span> tmux-2.9/</span><br><span class="line">bash autogen.sh</span><br><span class="line">./configure &amp;&amp; make</span><br><span class="line">sudo make install</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">rm -rf ./tmux-2.9*</span><br></pre></td></tr></table></figure>

<p>Done，在命令行查看tmux版本，如果是2.9就说明okay了。**另外记得关掉所有的tmux session，重新打开后环境的修改才会生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux -V</span><br><span class="line">tmux 2.9</span><br></pre></td></tr></table></figure>

<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol>
<li><a href="https://gist.github.com/japrescott/aa15cb024fe38ea36849f5f62c3314a3">https://gist.github.com/japrescott/aa15cb024fe38ea36849f5f62c3314a3</a></li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode无法安装ios程序的一种情况记录</title>
    <url>/2022/04/06/ios-cannot-install/</url>
    <content><![CDATA[<p>在用Xcode调试ios代码的时候，发现代码可以正常编译，但是安装到手机的时候，提示”App installation failed: Could not write to the device”。在网上找了很多回答，都没能解决。后来发现原因是在要复制到ios的目录中添加了一个软链接，导致出错。删除软链接后，安装正常。这应该是一个比较少见的原因，记录一下。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>听孙雷博士论文答辩记录</title>
    <url>/2015/03/21/leisun-phd-note/</url>
    <content><![CDATA[<p>任务目标：自然场景图片中的文字提取</p>
<p>答辩人：孙雷</p>
<p>答辩时间：2015.3.21早上9：00</p>
<p>答辩老师：霍强，李厚强，俞能海，汪勇，刘老师，还有另外一位老师</p>
<p>下面听答辩的学生有董政，我，研一的联合培养的记录员师兄，还有一位从ubc回国到合工大任教的博士师兄。</p>
<span id="more"></span>

<p>&nbsp;</p>
<p>主要工作：</p>
<p><strong>1.提出CER：Color-enhanced ER(Extremal Region)</strong></p>
<p>优点：相比MSER，对低对比度的图像很鲁棒</p>
<p>相关背景：</p>
<p>候选文字区域提取：ER</p>
<p>MSER：最大平稳极值区域</p>
<p>CER：将MSER中的极值改为一个特定阈值，使得对低对比度图像更鲁棒</p>
<p>&nbsp;</p>
<p><strong>2.提出“分治”的方法来归类特征，使得训练速率大幅提升</strong></p>
<p>具体方法：</p>
<p>a.将图片按照字体大小和个数，分为Thin（比较瘦长的字符，如i，t，一般是一个字符），Square（比较方的字符，一般是一到两个字符），Long（水平方向上比较长，一般是多个字符）三大类</p>
<p>b.Square和Long下面根据训练时间长短又细分为几类</p>
<p>c.每个类之间可以互补，解决有些类训练样本不足的问题</p>
<p>d.训练时正样本使用“假数据”，即一部分不是从自然场景中获取的数据，而是使用标准图像来做正样本</p>
<p>&nbsp;</p>
<p>答辩老师argue的地方：</p>
<p>a.可以将图片的横纵坐标作为参数，进行机器学习，而不是使用分治的方法，将分类固定下来（即老师说的“Hard”），转Hard为Soft</p>
<p>b.或许可以使用CNN，达到更好的效果</p>
<p>(我的一点看法：其实“分治”这种方法对实际应用来说，是一个很好的解决方案，既缩短了时间，又不至于太麻烦；而几位答辩老师却认为这是在学术上不严谨或者说这种方法不是最佳方法，这也体现了学术和工程的分歧。)</p>
<p>&nbsp;</p>
<p><strong>3.使用浅层神经网络训练，得到了与深度神经网络类似的性能</strong></p>
<p>为什么不使用深度神经网络：</p>
<p>a.不平衡分类：有的类数据多，有的类数据少，而深度神经网络一般解决平衡分类的问题</p>
<p>b.歧义性：有的特征即可以认为是正样本，也可认为是负样本，如图片中的“I”，可以认为是字符“I”，也可能是砖块之间的缝隙</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a href="/uploads/2015/03/example_picture.jpg"><img src="/uploads/2015/03/example_picture.jpg" alt="example_picture"></a></p>
<p><strong>4.算法缺陷：</strong></p>
<p>a.对竖着的文字和环形文字暂时无法处理</p>
<p>b.只是改进的了MSER，没有从根本上解决ER的问题</p>
<p>c.对部分艺术字处理不好，还有些艺术字没有加入到训练样本中</p>
<p>&nbsp;</p>
<p><strong>5. 听不懂乱记的东西</strong></p>
<p>a.采用了组件树</p>
<p>&nbsp;</p>
<p>（end）</p>
<p>&nbsp;</p>
]]></content>
      <categories>
        <category>速记</category>
      </categories>
      <tags>
        <tag>速记</tag>
      </tags>
  </entry>
  <entry>
    <title>Keras Callback之RemoteMonitor</title>
    <url>/2018/03/18/keras-callbacks-remote-monitor/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Keras提供了一系列的回调函数，用来在训练网络的过程中，查看网络的内部信息，或者控制网络训练的过程。<code>BaseLogger</code>、<code>ProgbarLogger</code>用来在命令行输出Log信息（默认会调用）， <code>EarlyStopping</code>、<code>ReduceLROnPlateu</code>分别用来提前终止训练和自动调整学习率，改变网络训练过程；而今天要介绍的<code>RemoteMonitor</code>则用来<strong>实时</strong>输出网络训练过程中的结果变化情况，包括训练集准确率(<code>accu</code>)、训练集损失值(<code>loss</code>)、验证集准确率(<code>val_acc</code>)、验证集损失值(<code>val_loss</code>)，用户也可以自己修改需要显示的数据。一图胜千言，看看下面的结果图吧：<br><img src="/imgs/keras_viz.png"></p>
<p>这个图是在浏览器中打开得到，Keras使用了Flask搭建了一个简单的服务器，然后采用D3.js来可视化数据。下面详细介绍可视化的过程吧</p>
<span id="more"></span>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><ol>
<li>首先，你得安装Keras: <code>sudo pip install keras</code>或者没有管理员权限的话，执行：<code>pip install --user keras</code>，下同</li>
<li>安装Flask网络框架： <code>sudo pip install Flask</code></li>
<li>安装gevent,gevent是一个并发框架，可以监听网络训练，并将结果传回网络服务，安装命令：<code>sudo pip install gevent</code></li>
</ol>
<h3 id="下载-Hualos"><a href="#下载-Hualos" class="headerlink" title="下载 Hualos"></a>下载 Hualos</h3><p>这是Keras作者写的Keras可视化的项目，其中包括了D3.js这些数据可视化库，也有一个简单的Flask app，即api.py文件，来运行我们的网络参数可视化。具体安装过程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/fchollet/hualos.git</span><br><span class="line"><span class="built_in">cd</span> hualos</span><br><span class="line">python api.py</span><br></pre></td></tr></table></figure>
<p>这样网络服务器就建立了，该服务会监听<code>http://localhost:9000</code>端口，你打开浏览器访问该网址，会看到一个初始的页面，我们接下来要做的是在训练网络的时候增加回调函数RemoteMonitor，将网络参数显示到该网址的页面上。</p>
<h3 id="在Keras训练网络中加入RemoteMonitor回调函数"><a href="#在Keras训练网络中加入RemoteMonitor回调函数" class="headerlink" title="在Keras训练网络中加入RemoteMonitor回调函数"></a>在Keras训练网络中加入RemoteMonitor回调函数</h3><p>这一步只需要在keras的代码里面增加3行即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 1. import RemoteMonitor</span></span><br><span class="line"><span class="keyword">from</span> keras.callbacks <span class="keyword">import</span> RemoteMonitor</span><br><span class="line"></span><br><span class="line"><span class="comment">## 2. 创建RemoteMonitor对象</span></span><br><span class="line">remote = RemoteMonitor()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 3. 在model.fit中增加回调函数设置</span></span><br><span class="line">model.fit(</span><br><span class="line">	...,</span><br><span class="line">	...,</span><br><span class="line">	callbacks=[remote]</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<p>我修改了<a href="https://github.com/fchollet/keras/blob/master/examples/mnist_cnn.py">https://github.com/fchollet/keras/blob/master/examples/mnist_cnn.py</a>，增加了以上3行，整个文件如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="string">&#x27;&#x27;&#x27;Trains a simple convnet on the MNIST dataset.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Gets to 99.25% test accuracy after 12 epochs</span></span><br><span class="line"><span class="string">(there is still a lot of margin for parameter tuning).</span></span><br><span class="line"><span class="string">16 seconds per epoch on a GRID K520 GPU.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Flatten</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Conv2D, MaxPooling2D</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">from</span> keras.callbacks <span class="keyword">import</span> RemoteMonitor</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">num_classes = <span class="number">10</span></span><br><span class="line">epochs = <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># input image dimensions</span></span><br><span class="line">img_rows, img_cols = <span class="number">28</span>, <span class="number">28</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the data, shuffled and split between train and test sets</span></span><br><span class="line">(x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> K.image_data_format() == <span class="string">&#x27;channels_first&#x27;</span>:</span><br><span class="line">    x_train = x_train.reshape(x_train.shape[<span class="number">0</span>], <span class="number">1</span>, img_rows, img_cols)</span><br><span class="line">    x_test = x_test.reshape(x_test.shape[<span class="number">0</span>], <span class="number">1</span>, img_rows, img_cols)</span><br><span class="line">    input_shape = (<span class="number">1</span>, img_rows, img_cols)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    x_train = x_train.reshape(x_train.shape[<span class="number">0</span>], img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line">    x_test = x_test.reshape(x_test.shape[<span class="number">0</span>], img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line">    input_shape = (img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">x_train = x_train.astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">x_test = x_test.astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">x_train /= <span class="number">255</span></span><br><span class="line">x_test /= <span class="number">255</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x_train shape:&#x27;</span>, x_train.shape)</span><br><span class="line"><span class="built_in">print</span>(x_train.shape[<span class="number">0</span>], <span class="string">&#x27;train samples&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x_test.shape[<span class="number">0</span>], <span class="string">&#x27;test samples&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># convert class vectors to binary class matrices</span></span><br><span class="line">y_train = keras.utils.to_categorical(y_train, num_classes)</span><br><span class="line">y_test = keras.utils.to_categorical(y_test, num_classes)</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Conv2D(<span class="number">32</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">                 activation=<span class="string">&#x27;relu&#x27;</span>,</span><br><span class="line">                 input_shape=input_shape))</span><br><span class="line">model.add(Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(Dropout(<span class="number">0.25</span>))</span><br><span class="line">model.add(Flatten())</span><br><span class="line">model.add(Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.5</span>))</span><br><span class="line">model.add(Dense(num_classes, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(loss=keras.losses.categorical_crossentropy,</span><br><span class="line">              optimizer=keras.optimizers.Adadelta(),</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">remote = RemoteMonitor()</span><br><span class="line">model.fit(x_train, y_train,</span><br><span class="line">          batch_size=batch_size,</span><br><span class="line">          epochs=epochs,</span><br><span class="line">          verbose=<span class="number">1</span>,</span><br><span class="line">          validation_data=(x_test, y_test),</span><br><span class="line">          callbacks=[remote]</span><br><span class="line">        )</span><br><span class="line">score = model.evaluate(x_test, y_test, verbose=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test loss:&#x27;</span>, score[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test accuracy:&#x27;</span>, score[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>注意15、64和70行是我新加的。<br>修改完文件后，在命令行运行该文件，在浏览器打开<code>http://localhost:9000</code>网址，就可以看到你训练时的参数了。注意结果是每个epoch输出一次。</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
        <tag>Deep Learning</tag>
        <tag>Keras</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器增加硬盘操作记录</title>
    <url>/2017/02/24/linux-add-disk/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>最近我们实验室的GPU服务器数据空间不够用了，老师让我联系公司来增加硬盘。我这里记录一下对Amax公司生产的GPU服务器增加硬盘的步骤。</p>
<span id="more"></span>
<p>机器的参数：</p>
<ol>
<li>操作系统：Ubuntu 14.04</li>
<li>显卡： Nvidia  Tesla K80</li>
<li>机器厂商： Amax</li>
<li>是否有RAID: 有</li>
</ol>
<h3 id="配置RAID"><a href="#配置RAID" class="headerlink" title="配置RAID"></a>配置RAID</h3><p>RAID(Redundant Array of Independent Disks)，即独立硬盘冗余阵列，是一种管理较大空间硬盘阵列的方法，常见的RAID方式到RAID 0-RAID 6，简单的来讲可以这样理解：</p>
<ol>
<li>RAID 0: 数据不做备份操作，每块盘都可以存储数据</li>
<li>RAID 1: 将一半的磁盘作为镜像磁盘，空间利用率只有50%，但是允许有一半的磁盘坏掉（坏掉后备份盘可以继续使用）</li>
<li>RAID 5: 使用1块盘作为备份，别的盘可以正常存取数据<br>关于RAID 各种方式的细节，可以看<a href="https://www.zhihu.com/question/20131784">这里</a>。<br>因为我们想让数据盘尽可能被充分地利用，所以我们采用RAID 0。<br>将硬盘插入到插槽后，开机启动服务器，就可以进入RAID的设置。在设置页面中，选择“Configuration Wizard”开始设置。具体的设置内容可以参看<a href="https://siliconmechanics.zendesk.com/hc/en-us/articles/205066349-Creating-a-RAID-0-1-5-or-6-through-the-LSI-Web-BIOS">这篇博客</a>。  </li>
</ol>
<h3 id="对硬盘分区"><a href="#对硬盘分区" class="headerlink" title="对硬盘分区"></a>对硬盘分区</h3><p>设置好RAID后，重启进入系统，查看新加的硬盘。<br>通过<code>sudo fdisk -l</code>可以查看所有连接的系统的硬盘，而<code>df -h</code>则只显示挂载到系统的硬盘，所以查看前者中有而后者中不存在的硬盘，比如<code>/dev/sdf</code>，就是我们新加的硬盘。<br>找到新加的硬盘后，我们采用<code>sudo fdisk /dev/sdf</code>命令来对/dev/sdf硬盘创建分区表，输入该命令后，结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ ᐅ sudo fdisk /dev/sdf</span><br><span class="line">Device contains neither a valid DOS partition table， nor Sun， SGI or OSF disklabel</span><br><span class="line">Building a new DOS disklabel with disk identifier 0x083d94fb.</span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only， until you decide to write them.</span><br><span class="line">After that， of course， the previous content won<span class="string">&#x27;t be recoverable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The device presents a logical sector size that is smaller than</span></span><br><span class="line"><span class="string">the physical sector size. Aligning to a physical sector (or optimal</span></span><br><span class="line"><span class="string">I/O) size boundary is recommended， or performance may be impacted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">命令(输入 m 获取帮助)： </span></span><br></pre></td></tr></table></figure>
<p>根据提示，我们输入m，得到如下反馈：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">命令操作</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit bsd disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">   d   delete a partition</span><br><span class="line">   l   list known partition types</span><br><span class="line">   m   <span class="built_in">print</span> this menu</span><br><span class="line">   n   add a new partition</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   p   <span class="built_in">print</span> the partition table</span><br><span class="line">   q   quit without saving changes</span><br><span class="line">   s   create a new empty Sun disklabel</span><br><span class="line">   t   change a partition<span class="string">&#x27;s system id</span></span><br><span class="line"><span class="string">   u   change display/entry units</span></span><br><span class="line"><span class="string">   v   verify the partition table</span></span><br><span class="line"><span class="string">   w   write table to disk and exit</span></span><br><span class="line"><span class="string">   x   extra functionality (experts only)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">命令(输入 m 获取帮助)： </span></span><br></pre></td></tr></table></figure>
<p>可以看到列出了所有可能的选项。我们这里输入n，得到输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (0 primary， 0 extended， 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p):   </span><br></pre></td></tr></table></figure>
<p>因为我们在新加的硬盘上只创建一个分区，而且新加的盘用作数据盘，不会作为启动分区，所以选Primary 分区和extended分区都没关系。从这里开始，我们所有的操作都可以选择默认，即每次都是按<code>Enter</code>键到下一步。到所有设置到完成后，fdisk命令会创建分区，大概需要等1分钟。  </p>
<h3 id="格式化硬盘"><a href="#格式化硬盘" class="headerlink" title="格式化硬盘"></a>格式化硬盘</h3><p>创建好分区表后，需要格式化硬盘，将Linux的文件系统应用到硬盘上，硬盘才能存储数据。格式化硬盘采用的是<code>mkfs</code>命令。<br>目前Linux常用的文件格式是ext3和ext4，其中ext4是ext3的后续版本，对后者进行了一些改进，例如最大文件变成16TB、最大子目录数高达64000个等。具体的改进请参考<a href="https://en.wikipedia.org/wiki/Ext4">这里</a>。使用mkfs命令时，可以使用-t 选项制定文件格式。不指定默认的文件格式是ext2。<br>所以我们这里的命令是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkfs -t ext4 /dev/sdf</span><br></pre></td></tr></table></figure>
<p>对于弹出的问题，选择<code>y</code>即可，可以看到会写入inode数等操作，进行格式化。  </p>
<h3 id="挂载硬盘"><a href="#挂载硬盘" class="headerlink" title="挂载硬盘"></a>挂载硬盘</h3><p>硬盘格式化后，只要挂载到系统就可以正常使用了。接下来的操作就跟插硬盘或U盘到服务器上时的操作一样，先创建一个目录，然后将硬盘挂载到该目录，然后就可以在挂载后的目录里面写入或读出文件了，所有操作都在会在硬盘上进行。具体命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir /data5</span><br><span class="line">sudo mount /dev/sdf /data5</span><br><span class="line">sudo chmod -R 777 /data5</span><br></pre></td></tr></table></figure>
<p>注意最后一步需要修改文件夹的权限，否则服务器上的其他用户没有读写的权限。  </p>
<h3 id="将挂载信息写入到fstab"><a href="#将挂载信息写入到fstab" class="headerlink" title="将挂载信息写入到fstab"></a>将挂载信息写入到fstab</h3><p>如果只执行了挂载操作而不将硬盘的挂载操作写入到<code>/etc/fstab</code>中，则下次重启的时候，需要手动挂载，而用户对于/data5目录是无法进行读写操作的。所以接下来我们需要将挂载操作命令写入到<code>/etc/fstab</code>文件中。<br>fstab命令的写法有两种，一种是采用UUID，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">UUID=8aeec127-62bd-4e7a-2020-5a5024f27a22 /data1 ext4 defaults 0 0</span><br></pre></td></tr></table></figure>
<p>这种格式，其中硬盘对应的UUID号可以通过命令<code>sudo file -sL /dev/sdf</code>得到。关于fstab命令后面参数的含义，请参见我的<a href="http://goingthink.wang/2014/12/14/fstab-automount-windows-partitions/">另一篇博客</a>。<br>另外一种格式就是用<code>/dev/sdf</code>来代替UUID，即一条记录如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/sdf /data5 ext4  defaults 0 0</span><br></pre></td></tr></table></figure>
<p>添加该记录到<code>/etc/fstab</code>文件后，下次重启，硬盘也会自动挂载。<br>至此，我们的任务就算大功告成了，希望对你有所帮助。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>GPU</tag>
        <tag>Amax</tag>
        <tag>RAID</tag>
        <tag>ext4</tag>
      </tags>
  </entry>
  <entry>
    <title>kinematics和dynamics含义辨析</title>
    <url>/2022/04/13/kinematics-vs-dynamics/</url>
    <content><![CDATA[<blockquote>
<p>Kinematics is the study of how things move, while dynamics is the study of forces and motion. Kinematics is the study of motion. It is concerned with what happens to a body when it is at rest and in uniform motion. Dynamics is the study of forces and their effect on moving bodies.</p>
</blockquote>
]]></content>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的包名&quot;xxx&quot;和&quot;xxx-dev&quot;有什么区别?</title>
    <url>/2022/07/23/linux-package-vs-package-dev/</url>
    <content><![CDATA[<h2 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h2><p>在安装包的时候，有时候需要安装<code>xxx</code>的包，有时候又需要安装<code>xxx-dev</code>的包 (在CentOS系列发行版上则是<code>xxx-devel</code>)。这两类包之间又什么区别呢？</p>
<span id="more"></span>

<h2 id="2-结论"><a href="#2-结论" class="headerlink" title="2. 结论"></a>2. 结论</h2><p>不包含<code>-dev</code>的包里面包含的是运行所需要的二进制文件或者连接库文件（如<code>xxx.so</code>），而包含<code>-dev</code>的包则包含包的源码文件（如<code>.h</code>文件），为的是在编译使用了这些库的程序的时候，能找到对应的头文件，否则只有二进制文件或者<code>.so</code>文件，编译时会报代码找不到头文件的错误。</p>
<p>下面举个例子进行说明。</p>
<p>我们只使用Python的话，用<code>sudo apt install python</code>即可，安装后就可以正常使用Python。</p>
<p>如果想要编译一个叫<a href="https://github.com/lxml/lxml">lxml</a>的库，它依赖Python的源码，例如<a href="https://github.com/lxml/lxml/blob/06631bb0677250cb632638a2c89f4d336360965b/src/lxml/includes/etree_defs.h#L5">这里</a>的代码依赖<code>Python.h</code>这个文件，因此我们需要安装<code>python-dev</code>包，把<code>Python.h</code>安装到本地上，这样lxml包才能正常安装。</p>
<h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><ol>
<li><a href="https://stackoverflow.com/questions/2358801/what-are-devel-packages">https://stackoverflow.com/questions/2358801/what-are-devel-packages</a></li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>Debian</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 小技巧总结</title>
    <url>/2017/10/29/linux-skills/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这里列举了我常用的一些Linux命令行下的技巧，希望对大家有帮助。</p>
<span id="more"></span>

<h3 id="1-按行合并2个文件"><a href="#1-按行合并2个文件" class="headerlink" title="1. 按行合并2个文件"></a>1. 按行合并2个文件</h3><p>即第一个文件的第一行接第二个文件的第一行，然后是第一个文件的第二行和第二个文件的第二行，举例：<br>a.txt</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>b.txt</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<p>期望的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">a</span><br><span class="line">2</span><br><span class="line">b</span><br><span class="line">3</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">paste -d <span class="string">&#x27;\n&#x27;</span> a.txt b.txt &gt; c.txt</span><br></pre></td></tr></table></figure>


<h3 id="2-删除行尾多余的-r"><a href="#2-删除行尾多余的-r" class="headerlink" title="2. 删除行尾多余的\r"></a>2. 删除行尾多余的<code>\r</code></h3><p>一般在Windows平台创建的文件行尾有多余的<code>\r</code>，在Linux命令行操作的时候会报错。<br>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># method 1:</span></span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt; infile &gt; outfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># method 2:</span></span><br><span class="line">cat infile |sed <span class="string">&#x27;s/\r$//g&#x27;</span> &gt;&gt; outfile</span><br></pre></td></tr></table></figure>

<h3 id="3-批量创建目录"><a href="#3-批量创建目录" class="headerlink" title="3. 批量创建目录"></a>3. 批量创建目录</h3><p>例如我想创建dir1，dir2, … dir100的目录。<br>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir dir&#123;1..100&#125; <span class="comment"># 创建目录dir1, dir2, dir3, ... dir100</span></span><br><span class="line">mkdir &#123;1..100&#125; <span class="comment"># 创建目录1，2，3，... 100</span></span><br></pre></td></tr></table></figure>

<h3 id="4-删除特定目录的所有空文件或空目录"><a href="#4-删除特定目录的所有空文件或空目录" class="headerlink" title="4. 删除特定目录的所有空文件或空目录"></a>4. 删除特定目录的所有空文件或空目录</h3><p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除空目录</span></span><br><span class="line">find /path/to/target/dir -<span class="built_in">type</span> d -empty -<span class="built_in">exec</span> rmdir &#123;&#125; \;</span><br><span class="line"><span class="comment"># 删除空文件</span></span><br><span class="line">find /path/to/target/dir -<span class="built_in">type</span> f -empty -<span class="built_in">exec</span> rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h3 id="5-删除名字中包含特殊字符的文件或目录"><a href="#5-删除名字中包含特殊字符的文件或目录" class="headerlink" title="5. 删除名字中包含特殊字符的文件或目录"></a>5. 删除名字中包含特殊字符的文件或目录</h3><p>在rm后面加<code>--</code>，然后对文件名加双引号。<br>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -- <span class="string">&quot;--abc&quot;</span></span><br><span class="line">rm -- <span class="string">&quot;)abc&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-查找目录下所有文件中包含特定字符串的文件"><a href="#6-查找目录下所有文件中包含特定字符串的文件" class="headerlink" title="6. 查找目录下所有文件中包含特定字符串的文件"></a>6. 查找目录下所有文件中包含特定字符串的文件</h3><p>如要搜索当前目录中包含<code>include</code>的所有文件。<br>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -RIn <span class="string">&quot;include&quot;</span> * <span class="comment"># R：递归搜索，I:区分大小写，n:显示行号</span></span><br></pre></td></tr></table></figure>

<h3 id="7-ls命令只列出目录-文件"><a href="#7-ls命令只列出目录-文件" class="headerlink" title="7. ls命令只列出目录/文件"></a>7. ls命令只列出目录/文件</h3><p>命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只列出目录</span></span><br><span class="line">ls  -l /path/to/dir |grep <span class="string">&#x27;^d&#x27;</span> </span><br><span class="line"><span class="comment"># 只列出文件</span></span><br><span class="line">ls  -l /path/to/dir |grep <span class="string">&#x27;^-&#x27;</span> </span><br></pre></td></tr></table></figure>

<h3 id="8-统计目录下的文件和目录数"><a href="#8-统计目录下的文件和目录数" class="headerlink" title="8. 统计目录下的文件和目录数"></a>8. 统计目录下的文件和目录数</h3><p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls /pat/to/dir |wc -l</span><br></pre></td></tr></table></figure>
<h3 id="9-按数字顺序对文件每行排序"><a href="#9-按数字顺序对文件每行排序" class="headerlink" title="9. 按数字顺序对文件每行排序"></a>9. 按数字顺序对文件每行排序</h3><p>如文件a.txt如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td></tr></table></figure>
<p>期望得到的结果文件b.txt:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">10</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td></tr></table></figure>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sort -n a.txt &gt; b.txt</span><br></pre></td></tr></table></figure>

<h3 id="10-显示当前系统安装的lib文件的版本"><a href="#10-显示当前系统安装的lib文件的版本" class="headerlink" title="10. 显示当前系统安装的lib文件的版本"></a>10. 显示当前系统安装的lib文件的版本</h3><p>命令:  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ldconfig -v |grep libname</span><br></pre></td></tr></table></figure>

<h3 id="11-显示系统所有安装的软件包"><a href="#11-显示系统所有安装的软件包" class="headerlink" title="11. 显示系统所有安装的软件包"></a>11. 显示系统所有安装的软件包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt list --installed <span class="comment"># 不加--installed 选项则会列出源里面的所有包名</span></span><br></pre></td></tr></table></figure>

<h3 id="12-查看硬盘读写情况"><a href="#12-查看硬盘读写情况" class="headerlink" title="12. 查看硬盘读写情况"></a>12. 查看硬盘读写情况</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iostat </span><br></pre></td></tr></table></figure>

<h3 id="13-动态地查看某个命令的输出结果"><a href="#13-动态地查看某个命令的输出结果" class="headerlink" title="13. 动态地查看某个命令的输出结果"></a>13. 动态地查看某个命令的输出结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">watch -n 1 nvidia-smi <span class="comment"># -n 后面的参数表示刷新的秒数</span></span><br></pre></td></tr></table></figure>

<h3 id="14-删除某个文件中所有不包含某个字段的行"><a href="#14-删除某个文件中所有不包含某个字段的行" class="headerlink" title="14. 删除某个文件中所有不包含某个字段的行"></a>14. 删除某个文件中所有不包含某个字段的行</h3><p>如文件a.txt如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ustc-123</span><br><span class="line">ustc-222</span><br><span class="line">ustc-bcd</span><br><span class="line">fdu-222</span><br><span class="line">pku-222</span><br></pre></td></tr></table></figure>
<p>现在要删除不包含<code>ustc</code>的所有行，得到b.txt如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ustc-123</span><br><span class="line">ustc-222</span><br><span class="line">ustc-bcd</span><br></pre></td></tr></table></figure>
<p>命令：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;/ustc/!d&#x27;</span> a.txt &gt; b.txt</span><br></pre></td></tr></table></figure>

<h3 id="15-删除某个文件中包含特定字段的所有行"><a href="#15-删除某个文件中包含特定字段的所有行" class="headerlink" title="15. 删除某个文件中包含特定字段的所有行"></a>15. 删除某个文件中包含特定字段的所有行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;/ustc/d&#x27;</span> a.txt &gt; b.txt</span><br></pre></td></tr></table></figure>

<h3 id="16-查找局域网里面所有的联网机器的IP"><a href="#16-查找局域网里面所有的联网机器的IP" class="headerlink" title="16. 查找局域网里面所有的联网机器的IP"></a>16. 查找局域网里面所有的联网机器的IP</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -sP 192.168.110.0/24</span><br></pre></td></tr></table></figure>

<h3 id="17-不同机器间同步数据"><a href="#17-不同机器间同步数据" class="headerlink" title="17. 不同机器间同步数据"></a>17. 不同机器间同步数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -aPhv src  --exclude <span class="string">&quot;excluded_dir&quot;</span> user@host:~/dst</span><br></pre></td></tr></table></figure>
<p>rsync命令的详细用法可以参考<a href="http://roclinux.cn/?p=2643">这里</a></p>
<h3 id="18-通过ssh在远端执行命令"><a href="#18-通过ssh在远端执行命令" class="headerlink" title="18. 通过ssh在远端执行命令"></a>18. 通过ssh在远端执行命令</h3><p>例如我想在本地屏幕上显示在远程服务器上执行某条命令的结果。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh user@host <span class="built_in">command</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac上如何运行OpenGL:第一个例子</title>
    <url>/2021/11/20/mac-opengl-first-example/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>搜索发现，OpengGL在mac下其实运行还是比较容易的，这里做一个简单的总结。</p>
<span id="more"></span>

<h2 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h2><p>安装依赖项:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install glfw3 glew cmake</span><br></pre></td></tr></table></figure>

<h2 id="编写OpenGL代码"><a href="#编写OpenGL代码" class="headerlink" title="编写OpenGL代码"></a>编写OpenGL代码</h2><p>编写OpenGL代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> &lt;iostream&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="comment">/* Poll for and process events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="编写CMake-配置文件"><a href="#编写CMake-配置文件" class="headerlink" title="编写CMake 配置文件"></a>编写CMake 配置文件</h2><p>为了简单可复现，这里我们直接编写<code>CMakeLists.txt</code>, 内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(opengl_first_example)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(/usr/local/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(/usr/local/Cellar/glew/<span class="number">2.2</span>.<span class="number">0</span>_1/lib)</span><br><span class="line"><span class="keyword">link_directories</span>(/usr/local/Cellar/glfw/<span class="number">3.3</span>.<span class="number">4</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> GLEW GLFW)</span><br></pre></td></tr></table></figure>

<p><strong>需要修改其中第5行和第6行路径中的glew和glfw为你自己电脑安装的版本</strong></p>
<h2 id="编译执行代码"><a href="#编译执行代码" class="headerlink" title="编译执行代码"></a>编译执行代码</h2><p>编译代码，使用CMake的常规流程:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. </span><br><span class="line">make -j8 </span><br></pre></td></tr></table></figure>
<p>编译完成后运行生成的可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./opengl_first_example</span><br></pre></td></tr></table></figure>
<p>可以看到一个图窗弹出来，说明OpenGL调用成功了.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/153550789">https://zhuanlan.zhihu.com/p/153550789</a></li>
</ol>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>macOS</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 下 Unable to load OpenGL library 的解决办法</title>
    <url>/2021/11/04/mac-opengl-load-error/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在Mac上使用Pyrender时，出现了OpenGL无法加载的错误，具体复现情况如下:<br>打开Python的REPL, 输入下面的命令(前提是安装pyrender):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyrender</span><br></pre></td></tr></table></figure>
<p>报下面的错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">raise ImportError(<span class="string">&quot;Unable to load OpenGL library&quot;</span>, *err.args)</span><br><span class="line">ImportError: (<span class="string">&#x27;Unable to load OpenGL library&#x27;</span>, <span class="string">&quot;dlopen(OpenGL, 0x000A): tried: &#x27;OpenGL&#x27; (no such file), &#x27;/usr/local/lib/OpenGL&#x27; (no such file), &#x27;/usr/lib/OpenGL&#x27; (no such file), &#x27;/usr/local/lib/OpenGL&#x27; (no such file), &#x27;/usr/lib/OpenGL&#x27; (no such file)&quot;</span>, <span class="string">&#x27;OpenGL&#x27;</span>, None)</span><br></pre></td></tr></table></figure>
<p>这里记录一下解决的办法。</p>
<span id="more"></span>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>解决办法比较简单，首先找到<code>OpenGL</code>的安装目录:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> python3 -c <span class="string">&quot;import OpenGL; print(OpenGL.__path__)&quot;</span></span><br><span class="line"> <span class="comment"># 输出路径</span></span><br><span class="line">[<span class="string">&#x27;/usr/local/lib/python3.7/site-packages/OpenGL&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>有了包路径后，修改包目录下的<code>platform/ctypesloader.py</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /usr/<span class="built_in">local</span>/lib/python3.7/site-packages/OpenGL/platform/ctypesloader.py</span><br></pre></td></tr></table></figure>
<p>将第35行注释掉，添加新的一行代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原先的代码</span></span><br><span class="line"><span class="comment">#fullName = util.find_library( name )</span></span><br><span class="line"><span class="comment"># 新的代码</span></span><br><span class="line">fullName = <span class="string">&#x27;/System/Library/Frameworks/OpenGL.framework/OpenGL&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后就可以正常运行了。<br>注意：不用确认路径<code>/System/Library/Frameworks/OpenGL.framework/OpenGL</code>是否存在，只需原样修改代码即可.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://stackoverflow.com/questions/63475461/unable-to-import-opengl-gl-in-python-on-macos/64021312#64021312">https://stackoverflow.com/questions/63475461/unable-to-import-opengl-gl-in-python-on-macos/64021312#64021312</a></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>总结</tag>
        <tag>macOS</tag>
        <tag>OpenGL</tag>
        <tag>错误汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac OpenGL入门：显示颜色</title>
    <url>/2021/11/21/mac-opengl-red/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这里以显示一个红色的窗口为例，展示Mac下运行OpenGL代码的一些配置项。这里采用c++ 和cmake来编译代码的方式，比用xcode更直观。</p>
<span id="more"></span>

<h2 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install glfw3 glew cmake</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>C++源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(GLFWwindow* window)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> currentTime)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>()) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// mac增加的代码</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line"></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">600</span>, <span class="number">600</span>, <span class="string">&quot;Chapter 2 - program1&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">        <span class="built_in">display</span>(window, <span class="built_in">glfwGetTime</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="cmake文件"><a href="#cmake文件" class="headerlink" title="cmake文件"></a>cmake文件</h2><p>cmake 代码：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(show_box)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(/usr/local/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(/usr/local/Cellar/glew/<span class="number">2.2</span>.<span class="number">0</span>_1/lib)</span><br><span class="line"><span class="keyword">link_directories</span>(/usr/local/Cellar/glfw/<span class="number">3.3</span>.<span class="number">4</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> ch2.<span class="number">1</span>.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">GLEW</span><br><span class="line">GLFW</span><br><span class="line"><span class="string">&quot;-framework OpenGL&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make -j8</span><br><span class="line">./show_box</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Mac</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 命令行文本操作快捷键</title>
    <url>/2018/01/27/linux-cmdline-edit-shortcuts/</url>
    <content><![CDATA[<p>可能有些人不知道，Linux命令行也有一些方便文本操作的快捷键，如跳到行首的快捷键是<code>Ctrl-a</code>,，跳到行尾的快捷键是<code>Ctrl-e</code>,删除光标所在处的字符的快捷键是<code>Ctrl-d</code>。 虽然这些快捷键很多时候都可以被小键盘的左右移动键、Home和End键替代，但是对于比较长的命令的修改，快捷键的操作还是比较快的。因为我平时用Vim比较多，而Linux命令行绑定的是Emacs的快捷键方式，虽然可以通过在命令行执行<code>set -o vi</code>修改为Vim的快捷键方式，但是这样会影响常用的像<code>Ctrl-p</code>，<code>Ctrl-n</code>等操作，因此我还是打算将这些难记的<strong>文本操作快捷键</strong>总结下来，让自己多练习，以后能更熟练地使用。注意这里我只列了文本操作的快捷键，像别的历史命令查询<code>Ctrl-r</code>和清屏操作<code>Ctrl-l</code>等快捷操作，大家可以参考我写的<a href="https://vra.github.io/2017/10/29/linux-skills/">这篇博客</a>。</p>
<span id="more"></span>


<h3 id="指令说明："><a href="#指令说明：" class="headerlink" title="指令说明："></a>指令说明：</h3><ol>
<li>Alt-a: 表示 按住Alt键的同时按住小写的a，即同时按住Alt键、字母a键</li>
<li>Alt-A: 表示 按住Alt键的同时按住大写的A，即同时按住Alt键、SHIFT键和字母a键</li>
</ol>
<h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><ol>
<li>Ctrl-f: 光标向前移动一个字符，这里的前不是前面，而是表示敲字符时下一个字符的顺序，即向右移动一个字符</li>
<li>Ctrl-b: 光标向后移动一个字符，即向左移动一个字符</li>
<li>Alt-f: 光标向右移动一个单词，这里的单词表示用标点符号下划线等分开的数字和字母串，因此像<code>256_3484_2222</code>需要按3次<code>Alt-f</code>才能从开始到结尾</li>
<li>Alt-b: 光标向左移动一个单词，单词的定义同上一条</li>
<li>Ctlr-a: 光标移动到行首</li>
<li>Ctrl-e: 光标移动到行尾</li>
<li>Ctrl-x-x: 将光标移动到行首，再按一次则光标跳回当前位置</li>
</ol>
<h3 id="增加和删除"><a href="#增加和删除" class="headerlink" title="增加和删除"></a>增加和删除</h3><ol>
<li>Ctrl-d: 删除光标处的字符，即字符删除</li>
<li>Ctrl-h: 删除光标左边的字符，效果同退格键</li>
<li>Alt-d: 向右删除光标处字符所在单词，保留下一个单词分隔符。注意：如果光标所在位置为标点符号，则删除这个标点符号和跟在它后面的一个单词</li>
<li>Ctrl-w: 删除光标左边的单词，如果当前的光标在单词中间，则删除这个单词在光标左侧的部分</li>
<li>Ctrl-k: 删除光标后面的所有内容</li>
<li>Ctrl-u: 删除输入的所有字符</li>
<li>Ctrl-y: 粘贴之前一次Ctrl-k 或Ctrl-w 删除掉的内容</li>
<li>Atl-t: 交换光标所在单词和左边的单词</li>
<li>Ctrl-t: 交换光标处字符和左边的字符，然后光标移动到下一个字符</li>
<li>Alt-u: 将光标所在单词的右边部分全变为对应的大写字母，光标移动到当前单词后面的标点符号上</li>
<li>Alt-l: 将光标所在单词的右边部分全变为对应的小写字母，光标移动到当前单词后面的标点符号上</li>
<li>Alt-c: 将光标所在处字母变为大写，然后光标移动到当前单词后面的标点符号处</li>
<li>Ctrl-_: 取消之前的一个字符的操作，可以重复多次。<strong>注：这条比较特殊，我在cygwin中测试的时候，需要按Ctrl-SHIFT-_才可以。</strong></li>
</ol>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol>
<li><a href="https://gist.github.com/zhulianhua/befb8f61db8c72b4763d">Linux 命令行编辑快捷键.md</a></li>
<li><a href="https://www.howtogeek.com/howto/ubuntu/keyboard-shortcuts-for-bash-command-shell-for-ubuntu-debian-suse-redhat-linux-etc/">The Best Keyboard Shortcuts for Bash (aka the Linux and macOS Terminal)</a></li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记-总结</title>
    <url>/2015/12/12/machine-learning-summary/</url>
    <content><![CDATA[<p>机器学习笔记是我这学期在上”统计学习”这门课时学习到的内容的一个总结.因为过往很多学过的知识,现在大多都已经忘掉了,而统计机器学习的内容则很重要,我可不能再上过就忘掉,所以在复习的时候把这些内容都记录下来,以便以后查阅.</p>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li>学习：一个系统在完成一项任务T的时候,使用了数据E,使得在评判标准P下,性能获得了提升,这就是学习  </li>
<li>统计学习的对象是数据,关于统计学习的基本假设是：同类数据服从一定的统计规律性,即数据都是独立同分布的  </li>
<li>统计学习中的问题可以分为4大类,分别是 <ul>
<li>监督学习：解决<strong>预测</strong>问题, 根据预测变量是否连续,分为回归问题和分类问题</li>
<li>非监督学习：解决<strong>分析</strong>型问题, 分为聚类(.如图像分割).,密度估计和关联分析三类</li>
<li>半监督学习：问题中既有分析的部分,又有预测的部分,主要有主动学习(.先分析,出现问题时向人要数据(.如分类label).).</li>
<li>增强学习：在合适过程中,根据反馈做新的判断,主动增强自身的学习,典型应用：机器人足球</li>
</ul>
</li>
<li>统计学习的基本步骤</li>
<li>获取数据(.即E).</li>
<li>确定用什么样的数学模型,所有模型构成假设空间</li>
<li>有了一组模型后,确定策略,即如何来找到最优的模型</li>
<li>写出模型选择策略的算法</li>
<li>通过学习得到最优模型</li>
<li>用学习到的模型来在新的数据上进行分析和预测</li>
<li>学习的三大要素：模型,策略,算法.模型是知识的集合,策略是模型选择的准则,算法就是学习的具体方法</li>
</ol>
<h2 id="模型的种类"><a href="#模型的种类" class="headerlink" title="模型的种类"></a>模型的种类</h2><ol>
<li>线性模型(Linear model)：y=ax+b,算法实例：线性回归(Linear regression)</li>
<li>对数线性(Log-linear model)：算法实例：逻辑斯蒂回归(Logistic regression)</li>
<li>稀疏模型(Sparse model)：形式也是y=ax+b,但a很稀疏,算法实例：稀疏分解(Sparese decomposition)</li>
<li>非线性核方法(Non-linear by kernel),利用核技巧将非线性问题转化为线性问题,实例：支持向量机(SVM, support vector machine)</li>
<li>层级非线性(Layered nonlinear)：实例：神经网络(Neural Network)</li>
<li>图模型(Graphic model)：将数据看作随机变量的话,它们之间的依赖关系可用图来表示,实例：贝叶斯网络(Bayes network)</li>
<li>树模型(Tree model)：对输入变量进行分块处理,每个子块有可以使用别的机器学习算法,实例：决策树(Decision tree),提升数(Boosting tree)</li>
<li>混合模型(Mixture model)：实例：聚类(Clustering)<br>上述模型中,1-5为非概率模型,6,8为概率模型,7为混合类型,概率模型和非概率模型可能都有.</li>
</ol>
<h2 id="学习的策略"><a href="#学习的策略" class="headerlink" title="学习的策略"></a>学习的策略</h2><p>策略是模型选择的准则,为了量化模型的好坏,我们定义了损失函数和风险函数<br>损失函数(Loss function)：也叫代价函数(Cost function),用来度量模型对于<strong>一个</strong>输入<code>X</code>产生的预测值<code>f(x)</code>与真实值<code>Y</code>之间的差异的大小.常见的损失函数有:</p>
<ol>
<li>0-1 损失函数(0-1 loss function)<br><img src="/imgs/01loss.png"></li>
<li>平方损失函数(Square loss function)<br><img src="/imgs/pingfang.png"></li>
<li>绝对值损失函数(Absolute loss function)<br><img src="/imgs/jueduizhi.png"></li>
<li>对数损失函数(Log loss function)<br><img src="/imgs/duishu.png"><br>风险函数是损失函数的期望,即将模型的输入输出<code>XY</code>作为随机变量,风险函数就是模型<code>f(X)</code>关于联合分布<code>P(X,Y)</code>的平均意义下的损失.风险函数的值越小,表示模型预测结果越准确,这种模型就越好,所以机器学习的目的就是最小化风险函数(Rish miniization).需要注意的是：<code>P(X,Y)</code>是未知的<br>如果给定数据集,我们可以计算在该数据集上的平均损失,这个损失定义为经验风险.经验风险在数据量足够大的时候,能很好的近似期望风险,但在数据量较少的时候误差会比较大.<br>在经验风险的基础上,加上表示模型复杂度的正则化项,则构成结构风险.结构风险能有效的防止过拟合,因为结构风险要求经验风险和模型复杂度同时都小.  </li>
</ol>
<h2 id="经典机器学习算法"><a href="#经典机器学习算法" class="headerlink" title="经典机器学习算法"></a>经典机器学习算法</h2><p>分类算法：</p>
<ol>
<li>K近邻(KNN, K Nearest Neighbor)</li>
<li>朴素贝叶斯(Naive Bayes)</li>
<li>支持向量机(SVM, Support Vector Machine)</li>
<li>AdaBoost </li>
</ol>
<p>聚类算法：</p>
<ol>
<li>K-Means </li>
<li>期望最大化(EM, Expectation Maximization)</li>
</ol>
<p>回归算法：</p>
<ol>
<li>脊回归(Ridge regression)</li>
<li>Lasso回归(The Least Absolute Shrinkage and Selectionator Operator)</li>
</ol>
<p>关联分析算法：</p>
<ol>
<li>先验算法(Aprior)</li>
</ol>
<p>降维算法：</p>
<ol>
<li>主成份分析法(PCA, Principal Component Analysis)</li>
<li>局部线性嵌入(Locally linear embedding)</li>
</ol>
<h2 id="欠拟合-under-fitting-和过拟合-over-ftting"><a href="#欠拟合-under-fitting-和过拟合-over-ftting" class="headerlink" title="欠拟合(under-fitting)和过拟合(over-ftting)"></a>欠拟合(under-fitting)和过拟合(over-ftting)</h2><p>在训练模型的时候,有的时候需要选择不同的复杂度(.如不同参数的个数).来训练,不同的复杂度体现了模型对训练数据的拟合程度.<br>如果参数过少,模型过于简单,则模型不能很好的拟合训练数据,这种情况称为欠拟合,很显然,欠拟合因为连训练数据的规律都没有学习到,所以对于预测,性能肯定不会太好.<br>另一方面,如果参数太多,模型过于复杂,则对训练数据可以做到特别好的拟合,但由于训练数据是有噪声和误差的,这种情况会将训练数据的噪声和误差都考虑进来,在测试集上性能反而会下降.下面是训练误差和测试误差与模型复杂度的关系<br><img src="/imgs/overfitting.gif"></p>
<h2 id="交叉验证-Cross-Validation"><a href="#交叉验证-Cross-Validation" class="headerlink" title="交叉验证(Cross Validation)"></a>交叉验证(Cross Validation)</h2><p>学习的最终目的是预测,即学习一个模型,使得对未知数据能很好地预测.在实际操作中,一般将数据集分为3部分：训练集,验证集和测试集.为了验证在训练集上学习到的模型好坏,需要现在验证集上进行验证.实际中数据总是不充足的,所以需要重复使用数据,采用交叉验证的方法.最常用的交叉验证方法是S折交叉验证方法.<br>S折交叉验证方法(S-fold cross validation)：随机地将数据切分为S个互不相交的子集,然后利用S-1个子集的数据训练模型,利用余下的1个子集作为测试集.测试集的选择有S中情况,所以这种验证可以进行S次.对每个模型,都进行S次训练和验证,然后求出平均测试误差,将平均测试误差最小的模型作为最优模型.<br>当数据量特别少的时候,我们将每个数据分为一个子集,即如果有N个数据,则S=N,这种方法称为留一交叉验证(Leave-one-out cross validation).</p>
<h2 id="判别模型-Discriminative-model-和生成模型-generative-model"><a href="#判别模型-Discriminative-model-和生成模型-generative-model" class="headerlink" title="判别模型(Discriminative model)和生成模型(generative model)"></a>判别模型(Discriminative model)和生成模型(generative model)</h2><p>生成式方法：对于某个给定的输入<code>X</code>,先学习得到联合分布<code>P(X,Y)</code>,再计算<code>P(Y|X)</code>,也即该方法考虑给定输入<code>X</code>,输出<code>Y</code>是怎么生成的,要求得到一个关于整体的信息,即对<code>P(X,Y)</code>进行建模.<br>生成式方法应用更广,适用于各种机器学习问题,而且收敛速度快,而且对于有隐变量的情况,也适用.但由于需要建模<code>XY</code>的联合分布,所以不能进行降维处理.<br>常见的生成式模型有朴素贝叶斯法和隐马尔科夫模型.<br>判别式方法：对于某个给定的输入<code>X</code>,直接给出预测值<code>f(X)</code>或<code>P(Y|X)</code>.该方法关注的是对于给定的输入<code>X</code>,应该预测什么样的输出<code>Y</code>,而不用去考虑数据整体的分布这些信息,即对<code>P(Y|X)</code>建模.<br>常见的判别模型有KNN,感知机,决策树,逻辑斯蒂回归,最大熵模型,SVM,AdaBoost,条件随机场等.<br>判别式方法只能用于分类和回归问题,可以对<code>X</code>进行降维处理.  </p>
]]></content>
      <tags>
        <tag>机器学习 总结</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown易错点总结</title>
    <url>/2016/03/29/markdown-note/</url>
    <content><![CDATA[<p>markdown 是一种标记语言，我这个博客就是用markdown格式写好后，由hexo框架将markdown格式转换为静态的HTML文件，再上传到网站服务器上。在使用markdown的时候，有的时候在使用有序列表的时候，总会出现一些与预期效果不符的情况。因此今天我查看了markdown的文档，发现有一些规则我之前没注意到，导致出错，所以写下来，避免再犯错了。  </p>
<span id="more"></span>
<ol>
<li><p>有序下标中，有多个段落，则下标以及每个段落的开头都必须缩进4个空格或1个制表符    1.    how are you today?</p>
<pre><code> I am fine.    2.    Good Morning!
 Good Morning!
</code></pre>
</li>
<li><p>下标中的表示代码段的3个撇号不用缩进</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>   不同下标间不用空行，否则也会出错</p>
</li>
<li><p>   表示代码结束的三个```后面不能加空格，否则后面的内容也会被当作代码段的。</p>
</li>
<li><p><strong>在GitHub网站上，有序列表的不同下标之间需要隔一个空行，否则渲染会出问题</strong><br>参考:<a href="http://wowubuntu.com/markdown/">http://wowubuntu.com/markdown/</a></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>总结</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlibt图像转OpenCV图像</title>
    <url>/2022/06/24/matplotlib-convert-opencv/</url>
    <content><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>有时候，我们需要使用Matplotlib库强大的绘图函数来在numpy.ndarray格式的图像上进行一些可视化，比如关键点绘制，投影点绘制。绘制完后，还需要把matplotlib的figure对象转换为numpy.ndarray 格式的对象，方便和原图进行比较。有时候为了可视化的美观，需要验证保证转换后的图像与原始图像大小一致。这里记录一下操作的流程，以及一些常遇到的问题。</p>
<span id="more"></span>

<h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h2><p>核心原理是利用matplotlib.pyplot的<code>imshow</code>函数来显示np.ndarray格式的图像，然后进行可视化绘制，再通过matplotlib.pyplot.figure.canvas的<code>tostring_rgb</code>函数来将图像转换为string，在用numpy的<code>fromstring</code>函数将string转换为np.ndarray，即为我们所求。</p>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 numpy.ndarray格式的图像</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;/path/to/my.jpg&#x27;</span>)</span><br><span class="line">h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建figure对象</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">plt.imshow(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加函数绘制代码</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制画布</span></span><br><span class="line">fig.canvas.draw()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换plt canvas为string，再导入numpy</span></span><br><span class="line">vis_img = np.fromstring(fig.canvas.tostring_rgb(), dtype=np.uint8)</span><br><span class="line"><span class="comment"># 设置numpy数组大小为图像大小</span></span><br><span class="line">vis_img.shape = (h, w, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">plt.close()</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;/path/to/vis_img.jpg&#x27;</span>, vis_img)</span><br></pre></td></tr></table></figure>

<h2 id="3-几个关键点"><a href="#3-几个关键点" class="headerlink" title="3. 几个关键点"></a>3. 几个关键点</h2><p>上述代码是简单的原理，但要达到保存的<code>vis_img</code>对象与<code>img</code>对象完全等大小，还需要设置figure对象的size，具体实现是通过<code>set_size_inches</code>函数，传入原始图像的宽和高除以dpi的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">fig.set_size_inches(w/fig.dpi, h/fig.dpi)</span><br></pre></td></tr></table></figure>
<p>注意是宽在前面，高在后面。</p>
<p>还有一个很关键的点是需要去除matplotlib设置的padding白边，否则在相同尺寸的情况下，包含白边显得里面的内容变小了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.gca().set_position((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>为了不显示横纵坐标轴，需要添加<code>plt.axis(&#39;off&#39;)</code>语句。</p>
<p>为了能在无GUI的环境（比如SSH连到的Linux 服务器）这个脚本也能正常工作，需要采用<code>Agg</code> 这个backend：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;Agg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>插句题外话，<code>Agg</code>这个backend原来是来自于<a href="http://agg.sourceforge.net/antigrain.com/">Anti-Grain Geometry</a> 2D渲染库，2002年开始开发，距今已有20年历史了，Respect。</p>
<p>此外由于matploltlib的<code>imshow</code>需要RGB格式的图像，而OpenCV图像格式为BGR，需要做转换。</p>
<h2 id="4-完整代码"><a href="#4-完整代码" class="headerlink" title="4. 完整代码"></a>4. 完整代码</h2><p>结合上一部分的几个关键点，最终的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;Agg&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;/path/to/my.jpg&#x27;</span>)</span><br><span class="line">img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line">h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">fig.set_size_inches(w/fig.dpi, h/fig.dpi)</span><br><span class="line"></span><br><span class="line">plt.imshow(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始 matplotlib的绘制</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关掉坐标轴的显示</span></span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加这一句，避免matplotlib的自动padding导致的空白</span></span><br><span class="line">plt.gca().set_position((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">fig.canvas.draw()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换plt canvas为string，再导入numpy</span></span><br><span class="line">vis_img = np.fromstring(fig.canvas.tostring_rgb(), dtype=np.uint8)</span><br><span class="line"><span class="comment"># 设置numpy数组大小为图像大小</span></span><br><span class="line">vis_img.shape = (h, w, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 将RGB格式转换为BGR格式</span></span><br><span class="line">vis_img = cv2.cvtColor(vis_img, cv2.COLOR_RGB2BGR)</span><br><span class="line"></span><br><span class="line">plt.close()</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;/path/to/vis_img.jpg&#x27;</span>, vis_img)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，直接执行这段代码虽然可以得到你想要的结果，但本身是没有意义的，最核心的matplotlib调用需要你自己填写。</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>OpenCV</tag>
        <tag>Matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>A Simple Introduction to Make</title>
    <url>/2016/04/10/make-introduction/</url>
    <content><![CDATA[<p>GNU Make is a tool which controls the generation of executables and other non-source files of a program from the program’s source files.<br>Make gets its knowledge of how to build your program from a file called the makefile, which lists each of the non-source files and how to compute it from other files. When you write a program, you should write a makefile for it, so that it is possible to use Make to build and install the program.<br>I will introduce some basic skills about using make.  </p>
<span id="more"></span>

<h2 id="Format-of-make"><a href="#Format-of-make" class="headerlink" title="Format of make"></a>Format of make</h2><p>The format of make rule is:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">target: prerequisite</span><br><span class="line">	<span class="built_in">command</span></span><br></pre></td></tr></table></figure>
<p><code>target</code> is the output or middle objects. <code>prerequisite</code> is the requiring files for target. When <code>prerequisite</code> files have update, then when you execute <code>make</code> command, the utility will generate target. the <code>command</code> indicates how to generate <code>target</code>. <code>command</code> can be any shell commands. But generally, <code>commmand</code> contains the compiling commands. A example of make command:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file: file.c file.h</span><br><span class="line">	gcc -o file file.c file.h</span><br></pre></td></tr></table></figure>
<p>There can be many targets in make file, but the first target will be executed when type <code>make</code>.<br>##Define variables<br>We can define variables and use it in Makefile. for example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OBJ = file.o</span><br><span class="line">file: $(OBJ)</span><br><span class="line">	gcc -o file $(OBJ)</span><br><span class="line">$(OBJ): file.c file.h</span><br><span class="line">	gcc -c file.c file.h</span><br></pre></td></tr></table></figure>
<p>In this example, we define <code>OBJ</code> as <code>file.o</code> and use it later to replace <code>file.o</code>.<br>It can be quite useful if there are many objects files in target or prerequisite.<br>Sometimes we can move object files or head files to other directories, at this time, we can define variables to reduce our typing. For example, you have <code>*.h</code> file in <code>lib</code> directory in current path, you can write like this:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LIB = lib</span><br><span class="line">file: file.c $(LIB)/file.h</span><br><span class="line">	gcc -o file file.c $(LIB)/file.h</span><br></pre></td></tr></table></figure>

<h2 id="Phony-target"><a href="#Phony-target" class="headerlink" title="Phony target"></a>Phony target</h2><p>Phony target is a kind of label in make. It’s similar to target, but it has no prerequisite for most time, and we can append it to <code>make</code> command to execute command defined in it. For example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">clean: </span><br><span class="line">	rm *.o file</span><br></pre></td></tr></table></figure>
<p>When we type <code>make clean</code> in command line, <code>rm *.o file</code> will be executed.<br>NOTE: in order to avoid phony target has the same name with file in directory, we add <code>.PHONY clean</code> to make sure that clean command must be executed.<br>Sometimes phony target can have prerequisite, and place it as the first target, then this phony target will be execute. This is very helpful when you want generate several executable files and you just want type a <code>make</code>. For example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">all: prog1 prog2 prog3  </span><br><span class="line">.PHONY: all  </span><br><span class="line">  </span><br><span class="line">prog1: prog1.o utils.o  </span><br><span class="line">	cc -o prog1 prog1.o utils.o  </span><br><span class="line">  </span><br><span class="line">prog2: prog2.o  </span><br><span class="line">	cc -o prog2 prog2.o  </span><br><span class="line">  </span><br><span class="line">prog3: prog3.o sort.o utils.o  </span><br><span class="line">	cc -o prog3 prog3.o sort.o utils.o </span><br></pre></td></tr></table></figure>

<h2 id="Automatic-variables"><a href="#Automatic-variables" class="headerlink" title="Automatic variables"></a>Automatic variables</h2><p>There are some default variables in each make rule. We can use it to simplify our work. There are some useful automatic variables:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$@</span>: The file name of the target of the rule</span><br><span class="line">$%: The target member name, when the target is an archive member</span><br><span class="line">$&lt;: The name of the first prerequisite</span><br><span class="line">$?: The names of all the prerequisites that are newer than the target, with spaces between them</span><br><span class="line">$^: The names of all the prerequisites, with spaces between them</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>For example, if we have a makefile like this:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAG=I.</span><br><span class="line">DEPS=hellomake.h</span><br><span class="line"></span><br><span class="line">%.o: %.c $(DEPS)</span><br><span class="line">	$(CC) -c -o <span class="variable">$@</span> $&lt; $(CFLAG)</span><br></pre></td></tr></table></figure>
<p>Where <code>$@</code> indicates the <code>.o</code> file and <code>@&lt;</code> indicates the corresponding <code>.c</code> file.</p>
<h2 id="Other-skills"><a href="#Other-skills" class="headerlink" title="Other skills"></a>Other skills</h2><ol>
<li>   comments begin with <code>#</code>, just like shell</li>
<li>   the comment begin with <code>@</code> will not be display, so we can echo like this:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> <span class="string">&#x27;Compiling begin...&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>   We can choose make file using <code>-f</code> options: <code>make -f myMakefile</code> will choose <code>myMakefile</code> as rule file.</li>
<li>   Adding <code>-n</code> in make will not do make really, just test if all things are okay.</li>
<li>   We can use <code>include</code> to add other makefiles into here, for example: <code>include Makefile1 Makefile2</code>.</li>
<li>   Add <code>-</code> in front of a command will ignore the errors occurring when execute it. </li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h2><ol>
<li>   <a href="https://www.gnu.org/software/make/manual/html_node/">https://www.gnu.org/software/make/manual/html_node/</a></li>
<li>   <a href="http://blog.csdn.net/haoel/article/details/2886">http://blog.csdn.net/haoel/article/details/2886</a></li>
<li>   <a href="http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/">http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/</a></li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Make</tag>
      </tags>
  </entry>
  <entry>
    <title>Move to NexT——博客迁移记录2019</title>
    <url>/2019/02/27/mv-to-next/</url>
    <content><![CDATA[<p>这个博客以前是采用Disqus作为评论系统，之前Disqus还是偶尔能访问，最近是怎么着都没法访问了。写东西很多时候还是希望能得到反馈，因此为了更愉快的博客交流，我调查了下常见的还活着的的评论系统，最后发现了Valine。配置后发现真的是简单又好用，有任何想说的小伙伴都可以轻轻松松留言了，给有创造力的工程师们点赞！而且由于Hexo的NexT主题默认支持Valine配置（而之前使用的Jacman并不支持），所以也将博客的主题改成NexT了。于是从蓝花花变成了白花花～</p>
<p>后面说下这个博客经历的几次迁移记录，从2013-2019。</p>
<span id="more"></span>
<h2 id="2013-2015年6月，科大博客上的Wordpress站点"><a href="#2013-2015年6月，科大博客上的Wordpress站点" class="headerlink" title="2013-2015年6月，科大博客上的Wordpress站点"></a>2013-2015年6月，科大博客上的Wordpress站点</h2><p>2013年，我大三的时候，偶然看到USTC LUG 社团建了一个<a href="https://lug.ustc.edu.cn/wiki/lug/services/blog?s%5B%5D=blog">科大博客</a>的网站，域名是<code>blog.ustc.edu.cn</code>，上面可以放在校师生的博客或者主页。于是我申请了一个账号，建了一个域名为<code>vra.blog.ustc.edu.cn</code>的Wordpress博客。由于社团已经配置好了Wordpress服务，也提供了几个默认的主题，而且Wordpress可视化的操作也比较容易，因此在不想学习的时候，就在上面写一些比较个人化的文字和技术记录。当自己写的博文在web上被加载出来的时候，内心还是很激动的。<br>渐渐地，也写了一些关于C++，Linux的内容，也有几个关系比较好的同学也在上面搭建了自己的博客，分享自己的技术和人文方面的东西，所以当时感觉这个科大博客会越做越好的。<br>然而后面由于维护成本较高，而LUG里面也没有像<a href="https://ring0.me/">boj</a>师兄那样一人顶十人的战斗力了，因此科大博客也发出通知，后面会关停科大博客。而也是在LUG的某次分享上，我听到了Hexo这个静态博客框架，因此在本科毕业后，我将科大博客上的内容迁移到GitHub Pages上，采用了Hexo框架，具体的说明可以见<a href="https://vra.github.io/2015/06/02/blog-transfer-record/">这篇博文</a>。<br>由科大博客从开始到兴盛到关闭，作为一个见证者，我觉得还是挺遗憾的。不过在学校办这种服务性的项目，确实是不容易的，一方面大家都有繁重的学业压力，还有能够获取的资源也是不够的。还是很感谢LUG的小伙伴无私的奉献，给我们创造了无数个激动的时刻。</p>
<h2 id="2015年6月-2019年2月，-Hexo-on-GitHub-Pages-with-Jacman-theme"><a href="#2015年6月-2019年2月，-Hexo-on-GitHub-Pages-with-Jacman-theme" class="headerlink" title="2015年6月-2019年2月， Hexo on GitHub Pages with Jacman theme"></a>2015年6月-2019年2月， Hexo on GitHub Pages with Jacman theme</h2><p>采用Hexo静态博客框架后，我也尝试过不同的Host地址，GitHub Pages，Gitcaffe的配置，也自己买过几个域名。后来发现还是用<code>vra.github.io</code>这个域名吧，稍微简短点，也比较通用。<br>一个比较麻烦的问题是，静态博客的评论系统一直没有比较好的解决方案，而评论系统的一再更改也是一部血泪史。<br>一开始使用Disqus，结果Disqus被block，访问不了了。<br>然后使用多说，使用没多久多说关停了。<br>后面使用gitment，但是时不时会有问题，每次需要重新登录GitHub账号。  </p>
<h2 id="2019年2月，-Hexo-on-GitHub-Pages-with-NexT-theme"><a href="#2019年2月，-Hexo-on-GitHub-Pages-with-NexT-theme" class="headerlink" title="2019年2月， Hexo on GitHub Pages with NexT theme"></a>2019年2月， Hexo on GitHub Pages with NexT theme</h2><p>由于没有完善的评论系统，因此博客很少能听到有效的反馈。因此从18年夏天开始，我也在<a href="https://www.zhihu.com/people/yunfeng-87/columns">知乎专栏</a>上分享自己的学习总结，希望能够帮助到更多的人。<br>最近搜了下发现Valine挺好用的，于是今天借这个机会重新配置了下，发现确实简单好用，工具越来越好用，生活真实越来越美好了，所以保持探索的心还是很重要的，说不定那天就能找到令人兴奋的作品呢^-^</p>
]]></content>
      <tags>
        <tag>总结</tag>
        <tag>迁移记录</tag>
      </tags>
  </entry>
  <entry>
    <title>利用国内开源镜像加速你的包安装</title>
    <url>/2018/04/18/mirrors-speedup/</url>
    <content><![CDATA[<p>由于许多包的存放服务器在国外，国内安装比较慢，因此本文总结了常见的包（例如Python包，Linux不同发行版的包）在国内的开源镜像，加速你的下载，提高安装体验。下面总结了PyPi，Anacoda，NPM， Docker，RubyGems和Linux的国内镜像，并且在GitHub上放置了本文提到的所有的包的配置文件，直接下载使用，具体使用说明访问<a href="https://github.com/vra/mirrors-china">这里</a>。</p>
<span id="more"></span>
<h2 id="PyPi-加速"><a href="#PyPi-加速" class="headerlink" title="PyPi 加速"></a>PyPi 加速</h2><p>临时加速可以用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -i https://path/to/pypi/mirror package</span><br></pre></td></tr></table></figure>
<p>永久使用的话，需要修改配置文件。对于系统级别的修改，增加下面的配置文件到<code>/etc/pip.conf</code>，如果只是自己使用，修改<code>~/.pip/pip.conf</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file path: /etc/pip.conf or ~/.pip/pip.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ustc, doc: https://lug.ustc.edu.cn/wiki/mirrors/help/pypi</span></span><br><span class="line">[global]</span><br><span class="line">    index-url = https://mirrors.ustc.edu.cn/pypi/web/simple</span><br><span class="line">    trusted-host=mirrors.ustc.edu.cn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># thu, doc: https://mirrors.tuna.tsinghua.edu.cn/help/pypi/</span></span><br><span class="line"><span class="comment">#[global]</span></span><br><span class="line"><span class="comment">#    index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"><span class="comment">#    trusted-host=pypi.tuna.tsinghua.edu.cn</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># aliyun, doc: http://www.atjiang.com/aliyun-pip-mirror/</span></span><br><span class="line"><span class="comment">#[global]    </span></span><br><span class="line"><span class="comment">#    index-url=http://mirrors.aliyun.com/pypi/simple</span></span><br><span class="line"><span class="comment">#    trusted-host=mirrors.aliyun.com</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 163, no doc.</span></span><br><span class="line"><span class="comment">#[global]</span></span><br><span class="line"><span class="comment">#    index-url=https://mirrors.163.com/pypi/simple</span></span><br><span class="line"><span class="comment">#    trusted-host=mirrors.163.com</span></span><br></pre></td></tr></table></figure>

<p>本文中默认用的中科大的源实际使用的时候，选择自己访问最快的<strong>一个</strong>镜像就可以了，将别的镜像设置注释掉或者删掉。</p>
<h2 id="Anaconda-包加速"><a href="#Anaconda-包加速" class="headerlink" title="Anaconda 包加速"></a>Anaconda 包加速</h2><p>Anaconda是一个Python的包管理系统，包含科学计算常用的包。通过在命令行执行下面的文件就可以使用中科大或者清华的Anaconda镜像了，注意只执行自己访问最快的镜像对应的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># run this script in terminal</span></span><br><span class="line"><span class="comment"># ustc, doc: https://mirrors.ustc.edu.cn/help/anaconda.html</span></span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># thu, doc: https://mirror.tuna.tsinghua.edu.cn/help/anaconda/</span></span><br><span class="line"><span class="comment">#conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span></span><br><span class="line"><span class="comment">#conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span></span><br><span class="line"><span class="comment">#conda config --set show_channel_urls yes</span></span><br></pre></td></tr></table></figure>

<h2 id="NPM-包加速"><a href="#NPM-包加速" class="headerlink" title="NPM 包加速"></a>NPM 包加速</h2><p>NPM 是NodeJs的包管理系统，NodeJs的包通过该命令来安装。临时使用镜像来安装某个包可以用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm --registry http://path/to/npm/mirror install package</span><br></pre></td></tr></table></figure>
<p>永久使用某个镜像需要修改<code>~/.npmrc</code>，加入下面的某一个镜像即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file path: ~/.npmrc</span></span><br><span class="line"><span class="comment"># ustc, doc: https://lug.ustc.edu.cn/wiki/mirrors/help/npm</span></span><br><span class="line">registry=http://npmreg.mirrors.ustc.edu.cn/</span><br><span class="line"></span><br><span class="line"><span class="comment"># taobao, doc: https://npm.taobao.org/</span></span><br><span class="line"><span class="comment">#registry=http://registry.npm.taobao.org/</span></span><br></pre></td></tr></table></figure>

<h2 id="Docker-镜像加速"><a href="#Docker-镜像加速" class="headerlink" title="Docker 镜像加速"></a>Docker 镜像加速</h2><p>修改<code>/etc/docker/daemon.json</code>，加入下面的内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ustc, doc: https://lug.ustc.edu.cn/wiki/mirrors/help/docker</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// docker-cn, doc: https://www.docker-cn.com/registry-mirror </span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="RubyGems-加速"><a href="#RubyGems-加速" class="headerlink" title="RubyGems 加速"></a>RubyGems 加速</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># run this script in terminal</span></span><br><span class="line"><span class="comment"># ustc, doc: https://mirrors.ustc.edu.cn/help/rubygems.html</span></span><br><span class="line">gem sources  <span class="comment">#列出默认源</span></span><br><span class="line">gem sources --remove https://rubygems.org/  <span class="comment">#移除默认源</span></span><br><span class="line">gem sources -a https://mirrors.ustc.edu.cn/rubygems/  <span class="comment">#添加科大源</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># thu, doc: https://mirror.tuna.tsinghua.edu.cn/help/rubygems/</span></span><br><span class="line"><span class="comment">#gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove #https://rubygems.org/</span></span><br><span class="line"><span class="comment">#gem sources -l</span></span><br></pre></td></tr></table></figure>

<h2 id="Linux-包加速"><a href="#Linux-包加速" class="headerlink" title="Linux 包加速"></a>Linux 包加速</h2><p>由于Linux发行版众多，配置各不相同，因此请参考下面的源下面的文档进行对应发行版的配置：</p>
<ol>
<li>中科大: <a href="http://mirrors.ustc.edu.cn/help">http://mirrors.ustc.edu.cn/help</a></li>
<li>清华：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP">https://mirrors.tuna.tsinghua.edu.cn/help/AOSP</a></li>
<li>aliyun: <a href="https://opsx.alibaba.com/mirror">https://opsx.alibaba.com/mirror</a></li>
<li>163: <a href="https://mirrors.163.com/">https://mirrors.163.com</a></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
        <tag>Docker</tag>
        <tag>Pip</tag>
        <tag>NPM</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用matlab画稍微美观点的图</title>
    <url>/2015/05/31/matlab-plot/</url>
    <content><![CDATA[<p>本科毕设论文写作过程中，老师指出我用matlab画的图太丑，需要好好改改。于是我这几天参考网上资料，对画图的一些细节进行了设置，得到的图确实比以前好了些。而且我matlab用的不多，很多东西这次用过，下次碰可能要过很长时间，许多之前记得的东西都忘了，所以写下来是很有必要的。另外我现在画的图也只是比之前稍微好点，所以就起了这样一个题目。</p>
<span id="more"></span>


<h2 id="1-设置plot"><a href="#1-设置plot" class="headerlink" title="1. 设置plot"></a>1. 设置plot</h2><p>参考内容：<a href="http://www.mathworks.com/help/matlab/ref/plot.html">http://www.mathworks.com/help/matlab/ref/plot.html</a></p>
<h3 id="设置曲线形式-LineSpec"><a href="#设置曲线形式-LineSpec" class="headerlink" title="设置曲线形式(LineSpec)"></a>设置曲线形式(LineSpec)</h3><p>曲线形式包括3个部分，分别是<code>Line Style</code>，<code>marker symbol</code>和<code>color</code>。</p>
<ol>
<li><p><code>Line style</code>表示曲线的类别，有4类：</p>
</li>
<li><p>-：实线(Solid line)，也是默认的格式</p>
</li>
<li><p>–:虚线(dashed line)，也就是——这种格式</p>
</li>
<li><p>::点线(dotted line),也就是将引号:横过来的格式</p>
</li>
<li><p>-.:点虚线(Dash-dot line),就是虚线和点交替出现,-.-.-.-.,不过点是在中间，跟虚线相平的。</p>
</li>
<li><p>marker symbol表示数据点的标记形式，有如下几类，直接复制过来了：</p>
</li>
<li><p>o Circle</p>
</li>
<li><ul>
<li>Plus sign</li>
</ul>
</li>
<li><ul>
<li>Asterisk</li>
</ul>
</li>
<li><p>. Point</p>
</li>
<li><p>x Cross</p>
</li>
<li><p>s Square</p>
</li>
<li><p>d Diamond</p>
</li>
<li><p>^ Upward-pointing triangle</p>
</li>
<li><p>v Downward-pointing triangle</p>
</li>
<li><p><code>&gt;</code> Right-pointing triangle</p>
</li>
<li><p>&lt; Left-pointing triangle</p>
</li>
<li><p>p Pentagram</p>
</li>
<li><p>h Hexagram</p>
</li>
<li><p>color表示颜色设置，matlab画图里面所有的颜色都是这几种：</p>
</li>
<li><p>y yellow</p>
</li>
<li><p>m magenta,品红</p>
</li>
<li><p>c cyan,青色</p>
</li>
<li><p>r red</p>
</li>
<li><p>g green</p>
</li>
<li><p>b blue</p>
</li>
<li><p>w white</p>
</li>
<li><p>k black</p>
</li>
</ol>
<p>需要主要的有2点：</p>
<ol>
<li>这三个选项可以省略任意一个或多个，当省略<code>line style</code>且设定了<code>marker symbol</code>时，这时候得到的只有数据点，没有曲线。</li>
<li>如果Y值是一个矩阵的时候，如果设定了<code>color</code>选项，怎对所有曲线，颜色都是设定的那种颜色；如果没设定<code>color</code>,则曲线颜色按上面所示颜色顺序依次往下选择。</li>
</ol>
<h3 id="设置曲线宽度-LineWidth"><a href="#设置曲线宽度-LineWidth" class="headerlink" title="设置曲线宽度:LineWidth"></a>设置曲线宽度:LineWidth</h3><p>曲线宽度设置好也是很重要的，默认的曲线太细，不美观，我们可以使用LineWidth来设置，其单位为点的大小,比如</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>表示线宽是两倍的点大小。</p>
<h3 id="设置标记大小-MarkerSize"><a href="#设置标记大小-MarkerSize" class="headerlink" title="设置标记大小:MarkerSize"></a>设置标记大小:MarkerSize</h3><p>标记大小表示前面设定的<code>marker symbol</code>的大小，单位为点的大小。</p>
<h3 id="设置标记边缘颜色-MarkerEdgeColor"><a href="#设置标记边缘颜色-MarkerEdgeColor" class="headerlink" title="设置标记边缘颜色:MarkerEdgeColor"></a>设置标记边缘颜色:MarkerEdgeColor</h3><p>标记边缘颜色就是标记周围一圈的颜色。</p>
<h3 id="标记填充颜色-MarkerFaceColor"><a href="#标记填充颜色-MarkerFaceColor" class="headerlink" title="标记填充颜色:MarkerFaceColor"></a>标记填充颜色:MarkerFaceColor</h3><p>标记填充颜色。</p>
<h2 id="2-设置网格Grid"><a href="#2-设置网格Grid" class="headerlink" title="2. 设置网格Grid"></a>2. 设置网格Grid</h2><p>参考内容：</p>
<ol>
<li><a href="http://www.mathworks.com/help/matlab/ref/gca.html">http://www.mathworks.com/help/matlab/ref/gca.html</a></li>
<li><a href="http://www.mathworks.com/help/matlab/ref/grid.html">http://www.mathworks.com/help/matlab/ref/grid.html</a></li>
<li><a href="http://www.mathworks.com/help/matlab/ref/axes-properties.html#prop_MinorGridLineStyle">http://www.mathworks.com/help/matlab/ref/axes-properties.html#prop_MinorGridLineStyle</a></li>
<li><a href="http://www.mathworks.com/help/matlab/ref/axes-properties.html#prop_GridAlpha">http://www.mathworks.com/help/matlab/ref/axes-properties.html#prop_GridAlpha</a></li>
</ol>
<h3 id="显示-隐藏网格"><a href="#显示-隐藏网格" class="headerlink" title="显示/隐藏网格"></a>显示/隐藏网格</h3><ol>
<li>grid on：显示网格</li>
<li>grid off：隐藏网格</li>
</ol>
<h3 id="得到当前坐标轴Axis"><a href="#得到当前坐标轴Axis" class="headerlink" title="得到当前坐标轴Axis"></a>得到当前坐标轴Axis</h3><p><code>ax = gca;</code>:得到当前坐标轴，其中<code>gca</code>意为get current axis，实际是一个函数，只不过后面没加括号而已。<br>得到坐标轴后，就可以对图像进行一系列的设置。</p>
<h3 id="设置网格线类型-GridLineStyle"><a href="#设置网格线类型-GridLineStyle" class="headerlink" title="设置网格线类型:GridLineStyle"></a>设置网格线类型:GridLineStyle</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">ax= gca;</span><br><span class="line">ax.GridLineStyle = <span class="string">&#x27;:&#x27;</span>; <span class="comment">%设置网格线为点线</span></span><br></pre></td></tr></table></figure>

<h3 id="设置网格线透明度：GridAlpha"><a href="#设置网格线透明度：GridAlpha" class="headerlink" title="设置网格线透明度：GridAlpha"></a>设置网格线透明度：GridAlpha</h3><p>默认透明度是0.15，可以使用GridAlpha来设置</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">ax = gca;</span><br><span class="line">ax.GridAlpha = <span class="number">0.5</span> <span class="comment">%设置透明度为0.5</span></span><br></pre></td></tr></table></figure>

<h2 id="3-设置坐标轴"><a href="#3-设置坐标轴" class="headerlink" title="3. 设置坐标轴"></a>3. 设置坐标轴</h2><h3 id="设置坐标轴范围"><a href="#设置坐标轴范围" class="headerlink" title="设置坐标轴范围"></a>设置坐标轴范围</h3><p>可以用<code>axis([xStart xEnd yStart yEnd])</code>这样一条命令来设置坐标轴的范围。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">axis([<span class="number">0.1</span> <span class="number">0.6</span> <span class="number">0.5</span> <span class="number">0.8</span>]);<span class="comment">%x轴从0.1到0.6，y轴从0.5到0.8</span></span><br></pre></td></tr></table></figure>

<h3 id="设置坐标轴跨度"><a href="#设置坐标轴跨度" class="headerlink" title="设置坐标轴跨度"></a>设置坐标轴跨度</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">set(gca, <span class="string">&#x27;xtick&#x27;</span>,[xStart:xStep:xEnd]):设置x轴步长，从xStart开始，从xEnd结束，步长是xStep。</span><br><span class="line">set(gca, <span class="string">&#x27;ytick&#x27;</span>,[yStart:yStep:yEnd]):同X轴。</span><br></pre></td></tr></table></figure>

<h2 id="4-设置图标题和图中文字"><a href="#4-设置图标题和图中文字" class="headerlink" title="4. 设置图标题和图中文字"></a>4. 设置图标题和图中文字</h2><p>参考内容：</p>
<p><a href="http://www.mathworks.com/help/matlab/ref/legend.html">http://www.mathworks.com/help/matlab/ref/legend.html</a></p>
<h3 id="设置图片标题：legend"><a href="#设置图片标题：legend" class="headerlink" title="设置图片标题：legend"></a>设置图片标题：legend</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;figure1&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="设置x-y轴坐标：x-ylabel"><a href="#设置x-y轴坐标：x-ylabel" class="headerlink" title="设置x/y轴坐标：x/ylabel"></a>设置x/y轴坐标：x/ylabel</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">xlabel(<span class="string">&#x27;\alpha&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;soccer&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="设置图中文字：text"><a href="#设置图中文字：text" class="headerlink" title="设置图中文字：text"></a>设置图中文字：text</h3><p>使用方法：text(xPos, yPos,’str’)</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="number">10</span></span><br><span class="line">	text(x(<span class="built_in">i</span>)+<span class="number">0.1</span>, y(<span class="built_in">i</span>)+<span class="number">0.3</span>, num2str(y(<span class="built_in">i</span>))); <span class="comment">%num2str：将数字转换为字符</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示在(x+0.1, y+0.3)处显示y的值</p>
]]></content>
      <tags>
        <tag>学习总结</tag>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib的backend浅析</title>
    <url>/2017/06/13/mpl-backend/</url>
    <content><![CDATA[<p>在服务器使用<code>matplotlib</code>的时候，可能是因为没有装图形化和显示相关的包的原因，总是会出现<code>backend</code>相关的错误。所以我调查了下matplotlib中的backend的含义，以及如何处理相关的错误。<br><img src="http://matplotlib.org/1.3.0/_static/logo2.png" alt="matplotlib"></p>
<span id="more"></span>


<h3 id="matplotlib中的backend"><a href="#matplotlib中的backend" class="headerlink" title="matplotlib中的backend"></a>matplotlib中的backend</h3><p>matplotlib中，frontend就是我们写的python代码，而backend就是负责显示我们代码所写图形的底层代码。因为不同使用环境下硬件情况不同，所以后端是跟具体的硬件和显示条件相关的。</p>
<h3 id="backend的类别"><a href="#backend的类别" class="headerlink" title="backend的类别"></a>backend的类别</h3><p>backend又分为两类，一类是<code>interface backend</code>，又叫做<code>interactive backend</code>，这一类是表示跟显示到屏幕相关的后端；另一类是<code>hardcopy backend</code>，又叫做<code>non-interactive backend</code>，这一类是写入到文件相关的后端。下面两图分别是non-interactive backend和interactive backend的具体值：<br><img src="/imgs/non-iteractive-backend.png" alt="non-interactive backend"></p>
<p><img src="/imgs/iteractive-backend.png" alt="interactive backend"><br>在python中，可以通过如下的命令来获取当前机器支持的这两种后端：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.rcsetup.interactive_bk <span class="comment"># 获取 interactive backend</span></span><br><span class="line">matplotlib.rcsetup.non_interactive_bk <span class="comment"># 获取 non-interactive backend</span></span><br><span class="line">matplotlib.rcsetup.all_backends <span class="comment"># 获取 所有 backend</span></span><br></pre></td></tr></table></figure>
<p>在我们实验室的GPU服务器上，得到的结果如下：</p>
<script type="text/javascript" src="https://asciinema.org/a/avw1ng2fbxp5fdk8b2cncpbp0.js" id="asciicast-avw1ng2fbxp5fdk8b2cncpbp0" async></script>


<h3 id="设置backend"><a href="#设置backend" class="headerlink" title="设置backend"></a>设置backend</h3><p>有4种方式可以来设置matplotlib的backend，而且下列越后面的设置方式，优先级越高，也就是后面的设置会覆盖前面的设置。  </p>
<h4 id="1-通过设置matplotlibrc的配置文件来设置"><a href="#1-通过设置matplotlibrc的配置文件来设置" class="headerlink" title="1. 通过设置matplotlibrc的配置文件来设置"></a>1. 通过设置<code>matplotlibrc</code>的配置文件来设置</h4><p>注意<code>matplotlibrc</code>文件不一定在你的家目录下，可以通过如下命令来获取其存放位置:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.get_configdir()</span><br><span class="line"><span class="string">u&#x27;/home/yunfeng/.config/matplotlib&#x27;</span></span><br></pre></td></tr></table></figure>
<p>得到配置文件路径后，打开这个文件，写入如下一行来设置backend:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">backend : WXAgg   <span class="comment"># use wxpython with antigrain (agg) rendering</span></span><br></pre></td></tr></table></figure>
<p>其中<code>WXAgg</code>可以换成任意的你的系统支持的backend类型。<br><strong>注意：在backend的名字中是不区分大小写的，所以<code>Qt4Agg</code>和<code>qt4agg</code>是等价的。</strong></p>
<h4 id="2-通过MPLBACKEND环境变量来设置backend"><a href="#2-通过MPLBACKEND环境变量来设置backend" class="headerlink" title="2. 通过MPLBACKEND环境变量来设置backend"></a>2. 通过<code>MPLBACKEND</code>环境变量来设置backend</h4><p>下面两种方式都可以:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 方式1. 先export MPLBACKEND在执行python文件</span></span><br><span class="line">$ <span class="built_in">export</span> MPLBACKEN=<span class="string">&#x27;Agg&#x27;</span></span><br><span class="line">$ python works.py</span><br><span class="line"></span><br><span class="line"><span class="comment">## 方式2. 在python命令前加MPLBACKEND=&#x27;XXX&#x27;</span></span><br><span class="line">$ MPLBACKEND=<span class="string">&#x27;Agg&#x27;</span> python works.py</span><br></pre></td></tr></table></figure>

<h4 id="3-通过-d选项来设置"><a href="#3-通过-d选项来设置" class="headerlink" title="3. 通过-d选项来设置"></a>3. 通过<code>-d</code>选项来设置</h4><p>使用方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python script.py -dbackend</span><br></pre></td></tr></table></figure>
<p>因为这种方式很容易和脚本内部的参数解析冲突，所以不建议使用这种方式，而是通过<code>MPLBACKEND</code>参数的方式2来设置。</p>
<h4 id="4-通过matplotlib-use-函数来设置"><a href="#4-通过matplotlib-use-函数来设置" class="headerlink" title="4. 通过matplotlib.use()函数来设置"></a>4. 通过<code>matplotlib.use()</code>函数来设置</h4><p>使用方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.use(<span class="string">&#x27;Agg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>再次提醒下，注意这4种方式的优先级：4&gt;3&gt;2&gt;1，后面的设置会覆盖前面的设置。</strong></p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><h4 id="1-GPU集群执行import-matplotlib-pyplot-as-plt的错误"><a href="#1-GPU集群执行import-matplotlib-pyplot-as-plt的错误" class="headerlink" title="1. GPU集群执行import matplotlib.pyplot as plt的错误"></a>1. GPU集群执行<code>import matplotlib.pyplot as plt</code>的错误</h4><p>错误信息可能如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">** (test_net_multi.py:23890): WARNING **: Could not open X display</span><br><span class="line"></span><br><span class="line">(test_net_multi.py:23890): Gdk-CRITICAL **: gdk_cursor_new_for_display: assertion <span class="string">&#x27;GDK_IS_DISPLAY (display)&#x27;</span> failed</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;./tools/test_net_multi.py&quot;</span>, line 13, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from fast_rcnn.test_multi import test_net</span><br><span class="line">  File <span class="string">&quot;/data2/yunfeng/Lab/RstarCNN/tools/../lib/fast_rcnn/__init__.py&quot;</span>, line 9, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from . import train</span><br><span class="line">  File <span class="string">&quot;/data2/yunfeng/Lab/RstarCNN/tools/../lib/fast_rcnn/train.py&quot;</span>, line 15, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    import caffe</span><br><span class="line">  File <span class="string">&quot;/data2/yunfeng/Lab/RstarCNN/tools/../caffe-fast-rcnn/python/caffe/__init__.py&quot;</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from .pycaffe import Net, SGDSolver</span><br><span class="line">  File <span class="string">&quot;/data2/yunfeng/Lab/RstarCNN/tools/../caffe-fast-rcnn/python/caffe/pycaffe.py&quot;</span>, line 14, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    import caffe.io</span><br><span class="line">  File <span class="string">&quot;/data2/yunfeng/Lab/RstarCNN/tools/../caffe-fast-rcnn/python/caffe/io.py&quot;</span>, line 2, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    import skimage.io</span><br><span class="line">  File <span class="string">&quot;/usr/lib64/python2.7/site-packages/skimage/io/__init__.py&quot;</span>, line 15, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    reset_plugins()</span><br><span class="line">  File <span class="string">&quot;/usr/lib64/python2.7/site-packages/skimage/io/manage_plugins.py&quot;</span>, line 93, <span class="keyword">in</span> reset_plugins</span><br><span class="line">    _load_preferred_plugins()</span><br><span class="line">  File <span class="string">&quot;/usr/lib64/python2.7/site-packages/skimage/io/manage_plugins.py&quot;</span>, line 73, <span class="keyword">in</span> _load_preferred_plugins</span><br><span class="line">    _set_plugin(p_type, preferred_plugins[<span class="string">&#x27;all&#x27;</span>])</span><br><span class="line">  File <span class="string">&quot;/usr/lib64/python2.7/site-packages/skimage/io/manage_plugins.py&quot;</span>, line 85, <span class="keyword">in</span> _set_plugin</span><br><span class="line">    use_plugin(plugin, kind=plugin_type)</span><br><span class="line">  File <span class="string">&quot;/usr/lib64/python2.7/site-packages/skimage/io/manage_plugins.py&quot;</span>, line 255, <span class="keyword">in</span> use_plugin</span><br><span class="line">    _load(name)</span><br><span class="line">  File <span class="string">&quot;/usr/lib64/python2.7/site-packages/skimage/io/manage_plugins.py&quot;</span>, line 299, <span class="keyword">in</span> _load</span><br><span class="line">    fromlist=[modname])</span><br><span class="line">  File <span class="string">&quot;/usr/lib64/python2.7/site-packages/skimage/io/_plugins/matplotlib_plugin.py&quot;</span>, line 3, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    import matplotlib.pyplot as plt</span><br><span class="line">  File <span class="string">&quot;/usr/lib64/python2.7/site-packages/matplotlib/pyplot.py&quot;</span>, line 114, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    _backend_mod, new_figure_manager, draw_if_interactive, _show = pylab_setup()</span><br><span class="line">  File <span class="string">&quot;/usr/lib64/python2.7/site-packages/matplotlib/backends/__init__.py&quot;</span>, line 32, <span class="keyword">in</span> pylab_setup</span><br><span class="line">    globals(),locals(),[backend_name],0)</span><br><span class="line">  File <span class="string">&quot;/usr/lib64/python2.7/site-packages/matplotlib/backends/backend_gtk3agg.py&quot;</span>, line 11, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from . import backend_gtk3</span><br><span class="line">  File <span class="string">&quot;/usr/lib64/python2.7/site-packages/matplotlib/backends/backend_gtk3.py&quot;</span>, line 58, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    cursors.MOVE          : Gdk.Cursor.new(Gdk.CursorType.FLEUR),</span><br><span class="line">TypeError: constructor returned NULL</span><br></pre></td></tr></table></figure>
<p>这是因为服务器没有装显示相关的包，可以通过在上述第2种方式来设置<code>MPLBACKEN=&#39;Agg&#39;</code>即可解决这个问题，因为Agg是non-interactive backend，所以不会要求显示图片，所以也不会再报错了。举个例子，如果你的TorqueServer的配置文件如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#PBS    -N  v_test_60k</span></span><br><span class="line"><span class="comment">#PBS    -o  /home/yunfeng/logs/v_test_60k.out</span></span><br><span class="line"><span class="comment">#PBS    -e  /home/yunfeng/logs/v_test_60k.err</span></span><br><span class="line"><span class="comment">#PBS    -l nodes=1:gpus=2:D</span></span><br><span class="line"><span class="comment">#PBS    -r y</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$PBS_O_WORKDIR</span></span><br><span class="line"><span class="built_in">echo</span> Time is `date`</span><br><span class="line"><span class="built_in">echo</span> Directory is <span class="variable">$PWD</span></span><br><span class="line"><span class="built_in">echo</span> This job runs on following nodes:</span><br><span class="line">cat <span class="variable">$PBS_NODEFILE</span></span><br><span class="line"><span class="built_in">cd</span> /data10/yunfeng/Dev/tsn</span><br><span class="line">python v_test_60k.py 2&gt;&amp;1 |tee ~/logs/v_test_60k.log</span><br></pre></td></tr></table></figure>
<p>在python执行那行行首，增加<code>MPLBACKEND=Agg</code>，即改为如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#PBS    -N  v_test_60k</span></span><br><span class="line"><span class="comment">#PBS    -o  /home/yunfeng/logs/v_test_60k.out</span></span><br><span class="line"><span class="comment">#PBS    -e  /home/yunfeng/logs/v_test_60k.err</span></span><br><span class="line"><span class="comment">#PBS    -l nodes=1:gpus=2:D</span></span><br><span class="line"><span class="comment">#PBS    -r y</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$PBS_O_WORKDIR</span></span><br><span class="line"><span class="built_in">echo</span> Time is `date`</span><br><span class="line"><span class="built_in">echo</span> Directory is <span class="variable">$PWD</span></span><br><span class="line"><span class="built_in">echo</span> This job runs on following nodes:</span><br><span class="line">cat <span class="variable">$PBS_NODEFILE</span></span><br><span class="line"><span class="built_in">cd</span> /data10/yunfeng/Dev/tsn</span><br><span class="line">MPLBACKEND=Agg python v_test_60k.py 2&gt;&amp;1 |tee ~/logs/v_test_60k.log</span><br></pre></td></tr></table></figure>

<h4 id="2-GPU服务器上使用matplotlib显示图片"><a href="#2-GPU服务器上使用matplotlib显示图片" class="headerlink" title="2. GPU服务器上使用matplotlib显示图片"></a>2. GPU服务器上使用matplotlib显示图片</h4><p>由于服务器没有安装图形化显示界面，所以使用默认的matplotlib设置会有一些问题，图片没法正常显示。解决方法是在python文件中增加如下两行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.use(<span class="string">&#x27;Qt4Agg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在Jupyter notebook和VNC连过去后，这种设置都可以正确地显示图片。<br><strong>注意，这两行必须在<code>import matplotlib.pyplot as plt</code>之前插入，否则在plt引入后，上面的设置就没有效果了。</strong><br>至于为什么是<code>Qt4Agg</code>，我是一个个后端一一试出来的，应该跟服务器安装的显示包有关系，但是我暂时还没弄懂该如何查看。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://matplotlib.org/1.3.0/faq/usage_faq.html">http://matplotlib.org/1.3.0/faq/usage_faq.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>my-dot-file</title>
    <url>/2019/05/07/my-dot-file/</url>
    <content><![CDATA[<h2 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="修改SHELL为zsh"><a href="#修改SHELL为zsh" class="headerlink" title="修改SHELL为zsh"></a>修改SHELL为zsh</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo usermod -s /bin/zsh $(whoami)</span><br></pre></td></tr></table></figure>

<h2 id="安装fzf"><a href="#安装fzf" class="headerlink" title="安装fzf"></a>安装fzf</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/junegunn/fzf.git ~/.fzf</span><br><span class="line">~/.fzf/install</span><br></pre></td></tr></table></figure>

<h2 id="git-alias设置"><a href="#git-alias设置" class="headerlink" title="git alias设置"></a>git alias设置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.a add  </span><br><span class="line">git config --global alias.p push </span><br><span class="line">git config --global alias.pu pull</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.unstage <span class="string">&#x27;reset HEAD&#x27;</span></span><br><span class="line">git config --global alias.last <span class="string">&#x27;log -1&#x27;</span></span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>总计</tag>
      </tags>
  </entry>
  <entry>
    <title>NumPy的C++替代NumCpp使用教程</title>
    <url>/2020/12/26/numcpp-intro/</url>
    <content><![CDATA[<p>NumPy提供了很多开箱即用的函数，用处非常大，所以写C++的时候，让人无比怀念，要是有一个替代版本，就太好了。最近搜索发现， <a href="https://github.com/dpilger26/NumCpp">NumCpp</a> 这是我想要的，而且因为是 <code>Header-only</code>的库，因此使用时不需要编译，直接添加到头文件包含目录即可，使用很方便。不过NumCpp使用了boost库，需要进行一些下载和配置，这里记录一下。</p>
<span id="more"></span>
<p>总结下来下面是需要下载的东西，我写成了几行代码，在Ubuntu下测试是可以执行的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir includes</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/dpilger26/NumCpp.git </span><br><span class="line">mv NumCpp/include includes/NumCpp</span><br><span class="line">wget https://dl.bintray.com/boostorg/release/1.75.0/<span class="built_in">source</span>/boost_1_75_0.zip</span><br><span class="line">unzip boost_1_75_0.zip</span><br><span class="line">mv boost_1_75_0/boost includes/NumCpp</span><br></pre></td></tr></table></figure>
<p>这里我们创建了一个<code>includes</code>目录，用来存放NumCpp和Boost库的头文件，这里以现在 (2020-12-26) 最新的Boost 1.75.0 为例，后面boost库肯定会更新，可以从这里找到最新boost的下载地址：<a href="https://www.boost.org/users/download">https://www.boost.org/users/download</a>.</p>
<p>执行上面的命令后，就可以使用了NumCpp了，下面是一个使用示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：test_num_cpp.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;NumCpp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nc::NdArray&lt;<span class="keyword">float</span>&gt; a = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">        nc::NdArray&lt;<span class="keyword">float</span>&gt; b = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">        nc::NdArray&lt;<span class="keyword">float</span>&gt; c = a * b;</span><br><span class="line">        std::cout &lt;&lt; c[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子里面，简单地调用NumCpp最基本的类 <code>nc::NdArray</code>来进行两个2维数组的矩阵乘操作。<br>详细的教程参考：<a href="https://github.com/dpilger26/NumCpp">https://github.com/dpilger26/NumCpp</a>.<br>接下来就是编译C++代码，这里以Linux下g++编译为例说明，需要注意的有2个点:</p>
<ul>
<li>NumCpp只支持C++14以及以上版本，所以编译时需要加<code>--std=c++14</code></li>
<li>需要将NumCpp所在的目录添加到头文件包含指令<code>-I</code>里</li>
</ul>
<p>具体如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ test_num_cpp.cpp --std=c++14 -Iincludes/</span><br></pre></td></tr></table></figure>
<p>编译完后运行生成的可执行文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./a.out</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>NumPy</tag>
        <tag>NumCpp</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读：A Closer Look at Spatiotemporal Convolutions for Action Recognition</title>
    <url>/2018/03/23/note-closer-look-3d/</url>
    <content><![CDATA[<script type="text/javascript"
   src="https://cdn.staticfile.org/MathJax/MathJax-2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这篇论文是CVPR2018年的录取论文，主要讨论了时空卷积的几种网络结构，在Action Recognition 的几个标准数据集上也取得了媲美最好方法的效果。作者是FAIR的工作人员，其中包括Du Tran(C3D)作者，Heng Wang(iDT)作者和Yann LecCun等，可谓是大牛云集。论文可以在<a href="https://arxiv.org/abs/1711.11248">这里</a>下载。这里大概介绍下论文中的内容，可以看作是原论文的一个翻译。</p>
<span id="more"></span>
<h2 id="1-几种网络结构说明"><a href="#1-几种网络结构说明" class="headerlink" title="1. 几种网络结构说明"></a>1. 几种网络结构说明</h2><p><img src="/imgs/closer_fig1.png"><br>网络结构如图Figure 1所示，具体每种网络陈述如下。</p>
<h3 id="R2D-整个clip上的2D卷积网络"><a href="#R2D-整个clip上的2D卷积网络" class="headerlink" title="R2D: 整个clip上的2D卷积网络"></a>R2D: 整个clip上的2D卷积网络</h3><p>R代表ResNet， 即残差网络。 R2D将L帧，宽高分别为W，H的一个视频clip当成3LxWxH的3D tensor输入网络，得到的还是3D的tensor。虽然是3D tensor，实际的卷积是2D卷积，因此时间信息是全部丢失了的。</p>
<h3 id="f-R2D-帧层面的2D卷积网络"><a href="#f-R2D-帧层面的2D卷积网络" class="headerlink" title="f-R2D: 帧层面的2D卷积网络"></a>f-R2D: 帧层面的2D卷积网络</h3><p>跟R2D不同，f-R2D中没有将整个clip的L帧当作不同的channel，而是每个frame单独的作用卷积 （原文： The same filters are applied to all L frames）。这里我有些不太清楚具体实现的时候和R2D有什么区别，是指将不同的frame当作不同的样本输入网络吗？ 和R2D一样，这种方法也没有保留时间维度的信息</p>
<h3 id="R3D-3D的ResNet"><a href="#R3D-3D的ResNet" class="headerlink" title="R3D: 3D的ResNet"></a>R3D: 3D的ResNet</h3><p>这个就是标准的3D ResNet结构，即将输入看作N<sub>i</sub> * L * W * H 的4D tensor, 卷积核也是4D的。<br>时间维度是有卷积的，因此时序信息能够保留下来。</p>
<h3 id="MCx和rMCx-混合2D和3D卷积的结构"><a href="#MCx和rMCx-混合2D和3D卷积的结构" class="headerlink" title="MCx和rMCx: 混合2D和3D卷积的结构"></a>MC<sub>x</sub>和rMC<sub>x</sub>: 混合2D和3D卷积的结构</h3><p>有一种观点认为卷积网络较低层对motion的建模比较好，而高层由于特征已经很抽象了，motion和时序信息建模是不需要的，因此作者提出了MC<sub>x</sub>网络，即将第x以及后面的3D卷积group换为2D的卷积group，而R3D总共有5个卷积group（具体参数见Table 1），因此像MC4表示将group 4和group 5中的卷积和都换为2D卷积，而前面的group 1-3则保留为3D卷积。 注意此时MC1等效于f-R2D，即所有的层都是2D卷积。</p>
<p><img src="/imgs/closer_table1.png"></p>
<p>同时还有一种假设认为高层的信息需要用3D卷积来建模，而底层的信息通过2D卷积就可以获取，因此作者提出了rMC<sub>x</sub>结构，前面的<code>r</code>代表reverse，即反向的意思。rMC<sub>x</sub>表示前面的5-x层为2D卷积，后面的x层为3D卷积。</p>
<h3 id="R-2-1-D-拆分3D卷积为2D卷积-1D卷积"><a href="#R-2-1-D-拆分3D卷积为2D卷积-1D卷积" class="headerlink" title="R(2+1)D: 拆分3D卷积为2D卷积+1D卷积"></a>R(2+1)D: 拆分3D卷积为2D卷积+1D卷积</h3><p>这几年1D卷积的应用比较广，可以用来进行通道变换，拆分单个卷积核为多个卷积核等等。这里作者提出了R(2+1)D的结构，将3D卷积改为一个2D的空间卷积和一个1D的时间卷积。具体来说，作者将$N_i$个$N_{i-1}\times t\times d\times d$的3D卷积核改为$M_i$个大小为$N_{i-1}\times 1\times d\times d$的2D卷积和$N_i$个$M_i\times t\times 1\times 1$的卷积核。 $M_i$的值实验中取为$\lfloor \frac{td^2N_{i-1}N_i}{d^2N_{i-1}+tN_i}\rfloor$，这样取是为了让R(2+1)D的参数和R3D的参数保持一致，具体计算方式就是算出两种情况下的参数个数，求出$M_i$被别的参数表示的形式即可。  (2+1)D和3D的比较见Figure 2，其中以$N_{i-1} = 1$为例。如果3D卷积有stride，则stride也按时间空间拆分给对应的2D卷积和1D卷积。</p>
<p><img src="/imgs/closer_fig2.png" alt="Figure 2"></p>
<p>这种从3D到(2+1)D的拆分有下面两个好处：</p>
<ol>
<li>增加了非线性的层数，因为从图2可以看到，原先的1个卷积变成2个卷积，而2个卷积之间多了非线性层（通过ReLU来得到）， 因此总体的非线性层增加了。 用同样的参数来得到增加非线性的目的。</li>
<li>使得网络优化更容易，这个可以参考Figure 4中的结果，可以看到R(2+1)D的训练错误率比R3D更低，说明网络更易于训练。</li>
</ol>
<p> <img src="/imgs/closer_fig4.png"></p>
<p>另外作者还和<a href="https://arxiv.org/abs/1711.10305">P3D</a>进行了比较，因为两者结构确实比较类似。</p>
<h2 id="2-实验设置"><a href="#2-实验设置" class="headerlink" title="2. 实验设置"></a>2. 实验设置</h2><p>作者在视频动作识别的中型和大型数据集上都做了实验，包括HMDB51, UCF101， Sport-1M 和 Kinetics这几个数据集。<br>由于前面讨论的都是残差网络，因此实验中的网络都采用了残差网络。对R3D网络，作者采取了2种结构，包括18层的和34层的，图片输入采用了8帧的clip，图像大小为112x112。在3D网络的基础上，进行修改来得到R2D, MC<sub>x</sub>和rMC<sub>x</sub>，R(2+1)D等结构。 需要注意的是，由于不同网络结构时间维度的卷积和stride操作和个数不同，因此输出的feature map的时间维度是不一致的，为了方便统一比较，作者在卷积层最后的feature map后跟了一个时间空间的average pooling，然后晋国一个维度为K的fc层，$K$为数据集对应的类别，如对UCF101数据集，$K$=101。</p>
<p>视频帧数据首先被缩放到128x171，然后通过随机crop112x112的区域得到clip。训练时还应用了时域上的抖动。每个卷积层后面还使用到了BN。训练是batch size设置为32个clip，初始学习率设置为0.01，然后每过10个周期下降为原来的1/10，总共训练45个周期。video-level的准确率是在clip-level的准确率上得到的，即随机在视频中选择10个clip，然后对每个clip做center crop得到最后的clip，将这10个clip单独训练，结果进行一个平均，即为video-level的准确率。实验中采用caffe2在GPU cluster进行训练。</p>
<h2 id="3-实验分析"><a href="#3-实验分析" class="headerlink" title="3. 实验分析"></a>3. 实验分析</h2><h3 id="不同网络结构性能分析"><a href="#不同网络结构性能分析" class="headerlink" title="不同网络结构性能分析"></a>不同网络结构性能分析</h3><p><img src="/imgs/closer_table2.png"><br>由于这部分实验比较的是不同网络结构的性能，因此作者只在Kinetics上用18层的ResNet进行了实验，具体结果见Table 2。这里主要的结论有下面几点：</p>
<ol>
<li>纯2D网络（包括R2D和f-R2D）比含3D的网络（包括R3D, MC<sub>x</sub>,rMC<sub>x</sub>, R(2+1)D）性能要差</li>
<li>R(2+1)D性能最好</li>
<li>MC<sub>x</sub>性能优于rMC<sub>r</sub>，因此说明在网络底层的3D卷积层更有用，而后面用2D卷积更合理。</li>
</ol>
<h3 id="不同clip长度分析"><a href="#不同clip长度分析" class="headerlink" title="不同clip长度分析"></a>不同clip长度分析</h3><p> <img src="/imgs/closer_fig5.png"><br> 作者采用了8，16，24，32，40和48帧的clip进行实验，对clip-level的结果和video-level的结果进行分析，得到的准确率如Figure 5所示。可以看到，clip-level的准确率随着clip的长度增长在持续上升，而video-level的准确率则在24帧的时候达到最高，后面反倒有所下降，作者分析随着clip长度的增加，不同clip之间的相关性增加（甚至可能会产生重叠），所以video-level的准确率增益越来越小。 为了分析video-level准确率下降的原因，作者又做了两个实验：</p>
<ol>
<li>采用8帧的clip训练网络，然后在32帧的的clip上测试，发现结果相比用8帧的clip做测试，clip-level的准确率下降2.6%</li>
<li>在8帧的clip上训练的网络的基础上，采用32帧的clip进行fine tune，得到的clip-level的准确率与32帧从头训练的结果相差不多（56.8% vs 58.5%），而比8帧的clip的clip-level结果高4.4%。因此用长的clip结果更高说明学到了long-term的时间域上的信息</li>
</ol>
<h3 id="不同图片分辨率的分析"><a href="#不同图片分辨率的分析" class="headerlink" title="不同图片分辨率的分析"></a>不同图片分辨率的分析</h3><p>作者采用了224x224的输入训练网路，发现和112x112的输入结果只有微小的差距。</p>
<h3 id="和现有方法在4个动作识别数据集上的性能分析"><a href="#和现有方法在4个动作识别数据集上的性能分析" class="headerlink" title="和现有方法在4个动作识别数据集上的性能分析"></a>和现有方法在4个动作识别数据集上的性能分析</h3><p>为了和目前最好的方法进行PK，作者采用了34层的ResNet网络，结构采用R(2+1)D。在Sports-1M上，取得了目前最好的性能，而在Kinetics上，RGB单路性能比I3D高4.5%，而RGB和光流融合后性能比I3D的融合结果稍微差些。在UCF101和HMDB51上，使用Sports-1M和Kinetics上预训练的模型，fine tune后性能有较大提升。 </p>
<h2 id="4-Comments"><a href="#4-Comments" class="headerlink" title="4. Comments"></a>4. Comments</h2><p>今年做网络结构优化的工作很多，可能是I3D网络讨论引起的新的风潮。我们当时觉得I3D在UCF101和HMDB51上做这么高，需要换数据集了，因此看了看Charades数据集，但是好像今年做Charades数据集的工作还是比较少。接下来还是得在Kinetics上做了，但是在国内网络情况下，数据下载还是挺捉急的。</p>
<p>总体来说论文较多篇幅介绍了各种不同的网络，最后实验证明了MC<sub>x</sub>比rMC<sub>x</sub>好，但是其中的原理没怎么分析，而且最后采用了R(2+1)D，而且其效果最好，因此MC<sub>x</sub>实际没有使用的价值了。根据本文的结论，以后应该采用R(2+1)D的结构，能达到最好的性能。</p>
<p>论文中说采用224x224相比112x112没有显著提升，不知道实验中是先缩放到128x171再crop还是在原图crop224的区域？这两种方法效果应该还是有区别的，后者估计会更好些吧。</p>
<p>个人认为，总体感觉文章实验和网络讨论很充实，结果也很棒，算是中规中矩，相比I3D的横空出世，猛提10个点的劲头，还是差一些。</p>
]]></content>
      <tags>
        <tag>Deep Learning</tag>
        <tag>3D CNN</tag>
        <tag>Action Recogntion</tag>
      </tags>
  </entry>
  <entry>
    <title>neovim/vim 中遇到jedi-vim 插件报错解决</title>
    <url>/2021/11/06/neovim-jedi-error/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><a href="https://github.com/davidhalter/jedi-vim">jedi-vim</a>是vim/neovim的Python代码自动补全插件，很好用，不过最近遇到这样一个问题，用neovim 打开python文件时，会有这样的提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error: jedi-vim failed to initialize Python: jedi<span class="comment">#setup_python_imports: ImportError: bad magic number in &#x27;jedi.common&#x27;:</span></span><br></pre></td></tr></table></figure>
<p>这里记录一下解决办法.</p>
<span id="more"></span>

<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>这个问题可能是更新<code>jedi-vim</code>插件时, 缓存的<code>.pyc</code> 文件没删除导致的，因此我们找到插件目录，手动删除这种类型的文件就行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果使用的是vim，将下面路径中的~/.nvim 替换为~/.vim</span></span><br><span class="line"><span class="built_in">cd</span> ~/.nvim/bundle/jedi-vim</span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.pyc&quot;</span> -<span class="built_in">exec</span> rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://github.com/davidhalter/jedi-vim/issues/1026">https://github.com/davidhalter/jedi-vim/issues/1026</a></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>总结</tag>
        <tag>错误汇总</tag>
        <tag>neovim</tag>
      </tags>
  </entry>
  <entry>
    <title>关于英伟达显卡命名的姿势</title>
    <url>/2016/12/18/nvidia-gpu-names/</url>
    <content><![CDATA[<p>平时在实验中用到GPU的地方比较多，看新闻也总是能看到英伟达又出了什么型号的显卡等等，可是我一直没搞清楚该公司显卡名称的命名关系，今天特地查了下，总结在这里，以便以后翻阅。  </p>
<span id="more"></span>
<p>Nvidia的GPU命名有4个层次：</p>
<ol>
<li>GPU 架构(microarchitecture), 表示GPU在芯片设计层面上的不同处理方式，包括的内容有计算单元(SIMD)的个数、有无L1,L2缓存、是否有双精度支持等。按时间顺序依次是Tesla, Fermi, Kepler， Maxwell, Pascal。</li>
<li>显卡系列：根据使用场景的不同，分成GeForce, Quadro, Tesla。GeForce用于家庭和个人电脑，包括游戏和娱乐等;Quadro用于工业渲染、艺术设计，工作站等场合。而Tesla用于科学计算，深度学习加速等场景。当然这三者的使用场景并没有严格的边界，想GeForce 系列的GTX 1080也可以用来做深度学习实验。</li>
<li>芯片型号，例如GT200、GK210、GM104、GF104， K80, M40等。其中第二个字母表示架构，如K40 中的K表示是Kepler架构,P100中的P表示Pascal架构。</li>
<li>针对GeForce系列，还有2系列，3系列，200系列，400系列等分类，像GeForce GTX 1080 就是10系列。</li>
</ol>
<p>需要注意的地方有：</p>
<ol>
<li>注意区分Tesla GPU架构和Tesla系列。前者已经用的不是很多了，而后者是最近才出的针对深度学习的系列，使用很多，像我们实验室用的K20,K80都是这个系列。</li>
<li>描述一个显卡的时候，一般是系列名+芯片型号，如 Tesla K80。 </li>
<li>针对GeForce系列，芯片型号一般是显卡型号+具体编号的形式，如 GeForce GT 705,其中GT 是显卡型号。</li>
<li>最近新出了一款 TiTan X, 主要要和GeForce GTX Tian X 区分。</li>
</ol>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol>
<li><a href="https://chenrudan.github.io/blog/2015/12/20/introductionofgpuhardware.html">https://chenrudan.github.io/blog/2015/12/20/introductionofgpuhardware.html</a></li>
<li><a href="https://www.quora.com/What-is-NVIDIA-GPU-micro-architecture">https://www.quora.com/What-is-NVIDIA-GPU-micro-architecture</a></li>
<li><a href="https://en.wikipedia.org/wiki/List_of_Nvidia_graphics_processing_units">https://en.wikipedia.org/wiki/List_of_Nvidia_graphics_processing_units</a></li>
</ol>
]]></content>
      <tags>
        <tag>总结</tag>
        <tag>GPU</tag>
        <tag>Nvidia</tag>
      </tags>
  </entry>
  <entry>
    <title>从Numpy中的ascontiguousarray说起</title>
    <url>/2019/03/18/numpy-array-contiguous/</url>
    <content><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在使用Numpy的时候，有时候会遇到下面的错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AttributeError: incompatible shape <span class="keyword">for</span> a non-contiguous array</span><br></pre></td></tr></table></figure>
<p>看报错的字面意思，好像是不连续数组的shape不兼容。</p>
<p>有的时候，在看别人代码时会时不时看到<code>ascontiguous()</code>这样的一个函数，查<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ascontiguousarray.html">文档</a>会发现函数说明只有一句话：“Return a contiguous array (ndim &gt;= 1) in memory (C order).”</p>
<p>光靠这些信息，似乎没能道出Numpy里面contiguous array和non-contiguous array有什么区别，以及为什么需要进行<code>ascontiguous</code>操作？带着这些疑问，我搜了比较多的资料，在stack overflow上发现一个比较详细的<a href="https://stackoverflow.com/questions/26998223/what-is-the-difference-between-contiguous-and-non-contiguous-arrays">回答</a>，简单明白地将Numpy里面的数组的连续性问题解释清楚了，因此这里翻译过来，希望能帮助到别的有同样疑问的小伙伴。</p>
<h2 id="2-额外知识：-C-order-vs-Fortran-order"><a href="#2-额外知识：-C-order-vs-Fortran-order" class="headerlink" title="2. 额外知识： C order vs Fortran order"></a>2. 额外知识： C order vs Fortran order</h2><p>所谓<code>C order</code>，指的是行优先的顺序（Row-major Order)，即内存中同行的存在一起，而<code>Fortran Order</code>则指的是列优先的顺序（Column-major Order)，即内存中同列的存在一起。这种命名方式是根据C语言和Fortran语言中数组在内存中的存储方式不同而来的。Pascal, C，C++，Python都是行优先存储的，而Fortran，MatLab是列优先存储的。</p>
<span id="more"></span>

<h2 id="3-译文"><a href="#3-译文" class="headerlink" title="3. 译文"></a>3. 译文</h2><p>所谓<code>contiguous array</code>，指的是数组在内存中存放的地址也是连续的（注意内存地址实际是一维的），即访问数组中的下一个元素，直接移动到内存中的下一个地址就可以。</p>
<p>考虑一个2维数组<code>arr = np.arange(12).reshape(3,4)</code>。这个数组看起来结构是这样的：<br><img src="/imgs/numpy_ascontiguous_2.png"></p>
<p>在计算机的内存里，数组<code>arr</code>实际存储是像下图所示的：<br><img src="/imgs/numpy_ascontiguous_3.png"></p>
<p>这意味着<code>arr</code>是<code>C连续的</code>（<code>C contiguous</code>)的，因为在内存是行优先的，即某个元素在内存中的下一个位置存储的是它同行的下一个值。</p>
<p>如果想要向下移动一列，则只需要跳过3个块既可（例如，从0到4只需要跳过1,2和3）。</p>
<p>上述数组的转置<code>arr.T</code>则没有了C连续特性，因为同一行中的相邻元素现在并不是在内存中相邻存储的了:<br><img src="/imgs/numpy_ascontiguous_1.png"><br>这时候<code>arr.T</code>变成了<code>Fortran 连续的</code>（<code>Fortran contiguous</code>），因为相邻列中的元素在内存中相邻存储的了。</p>
<p>从性能上来说，获取内存中相邻的地址比不相邻的地址速度要快很多（从RAM读取一个数值的时候可以连着一起读一块地址中的数值，并且可以保存在Cache中）。这意味着对连续数组的操作会快很多。</p>
<p>由于<code>arr</code>是C连续的，因此对其进行行操作比进行列操作速度要快，例如，通常来说</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.<span class="built_in">sum</span>(arr, axis=<span class="number">1</span>) <span class="comment"># 按行求和</span></span><br></pre></td></tr></table></figure>
<p>会比</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.<span class="built_in">sum</span>(arr, axis=<span class="number">0</span>) <span class="comment"># 按列求和</span></span><br></pre></td></tr></table></figure>
<p>稍微快些。</p>
<p>同理，在<code>arr.T</code>上，列操作比行操作会快些。</p>
<h2 id="4-补充"><a href="#4-补充" class="headerlink" title="4. 补充"></a>4. 补充</h2><p>Numpy中，随机初始化的数组默认都是C连续的，经过不规则的<code>slice</code>操作，则会改变连续性，可能会变成既不是C连续，也不是Fortran连续的。</p>
<p>Numpy可以通过<code>.flags</code>熟悉查看一个数组是C连续还是Fortran连续的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.flags</span><br><span class="line">  C_CONTIGUOUS : <span class="literal">True</span></span><br><span class="line">  F_CONTIGUOUS : <span class="literal">False</span></span><br><span class="line">  OWNDATA : <span class="literal">False</span></span><br><span class="line">  WRITEABLE : <span class="literal">True</span></span><br><span class="line">  ALIGNED : <span class="literal">True</span></span><br><span class="line">  WRITEBACKIFCOPY : <span class="literal">False</span></span><br><span class="line">  UPDATEIFCOPY : <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>从输出可以看到数组<code>arr</code>是C连续的。</p>
<p>对<code>arr</code>进行按列的<code>slice</code>操作，不改变每行的值，则还是C连续的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr1 = arr[:<span class="number">3</span>, :]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr1</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr1.flags</span><br><span class="line">  C_CONTIGUOUS : <span class="literal">True</span></span><br><span class="line">  F_CONTIGUOUS : <span class="literal">False</span></span><br><span class="line">  OWNDATA : <span class="literal">False</span></span><br><span class="line">  WRITEABLE : <span class="literal">True</span></span><br><span class="line">  ALIGNED : <span class="literal">True</span></span><br><span class="line">  WRITEBACKIFCOPY : <span class="literal">False</span></span><br><span class="line">  UPDATEIFCOPY : <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>如果进行在行上的<code>slice</code>，则会改变连续性，成为既不C连续，也不Fortran连续的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr1 = arr[:, <span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr1.flags</span><br><span class="line">  C_CONTIGUOUS : <span class="literal">False</span></span><br><span class="line">  F_CONTIGUOUS : <span class="literal">False</span></span><br><span class="line">  OWNDATA : <span class="literal">False</span></span><br><span class="line">  WRITEABLE : <span class="literal">True</span></span><br><span class="line">  ALIGNED : <span class="literal">True</span></span><br><span class="line">  WRITEBACKIFCOPY : <span class="literal">False</span></span><br><span class="line">  UPDATEIFCOPY : <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>此时利用<code>ascontiguousarray</code>函数，可以将其变为连续的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr2 = np.ascontiguousarray(arr1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr2.flags</span><br><span class="line">  C_CONTIGUOUS : <span class="literal">True</span></span><br><span class="line">  F_CONTIGUOUS : <span class="literal">False</span></span><br><span class="line">  OWNDATA : <span class="literal">True</span></span><br><span class="line">  WRITEABLE : <span class="literal">True</span></span><br><span class="line">  ALIGNED : <span class="literal">True</span></span><br><span class="line">  WRITEBACKIFCOPY : <span class="literal">False</span></span><br><span class="line">  UPDATEIFCOPY : <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>可以这样认为，<code>ascontiguousarray</code>函数将一个内存不连续存储的数组转换为内存连续存储的数组，使得运行速度更快。</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>总结</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下使用自定义路径来运行OpenCV</title>
    <url>/2017/12/04/opencv-custom/</url>
    <content><![CDATA[<p>有的时候系统安装的OpenCV版本和你需要的版本不一样，而你又没有权限或者为了兼容不能修改系统的OpenCV，这个时候你就得自己编译OpenCV，然后在需要的代码里面引用你编译的版本。整个过程不复杂，但是之前一直没搞清楚，最近经师弟点拨才明白，这里记录一下。  </p>
<span id="more"></span>
<p>我之前写过一篇在Linux下编译OpenCV的<a href="https://vra.github.io/2015/04/25/opencv-linux-install/">博客</a>，大家可以参考下，我这里只记录与其中不同的部分。  </p>
<h3 id="修改CMAKE-INSTALL-PREFIX"><a href="#修改CMAKE-INSTALL-PREFIX" class="headerlink" title="修改CMAKE_INSTALL_PREFIX"></a>修改<code>CMAKE_INSTALL_PREFIX</code></h3><p>默认的<code>CMAKE_INSTALL_PREFIX</code>为<code>/usr/local</code>，而我们不想安装到这里，所以这里修改其为你想要保存的目录，如<code>/home/username/local</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -D CMAKE_INSTALL_PREFIX=/home/username/<span class="built_in">local</span> ..</span><br></pre></td></tr></table></figure>
<p>另外一个小问题，如果你在cmake的时候出现下面信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ICV: Downloading ippicv_linux_20151201.tgz...</span><br><span class="line">CMake Error at 3rdparty/ippicv/downloader.cmake:73 (file):</span><br><span class="line">  file DOWNLOAD HASH mismatch</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> file: [/home/pauka/opencv/3rdparty/ippicv/downloads/linux-808b791a6eac9ed78d32a7666804320e/ippicv_linux_20151201.tgz]</span><br><span class="line">      expected <span class="built_in">hash</span>: [808b791a6eac9ed78d32a7666804320e]</span><br><span class="line">        actual <span class="built_in">hash</span>: [f166287239920c4a16e6f8870e15ef79]</span><br></pre></td></tr></table></figure>
<p>即ippicv这个包下载不了，你可以在cmake里面加<code>-D WITH_IPP=OFF</code>来禁用这个包，也可以手动下载，下载方式见<a href="https://github.com/opencv/opencv/issues/5973">这里</a>。  </p>
<p>cmake完后，继续执行<code>make</code>和<code>make install</code>。注意这里<code>make install</code>前面不需要<code>sudo</code>，因为我们不修改系统目录，不需要管理员权限。  </p>
<h3 id="修改lib和include，增加OpenCV的目录"><a href="#修改lib和include，增加OpenCV的目录" class="headerlink" title="修改lib和include，增加OpenCV的目录"></a>修改lib和include，增加OpenCV的目录</h3><p>为了在编译的时候找到我们的OpenCV，需要修改lib和include路径，把OpenCV的目录加到里面去。例如编译Caffe的时候，修改<code>INCLUDE_DIRS</code>和<code>LIBRARY_DIRS</code>，将OpenCV的目录加进去。加入我们的OpenCV的编译后存放路径是<code>/home/username/local/</code>,那么对应的lib和include目录应该是<code>/home/username/local/lib</code>和<code>/home/username/local/include</code>。  </p>
<h3 id="修改PKG-CONFIG-PATH环境变量"><a href="#修改PKG-CONFIG-PATH环境变量" class="headerlink" title="修改PKG_CONFIG_PATH环境变量"></a>修改<code>PKG_CONFIG_PATH</code>环境变量</h3><p>这个环境变量是给<code>pkg-config</code>这个工具增加额外的查找目录的，pkg-config会默认查找<code>/usr/lib/pkgconfig</code>和<code>/usr/share/pkgconfig</code>下的<code>.pc</code>配置文件，额外的目录通过设置<code>PKG_CONFIG_PATH</code>来增加。我们这里将自己的OpenCV放进去，即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH=/home/username/<span class="built_in">local</span>:<span class="variable">$PKG_CONFIG_PATH</span></span><br></pre></td></tr></table></figure>

<h3 id="检查设置是否正确"><a href="#检查设置是否正确" class="headerlink" title="检查设置是否正确"></a>检查设置是否正确</h3><p>如何验证编译别的库的时候找到的是我们编译的OpenCV而不是系统的呢？可以通过<code>pkg-config</code>命令来确定：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkg-config --modversion opencv</span><br></pre></td></tr></table></figure>
<p>如果版本是你编译的版本，那就说明找到了，可以正常用了。  </p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Caffe</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV配置——在Visual Studio中使用OpenCV</title>
    <url>/2015/04/22/opencv-vs-config/</url>
    <content><![CDATA[<p><a href="http://opencv.org/">OpenCV</a>是图像领域经常会用到的工具库函数的集合，有C/C++,Java和Python等语言的接口，并且适用于Windows，Linux，Mac OS桌面开发平台和Android 和IOS移动开发平台。目前已经出了1.x系列和2.x系列，3.0 Beta版也已经出了。OpenCV配置起来还是挺费事的，虽然网上已经有很多很全面也很有用的参考文章，我还是打算把自己配置的过程写下来，以后肯定还会配置这个东西，希望到时候有个方便的参考。</p>
<p>这篇文章记录在Windows平台上，如何安装OpenCV并且在Visual Studio 的C/C++开发环境中使用之。</p>
<p>我用的是Windows 7，Visual tudio 2012 Ultimate。</p>
<span id="more"></span>

<h2 id="下载OpenCV包"><a href="#下载OpenCV包" class="headerlink" title="下载OpenCV包"></a>下载OpenCV包</h2><p>在<a href="http://opencv.org/downloads.html">opencv下载</a> 页面上，下载想要安装的版本。据说3.x系列会修改较多的API名称等，所以建议下载比较新的版本。我下的是2.4.10。下载之后将文件解压。</p>
<p>解压后会看到看到两个文件夹：<code>build</code>和<code>source</code>，<code>build</code>文件夹下面是已经编译好的库文件和可执行文件，而<code>source</code>文件夹下面是未编译的源文件。我们在写程序时用到的是一些编译好的lib和dll文件，所以只要在程序中添加了头文件，调用了相应的函数，然程序运行时能找到相应的库文件（包括动态库文件即<code>.dll</code>文件和静态库文件，即<code>.lib</code>文件）就可以了。所以针对这个情况，大概做以下几个步骤就可以了。</p>
<h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>添加环境变量是为了让程序在运行时能找到函数对应的动态链接库（<code>dll</code>）。<strong>要注意的是，OpenCV对于32位程序和64位程序有不同的dll目录，并且对于不同的版本的VS，也有不同的dll文件目录。</strong></p>
<p>在<code>build</code>目录下，<code>x86</code>下面包含了32位程序所需的<code>dll</code>文件，<code>x64</code>目录下面包含了64位程序所需<code>dll</code>文件。在这个两个目录下，都有<code>vc10</code>,<code>vc11</code>,<code>vc12</code>三个文件夹，分别是针对<code>vs2010</code>,<code>vs2012</code>和<code>vs2013</code>。为了使32位程序和64位程序都能编写通过，我一般将两者目录下的和VS版本对应的文件夹下的<code>bin</code>目录都加入PATH变量中。所以在PATH环境变量中增加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">;D:\program_file\opencv\build\x86\vc11\bin;D:\program_file\opencv\build\x64\vc11\bin</span><br></pre></td></tr></table></figure>
<p>其中build前面的位置是我安装opencv的目录，安装位置不同前面部分也应改为相应的目录。</p>
<h2 id="生成独立的OpenCV配置属性表"><a href="#生成独立的OpenCV配置属性表" class="headerlink" title="生成独立的OpenCV配置属性表"></a>生成独立的OpenCV配置属性表</h2><p>我们的目标是通过操作生成一个单独的OpenCV配置属性表，然后将其导出保存起来，将来在需要用到OpenCV的程序中，直接导入这个保存的属性表即可。<br>下面几步都是在VS开发环境里面进行。</p>
<ol>
<li>创建一个空项目，通过视图-&gt;属性管理器找到属性管理器页面。每个项目都可以有四个编译情况，分别是：<code>Debug|win32</code>、<code>Release|win32</code>、<code>Debug|x64</code>、<code>Release|x64</code>，基本步骤都类似，下面针对<code>Debug|win32</code>来说。</li>
<li>在<code>Debug|win32</code>文件夹上右击，选择添加新项目属性表，在弹出的对话框里，给这个表取名为OpenCV_Debug_32.props，然后点击添加。</li>
<li>双击新建的属性表，就会弹出熟悉的MFC复古风格的属性设置页了。</li>
<li>在属性页上，点击C/C++-&gt;常规-&gt;附加库包含目录，在这里添加OpenCV安装路径下的include目录，具体如下：</li>
</ol>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\program_file\opencv\build\include</span><br></pre></td></tr></table></figure>
<p> 同样的，build前面是opencv的安装路径，按实际情况选择。</p>
<ol start="5">
<li>在属性页上，点击链接器-&gt;常规-&gt;附加库目录，在这里添加OpenCV安装路径下的lib目录。注意：对不同编译情况和不同版本的VS，lib文件夹目录不同。对于VS2012下面的<code>Debug|win32</code>模式，lib文件夹目录为：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\program_file\opencv\build\x86\vc11\lib</span><br></pre></td></tr></table></figure>

<p>其中<code>x86</code>目录表示是针对<code>win32</code>的，<code>vc11</code>表示是适用于<code>VS2012</code>的。</p>
<ol start="6">
<li>在属性页上，点击链接器-&gt;输入-&gt;附加依赖项，在里面添加附加依赖的lib文件：</li>
</ol>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opencv_calib3d2411d.lib</span><br><span class="line">opencv_contrib2411d.lib</span><br><span class="line">opencv_core2411d.lib</span><br><span class="line">opencv_features2d2411d.lib</span><br><span class="line">opencv_flann2411d.lib</span><br><span class="line">opencv_gpu2411d.lib</span><br><span class="line">opencv_highgui2411d.lib</span><br><span class="line">opencv_imgproc2411d.lib</span><br><span class="line">opencv_legacy2411d.lib</span><br><span class="line">opencv_ml2411d.lib</span><br><span class="line">opencv_nonfree2411d.lib</span><br><span class="line">opencv_objdetect2411d.lib</span><br><span class="line">opencv_ocl2411d.lib</span><br><span class="line">opencv_photo2411d.lib</span><br><span class="line">opencv_stitching2411d.lib</span><br><span class="line">opencv_superres2411d.lib</span><br><span class="line">opencv_ts2411d.lib</span><br><span class="line">opencv_video2411d.lib</span><br><span class="line">opencv_videostab2411d.lib</span><br></pre></td></tr></table></figure>
<p> 注意：对于不同的版本，要将后面的2411改为相应的版本号；对于Debug版本，后面有个字母d,而对于Release版本，则没有d，应根据实际情况添加。<br> 7. 添加好之后，点击属性页面板右下角的应用，确定。<br> 8. 在<code>Debug|win32</code>文件夹上右击，选择保存，该属性表就保存好了。<br> 9. 在该项目目录下面找到这个属性表，保存到一个安全的地方，下次在要用OpenCV的工程里，找出属性管理器，右键，选择添加现有属性表即可。<br>我将四种情况所需的属性表和添加的附加依赖库的列表都放到了github上，或许能帮到你（注意只适用于VS2012）。</p>
<p>整个配置过程就是这样了，配置好之后就可以安心的使用OpenCV 了！</p>
<p>最后，测试一下，做个图像处理的“Hello World”:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include &lt;opencv2\opencv.hpp&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">using namespace cv;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	Mat img = imread(<span class="string">&quot;lena.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (img.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;error&quot;</span>;</span><br><span class="line">		<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">&quot;lena&quot;</span>, img);</span><br><span class="line">	waitKey();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出来的图像：</p>
<p><img src="/uploads/2015/04/lena.png"></p>
]]></content>
      <categories>
        <category>学习总结</category>
        <category>计算机视觉</category>
        <category>OpenCV</category>
      </categories>
  </entry>
  <entry>
    <title>OpenMP并行编程简介</title>
    <url>/2016/06/17/openmp-begin/</url>
    <content><![CDATA[<p>在这学期的并行计算课程中，老师讲了OpenMP,MPI，CUDA这3种并行计算编程模型，我打算把相关的知识点记录下来，便于以后用到的时候查阅。  </p>
<p><img src="http://www.openmp.org/wp-content/uploads/openmp-menu-logo.jpg"></p>
<span id="more"></span>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OpenMP是基于共享存储体系的基于线程的并行编程模型。一个共享存储的进程由多个线程组成，而OpenMP就是基于已有线程的共享编程范例。<br>在OpenMP中，线程的并行化是由编程人员控制的，不是自动编程模型，而是外部变成模型。<br>OpenMP采用<strong>Fork-Join</strong>并行执行模型。即程序开始于一个单独的主线程，主线程会一直串行地执行，遇到第一个并行域，通过如下过程完成并行操作：  </p>
<ol>
<li>Fork: 主线程创建一系列并行的线程，由这些线程来完成并行域的代码。  </li>
<li>当所有并行线程完成代码的执行后，它们或被同步或被中断，最后只剩下主线程在执行。</li>
</ol>
<p>那么并行代码块是如何创建的呢？在OpenMP中，通过编译制导语句（即像<code>#pragma</code>开头的语句）来构造并行域，在原本的串行代码中，在可并行代码块周围添加编译制导语句并修改相应的代码，就可以完成并行的功能。<br>运行OpenMP代码不需要安装任何额外的库或工具，标准的C/C++代码编译器执行环境就可以执行。<br>下面是一个简单的OpenMP的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file name: test_openmp.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num_thread = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	omp_set_num_threads(num_thread);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> id = omp_get_thread_num();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;hello from thread%d\n&quot;</span>,id);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>gcc --openmp test_openmp.c</code>来编译，运行生成的可执行文件，得到结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hello from thread0</span><br><span class="line">hello from thread3</span><br><span class="line">hello from thread1</span><br><span class="line">hello from thread2</span><br></pre></td></tr></table></figure>
<p>可以看到，各个线程执行的顺序是无序的。  </p>
<h2 id="核心知识"><a href="#核心知识" class="headerlink" title="核心知识"></a>核心知识</h2><p>下面记录使用OpenMP的一些核心点。  </p>
<ol>
<li>包含头文件<code>omp.h</code></li>
<li>所有并行块由<code>#pragma omp</code>开头的编译制导语句来开始，在代码块周围要有大括号</li>
<li>常见的编译制导语句有<code>#pragma omp prallel</code>, 表示最基本的循环</li>
<li><code>#pragma omp parallel for</code>:并行部分包含一个for循环;</li>
<li><code>#pragma omp critical</code>:并行部分的代码一次只能由一个线程执行，相当于取消了并行化</li>
<li><code>#pragma omp barrier</code>: 同步并行线程，让线程等待，直到所有的线程都执行到该行</li>
<li><code>#pragma omp section</code>: 将并行块内部的代码划分给线程组中的各个线程，一般会在内部嵌套几个独立的<code>section</code>语句，可以使用<code>nowait</code>来停止等待 </li>
<li>通过<code>omp_set_num_threads</code>函数来手动设置线程数。可以看到线程数是在程序编写过程中指定的</li>
<li>通过<code>omp_get_thread_num</code>来获取当前线程的编号</li>
<li>通过<code>omp_get_num_threads</code>来获取线程总数</li>
</ol>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>这里举一个更完善的例子来说明。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">	<span class="built_in">gettimeofday</span>(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;USAGE: num_primer &lt;num_of_thread&gt; &lt;integer&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num_thread = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;num of thread: &quot;</span> &lt;&lt; num_thread &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot; n: &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">int</span>* num_primer = <span class="keyword">new</span> <span class="keyword">int</span>[num_thread];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_thread; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		num_primer[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">omp_set_num_threads</span>(num_thread);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">pragma</span> omp parallel shared(n, num_primer)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> id = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">		</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = id + <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i = i + num_thread)</span><br><span class="line">    	&#123;</span><br><span class="line">			<span class="keyword">bool</span> has_factor = <span class="literal">false</span>;</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> omp parallel shared(n, i, num_primer, has_factor)</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; <span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">sqrt</span>(i)) + <span class="number">1</span>; ++j)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						has_factor = <span class="literal">true</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!has_factor)</span><br><span class="line">				&#123;</span><br><span class="line">					++num_primer[id];</span><br><span class="line">					std::cout &lt;&lt; <span class="string">&quot;id: &quot;</span>&lt;&lt; id &lt;&lt; <span class="string">&quot;, primer:&quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="comment">//pragma</span></span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;<span class="comment">//pragma</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//add all primers</span></span><br><span class="line">	<span class="keyword">int</span> sum_num_primer = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_thread; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		sum_num_primer += num_primer[i];	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The number of primers between 0 and &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; sum_num_primer &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">gettimeofday</span>(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">double</span> time_gap = (end.tv_sec - start.tv_sec) * <span class="number">1000000u</span> + end.tv_usec - start.tv_usec;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Time cost: %.2lf s.\n&quot;</span>, time_gap / <span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>并行计算——结构，算法，编程（第3版），陈国良</p>
]]></content>
      <tags>
        <tag>并行计算</tag>
        <tag>C/C++</tag>
        <tag>OpenMP</tag>
      </tags>
  </entry>
  <entry>
    <title>openpyxl-读写Excel文件的Python库</title>
    <url>/2019/02/27/openpyxl-tutorial/</url>
    <content><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>写脚本的时候，想要用Python读取Excel文件内容，谷歌搜索发现了openpyxl这个包，学习后发现简单地读写Excel文件还是比较方便的，库的设计也很简洁，没有太多深奥的东西。这里记录一下，说不定哪天还是会用到呢。</p>
<span id="more"></span>

<h2 id="2-概念介绍"><a href="#2-概念介绍" class="headerlink" title="2. 概念介绍"></a>2. 概念介绍</h2><p>打开一个Excel文件的时候，首先我们会看到底部有“Sheet1”或“工作簿1”的文字，可见一个Excel文件是由一个或多个工作簿组成的。<br>每个工作簿的工作区，横向坐标是以字母为编号的，从A到Z;纵向是以数字为编号的，从1开始，一直往增大方向编号。由数字和字母为横纵坐标构成的每个小框叫做单元格，这是Excel的基本单位。字母和数字确定后，对应的单元格就唯一确定了；而单元格已知后，它对应的字母和数字也就确定了。<br>因此我们可以这样总结：<br>一个Excel文件由一或多个Sheet组成，而一个Sheet由字母和数字唯一表示的单元格们组成，这是一个三级的结构。下图表示一个名字为data.xlsx的Excel文件的3级层级结构。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">data.xlsx</span><br><span class="line">├── Sheet1</span><br><span class="line">│   ├── A1</span><br><span class="line">│   ├── A2</span><br><span class="line">│   ├── B1</span><br><span class="line">│   └── B2</span><br><span class="line">├── Sheet2</span><br><span class="line">│   ├── A1</span><br><span class="line">│   ├── A2</span><br><span class="line">│   ├── B1</span><br><span class="line">│   └── B2</span><br><span class="line">└── Sheet3</span><br><span class="line">    ├── A1</span><br><span class="line">    ├── A2</span><br><span class="line">    ├── B1</span><br><span class="line">    └── B2</span><br></pre></td></tr></table></figure>
<p>明白了这个结构，openpyxl的设计理念就很好理解了。<br>在opnepyxl里面，一个Excel文件对应着一个Workbook对象， 一个Sheet对应着一个Worksheet对象，而一个单元格对应着一个Cell对象，下面是一个最简单的例子，执行示例之前请使用<code>pip install --user openpyxl</code>安装openpyxl包。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ ipython3  <span class="comment"># 在命令行打开ipython交互式界面</span></span><br><span class="line">Python <span class="number">3.5</span><span class="number">.2</span> (default, Nov <span class="number">12</span> <span class="number">2018</span>, <span class="number">13</span>:<span class="number">43</span>:<span class="number">14</span>) </span><br><span class="line"><span class="type">Type</span> <span class="string">&#x27;copyright&#x27;</span>, <span class="string">&#x27;credits&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;license&#x27;</span> <span class="keyword">for</span> more information</span><br><span class="line">IPython <span class="number">6.4</span><span class="number">.0</span> -- An enhanced Interactive Python. <span class="type">Type</span> <span class="string">&#x27;?&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>.</span><br><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook <span class="comment"># load_workbook用于从一个xlsx文件读入数据</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: wb = load_workbook(<span class="string">&#x27;data.xlsx&#x27;</span>) <span class="comment"># wb是data.xlsx对应的Workbook对象</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="built_in">type</span>(wb)</span><br><span class="line">Out[<span class="number">3</span>]: openpyxl.workbook.workbook.Workbook</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: ws1 = wb[<span class="string">&#x27;Sheet1&#x27;</span>] <span class="comment"># ws1是Sheet1对应的Worksheet对象</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: <span class="built_in">type</span>(ws1)</span><br><span class="line">Out[<span class="number">5</span>]: openpyxl.worksheet.worksheet.Worksheet</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: cell1 = ws1[<span class="string">&#x27;A1&#x27;</span>] <span class="comment"># cell1是Sheet1中第一个单元格对应的Cell对象</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: <span class="built_in">type</span>(cell1)</span><br><span class="line">Out[<span class="number">7</span>]: openpyxl.cell.cell.Cell</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: cell1.value <span class="comment"># 使用.value参数来获取Cell对象对应的值</span></span><br><span class="line">Out[<span class="number">8</span>]: <span class="number">100</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: cell1.value = <span class="number">365</span> <span class="comment">#使用.value参数来对单元格赋值</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: cell1.value</span><br><span class="line">Out[<span class="number">10</span>]: <span class="number">365</span></span><br></pre></td></tr></table></figure>
<p>使用起来是不是很简单？这个例子看懂了，这篇总结80%的任务就完成了。下面是详细使用说明。</p>
<h2 id="3-Workbook读写"><a href="#3-Workbook读写" class="headerlink" title="3. Workbook读写"></a>3. Workbook读写</h2><p>如果要用openpyxl从头创建一个Excel文件，需要对Workbook进行默认初始化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wb = Workbook()</span><br></pre></td></tr></table></figure>
<p>如果是要从现有Excel里面导入数据，使用load_workbook函数即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wb = load_workbook(<span class="string">&#x27;data.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>要保存Workbook，调用Workbook的save函数就行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>wb.save(<span class="string">&#x27;data.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4-Sheet的操作"><a href="#4-Sheet的操作" class="headerlink" title="4. Sheet的操作"></a>4. Sheet的操作</h2><h3 id="4-1-获取Sheet对象"><a href="#4-1-获取Sheet对象" class="headerlink" title="4.1. 获取Sheet对象"></a>4.1. 获取Sheet对象</h3><p>有下面几种方式可以得到Sheet对象：</p>
<ol>
<li>调用Workbook对象的active属性，得到当前激活的工作簿：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ws = wb.active</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ws</span><br><span class="line">&lt;Worksheet <span class="string">&quot;Sheet&quot;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ws.title</span><br><span class="line"><span class="string">&#x27;Sheet&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>通过Workbook对象的[]函数，[]里面是Sheet对象的名字，所有工作簿的名字列表可以通过wb.sheetnames得到： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>wb.sheetnames  ＃ sheetnames属性表示 Workbook对象包含的Sheet的名字</span><br><span class="line">[<span class="string">&#x27;Sheet&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ws=wb[<span class="string">&#x27;Sheet&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ws</span><br><span class="line">&lt;Worksheet <span class="string">&quot;Sheet&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li>通过for循环迭代器得到:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> ws <span class="keyword">in</span> wb:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(ws.title)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">Sheet</span><br></pre></td></tr></table></figure></li>
<li>从已有的工作薄复制过来：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ws = wb.active</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ws1 = wb.copy_worksheet(ws)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ws1</span><br><span class="line">&lt;Worksheet <span class="string">&quot;Sheet Copy&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-2-Sheet对象属性"><a href="#4-2-Sheet对象属性" class="headerlink" title="4.2. Sheet对象属性"></a>4.2. Sheet对象属性</h3><p> Sheet对象有许多有用的函数和属性，基本的几个介绍如下。</p>
<ol>
<li>title，即工作薄的名称，显示在Excel底部<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ws.title</span><br><span class="line"><span class="string">&#x27;Sheet&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>parent，即所属的Ｗorkbook的名称<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>wb1 = ws.parent</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wb1 == wb</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></li>
<li>active_cell，即光标所在的单元格的编号<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ws.active_cell</span><br><span class="line"><span class="string">&#x27;B5&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>rows和columns，表示行和列的迭代器，通过for循环可以得到每行或每列的单元格元组<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> ws.rows:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(row)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">(&lt;Cell <span class="string">&#x27;Sheet&#x27;</span>.A1&gt;, &lt;Cell <span class="string">&#x27;Sheet&#x27;</span>.B1&gt;)</span><br><span class="line">(&lt;Cell <span class="string">&#x27;Sheet&#x27;</span>.A2&gt;, &lt;Cell <span class="string">&#x27;Sheet&#x27;</span>.B2&gt;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-Cell对象的操作"><a href="#5-Cell对象的操作" class="headerlink" title="5. Cell对象的操作"></a>5. Cell对象的操作</h2><h3 id="5-1-获取对象"><a href="#5-1-获取对象" class="headerlink" title="5.1. 获取对象"></a>5.1. 获取对象</h3><p>获取对象也有好几种方式，下面一一介绍。</p>
<ol>
<li>通过工作簿对象的cell函数获取<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = ws.cell(row=<span class="number">1</span>, column=<span class="number">1</span>)  <span class="comment"># 获取第一行第一列的单元格</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.value  <span class="comment"># 打印单元格的值</span></span><br><span class="line"><span class="string">&#x27;姓名&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.value  = ‘Name’  <span class="comment"># 重设单元格的值</span></span><br></pre></td></tr></table></figure></li>
<li>通过工作薄对象的[]函数来获取，这里面获取方式比较灵活，举例如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = ws[<span class="string">&#x27;A4&#x27;</span>]  <span class="comment"># 获取第４行，第１列的单元格</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = ws[<span class="string">&#x27;A&#x27;</span>]  <span class="comment"># 获取第１列的所有单元格</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = ws[<span class="string">&#x27;5&#x27;</span>]  <span class="comment"># 获取第５行的所有单元格</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = ws[<span class="string">&#x27;A1&#x27;</span>: <span class="string">&#x27;B10&#x27;</span>]  <span class="comment"># 获取第1行第1列到第10行第2列的矩形区域内的所有单元格</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = ws[<span class="string">&#x27;A&#x27;</span>:<span class="string">&#x27;B&#x27;</span>]  <span class="comment"># 获取第1列到第2列的所有单元格</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = ws[<span class="number">1</span>:<span class="number">10</span>]  <span class="comment"># 获取第1行到第10行的所有单元格</span></span><br></pre></td></tr></table></figure>
熟练使用这种操作，简单的任务就可以轻松处理了。</li>
<li>通过iter_cols或iter_rows来得到：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> ws.iter_rows(min_col=<span class="number">1</span>, max_col=<span class="number">2</span>, min_row=<span class="number">1</span>, max_row=<span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> c <span class="keyword">in</span> row:</span><br><span class="line"><span class="meta">... </span>            <span class="built_in">print</span>(c.value)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">姓名</span><br><span class="line">年龄</span><br><span class="line">ｗｗｗ</span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>
其中参数min_col和min_row是迭代时起始的列号和行号，max_col和max_row是结束的列号和行号，都是包含在迭代内部的。</li>
<li>通过工作簿对象的active_cell得到光标所在的单元格：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ws.active_cell</span><br><span class="line"><span class="string">&#x27;B5&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>上面介绍了openpyxl常见的用法，看完后你会发现有了这个库，用Python 操作Excel容易多了。这里是我最近用的一个例子：</p>
<p>更多用法请参考<a href="https://openpyxl.readthedocs.io/">官方教程</a><br>下篇博客再见～</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
        <tag>OpenPyxl</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV配置——在Linux中使用OpenCV</title>
    <url>/2015/04/25/opencv-linux-install/</url>
    <content><![CDATA[<p>这篇博客介绍在Linux中的gcc和g++编译环境下如何使用cmake来编译OpenCV源代码。我基本是按照OpenCV官方的<a href="http://docs.opencv.org/doc/tutorials/introduction/linux_install/linux_install.html">说明文档</a>，一步步地进行的，所以表述不清楚的地方还请参照原文。</p>
<span id="more"></span>

<h2 id="1-编译环境"><a href="#1-编译环境" class="headerlink" title="1. 编译环境"></a>1. 编译环境</h2><ul>
<li>  操作系统：Ubuntu 14.10</li>
<li>  gcc 版本: 4.9.1</li>
<li>  cmake 版本： 2.8.12.2</li>
<li>  opencv版本： 2.4.10</li>
</ul>
<h2 id="2-依赖包安装"><a href="#2-依赖包安装" class="headerlink" title="2. 依赖包安装"></a>2. 依赖包安装</h2><p>依赖包包括在编译的时候要用到一些软件，像gcc，cmake；还有一些是下载opencv需要的工具，像Git；还有一些编译opencv所必需的，像ffmpeg 或libav ；还有一些是可选的包等等。可以通过下面几条命令来安装这些依赖包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential </span><br><span class="line">sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line">sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</span><br></pre></td></tr></table></figure>

<p>运行完这三条命令，依赖包就安装好了！</p>
<h2 id="3-获取OpenCV源代码"><a href="#3-获取OpenCV源代码" class="headerlink" title="3. 获取OpenCV源代码"></a>3. 获取OpenCV源代码</h2><p>官方网站上给了2种获取源代码的方式：</p>
<ol>
<li> 从<a href="http://sourceforge.net/projects/opencvlibrary/">Sourceforge</a>上获取最新的稳定版(lastest staable)的OpenCV，下载完解压即可。</li>
<li>从<a href="http://github.com/itseez/opencv">github</a>上下载最前沿的版本。也可以在命令行下载：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Itseez/opencv.git</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="4-用cmake编译OpenCV"><a href="#4-用cmake编译OpenCV" class="headerlink" title="4. 用cmake编译OpenCV"></a>4. 用cmake编译OpenCV</h2><p>下载完源代码后，就可以用cmake来编译OpenCV了。<br>解压下载得到的opencv包，然后进入包目录，在下面进行操作。</p>
<ol>
<li> 创建release目录，然后将进入该目录，下面编译都是针对Release版来进行编译的：</li>
</ol>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir release</span><br><span class="line"><span class="built_in">cd</span> ~/release</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 执行cmake命令：</li>
</ol>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span> ..</span><br></pre></td></tr></table></figure>
<p> 上面的<code>CMAKE_BUILD_TYPE =RELEASE</code>指明编译的版本是Release版，<code>CMAKE_INSTALL_PREFIX=/usr/local</code>指明编译后的可执行程序的存放目录。</p>
<ol start="3">
<li> 执行make和install：</li>
</ol>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make    </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p> 如果没有出错的话，OpenCV的整个编译过程就完成了！ 如果有错误，那就复制错误内容，到网上查找解决办法，一般来说这是个很痛苦的过程，所以希望你有好运气，一次编译就能过：)</p>
<h2 id="5-在gcc-g-编译时使用opencv"><a href="#5-在gcc-g-编译时使用opencv" class="headerlink" title="5. 在gcc/g++编译时使用opencv"></a>5. 在gcc/g++编译时使用opencv</h2><p>在g++里面编译使用了opencv库的程序时，只需要在后面添加<code>pkg-config opencv --cflags --libs</code>即可，如下例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -o main main.cpp`pkg-config opencv --cflags --libs`</span><br></pre></td></tr></table></figure>

<p>以上就是Linux环境下使用OpenCV的一些总结。</p>
]]></content>
      <categories>
        <category>学习总结</category>
        <category>计算机视觉</category>
        <category>OpenCV</category>
      </categories>
  </entry>
  <entry>
    <title>记录我们的点点滴滴</title>
    <url>/2014/12/13/our-record/</url>
    <content><![CDATA[<p>还记得你初次敲代码时专注的模样</p>
<span id="more"></span>
<p><img src="/uploads/2014/12/first-coding.jpg"></p>
<p>程序的崩溃也曾令人发狂</p>
<p><img src="/uploads/2014/12/crash.jpg"></p>
<p>从开始的Hello world，到不甚完美的大段程序</p>
<p><img src="/uploads/2014/12/ruinian.jpg"></p>
<p>从变量未声明的error</p>
<p><img src="/uploads/2014/12/error.jpg"></p>
<p>到细心关怀的草稿</p>
<p><img src="/uploads/2014/12/note.jpg"></p>
<p>完成了加减乘除的计算器</p>
<p><img src="/uploads/2014/12/chu.jpg"></p>
<p>还有一元二次方程的解法</p>
<p><img src="/uploads/2014/12/solve-function.jpg"></p>
<p>我知道以后的路还很长</p>
<p>但我也知道我们美好的记忆比道路还要长</p>
<p>我们要看着我们的脚印</p>
<p>走在阳光灿烂里</p>
<p>&nbsp;</p>
]]></content>
      <categories>
        <category>我们的记录</category>
      </categories>
  </entry>
  <entry>
    <title>What Makes a Video a Video Analyzing Temporal Information in Video Understanding Models and Datasets 论文阅读</title>
    <url>/2018/04/14/paper-what/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>论文链接：<a href="http://ai.stanford.edu/~dahuang/papers/cvpr18-fb.pdf">点击查看PDF</a><br>作者主页：<a href="http://ai.stanford.edu/~dahuang/">De-An Huang</a></p>
<p>论文主要目的：显式地用量化的方法来分析motion对于视频理解的作用有多大，在整个视频分析过程中起到了多大的效果。这也是我了解的第一篇用量化的方法来探讨motion信息的贡献的论文，文中逐类的分析motion带来的性能增益（图4）也是第一次见到。</p>
<p>这篇论文的出发点是分析在某个网络结构（例如C3D）上训练好的模型在对测试视频进行分类的时候，是否真正地用到了运动信息（motion），或者说运动信息真正起到了作用。一个简单的验证实验是在在测试视频中选一帧，然后重复N次构成一个clip（如在C3D中，N=16）。作者实验发现这种情况性能下降了25%。但这25%的性能下降不光是motion丢失带来的，作者认为这里还引入了另外两个问题：（1）改变了视频帧的时间上分布（temporal distribution），因为训练时使用的是16帧的clip，而测试采用采样过的帧构成的clip，训练和测试数据的分布不一致。（2）可能将视频中最重要的帧，对视频分类最有用的帧给丢掉了。</p>
<p>为了解决上面提到的两个问题，这篇论文提出了两个针对性的框架：首先是在低帧率（例如相比C3D中采用的16帧的clip，这里采用1帧的clip）的情况下，基于cycleGAN的类别无关（class-agnostic）的时域生成器（temporal generator, 英文不好，暂时这样翻译了，如果有更准确的翻译请告知）来生成帧，构成视频输入到训练好的网络中。为了使得训练收敛，作者采用了perceptual loss。第二个框架是运动不变（motion-invariant）的关键帧选择器，通过选择一个关键帧进行视频分类的任务。</p>
<p>具体实验是采用C3D模型，在UCF101和Kinetics这两个数据集上进行。通过使用作者提出的两个框架，使得在UCF101上，单帧clip相比16帧的clip的性能下降从25%减小到6%，在Kinetics上性能下降从15%减小到5%。同时作者用实验表明，40%的UCF101测试视频（split1）和35%的Kinetics测试视频不需要motion信息就能达到平均的分类性能。此外，在使用了作者提出的两个框架后，采用4帧的clip就能达到原来16帧的clip下的性能。至于引入的额外的计算开销作者在论文中没有进行讨论。</p>
<span id="more"></span>

<p>下面详细说明论文提出的框架和实验结果分析。</p>
<h2 id="类别无关的时域生成器"><a href="#类别无关的时域生成器" class="headerlink" title="类别无关的时域生成器"></a>类别无关的时域生成器</h2><p>为了解决训练和测试数据集分布不一致的问题，作者提出了如图1所示的框架。首先将输入视频进行下采样，实验中将16帧的clip分别采样到1，2，4，8帧这四种情况，然后将选出来的帧输入到由cycleGAN构成的时域生成器中，生成16帧的clip，通过计算生成的clip和原先的clip输入到C3D网络中得到的不同层的feature map之间的归一化的L2距离作为loss（即Perceptual Loss，感知损失）进行网络优化。整个过程是无监督的，视频的类别标签和监督损失是没有使用的，因此是类别无关的。</p>
<p>可能有的人会有疑问：为什么需要先采样帧，再生成帧呢，绕了一圈回来最后的效果不是和直接使用原来的帧一样吗？这样做的原因是因为模型已经训练好了，而且是采用16帧的clip训练的，而我们为了看motion起了多大作用，需要改变motion的使用情况，因此不能用全部的帧训练，而为了使得训练数据和测试数据的分布保持一致，网络需要一个合理的输入。发现说的好绕啊。抱歉了。<br><img src="/imgs/what-fig1.png" alt="图1"></p>
<p>总的来说这部分是一个GAN在视频理解中的应用，用下采样的帧序列来生成完整的帧序列。</p>
<h2 id="运动不变的关键帧选择器"><a href="#运动不变的关键帧选择器" class="headerlink" title="运动不变的关键帧选择器"></a>运动不变的关键帧选择器</h2><p>所谓运动不变的帧选择器，就是说不管运动信息怎么变化，我得到的关键帧每次都是一样的，跟运动信息无关。满足这一点是很重要的，因为本论文就是讨论时域信息的作用，使用额外的运动信息的话这个讨论就没有意义了。作者提出了两种关键帧选择的方法。第一种是给定候选帧和一个固定的响应函数，选择响应函数的值最大（即置信度最高）的那个候选帧作为关键帧，这种选择方式作者称为<strong>Max Response</strong>。第二种是选择所有正确分类的候选帧作为关键帧（即只从候选帧中删去错误分类的帧），这种方式叫做<strong>Oracle</strong>。这种方式作者也说有些”cheating“，因为将ground truth利用了起来，而实际测试的时候ground truth是不可知的。不过这种方式也是运动不变的，没有用到额外的运动信息。帧选择器的框架如图2所示。</p>
<p><img src="/imgs/what-fig2.png" alt="图2"></p>
<h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p>如图3所示，本文的方法在采用1帧的情况下，比原先的16帧在UCF101上只差了6个点（73% v.s. 79%），而在Kinetics上则只差了5个点（42% v.s. 47%）。所以motion额外提供的信息其实作用是比较小的。<br><img src="/imgs/what-fig3.png" alt="图3"></p>
<p>图4中展示了和原来模型相比，这篇论文中模型的准确率对比。可以发现，40%的UCF101视频和35%的Kinetics视频不需要motion信息就能达到与使用motion信息情况类似的性能。对于有些类，motion信息作用很大，而且需要更多的motion信息来进一步提高分类准确率。<br><img src="/imgs/what-fig4.png" alt="图4"></p>
<p>另外的分析和结论还包括：</p>
<ol>
<li>UCF101数据集中，最不需要motion（即只使用空间信息就足以分类视频）的类是“WalkingWithDog”，最需要motion来帮助分类的类是“PushUps”，Kinetics中的这两个类别分别是“Playing Paintball”和“JuggleBall”，看起来还是挺合理的</li>
<li>从图4可以发现，采用本方法后，4帧的clip就能达到和原先类似的性能，而本文一直强调没有引入额外的motion信息，因此16帧是有冗余的，我们并不需要所有帧来对视频进行分类</li>
<li>感知损失（Perceptual Loss）是很重要的</li>
<li>Max Response能够删除噪声帧</li>
<li>Oracle 比原来的模型效果更好，说明正确地帧选择方法能够提升性能，而且现有的C3D方法还是有提升空间的，因此很有必要开个新坑来探索视频动作识别中的关键帧技术</li>
</ol>
<h2 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h2><ol>
<li>这篇论文第一次以量化的形式展示了具体有多少类的视频并不需要motion信息就可以很好地完成分类，我觉得比较有意义。</li>
<li>虽然这篇论文没有在数据集上有相比最好结果的提升，但是通过分析时域信息的作用，说明现有方法还是没有很好地用到motion的信息，或者说motion的作用还没有完全地利用起来，可能需要大家设计针对视频的网络结构来把motion更好地利用起来。</li>
<li>论文中的结果可视化做得很好，具体可以参考原论文的Figure 4, Figure 6 和 Figure 10。</li>
<li>希望视频理解中的关键帧选择能够在未来有大的突破。</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>CycleGAN: Unpaired Image-to-Image Translation using Cycle-Consistent Adversarial Networks</li>
<li>C3D: Learning Spatiotemporal Features with 3D Convolutional Networks</li>
<li>UCF101： UCF101: A dataset of 101 human actions classes from videos in the wild</li>
<li>Kinetics： Quo vadis, action recognition? a new model and the kinetics dataset</li>
<li>Perceptual Loss: Perceptual losses for real-time style transfer and super-resolution</li>
</ol>
]]></content>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Action Recogntion</tag>
        <tag>CNN</tag>
        <tag>C3D</tag>
        <tag>Motion</tag>
        <tag>UCF101</tag>
        <tag>Kinetics</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV Code Snippets——BGR与YUV转换</title>
    <url>/2019/12/19/opencv-bgr-yuv-conversion/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OpenCV BGR 图 转 YUV 图的代码，网上没有比较完整的示例，使用的时候搜索比较费劲。这里写一个代码片段和例子，方便查找。</p>
<span id="more"></span>

<h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h2><p>在 Ubuntu 16.04 自己从源码编译的OpenCV 4.1.0 上测试通过，具体如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file name: convert.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BGR 转 YUV</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BGR2YUV</span><span class="params">(<span class="keyword">const</span> cv::Mat bgrImg, cv::Mat &amp;y, cv::Mat &amp;u, cv::Mat &amp;v)</span> </span>&#123;</span><br><span class="line">    cv::Mat out;</span><br><span class="line">    cv::<span class="built_in">cvtColor</span>(bgrImg, out, cv::COLOR_BGR2YUV);</span><br><span class="line">bgr</span><br><span class="line">    cv::bgr channel[<span class="number">3</span>];</span><br><span class="line">    cv::<span class="built_in">split</span>(out, channel);</span><br><span class="line"></span><br><span class="line">    y = channel[<span class="number">0</span>];</span><br><span class="line">    u = channel[<span class="number">1</span>];</span><br><span class="line">    v = channel[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// YUV 转 BGR</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">YUV2BGR</span><span class="params">(<span class="keyword">const</span> cv::Mat y, <span class="keyword">const</span> cv::Mat u, <span class="keyword">const</span> cv::Mat v, cv::Mat&amp; bgrImg)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;cv::Mat&gt; inChannels;</span><br><span class="line">    inChannels.<span class="built_in">push_back</span>(y);</span><br><span class="line">    inChannels.<span class="built_in">push_back</span>(u);</span><br><span class="line">    inChannels.<span class="built_in">push_back</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并3个单独的 channel 进一个矩阵</span></span><br><span class="line">    cv::Mat yuvImg;</span><br><span class="line">    cv::<span class="built_in">merge</span>(inChannels, yuvImg);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">cvtColor</span>(yuvImg, bgrImg, cv::COLOR_YUV2BGR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用例子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv::Mat origImg = cv::<span class="built_in">imread</span>(<span class="string">&quot;test.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cv::Mat y, u, v;</span><br><span class="line">    <span class="built_in">BGR2YUV</span>(origImg, y, u, v);</span><br><span class="line"></span><br><span class="line">    cv::Mat bgrImg;</span><br><span class="line">    <span class="built_in">YUV2BGR</span>(y, u, v, bgrImg);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;origImg&quot;</span>, origImg);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Y channel&quot;</span>, y);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;U channel&quot;</span>, u);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;V channel&quot;</span>, v);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;converted bgrImg&quot;</span>, bgrImg);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在命令行用下面的命令来运行，查看代码有无问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -o convert convert.cpp  --std=c++11 `pkg-config --cflags --libs opencv`</span><br><span class="line">./convert</span><br></pre></td></tr></table></figure>

<h2 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h2><p>在 <code>pip</code> 安装的 OpenCV 4.1.2 上测试通过，具体如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file name: convert.py</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bgr2yuv</span>(<span class="params">img</span>):</span></span><br><span class="line">    yuv_img = cv2.cvtColor(img, cv2.COLOR_BGR2YUV)</span><br><span class="line">    y, u, v = cv2.split(yuv_img)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y, u, v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yuv2bgr</span>(<span class="params">y, u, v</span>):</span></span><br><span class="line">    yuv_img = cv2.merge([y, u, v])</span><br><span class="line">    bgr_img = cv2.cvtColor(yuv_img, cv2.COLOR_YUV2BGR)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bgr_img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    orig_img = cv2.imread(<span class="string">&#x27;test.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    y, u, v = bgr2yuv(orig_img)</span><br><span class="line"></span><br><span class="line">    bgr_img = yuv2bgr(y, u, v)</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;orig_img&#x27;</span>, orig_img)</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Y channel&#x27;</span>, y)</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;U channel&#x27;</span>, u)</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;V channel&#x27;</span>, v)</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;bgr_img&#x27;</span>, bgr_img)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>通过下面的命令来执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 convert.py</span><br></pre></td></tr></table></figure>

<p>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=3obyzp09lomco">https://cloud.tencent.com/developer/support-plan?invite_code=3obyzp09lomco</a></p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
        <tag>总结</tag>
        <tag>C++</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>更新Faster-RCNN代码到最新版的caffe</title>
    <url>/2017/11/15/py-faster-rcnn-update/</url>
    <content><![CDATA[<p>因为CuDNN函数接口更新的原因，以前用低版本写的项目在新版本的CuDNN环境下编译就会出问题。例如，<a href="https://github.com/rbgirshick/py-faster-rcnn">py-faster-rcnn</a>代码在最新版的CuDNN6上面编译时就会报错。<br>解决这个问题的一个方法是禁用CUDNN，即修改<code>Makefile.config</code>里面的第5行，在前面加<code>#</code>。这种方法没法使用CuDNN加速，不推荐。这里我们使用一种比较土的方法，即将使用了旧的CuDNN函数的文件都换成新的caffe里面的文件即可。  </p>
<span id="more"></span>

<p>将所有要修改的文件和命令写在下面这个bash文件里，只要修改<code>CAFFE_ROOT</code> 和<code>CAFFE_FAST_RCNN</code>的值，然后调用这个bash文件就可以用了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set path of lastest caffe and caffe in py-faster-rcnn                                                                                                                                                                                                                        </span></span><br><span class="line">CAFFE_ROOT=/data1/public/caffe                                                                                                                                                                                                                                                 </span><br><span class="line">CAFFE_FAST_RCNN=/data6/yunfeng/py-faster-rcnn/caffe-fast-rcnn                                                                                                                                                                                                                  </span><br><span class="line">                                                                                                                                                                                                                                                                               </span><br><span class="line"><span class="comment"># copy head files                                                                                                                                                                                                                                                              </span></span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/include/caffe/util/cudnn.hpp <span class="variable">$CAFFE_FAST_RCNN</span>/include/caffe/util/cudnn.hpp                                                                                                                                                                                      </span><br><span class="line">                                                                                                                                                                                                                                                                               </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/include/caffe/layers/cudnn_conv_layer.hpp <span class="variable">$CAFFE_FAST_RCNN</span>/include/caffe/layers/cudnn_conv_layer.hpp                                                                                                                                                            </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/include/caffe/layers/cudnn_lcn_layer.hpp <span class="variable">$CAFFE_FAST_RCNN</span>/include/caffe/layers/cudnn_lcn_layer.hpp                                                                                                                                                              </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/include/caffe/layers/cudnn_lrn_layer.hpp <span class="variable">$CAFFE_FAST_RCNN</span>/include/caffe/layers/cudnn_lrn_layer.hpp                                                                                                                                                              </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/include/caffe/layers/cudnn_pooling_layer.hpp <span class="variable">$CAFFE_FAST_RCNN</span>/include/caffe/layers/cudnn_pooling_layer.hpp                                                                                                                                                      </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/include/caffe/layers/cudnn_relu_layer.hpp <span class="variable">$CAFFE_FAST_RCNN</span>/include/caffe/layers/cudnn_relu_layer.hpp                                                                                                                                                            </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/include/caffe/layers/cudnn_sigmoid_layer.hpp <span class="variable">$CAFFE_FAST_RCNN</span>/include/caffe/layers/cudnn_sigmoid_layer.hpp                                                                                                                                                      </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/include/caffe/layers/cudnn_softmax_layer.hpp <span class="variable">$CAFFE_FAST_RCNN</span>/include/caffe/layers/cudnn_softmax_layer.hpp                                                                                                                                                      </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/include/caffe/layers/cudnn_tanh_layer.hpp <span class="variable">$CAFFE_FAST_RCNN</span>/include/caffe/layers/cudnn_tanh_layer.hpp                                                                                                                                                            </span><br><span class="line">                                                                                                                                                                                                                                                                               </span><br><span class="line"><span class="comment"># copy cpp files                                                                                                                                                                                                                                                               </span></span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/src/caffe/layers/cudnn_conv_layer.cpp <span class="variable">$CAFFE_FAST_RCNN</span>/src/caffe/layers/cudnn_conv_layer.cpp                                                                                                                                                                    </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/src/caffe/layers/cudnn_lcn_layer.cpp <span class="variable">$CAFFE_FAST_RCNN</span>/src/caffe/layers/cudnn_lcn_layer.cpp                                                                                                                                                                      </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/src/caffe/layers/cudnn_lrn_layer.cpp <span class="variable">$CAFFE_FAST_RCNN</span>/src/caffe/layers/cudnn_lrn_layer.cpp                                                                                                                                                                      </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/src/caffe/layers/cudnn_pooling_layer.cpp <span class="variable">$CAFFE_FAST_RCNN</span>/src/caffe/layers/cudnn_pooling_layer.cpp                                                                                                                                                              </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/src/caffe/layers/cudnn_relu_layer.cpp <span class="variable">$CAFFE_FAST_RCNN</span>/src/caffe/layers/cudnn_relu_layer.cpp                                                                                                                                                                    </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/src/caffe/layers/cudnn_sigmoid_layer.cpp <span class="variable">$CAFFE_FAST_RCNN</span>/src/caffe/layers/cudnn_sigmoid_layer.cpp                                                                                                                                                              </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/src/caffe/layers/cudnn_softmax_layer.cpp <span class="variable">$CAFFE_FAST_RCNN</span>/src/caffe/layers/cudnn_softmax_layer.cpp                                                                                                                                                              </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/src/caffe/layers/cudnn_tanh_layer.cpp <span class="variable">$CAFFE_FAST_RCNN</span>/src/caffe/layers/cudnn_tanh_layer.cpp                                                                                                                                                                    </span><br><span class="line">                                                                                                                                                                                                                                                                               </span><br><span class="line"><span class="comment"># copy cu files                                                                                                                                                                                                                                                                </span></span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/src/caffe/layers/cudnn_conv_layer.cu <span class="variable">$CAFFE_FAST_RCNN</span>/src/caffe/layers/cudnn_conv_layer.cu                                                                                                                                                                      </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/src/caffe/layers/cudnn_lcn_layer.cu <span class="variable">$CAFFE_FAST_RCNN</span>/src/caffe/layers/cudnn_lcn_layer.cu                                                                                                                                                                        </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/src/caffe/layers/cudnn_lrn_layer.cu <span class="variable">$CAFFE_FAST_RCNN</span>/src/caffe/layers/cudnn_lrn_layer.cu                                                                                                                                                                        </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/src/caffe/layers/cudnn_pooling_layer.cu <span class="variable">$CAFFE_FAST_RCNN</span>/src/caffe/layers/cudnn_pooling_layer.cu                                                                                                                                                                </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/src/caffe/layers/cudnn_relu_layer.cu <span class="variable">$CAFFE_FAST_RCNN</span>/src/caffe/layers/cudnn_relu_layer.cu                                                                                                                                                                      </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/src/caffe/layers/cudnn_sigmoid_layer.cu <span class="variable">$CAFFE_FAST_RCNN</span>/src/caffe/layers/cudnn_sigmoid_layer.cu                                                                                                                                                                </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/src/caffe/layers/cudnn_softmax_layer.cu <span class="variable">$CAFFE_FAST_RCNN</span>/src/caffe/layers/cudnn_softmaxlayer.cu                                                                                                                                                                 </span><br><span class="line">cp <span class="variable">$CAFFE_ROOT</span>/src/caffe/layers/cudnn_tanh_layer.cu <span class="variable">$CAFFE_FAST_RCNN</span>/src/caffe/layers/cudnn_tanh_layer.cu                                                                                                                                                                      </span><br><span class="line">                                                                                                                                                                                                                                                                               </span><br><span class="line">                                                                                                                                                                                                                                                                               </span><br><span class="line"><span class="comment"># update source code using v3 of cudnn                                                                                                                                                                                                                                         </span></span><br><span class="line">sed -i <span class="string">&#x27;s/cudnnConvolutionBackwardData_v3/cudnnConvolutionBackwardData/g&#x27;</span> <span class="variable">$CAFFE_FAST_RCNN</span>/src/caffe/layers/cudnn_conv_layer.cu                                                                                                                                                </span><br><span class="line">sed -i <span class="string">&#x27;s/cudnnConvolutionBackwardFilter_v3/cudnnConvolutionBackwardFilter/g&#x27;</span> <span class="variable">$CAFFE_FAST_RCNN</span>/src/caffe/layers/cudnn_conv_layer.cu    </span><br></pre></td></tr></table></figure>
<p>最后的两行是修改<code>src/caffe/layers/cudnn_conv_layer.cu</code>,将其中的<code>cudnnConvolutionBackwardData_v3</code> 替换为<code>cudnnConvolutionBackwardData</code>，将<code>cudnnConvolutionBackwardFilter_v3</code>替换为<code>cudnnConvolutionBackwardFilter</code>。<br>我已经将上述的脚本放到了GitHub上，可以从<a href="https://github.com/vra/update-cudnn-of-py-faster-rcnn">这里</a>下载，下载后修改<code>CAFFE_ROOT</code> 和<code>CAFFE_FAST_RCNN</code>的路径，就可以直接运行脚本，修改文件了。  </p>
<p>然后重新make, make pycaffe 即可。<br>参考：<br><a href="http://www.cnblogs.com/klitech/p/7651825.html">http://www.cnblogs.com/klitech/p/7651825.html</a></p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
        <tag>Caffe</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5 代码片段集合</title>
    <url>/2018/01/13/pyqt5-code-snippets/</url>
    <content><![CDATA[<p>PyQt5是Qt的Python绑定库，既有Qt的强大，又有Python语言的简洁，要实现一个实际场景的GUI程序的时候，确实非常实用而且代码量不是太多。这里我总结了最近写一个界面时用到的代码片段，希望以后用到的时候能及时拾起来，也希望能帮助到别人。 此外我将这个内容也放到<a href="https://github.com/vra/pyqt5-code-snippets/blob/master/pyqt_code_snippets.md">GitHub</a>上，有兴趣的同学可以收藏下。</p>
<span id="more"></span>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>目前PyQt主要是4和5版本，因为两者不兼容，因此官方建议使用PyQt5, 这里以Python3 为例进行说明。PyQt5通过pip3来安装，同时别忘了需要安装SIP，这是将Python代码转换为C或C++代码的工具。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install PyQt5 SIP</span><br></pre></td></tr></table></figure>
<p>安装好后可以使用下面这个代码片段测试安装是否成功，如果可以正常运行说明安装已经成功：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtCore, QtWidgets</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QMainWindow, QLabel, QGridLayout, QWidget</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> QSize    </span><br><span class="line">     </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWindow</span>(<span class="params">QMainWindow</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line"> </span><br><span class="line">        self.setMinimumSize(QSize(<span class="number">640</span>, <span class="number">480</span>))    </span><br><span class="line">        self.setWindowTitle(<span class="string">&quot;Hello world&quot;</span>) </span><br><span class="line">        </span><br><span class="line">        centralWidget = QWidget(self)          </span><br><span class="line">        self.setCentralWidget(centralWidget)   </span><br><span class="line"> </span><br><span class="line">        gridLayout = QGridLayout(self)     </span><br><span class="line">        centralWidget.setLayout(gridLayout)  </span><br><span class="line"> </span><br><span class="line">        title = QLabel(<span class="string">&quot;Hello World from PyQt&quot;</span>, self) </span><br><span class="line">        title.setAlignment(QtCore.Qt.AlignCenter) </span><br><span class="line">        gridLayout.addWidget(title, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = QtWidgets.QApplication(sys.argv)</span><br><span class="line">    mainWin = HelloWindow()</span><br><span class="line">    mainWin.show()</span><br><span class="line">    sys.exit( app.exec_() )</span><br></pre></td></tr></table></figure>

<h3 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> QDir, Qt, QUrl, QObject</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtMultimedia <span class="keyword">import</span> QMediaContent, QMediaPlayer</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtMultimediaWidgets <span class="keyword">import</span> QVideoWidget</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QApplication, QFileDialog, QHBoxLayout, QLabel,</span><br><span class="line">        QPushButton, QSizePolicy, QSlider, QStyle, QVBoxLayout, QWidget,</span><br><span class="line">        QGridLayout, QFileDialog,QMainWindow,QWidget, QPushButton, QAction,</span><br><span class="line">        QSplitter, QFrame)</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QIcon, QFont</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>(<span class="params">QMainWindow</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, numCam=<span class="number">6</span>, parent=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ReIDDemo, self).__init__(parent)</span><br><span class="line">        self.setWindowTitle(<span class="string">&quot;Video Person Re-ID Demo&quot;</span>)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    <span class="comment">#app.setFont(QFont(&quot;Consolas&quot;, 10))</span></span><br><span class="line">    demo = Demo(numCam=<span class="number">6</span>)</span><br><span class="line">    <span class="comment">#demo.resize(1200, 800)</span></span><br><span class="line">    demo.setGeometry(<span class="number">400</span>, <span class="number">30</span>, <span class="number">1200</span>, <span class="number">1000</span>)</span><br><span class="line">    demo.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>

<p>下面就是各个组件的使用方式，只列出了一些常用的功能，别的功能还得在使用的时候再查找。  </p>
<h3 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">btn = QPushButton()</span><br><span class="line">btnsetEnabled(<span class="literal">False</span>)</span><br><span class="line">btn.SetText(<span class="string">&quot;Open&quot;</span>)</span><br><span class="line">btn.setStyleSheet(<span class="string">&#x27;&#123;background-color: #A3C1DA; color: red;&#125;&#x27;</span>)</span><br><span class="line">lbl.setFont(QFont(<span class="string">&quot;Consolas&quot;</span>, <span class="number">12</span>))</span><br><span class="line">btn.clicked.connect(func)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lbl = QLabel()</span><br><span class="line">lbl.setText(<span class="string">&#x27;Information&#x27;</span>)</span><br><span class="line">lbl.setText(<span class="string">&quot;&lt;font color=&#x27;red&#x27;&gt;Information&lt;/font&gt;&quot;</span>)</span><br><span class="line">lbl.setFont(QFont(<span class="string">&quot;Consolas&quot;</span>, <span class="number">12</span>))</span><br></pre></td></tr></table></figure>

<h3 id="Slider"><a href="#Slider" class="headerlink" title="Slider"></a>Slider</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">positonSlider = QSlider(Qt.Horizontal)</span><br><span class="line">positonSlider.setRange(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">positonSlider.sliderMoved.connect(setPosition)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setPosition</span>(<span class="params">position</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="MediaPlayer"><a href="#MediaPlayer" class="headerlink" title="MediaPlayer"></a>MediaPlayer</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">player = QMediaPlayer(<span class="literal">None</span>, QMediaPlayer.VideoSurface)</span><br><span class="line">VideoWidget = QVideoWidget()</span><br><span class="line">player.setVideoOutput(VideoWidget)</span><br><span class="line">player.stateChanged.connect(playerStateChanged)</span><br><span class="line">player.positionChanged.connect(playerPositionChanged)</span><br><span class="line">player.durationChanged.connect(playerDurationChanged)</span><br><span class="line">player.setMedia(QMediaContent(QUrl.fromLocalFile(<span class="string">&quot;/home/user/a.mp4&quot;</span>])))</span><br><span class="line">player.play()   <span class="comment"># 开始播放</span></span><br><span class="line">player.pause()  <span class="comment"># 暂停播放</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">playerStateChanged</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">playerPositionChanged</span>(<span class="params">position</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">playerDurationChanged</span>(<span class="params">duration</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="FileDialog"><a href="#FileDialog" class="headerlink" title="FileDialog"></a>FileDialog</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = QFileDialog.getOpenFileName(self, <span class="string">&quot;Open Query Video&quot;</span>, <span class="string">&#x27;d:/3rd&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> names[<span class="number">0</span>]:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">leftWidget = QFrame()</span><br><span class="line">leftWidget.setFrameShape(QFrame.StyledPanel)</span><br><span class="line">leftWidget.setLayout(left)</span><br></pre></td></tr></table></figure>

<h3 id="QHBoxLayout"><a href="#QHBoxLayout" class="headerlink" title="QHBoxLayout"></a>QHBoxLayout</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">controlLayout = QHBoxLayout()</span><br><span class="line">controlLayout.setContentsMargins(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">controlLayout.addWidget(btn)</span><br><span class="line">controlLayout.addWidget(slider)</span><br></pre></td></tr></table></figure>

<h3 id="QVBoxLayout"><a href="#QVBoxLayout" class="headerlink" title="QVBoxLayout"></a>QVBoxLayout</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">controlLayout = QVBoxLayout()</span><br><span class="line">controlLayout.setContentsMargins(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">controlLayout.addWidget(btn)</span><br><span class="line">controlLayout.addWidget(slider)</span><br></pre></td></tr></table></figure>

<h3 id="QGridLayout"><a href="#QGridLayout" class="headerlink" title="QGridLayout"></a>QGridLayout</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left = QGridLayout()</span><br><span class="line">left.setSpacing(<span class="number">10</span>)</span><br><span class="line">left.addWidget(lblQuery, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">left.addLayout(queryVideo.layout, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">left.addWidget(btnOpen, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">left.addWidget(btnSearch, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">left.addWidget(lblHold, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">left.setRowStretch(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">left.setRowStretch(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">left.setColumnStretch(<span class="number">1</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Splitter"><a href="#Splitter" class="headerlink" title="Splitter"></a>Splitter</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">leftWidget = QFrame()</span><br><span class="line">rightWidget = QFrame()</span><br><span class="line">spliter1 = QSplitter(Qt.Horizontal)</span><br><span class="line">spliter1.addWidget(leftWidget)</span><br><span class="line">spliter1.addWidget(rightWidget)</span><br></pre></td></tr></table></figure>

<h3 id="教程和资源"><a href="#教程和资源" class="headerlink" title="教程和资源"></a>教程和资源</h3><ol>
<li><a href="https://www.gitbook.com/book/maicss/pyqt5">PyQt5 中文教程</a>, 上手非常好的教程</li>
<li><a href="https://pythonprogramminglanguage.com/pyqt/">PyQt5 实例教程</a>, 实例很全面</li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>PyQt5</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Attentional Pooling for Action Recognition 论文阅读笔记</title>
    <url>/2018/01/20/paper-attentional-pooling/</url>
    <content><![CDATA[<p>这是2017年NIPS上的一篇做动作识别的论文，作者提出了second-order pooling的低秩近似attentional pooling，用其来代替CNN网络结构最后pooling层中常用的mean pooling或者max pooling, 在MPII, HICO和HMDB51三个动作识别数据集上进行了实验，都取得了很好的结果。此外作者还尝试了加入pose关键点的信息，再次提高了性能。下面我详细说明我对这篇论文的理解。</p>
<span id="more"></span>


<h3 id="论文概况"><a href="#论文概况" class="headerlink" title="论文概况"></a>论文概况</h3><ol>
<li>论文链接： <a href="https://arxiv.org/abs/1711.01467">Attentional Pooling for Action Recognition</a></li>
<li>代码链接：<a href="https://github.com/rohitgirdhar/AttentionalPoolingAction">https://github.com/rohitgirdhar/AttentionalPoolingAction</a>, 采用TensorFlow和Slim来实现。</li>
<li>作者介绍：<a href="http://rohitgirdhar.github.io/">Rohit Girdhar</a>, CMU 在读博士生，也是<a href="https://github.com/rohitgirdhar/ActionVLAD">ActionVLAD</a>的作者。</li>
</ol>
<h3 id="Second-order-pooling"><a href="#Second-order-pooling" class="headerlink" title="Second-order pooling"></a>Second-order pooling</h3><p>在CNN结构中，pooling层我们一般采用mean pooling或者max pooling，这两者都是一阶pooling (first-order pooling)， 因为mean和max操作都是对feature map进行一阶操作。而second-order pooling，顾名思义，就是对feature map进行二阶操作的pooling，而这里的二阶操作，根据论文[1]中的说明，是通过feature map中的每个向量与自身的转置求外积来实现的。second-order pooling也有mean和max之分，如下面的图所示:</p>
<p><img src="/imgs/o2p_mean.png" alt="Second-order mean pooling, 摘自 论文[1]"></p>
<p><img src="/imgs/o2p_max.png" alt="Second-order max pooling, 摘自 论文[1]"></p>
<p>一个很显然的问题是，second-order pooling比first-order pooling计算量要大，因为实际实现的时候，second-order pooling须用到矩阵相乘，计算量自然比矩阵求max或求mean要大。既然如此，那会为什么还有人用second-order pooling呢？这是因为研究者发现在语义分割和细分类问题中，二阶pooling效果更好，因此为了效果提升，在某些情况下增加一些计算量还是值得的。  </p>
<h3 id="Second-order-pooling的低秩近似"><a href="#Second-order-pooling的低秩近似" class="headerlink" title="Second-order pooling的低秩近似"></a>Second-order pooling的低秩近似</h3><p>对于二分类问题，作者推导出了采用second-order pooling后输出score的计算形式，如下： </p>
<p><img src="/imgs/eq2.png" alt="eq. 2"><br>然后，对权重矩阵<code>W</code>进行秩为1的近似，将其表示为2个向量<code>a</code>和<code>b</code>的转置的乘积，则经过如下的推导可以得出公式如下： </p>
<p><img src="/imgs/eq3_6.png" alt="eq. 3 - eq. 6"><br>其中公式 (4) 利用了迹的性质：<code>tr(ABC) = tr(CAB) = tr(BCA)</code>，公式 (5) 利用了性质：<code>标量的迹等于标量本身</code>。 进一步，公式 (6) 还可以调整为如下形式： </p>
<p><img src="/imgs/eq7_8.png" alt="eq. 7 - eq. 8"><br>可以看到，最后的得分可以分成两部分，前一部分是输入feature map <code>X</code>与向量<code>a</code>的乘积的转置，第二部分是输入feature map <code>X</code>和向量<code>b</code>的乘积。</p>
<h3 id="Top-down-attention-和-bottom-up-attention"><a href="#Top-down-attention-和-bottom-up-attention" class="headerlink" title="Top-down attention 和 bottom-up attention"></a>Top-down attention 和 bottom-up attention</h3><p>以上公式推导是针对二分类问题的，对于多分类问题，只需要将参数<code>W</code>变为针对每个类不同的<code>Wk</code>即可，公式如下：</p>
<p><img src="/imgs/eq9.png" alt="eq. 9"></p>
<p>对输入<code>X</code>，计算所有的<code>score(X, k), k=1, 2, ..., N，N为类别数</code>，寻找最大的score值，对应的<code>k</code>即为predict的类别。<br>同时，对<code>Wk</code>也可以进行一阶的近似，将其表示为<code>Wk = ak * b</code>，注意<code>ak</code>表示向量<code>a</code>是跟<code>k</code>有关的，而向量<code>b</code>是与类别<code>k</code>无关，因此公式 (8) 可以写成下面形式：<br><img src="/imgs/eq10.png" alt="eq. 10"></p>
<p>其中<code>tk</code>项是top-down attention而<code>h</code>项是bottom-up attention。作者这样分，也是受一篇2006年CVPR论文的启发，从下面的摘要可以看出(怀念750张图片就可以发CVPR的时代……)， top-down attention 是用目标驱动的方式来进行visual search，而 bottom-up 则是根据图像的显著性信息来进行visual search，这种分类方式也是受到人类视觉系统的启发。  </p>
<p><img src="/imgs/750_cvpr.png" alt="abstract of &quot;An Integrated Model of Top-Down and Bottom-Up Attention for Optimizing Detection Speed&quot;"><br>以上介绍的 top-down attention 和 bottom-up attention 合在一起就是 attentional pooling 的实现方式。</p>
<h3 id="Pose-regularized-attention"><a href="#Pose-regularized-attention" class="headerlink" title="Pose-regularized attention"></a>Pose-regularized attention</h3><p>除了提出 attentional pooling， 作者还提出利用人体姿态关键点对attention进行约束，实现方式就是在之前网络最后加了2个MLP来预测17通道的heat map，其中16个通道时人体姿态关键点，而最后一个通道是 bottom-up attention 的 feature map， 如下图右侧中的method 2所示。 通过最小化姿态关键点的loss和 attentional pooling的loss 的加权和，使得最后的网络更好地收敛到对应的动作类别。<br><img src="/imgs/fig1.png" alt="Framework"></p>
<h3 id="实验数据集说明"><a href="#实验数据集说明" class="headerlink" title="实验数据集说明"></a>实验数据集说明</h3><p>实验中采用了MPII， HICO 和 HMDB51 数据集。 需要注意的是， HMDB51 虽然是视频数据集，但是作者只在RGB数据上做了实验，而且对比的结果也只是只采用RGB数据的结果，因此在视频动作识别上最终的性能怎样，还有待验证。<br>MPII是德国马克斯·普朗克计算机科学研究所发布的图片数据集，具体的任务有人体姿态估计，动作识别等。数据集已经有人体姿态关键点的数据。包括的动作类别有393类，总共有15205张图片，其中训练集、验证集、测试集分别有8218、6987和5708张图片。<br><a href="http://www-personal.umich.edu/~ywchao/hico/">HICO</a>是一个人和物体交互的数据集，包括117类动作和80类物体，训练集和测试集分别有38116张图像和9658张图像。<br><a href="http://serre-lab.clps.brown.edu/resource/hmdb-a-large-human-motion-database/">HMDB51</a>是视频动作识别任务里面的一个数据集，包含6766个视频，共51类，每个视频长度3-10秒。<br>由于HICO和HMDB51都不包含人体姿态关键点的数据，因此实验中采用<a href="https://github.com/CMU-Perceptual-Computing-Lab/openpose">OpenPose</a>来提取人体关键点。<br><strong>值得注意的是，实验中作者将224px的HMDB51的图像缩放到了450px，这样来确保最后的feature map不至于太小（14x14）， 因为太小的feature map上attentional pooling的效果不是很显著。</strong></p>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><h4 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1. 网络结构"></a>1. 网络结构</h4><p>实验中，作者采用了Inception-V2和RestNet-101两种网络结构，对这两种网络分别进行了不加Attentional Pooling和加入Attentional pooling后的结果对比，发现在MPII数据集上，ResNet-101性能更好，而且加入了Attentional pooling后，性能有约4%的绝对提升。<br>作者分析，之所以ResNet-101比Inception-V2效果要好，是因为ResNet的结构中feature map的大小下降比较缓慢，因此后面的层能学到图像不同位置的信息，从而Attentional pooling带来的增益也越多；而Inception结构在前面层上将feature map变的很小，因此后面层的感受野看到的图像范围基本都一致了，因此Attentional pooling带来的增益很小。</p>
<h4 id="2-Attentional-pooling-和-Pose-带来的提升"><a href="#2-Attentional-pooling-和-Pose-带来的提升" class="headerlink" title="2. Attentional pooling 和 Pose 带来的提升"></a>2. Attentional pooling 和 Pose 带来的提升</h4><p>如论文中Table 1 所示，在MPII数据集上，ResNet-101的baseline的mAP是26.2%,加了Attentional pooling后mAP为30.3%，增加了Pose约束后mAP变为30.6%。可以看到pose的作用还是有一些的，但主要还是Attentional pooling的提升大些。在HICO数据集上，加了pose性能出现了下降（35.0% vs 34.6%）， 在HMDB51的RGB数据上，增加pose有提升。  </p>
<h4 id="3-和-full-rank-pooling的比较"><a href="#3-和-full-rank-pooling的比较" class="headerlink" title="3. 和 full-rank pooling的比较"></a>3. 和 full-rank pooling的比较</h4><p>所谓“full-rank pooling”, 就是指使用原来的二阶pooling，不进行矩阵低秩近似。作者提到，二阶pooling计算量太大，因此采用compact bilinear approach （CBP）来近似，并且采用别人的开源代码实现，没有怎么调整参数，结果比普通的mean pooling效果要差， 自然就比低秩近似的结果也更差了。感觉这里作者的对比方法不是太规范。</p>
<h4 id="4-P秩近似"><a href="#4-P秩近似" class="headerlink" title="4. P秩近似"></a>4. P秩近似</h4><p>我们知道低秩近似可以有很多中情况，最极端的情况就是1秩近似，即将一个矩阵分解为2个向量相乘，此外还有2秩，3秩近似。一般来说，P秩近似就是把矩阵分解为两个低秩矩阵，其中秩较大的矩阵的秩为P。论文中，对于秩为P的近似，作者采用P个bottom-up feature maps 和 C个 top-down feature maps 来相乘，这时候公式(6)就需要发生改变，Figure 1 中的<code>Xb</code>也变为P个，最后的结果通过对P个乘积进行求和得到。发现在秩为1，2，5的时候，在MPII数据集上的mAP分别为30.3, 29.2和30.0, 可见结果对不同的秩还是比较稳定的。</p>
<h3 id="代码实现分析"><a href="#代码实现分析" class="headerlink" title="代码实现分析"></a>代码实现分析</h3><p>作者将代码实现放到了<a href="https://github.com/rohitgirdhar/AttentionalPoolingAction">GitHub</a>上，但是只提供了MPII的数据和训练好的模型，HICO和HMDB51的数据和姿态关键点并没有提供，如果想好在这两个数据集上做实验需要自己提取关键点数据了。<br>代码采用TensorFlow 1.0 和Slim一起来实现，中间用到了compact_bilinear_pooling代码但是没有在教程中进行说明，需要在<code>src</code>目录下创建<code>lib</code>目录，自己下载<a href="https://github.com/ronghanghu/tensorflow_compact_bilinear_pooling">这里的代码</a>并放到lib目录下。<br>top-down attention 和 bottom-up attention 在<code>Project_Root/models/slim/nets/nets_factory.py</code>中300行左右实现，具体为如下两行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bottm-up attention</span></span><br><span class="line">end_points[<span class="string">&#x27;PosePrelogitsBasedAttention&#x27;</span>] = attention_logits</span><br><span class="line"><span class="comment"># top-down attention</span></span><br><span class="line">end_points[<span class="string">&#x27;TopDownAttention&#x27;</span>] = logits</span><br></pre></td></tr></table></figure>
<p>通过查看代码，发现作者也是用很简单的卷积来实现attentional pooling, 通过在Slim中提供的ResNet-101网络的最后面加入几个卷积层就能达到attentional pooling的效果。<br>另外我采用作者的代码复现的时候，发现自己训练的模型比他提供的训练好模型在验证集上的mAP测试结果要低约3个百分点，我只能达到27.6%， 而作者提供的模型能达到30.3%。原因暂时还没有找到。</p>
<h3 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h3><ol>
<li>作者论文中提到，为了验证方法的有效性，在视频数据集上进行了测试。但实际在做的时候，也只是在HMDB51的RGB数据上进行了实验，其实结果距离I3D等视频动作识别方法在RGB上的结果还是有较大差距的(52.2% vs 74.5%)， 有效性还有待验证。</li>
<li>作者只在最后面使用了一次attentional pooling， 如果将网络中所有的pooling都换为attentional pooling，效果是否会更好？</li>
</ol>
<h3 id="参考论文"><a href="#参考论文" class="headerlink" title="参考论文"></a>参考论文</h3><p>[1]. <a href="http://home.isr.uc.pt/~joaoluis/papers/eccv2012.pdf">Semantic Segmentation with Second-Order Pooling</a> </p>
]]></content>
      <tags>
        <tag>Deep Learning</tag>
        <tag>CNN</tag>
        <tag>Paper Reading</tag>
        <tag>Action Recognition</tag>
        <tag>Attention</tag>
      </tags>
  </entry>
  <entry>
    <title>python importlib用法小结</title>
    <url>/2022/05/28/python-importlib-usage/</url>
    <content><![CDATA[<p>在使用Python的时候，大部分时候引入包，都是通过<code>import</code> 语句，比如<code>import numpy as np</code>。有时候为了更复杂的需求，我们需要用<strong>程序化</strong>的方式来引入包 (Programmatic Importing), 比如根据输入不同，选择执行两个不同包里面的同名函数，这时候就需要用到<code>importlib</code>这个库了。这里先从一个简单例子开始，逐渐深入地讲一下这个库的用法。</p>
<span id="more"></span>

<h2 id="import-module用法"><a href="#import-module用法" class="headerlink" title="import_module用法"></a>import_module用法</h2><p><code>importlib</code>是Python3.1增加的系统库，其中最常用的函数是其中的<code>import_module</code>，功能是用程序语句的方式替代<code>import</code>语句，用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与 import time 效果一样</span></span><br><span class="line">time = importlib.import_module(<span class="string">&#x27;time&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(time.time())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与 import os.path as path 效果一样</span></span><br><span class="line">path = importlib.import_module(<span class="string">&#x27;os.path&#x27;</span>)</span><br><span class="line">path.join(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)  <span class="comment"># results: &#x27;a/b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相对引入, 一级目录，与 import os.path as path 效果一样</span></span><br><span class="line">path = importlib.import_module(<span class="string">&#x27;.path&#x27;</span>, package=<span class="string">&#x27;os&#x27;</span>)</span><br><span class="line">path.join(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)  <span class="comment"># results: &#x27;a/b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相对引入，二级目录，与 import os.path as path 效果一样</span></span><br><span class="line">path = importlib.import_module(<span class="string">&#x27;..path&#x27;</span>, package=<span class="string">&#x27;os.time&#x27;</span>)</span><br><span class="line">path.join(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)  <span class="comment"># results: &#x27;a/b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意最后的例子中，相对引入时需要在前面增加<code>.</code>或者<code>..</code>来表示相对目录，如果直接使用<code>importlib.import_module(&#39;path&#39;, package=&#39;os&#39;)</code>会报错。</p>
<p>如果光看这几个例子的话，貌似跟<code>import</code> 没什么区别，而且语句变得更复杂了，有点多此一举的感觉。</p>
<p>其实不是的，<strong>个人认为，<code>importlib</code>的强大之处是将<code>import</code>语句中写死的字面值改成了<code>import_module</code>函数中的参数，因此可以通过修改参数在外部用变量来控制实际import的包或者模块，大大地增加了灵活性。</strong> 下面会举一个稍微实用一些的例子。</p>
<h2 id="一个实际例子"><a href="#一个实际例子" class="headerlink" title="一个实际例子"></a>一个实际例子</h2><p>假设我们在设计一个深度学习工具库，里面包含了N个网络模型（ResNet50, HRNet, MobileNet等等），每个模型的实现都有一个<code>load_model</code>的函数。由于计算设备的性能不同，需要调用的网络结构也会变化，我们需要根据外部传入的参数来判断实际load哪一个模型。</p>
<p>虽然采用<code>import</code>语句+<code>if-else</code>判断也能完成这个需求，举例实现如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">model_name, <span class="built_in">input</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> model_name == <span class="string">&#x27;resnet_50&#x27;</span>:</span><br><span class="line">        <span class="keyword">from</span> resnet_50.model <span class="keyword">import</span> load_model</span><br><span class="line">    <span class="keyword">elif</span> model_name == <span class="string">&#x27;hrnet&#x27;</span>:</span><br><span class="line">        <span class="keyword">from</span> hrnet.model <span class="keyword">import</span> load_model</span><br><span class="line">    <span class="keyword">elif</span> model_name == <span class="string">&#x27;moblienet&#x27;</span>:</span><br><span class="line">        <span class="keyword">from</span> mobilenet.model <span class="keyword">import</span> load_model</span><br><span class="line"></span><br><span class="line">    model = load_model()</span><br><span class="line">    output = model(<span class="built_in">input</span>)</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<p>这种写法存在下面的两个问题：</p>
<ol>
<li>写法很冗余, N个模型的话需要添加2N条语句</li>
<li>新增模型时需要修改调用处的代码，添加对应的import语句，不符合模块化的要求。</li>
</ol>
<p>这时候采用<code>importlib</code>就能比较简洁地解决这个问题:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">model_name, <span class="built_in">input</span></span>):</span></span><br><span class="line">    load_model = importlib.import_module(<span class="string">&#x27;load_model&#x27;</span>, package=<span class="string">&#x27;&#123;&#125;.model&#x27;</span>.<span class="built_in">format</span>(model_name))</span><br><span class="line"></span><br><span class="line">    model = load_model()</span><br><span class="line">    output = model(<span class="built_in">input</span>)</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<p>可以看到在这种场景下<code>importlib</code>确实能大大简化代码。</p>
<p>了解这些内容，日常使用这个库就没什么问题了（好像<code>importlib</code>针对普通用户场景的函数貌似就只有<code>import_module</code>这一个），别的一些进阶的概念<del>在下个部分展开说一下</del>(由于不太懂，暂时不展开了)。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://docs.python.org/3/library/importlib.html">https://docs.python.org/3/library/importlib.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Multiprocessing使用Queue的例子</title>
    <url>/2022/05/16/python-multiprocessing-queue-example/</url>
    <content><![CDATA[<p>对于一些计算密集性的任务，使用Python的多进程能显著缩短运行的时间。例如对10个元素进行相同的操作，通过Python的<code>multiprocessing</code> 包可以进行并行化，实测能有数倍的速度提升。这里写一个简单的例子，将所有的结果写入队列，等队列拿到10个结果后，将结果写入文件。</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue, Process, Pool</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_queue</span>(<span class="params">q, i</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Begin process (<span class="subst">&#123;os.getpid()&#125;</span>)&#x27;</span>)</span><br><span class="line">    cur_value = i * i</span><br><span class="line"></span><br><span class="line">    q.put(cur_value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_queue</span>(<span class="params">q, num_sample</span>):</span></span><br><span class="line">    val_list = []</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        v = q.get(<span class="literal">True</span>)</span><br><span class="line">        val_list.append(v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(val_list) &gt;= num_sample:</span><br><span class="line">            np.save(<span class="string">&#x27;data.npy&#x27;</span>, np.array(val_list))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    NUM_PROCESS = <span class="number">10</span></span><br><span class="line">    q = Queue(NUM_PROCESS)</span><br><span class="line">    pws = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(NUM_PROCESS):</span><br><span class="line">        pw = Process(target=write_queue, args=(q, i))</span><br><span class="line">        pws.append(pw)</span><br><span class="line"></span><br><span class="line">    pr = Process(target=read_queue, args=(q, NUM_PROCESS))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> pw <span class="keyword">in</span> pws:</span><br><span class="line">        pw.start()</span><br><span class="line"></span><br><span class="line">    pr.start()</span><br><span class="line">    <span class="keyword">for</span> pw <span class="keyword">in</span> pws:</span><br><span class="line">        pw.join()</span><br><span class="line"></span><br><span class="line">    pr.terminate()</span><br><span class="line"></span><br><span class="line">    data = np.load(<span class="string">&#x27;data.npy&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>简单好用的英文拼写检查工具codespell</title>
    <url>/2022/09/22/python-spell-checking-codespell/</url>
    <content><![CDATA[<p>网上冲浪看到了一个简单好用的英语单词拼写检查工具 <a href="https://github.com/codespell-project/codespell">codespell</a>，测试发现真的好用，一键安装&amp;一键开箱使用，没有比这更美好的体验了，下面展开说下流程。</p>
<span id="more"></span>

<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>codespell 是用 Python 写的工具，因此直接使用pip安装即可:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install codespell</span><br></pre></td></tr></table></figure>
<p>输出应该类似如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Collecting codespell</span><br><span class="line">  Downloading codespell-2.2.1-py3-none-any.whl (202 kB)</span><br><span class="line">     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 202.1/202.1 kB 165.1 kB/s eta 0:00:00</span><br><span class="line">Installing collected packages: codespell</span><br><span class="line">Successfully installed codespell-2.2.1</span><br></pre></td></tr></table></figure>
<p>很简单。</p>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><p>进一个包含英文文本的目录，比如你的源码根目录，或者文档目录，然后执行<code>codespell</code>, 就会检查当前目录下所有的文本，给出可能的拼写错误。</p>
<p>例如我clone一个我的GitHub 仓库，进去执行<code>codespell</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/vra/easybox</span><br><span class="line"><span class="built_in">cd</span> easybox</span><br><span class="line">codespell</span><br></pre></td></tr></table></figure>
<p>输出结果如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./README.md:10: termial ==&gt; terminal</span><br><span class="line">./README.md:53: termial ==&gt; terminal</span><br><span class="line">./easybox/main.py:41: Mimimal ==&gt; Minimal</span><br></pre></td></tr></table></figure>

<p>可以看到，markdown文件和Python文件中的一些拼写错误都被找出来了。</p>
<p>除了这么直接使用外，还可以在命令后面增加一些目录和路径的限定，比如<code>*.md</code> 只检查当前目录下的<code>.md</code>文件，<code>folder</code> 只检查文件夹<code>folder</code>下的所有文件，等等，都是Linux下的基本操作。</p>
<h3 id="3-原理"><a href="#3-原理" class="headerlink" title="3. 原理"></a>3. 原理</h3><p>这个工具的大致原理是将英文单词容易出错的情况写到代码库的数据中，然后在代码中进行匹配，所以不会出现别的工具那样，对变量命名的误判断，这是一个很好的特性。具体实现细节就需要查看<a href="https://github.com/codespell-project/codespell">源码</a>了，有空或许可以分析一下，写一个源码解读哈哈。</p>
<p>上面这些内容，对于普通人日常使用基本是够用了，关于codespell更多高级的配置选项，请参考GitHub上的<a href="https://github.com/codespell-project/codespell">README</a>文件中的说明。</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>工具</tag>
        <tag>TIL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 字符串的format用法</title>
    <url>/2022/05/28/python-format/</url>
    <content><![CDATA[<h2 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h2><p>我有一个朋友，某天突然问我：你知道下面的Python语句什么含义，结果是多少吗？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#123;:😄^+#20_x&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">12345</span>)</span><br></pre></td></tr></table></figure>
<p>我一看，十脸懵逼，吓得赶紧学了学Python的Format字符串的用法，总算明白了这个语句的含义。你想了解这个语句到底是什么鬼吗，欢迎跟我一起学。</p>
<span id="more"></span>

<h2 id="2-整体说明"><a href="#2-整体说明" class="headerlink" title="2. 整体说明"></a>2. 整体说明</h2><p>Python的Format语法，可以用在两个场景：一个是<code>&#123;&#125;</code>.format中，另一个是f-string中，`f{xxx}’中，只不过后者支持外部定义的变量:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .format way 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello &#123;&#125;!&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;World&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># .format way 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello &#123;name&#125;!&#x27;</span>.<span class="built_in">format</span>(name=<span class="string">&#x27;World&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># f-string</span></span><br><span class="line">name = <span class="string">&#x27;World&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Hello <span class="subst">&#123;name&#125;</span>!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>为了应对更复杂的使用场景，Python设计了一套全面的语法，来涵盖所有的使用情况。具体来说，这套语法将一个Format 语句分成五部分，分别是:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;&quot;</span> [字段名称部分] [<span class="string">&quot;!&quot;</span> 格式转换部分] [<span class="string">&quot;:&quot;</span> 格式规范部分] <span class="string">&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p> 也就是左大括号和右大括号以及中间的核心三个部分, 其中方括号中的内容是可选的，也就是说最简单的format语法就是<code>&#123;&#125;</code>.format(‘xxx’)，会打印format后的第一个内容。</p>
<p> 下面分开看看核心的三个部分。</p>
<h2 id="字段名称部分"><a href="#字段名称部分" class="headerlink" title="字段名称部分"></a>字段名称部分</h2><p> 这一部分是用来定位要进行操作的变量。大括号中的编号对应这实际传入的参数，例如:<br> 采用关键字形式：<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;My name is &#123;name&#125;, I am &#123;age&#125; years old&#x27;</span>.<span class="built_in">format</span>(name=<span class="string">&#x27;Root&#x27;</span>, age=<span class="number">100</span>)</span><br><span class="line"><span class="comment"># My name is Root, I am 100 years old</span></span><br></pre></td></tr></table></figure><br> 这里的<code>&#123;name&#125;</code>对应format后面的关键字形式的参数name。</p>
<p> 另一种是使用参数序号：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;My name is &#123;0&#125;, I am &#123;1&#125; years old&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Root&#x27;</span>, <span class="number">100</span>)</span><br><span class="line"><span class="comment"># My name is Root, I am 100 years old</span></span><br></pre></td></tr></table></figure>
<p> 这里的<code>&#123;0&#125;</code>对应<code>Root</code>, <code>&#123;1&#125;</code> 对应100，如果有更多的参数的话，编号按顺序往下继续。</p>
<p> 注意这里的<code>&#123;idx&#125;</code>在字符串中可以出现任意次，且出现的顺序是任意的：<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#123;5&#125; &#123;5&#125; &#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line"><span class="comment"># f f c</span></span><br></pre></td></tr></table></figure></p>
<p>如果下标越界的话，会报错:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#123;5&#125; &#123;5&#125; &#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">IndexError: Replacement index <span class="number">5</span> out of <span class="built_in">range</span> <span class="keyword">for</span> positional args <span class="built_in">tuple</span></span><br></pre></td></tr></table></figure>

<p>另外一个特性是，可以忽略括号中的编号，这时候就按照从0开始的顺序来读取输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面的命令等效于 &#x27;My name is &#123;0&#125;, I am &#123;1&#125; years old&#x27;.format(&#x27;Root&#x27;, 100)</span></span><br><span class="line"><span class="string">&#x27;My name is &#123;&#125;, I am &#123;&#125; years old&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Root&#x27;</span>, <span class="number">100</span>)</span><br><span class="line"><span class="comment"># My name is Root, I am 100 years old</span></span><br></pre></td></tr></table></figure>

<p> 如果对复杂如列表或者字典，也可以使用下标或者属性来操作:<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 列表例子</span></span><br><span class="line">friends = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;&#123;0[0]&#125;&#x27;</span>.<span class="built_in">format</span>(friends)</span><br><span class="line"><span class="comment"># &#x27;foo`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典例子</span></span><br><span class="line">info = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Root&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">100</span>&#125;</span><br><span class="line"><span class="string">&#x27;&#123;0[name]&#125;&#x27;</span>.<span class="built_in">format</span>(info)</span><br><span class="line"><span class="comment"># &#x27;Root&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 属性对象例子</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">Person = namedtuple(<span class="string">&#x27;Person&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])</span><br><span class="line">p = Person(<span class="string">&#x27;Root&#x27;</span>, <span class="number">100</span>)</span><br><span class="line"><span class="string">&#x27;&#123;0.name&#125;&#x27;</span>.<span class="built_in">format</span>(p)</span><br><span class="line"><span class="comment"># &#x27;Root</span></span><br><span class="line">通过这些设置，能满足常见的需求。</span><br></pre></td></tr></table></figure></p>
<h2 id="3-格式转换部分"><a href="#3-格式转换部分" class="headerlink" title="3. 格式转换部分"></a>3. 格式转换部分</h2><p>这部分比较简单，在格式规范转换之前执行，通过感叹号加转换符号[r, s, a]之一，将原先的类型转换为字符串的类型，其中<code>!a</code> 表示对输入对象进行ascii()函数的调用，<code>!s</code>表示对输入对象进行str()函数的调用，而<code>!r</code>则调用repr()函数。</p>
<h2 id="4-格式规范部分"><a href="#4-格式规范部分" class="headerlink" title="4 格式规范部分"></a>4 格式规范部分</h2><p>这部分是format格式中的大头，包含很多项设置，但都是可选的，例如上面的例子中我们都没有设置这部分。关于这部分的规范下面我们一一道来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">format_spec     ::=  [[fill]align][sign][#][0][width][grouping_option][.precision][type]</span><br><span class="line">fill            ::=  &lt;any character&gt;</span><br><span class="line">align           ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;=&quot; | &quot;^&quot;</span><br><span class="line">sign            ::=  &quot;+&quot; | &quot;-&quot; | &quot; &quot;</span><br><span class="line">width           ::=  digit+</span><br><span class="line">grouping_option ::=  &quot;_&quot; | &quot;,&quot;</span><br><span class="line">precision       ::=  digit+</span><br><span class="line">type            ::=  &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-fill-和align-填充和对齐部分"><a href="#4-1-fill-和align-填充和对齐部分" class="headerlink" title="4.1 fill 和align: 填充和对齐部分"></a>4.1 fill 和align: 填充和对齐部分</h3><p>这部分包括填充和对齐，填充部分是任意的一个字符，如’+’, ‘*’, 或者😄。不设置的话，默认使用空格来填充。对齐方式包括下面四种:</p>
<ul>
<li>“&lt;”: 左对齐<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以空格左对齐，长度为10位</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:&lt;10&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.14</span>)</span><br><span class="line"><span class="string">&#x27;3.14      &#x27;</span></span><br><span class="line"><span class="comment"># 以星号左对齐，长度为10位</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:*&lt;10&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.14</span>)</span><br><span class="line"><span class="string">&#x27;3.14******&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>“&gt;”：右对齐<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以空格右对齐，长度为10位</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:&gt;10&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.14</span>)</span><br><span class="line"><span class="string">&#x27;      3.14&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>“=”：只对数值类型使用，表示对齐强制放到正负号和数值之间<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以星号数值对齐，长度为10位</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:*=10&#125;&#x27;</span>.<span class="built_in">format</span>(-<span class="number">3.14</span>)</span><br><span class="line"><span class="string">&#x27;-*****3.14&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>“^”: 居中对齐<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:*^10&#125;&#x27;</span>.<span class="built_in">format</span>(-<span class="number">3.14</span>)</span><br><span class="line"><span class="string">&#x27;**-3.14***&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-sign-符号部分"><a href="#4-2-sign-符号部分" class="headerlink" title="4.2 sign: 符号部分"></a>4.2 sign: 符号部分</h3>这部分有三个选项；<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+ <span class="string">&quot;+&quot;</span>: 正负号都加符号</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:+&#125; &#123;1:+&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.14</span>, -<span class="number">3.14</span>)</span><br><span class="line"><span class="string">&#x27;+3.14 -3.14&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>“-“: 只有负数前面才加符号<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:-&#125; &#123;1:-&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.14</span>, -<span class="number">3.14</span>)</span><br><span class="line"><span class="string">&#x27;3.14 -3.14&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>“ “: 正数前面加空格，负数前面加负号<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0: &#125; &#123;1: &#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.14</span>, -<span class="number">3.14</span>)</span><br><span class="line"><span class="string">&#x27; 3.14 -3.14&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-3-进制表示位"><a href="#4-3-进制表示位" class="headerlink" title="4.3 #: 进制表示位"></a>4.3 #: 进制表示位</h3><p>使用<code>#</code>号结合不同的进制表示符号(下面详细展开)，会在进制前面增加对应的负号，如二进制前增加<code>0b</code>, 八进制前增加<code>0o</code>, 十六进制前增加<code>0x</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:#b&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">233</span>)</span><br><span class="line"><span class="string">&#x27;0b11101001&#x27;</span></span><br><span class="line"><span class="comment"># 八进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:#o&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">233</span>)</span><br><span class="line"><span class="string">&#x27;0o351&#x27;</span></span><br><span class="line"><span class="comment"># 十进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:#d&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">233</span>)</span><br><span class="line"><span class="string">&#x27;233&#x27;</span></span><br><span class="line"><span class="comment"># 十六进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:#x&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">233</span>)</span><br><span class="line"><span class="string">&#x27;0xe9</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-width-显示的字符长度"><a href="#4-4-width-显示的字符长度" class="headerlink" title="4.4 width: 显示的字符长度"></a>4.4 width: 显示的字符长度</h3><p>这一部分表示显示多少位字符，包括pad的字符位。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 总长度为10位，不足的部分用默认的符号补齐</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:10&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">233</span>)</span><br><span class="line"><span class="string">&#x27;       233&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-5-grouping-option-千位的标识符号"><a href="#4-5-grouping-option-千位的标识符号" class="headerlink" title="4.5 grouping_option: 千位的标识符号"></a>4.5 grouping_option: 千位的标识符号</h3><p>这部分表示千位的标识符号，有<code>,</code>和<code>\_</code>两种选择:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:10,&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">23333333</span>)</span><br><span class="line"><span class="string">&#x27;23,333,333&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:10_&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">23333333</span>)</span><br><span class="line"><span class="string">&#x27;23_333_333&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-6-precision-数值精度"><a href="#4-6-precision-数值精度" class="headerlink" title="4.6 .precision: 数值精度"></a>4.6 .precision: 数值精度</h3><p>这个表示浮点数的精度位数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:.3&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.14159</span>)</span><br><span class="line"><span class="string">&#x27;3.14&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-7-type-格式类型"><a href="#4-7-type-格式类型" class="headerlink" title="4.7 type: 格式类型"></a>4.7 type: 格式类型</h3><p>这部分表示最终的展示类型，共有下面这些类:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot;</span><br></pre></td></tr></table></figure>
<p>每种的解释如下:</p>
<ul>
<li>“b”: 二进制表示<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:b&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;1000</span></span><br></pre></td></tr></table></figure></li>
<li>“c”: 只支持整数，将其转换为对应的unicode符号<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:c&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">23</span>)</span><br><span class="line"><span class="string">&#x27;\x17&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>“d”: 十进制表示 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:d&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;8&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>“e”: 科学计数法，采用小写的e<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:e&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;8.000000e+00&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>“E”: 科学计数法，采用大写的E<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:E&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;8.000000E+00</span></span><br></pre></td></tr></table></figure></li>
<li>“f”: 浮点数表示<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:f&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;8.000000&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>“F”: 与”f”基本相同，除了将nan显示为NAN, inf显示为INF<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:F&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;8.000000&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>“g”: 通用数据格式<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:g&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;8&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>“G”: 通用数据格式<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:G&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;8&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>“n”: 数值格式<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:n&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;8&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>“o”: 八进制格式<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:o&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;10</span></span><br></pre></td></tr></table></figure></li>
<li>“s”: 只能对字符串使用,字符串类型，默认输出类型，可以忽略<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:s&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&#x27;www&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;www&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&#x27;www&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;www&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>“x”: 十六进制<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:#x&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;0x8&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>“X”: 十六进制，符号标识采用大写的X <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:#X&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;0X8&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>“%”: 只对数值类型使用，以百分比的形式显示<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:%&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;800.000000%&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:%&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">0.001</span>)</span><br><span class="line"><span class="string">&#x27;0.100000%&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-解答开头的神秘符号串"><a href="#5-解答开头的神秘符号串" class="headerlink" title="5. 解答开头的神秘符号串"></a>5. 解答开头的神秘符号串</h2><p>有了上面的知识，我们就可以解开文章开头的的神秘符号串了:</p>
<ol>
<li>以笑脸符号作为pad的字符，且居中对齐，总长为20个符号</li>
<li>在正数前面增加加号</li>
<li>显示为16进制，并且显示前面的进制标注符号<br>结果如下:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">&#x27;&#123;:😄^+#20_x&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">12345</span>)</span><br><span class="line"><span class="string">&#x27;😄😄😄😄😄😄+0x3039😄😄😄😄😄😄😄&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6. 参考"></a>6. 参考</h2><ol>
<li><a href="https://docs.python.org/3/library/string.html">https://docs.python.org/3/library/string.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中将图像切分为小的patch</title>
    <url>/2022/10/15/python-split-image-to-grid-patch/</url>
    <content><![CDATA[<h3 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h3><p>假如有张1000x1000的图像，我们要将它切成20x20的小patch，该怎么处理呢？<br>最简单的方法就是采用两重for循环，每次计算小patch对应的下标，在原图上进行crop:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">size = <span class="number">1000</span></span><br><span class="line">ncols = <span class="number">20</span></span><br><span class="line">nrows = <span class="number">20</span></span><br><span class="line">img = np.random.rand(size, size)</span><br><span class="line"></span><br><span class="line">patches = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size//ncols):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(size//nrows):</span><br><span class="line">		patch = img[ncols*i:ncols*(i+<span class="number">1</span>), nrows*j:nrows*(j+<span class="number">1</span>)]</span><br><span class="line">		patches.append(patch)</span><br><span class="line"></span><br><span class="line">patches = np.array(patches)</span><br></pre></td></tr></table></figure>

<p>但这样总共需要循环50*x50=2500次，而我们知道 Python 的 for 循环比较慢，因此整体开销还是比较大的，有没有更快的方式呢？</p>
<span id="more"></span>

<h3 id="reshape-swapaxes"><a href="#reshape-swapaxes" class="headerlink" title="reshape + swapaxes"></a>reshape + swapaxes</h3><p>搜索发现可以使用 reshape + swapaxes函数的组合来完成这个功能:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">size = <span class="number">1000</span></span><br><span class="line">ncols = <span class="number">20</span></span><br><span class="line">nrows = <span class="number">20</span></span><br><span class="line">img = np.random.rand(size, size)</span><br><span class="line"></span><br><span class="line">patches = img.reshape(size // ncols, ncols, -<span class="number">1</span>, nrows).swapaxes(<span class="number">1</span>, <span class="number">2</span>).reshape(-<span class="number">1</span>, ncols, nrows)</span><br></pre></td></tr></table></figure>

<p>完整对比代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">size = <span class="number">1000</span></span><br><span class="line">ncols = <span class="number">20</span></span><br><span class="line">nrows = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计100次耗时</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    img = np.random.rand(size, size)</span><br><span class="line">    t0 = time.time()</span><br><span class="line">    patches0 = img.reshape(size // ncols, ncols, -<span class="number">1</span>, nrows).swapaxes(<span class="number">1</span>, <span class="number">2</span>).reshape(-<span class="number">1</span>, ncols, nrows)</span><br><span class="line"></span><br><span class="line">    t1 = time.time()</span><br><span class="line">    d1 = t1 - t0</span><br><span class="line"></span><br><span class="line">    patches = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size//ncols):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(size//nrows):</span><br><span class="line">            patch = img[ncols*i:ncols*(i+<span class="number">1</span>), nrows*j:nrows*(j+<span class="number">1</span>)]</span><br><span class="line">            patches.append(patch)</span><br><span class="line"></span><br><span class="line">    patches1 = np.array(patches)</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    d2 = t2 - t1</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;time ratio:&#x27;</span>, d2/d1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;diff:&#x27;</span>, (patches0-patches1).<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure>

<p>实际测试对于1000x1000的图像，采用reshape + swapaxes 要比循环快大约4倍。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">time ratio: 4.684571428571428</span><br><span class="line">diff: 0.0</span><br><span class="line">time ratio: 4.806614785992218</span><br><span class="line">diff: 0.0</span><br><span class="line">time ratio: 4.696482035928144</span><br><span class="line">diff: 0.0</span><br><span class="line">time ratio: 3.00382226469183</span><br><span class="line">diff: 0.0</span><br><span class="line">time ratio: 3.710854363028276</span><br><span class="line">diff: 0.0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<h3 id="Pytorch中的实现？"><a href="#Pytorch中的实现？" class="headerlink" title="Pytorch中的实现？"></a>Pytorch中的实现？</h3><p>Pytorch相比numpy，又增加了许多操作tensor的函数，因此实现方式会更多，这里大概列一下几种实现，具体函数可以查询 Pytorch 的文档:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">patches1 = img.unfold(<span class="number">0</span>, ncols, nrows).unfold(<span class="number">1</span>, ncols, nrows).reshape(-<span class="number">1</span>, ncols, nrows)</span><br><span class="line">patches2 = img.reshape(size//ncols, ncols, -<span class="number">1</span>, nrows).swapaxes(<span class="number">1</span>, <span class="number">2</span>).reshape(-<span class="number">1</span>, ncols, nrows)</span><br><span class="line">patches3 = img.reshape(size//ncols, ncols, -<span class="number">1</span>, nrows).permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>).reshape(-<span class="number">1</span>, ncols, nrows)</span><br></pre></td></tr></table></figure>

<h3 id="其他相关操作"><a href="#其他相关操作" class="headerlink" title="其他相关操作"></a>其他相关操作</h3><p>ShuffleNet中的ShuffleBlock中的channel shuffle也是通过reshape+维度变换来完成的，可以参考<a href="https://github.com/MegEngine/Models/blob/master/official/vision/classification/shufflenet/model.py#L98">这里</a> 和<a href="https://iq.opengenus.org/shufflenet-implementation-using-pytorch/">这里</a>的实现。</p>
<p>另外之前一篇做分割的论文<a href="https://arxiv.org/abs/1702.08502">DUC</a>里面也用到了类似的把图像特征重排列来Upsample的操作，<a href="https://github.com/ycszen/pytorch-segmentation/blob/master/duc.py#L18">搜索了下</a>对应的实现，是用Pytorch的PixelShuffle来做的，具体用法参考<a href="https://pytorch.org/docs/stable/generated/torch.nn.PixelShuffle.html">文档</a>，还有个匹配的PixelUnShuffle来进行逆向操作。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://stackoverflow.com/questions/16856788/slice-2d-array-into-smaller-2d-arrays/16858283#16858283">https://stackoverflow.com/questions/16856788/slice-2d-array-into-smaller-2d-arrays/16858283#16858283</a></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch模型转ONNX时cross操作不支持的解决方法</title>
    <url>/2022/03/20/pytorch-cross-to-onnx/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Pytorch很灵活，支持各种OP和Python的动态语法。但是转换到onnx的时候，有些OP（目前）并不支持，比如<code>torch.cross</code>。这里以一个最小化的例子来演示这个过程，以及对应的解决办法。</p>
<span id="more"></span>

<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>考虑下面这个简单的Pytorch转ONNX的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file name: pytorch_cross_to_onnx.py</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModel</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MyModel, self).__init__()</span><br><span class="line">        self.conv = nn.Conv2d(<span class="number">3</span>, <span class="number">10</span>, <span class="number">3</span>, stride=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = torch.cross(x, x)</span><br><span class="line">        y = self.conv(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = MyModel()</span><br><span class="line"></span><br><span class="line">dummy_input = torch.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>, device=<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">input_names = [<span class="string">&quot;x&quot;</span>]</span><br><span class="line">output_names = [<span class="string">&quot;y&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># opset_version 选择范围：[7,15]</span></span><br><span class="line">torch.onnx.export(</span><br><span class="line">    model,</span><br><span class="line">    dummy_input,</span><br><span class="line">    <span class="string">&quot;my_model.onnx&quot;</span>,</span><br><span class="line">    input_names=input_names,</span><br><span class="line">    output_names=output_names,</span><br><span class="line">    opset_version=<span class="number">14</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>运行这个脚本，会报下面的错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 pytorch_cross_to_onnx.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;pytorch_cross.py&quot;</span>, line 25, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    torch.onnx.export(model, dummy_input, <span class="string">&quot;my_model.onnx&quot;</span>, input_names=input_names, output_names=output_names, opset_version=14)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/__init__.py&quot;</span>, line 320, <span class="keyword">in</span> <span class="built_in">export</span></span><br><span class="line">    custom_opsets, enable_onnx_checker, use_external_data_format)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/utils.py&quot;</span>, line 111, <span class="keyword">in</span> <span class="built_in">export</span></span><br><span class="line">    custom_opsets=custom_opsets, use_external_data_format=use_external_data_format)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/utils.py&quot;</span>, line 729, <span class="keyword">in</span> _export</span><br><span class="line">    dynamic_axes=dynamic_axes)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/utils.py&quot;</span>, line 501, <span class="keyword">in</span> _model_to_graph</span><br><span class="line">    module=module)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/utils.py&quot;</span>, line 216, <span class="keyword">in</span> _optimize_graph</span><br><span class="line">    graph = torch._C._jit_pass_onnx(graph, operator_export_type)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/__init__.py&quot;</span>, line 373, <span class="keyword">in</span> _run_symbolic_function</span><br><span class="line">    <span class="built_in">return</span> utils._run_symbolic_function(*args, **kwargs)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/utils.py&quot;</span>, line 1028, <span class="keyword">in</span> _run_symbolic_function</span><br><span class="line">    symbolic_fn = _find_symbolic_in_registry(domain, op_name, opset_version, operator_export_type)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/utils.py&quot;</span>, line 982, <span class="keyword">in</span> _find_symbolic_in_registry</span><br><span class="line">    <span class="built_in">return</span> sym_registry.get_registered_op(op_name, domain, opset_version)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/symbolic_registry.py&quot;</span>, line 125, <span class="keyword">in</span> get_registered_op</span><br><span class="line">    raise RuntimeError(msg)</span><br><span class="line">RuntimeError: Exporting the operator cross to ONNX opset version 14 is not supported. Please feel free to request support or submit a pull request on PyTorch GitHub.</span><br></pre></td></tr></table></figure>
<p>注意最后一句的报错:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RuntimeError: Exporting the operator cross to ONNX opset version 14 is not supported. Please feel free to request support or submit a pull request on PyTorch GitHub.</span><br></pre></td></tr></table></figure>
<p>也就是说目前版本是不支持<code>torch.cross</code>转onnx的，同时提示你”feel free” 去Pytorch 的 GitHub 上提交/贡献一个转换操作。不过2020年03月就有人提了<a href="https://github.com/onnx/onnx/issues/2683">issue</a>，至今仍没有g官方的解决方案。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>上面的issue里有人给出了解决思路，就是用元素相乘替代<code>cross</code>操作。具体来说，实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_cross</span>(<span class="params">x, y, dim=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">assert</span> x.dim() == y.dim() <span class="keyword">and</span> dim &lt; x.dim()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> torch.stack(</span><br><span class="line">        (</span><br><span class="line">            x[:, <span class="number">1</span>, ...] * y[:, <span class="number">2</span>, ...] - x[:, <span class="number">2</span>, ...] * y[:, <span class="number">1</span>, ...],</span><br><span class="line">            x[:, <span class="number">2</span>, ...] * y[:, <span class="number">0</span>, ...] - x[:, <span class="number">0</span>, ...] * y[:, <span class="number">2</span>, ...],</span><br><span class="line">            x[:, <span class="number">0</span>, ...] * y[:, <span class="number">1</span>, ...] - x[:, <span class="number">1</span>, ...] * y[:, <span class="number">0</span>, ...],</span><br><span class="line">        ),</span><br><span class="line">        dim=dim,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p><strong>注意：这里是以dim=1为例写的实现，如果是在别的维度进行cross操作，需要修改dim参数，同时修改对应stack的维度。</strong></p>
<p>同时在Pytorch doc网站上看到，如果<code>torch.cross</code>不指定<code>dim</code>参数的话，默认是从前往后找第一个维度为3的维度，因此这个可能是你所不期望的，建议显式指定这个参数。</p>
<p>因此总结下来，下面是修改后的代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_cross</span>(<span class="params">x, y, dim=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">assert</span> x.dim() == y.dim() <span class="keyword">and</span> dim &lt; x.dim()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> torch.stack(</span><br><span class="line">        (</span><br><span class="line">            x[:, <span class="number">1</span>, ...] * y[:, <span class="number">2</span>, ...] - x[:, <span class="number">2</span>, ...] * y[:, <span class="number">1</span>, ...],</span><br><span class="line">            x[:, <span class="number">2</span>, ...] * y[:, <span class="number">0</span>, ...] - x[:, <span class="number">0</span>, ...] * y[:, <span class="number">2</span>, ...],</span><br><span class="line">            x[:, <span class="number">0</span>, ...] * y[:, <span class="number">1</span>, ...] - x[:, <span class="number">1</span>, ...] * y[:, <span class="number">0</span>, ...],</span><br><span class="line">        ),</span><br><span class="line">        dim=dim,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModel</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MyModel, self).__init__()</span><br><span class="line">        self.conv = nn.Conv2d(<span class="number">3</span>, <span class="number">10</span>, <span class="number">3</span>, stride=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># x = torch.cross(x, x)</span></span><br><span class="line">        x = my_cross(x, x)</span><br><span class="line">        y = self.conv(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = MyModel()</span><br><span class="line"></span><br><span class="line">dummy_input = torch.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>, device=<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">output = model(dummy_input)</span><br><span class="line">input_names = [<span class="string">&quot;x&quot;</span>]</span><br><span class="line">output_names = [<span class="string">&quot;y&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># opset_version 选择范围：[7,15]</span></span><br><span class="line">torch.onnx.export(</span><br><span class="line">    model,</span><br><span class="line">    dummy_input,</span><br><span class="line">    <span class="string">&quot;my_model.onnx&quot;</span>,</span><br><span class="line">    input_names=input_names,</span><br><span class="line">    output_names=output_names,</span><br><span class="line">    opset_version=<span class="number">14</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>为了验证我们的实现与Pytorch的实现是否一致，可以用下面的函数验证:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_torch_cross_and_my_cross</span>():</span></span><br><span class="line">    x = torch.randn(<span class="number">10</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">    y = torch.randn(<span class="number">10</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;my_cross == torch.cross:&quot;</span>, torch.allclose(torch.cross(x, y), my_cross(x, y)))</span><br></pre></td></tr></table></figure>
<p>执行后输出如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">my_cross == torch.cross: True</span><br></pre></td></tr></table></figure>
<p>说明这个实现是正确的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://github.com/onnx/onnx/issues/2683">https://github.com/onnx/onnx/issues/2683</a></li>
<li><a href="https://pytorch.org/docs/stable/generated/torch.cross.html">https://pytorch.org/docs/stable/generated/torch.cross.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Deep Learning</tag>
        <tag>Pytorch</tag>
        <tag>ONNX</tag>
        <tag>Torchscript</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch使用交叉熵损失时的一个坑</title>
    <url>/2021/08/21/pytorch-cross-entropy/</url>
    <content><![CDATA[<p>在Pytorch里面使用交叉熵loss函数的时候，发现结果最是比较差，通过搜索才发现这样一段话：</p>
<blockquote>
<p>You should pass raw logits to nn.CrossEntropyLoss, since the function itself applies F.log_softmax and nn.NLLLoss() on the input.</p>
</blockquote>
<p>也就是用交叉熵损失的时候，不能在网络的最后用 <code>log_softmax</code> 或者 <code>Softmax</code>层，因为交叉熵损失相当与是 <code>log_softmax</code> + <code>NLLLos</code>的组合。</p>
<p>如果网络最后用了Softmax层的话，需要使用 <code>NLLLoss</code> 或者 <code>MSE loss</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><ol>
<li><a href="https://discuss.pytorch.org/t/logsoftmax-vs-softmax/21386/9">https://discuss.pytorch.org/t/logsoftmax-vs-softmax/21386/9</a></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Deep Learning</tag>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch 拟合多项式的例子</title>
    <url>/2022/06/26/pytorch-fit-polynomial/</url>
    <content><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Pytorch包含了Linear层，可以用来拟合<code>y = w * x + b</code> 形式的函数，其中<code>w</code>和<code>bias</code>就是Linear层的weights和bias。这里写个拟合一次多项式的简单demo，作为一个小实验。</p>
<span id="more"></span>

<h2 id="2-拟合一次多项式"><a href="#2-拟合一次多项式" class="headerlink" title="2. 拟合一次多项式"></a>2. 拟合一次多项式</h2><p>采用下面的代码，我们设计了一个包含一个线性层的网络，通过给它feed随机构造的数据(y = 1.233 * x + 0.988)，结合梯度下降算法和MSE loss惩罚函数，让它学习数据的构造参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    torch.manual_seed(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    model = Model()</span><br><span class="line">    model.train()</span><br><span class="line">    optimizer = optim.SGD(model.parameters(), lr=<span class="number">1e-2</span>)</span><br><span class="line"></span><br><span class="line">    w = <span class="number">1.233</span></span><br><span class="line">    b = <span class="number">0.988</span></span><br><span class="line">	num_iteration = <span class="number">5000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_iteration):</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        x = torch.rand(<span class="number">1</span>)</span><br><span class="line">        y = w * x + b</span><br><span class="line">        pred = model(x)</span><br><span class="line"></span><br><span class="line">        loss = F.mse_loss(y, pred)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name, param <span class="keyword">in</span> model.named_parameters():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>=<span class="subst">&#123;param.data.numpy().squeeze():<span class="number">.3</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>
<p>运行这个脚本的输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">linear.weight=1.233</span><br><span class="line">linear.bias=0.988</span><br></pre></td></tr></table></figure>
<p>可以看到，经过5000次的迭代，网络能成功地学习到数据构造过程中的w和b参数, 这个小网络现在可以用来替代线性回归机器学习算法了!</p>
<p>如果迭代周期太小则可能收敛不到我们预设的参数，可以手动修改迭代次数<code>num_iteration</code>为2000查看结果。</p>
<h2 id="3-如果重复Linear层会发生什么？"><a href="#3-如果重复Linear层会发生什么？" class="headerlink" title="3. 如果重复Linear层会发生什么？"></a>3. 如果重复Linear层会发生什么？</h2><p>如果我们把同一个linear层重复执行两次，会有什么结果呢？也就是网络定义修改如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p>这里调用了两次同一个linear层，因此相当于 <code>y = w * ( w * x + b) + b</code>，也就是一次forward更新两次参数，也可以理解成两个共享参数的线性层。<br>完整的示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    torch.manual_seed(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    model = Model()</span><br><span class="line">    model.train()</span><br><span class="line">    optimizer = optim.SGD(model.parameters(), lr=<span class="number">1e-2</span>)</span><br><span class="line"></span><br><span class="line">    w = <span class="number">1.233</span></span><br><span class="line">    b = <span class="number">0.988</span></span><br><span class="line">    num_iteration = <span class="number">5000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_iteration):</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        x = torch.rand(<span class="number">1</span>)</span><br><span class="line">        y = w * x + b</span><br><span class="line">        pred = model(x)</span><br><span class="line"></span><br><span class="line">        loss = F.mse_loss(y, pred)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name, param <span class="keyword">in</span> model.named_parameters():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>=<span class="subst">&#123;param.data.numpy().squeeze():<span class="number">.3</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>

<p>同样的，通过我们构造 y = 1.233 * x + 0.998的数据，带入 y = w * ( w * x + b) + b，可以得到一组解 <code>w=1.110, b=0.468</code>,这与我们网络运行得到的结果是一致的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">linear.weight=1.110</span><br><span class="line">linear.bias=0.468</span><br></pre></td></tr></table></figure>
<p>同时也有一个问题：为什么没得到w为负数的另一组解呢？这是因为我这里为了保证复现性，手动设置了随机数种子为1024，设置为别的值应该可以得到另一组参数，欢迎尝试。</p>
]]></content>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch Apple Silicon GPU 训练与测评</title>
    <url>/2022/05/19/pytorch-mps-benchmark/</url>
    <content><![CDATA[<p>今天中午看到Pytorch的官方博客发了Apple M1 芯片 GPU加速的文章，这是我期待了很久的功能，因此很兴奋，立马进行测试，结论是在MNIST上，速度与P100差不多，相比CPU提速1.7倍。当然这只是一个最简单的例子，不能反映大部分情况。这里详细记录操作的一步步流程，如果你也感兴趣，不妨自己上手一试。</p>
<span id="more"></span>

<h2 id="加速原理"><a href="#加速原理" class="headerlink" title="加速原理"></a>加速原理</h2><p>苹果有自己的一套GPU实现API Metal，而Pytorch此次的加速就是基于Metal，具体来说，使用苹果的Metal Performance Shaders（MPS）作为PyTorch的后端，可以实现加速GPU训练。MPS后端扩展了PyTorch框架，提供了在Mac上设置和运行操作的脚本和功能。MPS通过针对每个Metal GPU系列的独特特性进行微调的内核来优化计算性能。新设备在MPS图形框架和MPS提供的调整内核上映射机器学习计算图形和基元。</p>
<p>因此此次新增的的device名字是<code>mps</code>，使用方式与<code>cuda</code>类似，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">foo = torch.rand(<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>).to(<span class="string">&#x27;mps&#x27;</span>)</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&#x27;mps&#x27;</span>)</span><br><span class="line">foo = foo.to(device)</span><br></pre></td></tr></table></figure>

<p>是不是熟悉的配方，熟悉的味道？可以说是无门槛即可上手。</p>
<p>此外发现，Pytorch已经支持下面这些device了，确实出乎意料:</p>
<ul>
<li>cpu, cuda, ipu, xpu, mkldnn, opengl, opencl, ideep, hip, ve, ort, mps, xla, lazy, vulkan, meta, hpu</li>
</ul>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>为了使用这个实验特性，你需要满足下面三个条件：</p>
<ol>
<li>有一台配有Apple Silicon 系列芯片（M1, M1 Pro, M1 Pro Max, M1 Ultra)的Mac笔记本</li>
<li>安装了<strong>arm64</strong>位的Python</li>
<li>安装了最新的<code>nightly</code>版本的Pytorch </li>
</ol>
<p>第一个条件需要你自己来设法满足，这篇文章对它的达到没有什么帮助。</p>
<p>假设机器已经准备好。我们可以从<a href="https://docs.conda.io/en/latest/miniconda.html">这里</a>下载arm64版本的miniconda(文件名是<code>Miniconda3 macOS Apple M1 64-bit bash</code>)，基于它安装的Python环境就是arm64位的。下载和安装Minicoda的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-arm64.sh </span><br><span class="line">chmod +x Miniconda3-latest-MacOSX-arm64.sh </span><br><span class="line">./Miniconda3-latest-MacOSX-arm64.sh </span><br></pre></td></tr></table></figure>
<p>按照说明来操作即可，安装完成后，创建一个虚拟环境，通过检查<code>platform.uname()[4]</code>是不是为<code>arm64</code>来检查Python的架构:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --env --<span class="built_in">set</span> always_yes <span class="literal">true</span></span><br><span class="line">conda create -n try-mps python=3.8</span><br><span class="line">conda activate try-mps</span><br><span class="line">python -c <span class="string">&quot;import platform; print(platform.uname()[4])&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果最后一句命令的输出为<code>arm64</code>，说明Python版本OK，可以继续往下走了。  </p>
<p>第三步，安装nightly版本的Pytorch，在开启的虚拟环境中进行下面的操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m pip  install --pre torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/nightly/cpu</span><br></pre></td></tr></table></figure>
<p>执行完成后通过下面的命令检查MPS后端是否可用:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&quot;import torch;print(torch.backends.mps.is_built())&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果输出为<code>True</code>，说明MPS后端可用，可以继续往下走了。</p>
<h2 id="跑一个MNIST"><a href="#跑一个MNIST" class="headerlink" title="跑一个MNIST"></a>跑一个MNIST</h2><p>基于Pytorch官方的example中的MNIST例子，修改了来测试cpu和mps模式，代码如下:</p>
<figure class="highlight python"><figcaption><span>mark:85</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"><span class="keyword">from</span> torch.optim.lr_scheduler <span class="keyword">import</span> StepLR</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">32</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">        self.dropout1 = nn.Dropout(<span class="number">0.25</span>)</span><br><span class="line">        self.dropout2 = nn.Dropout(<span class="number">0.5</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">9216</span>, <span class="number">128</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">128</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = F.max_pool2d(x, <span class="number">2</span>)</span><br><span class="line">        x = self.dropout1(x)</span><br><span class="line">        x = torch.flatten(x, <span class="number">1</span>)</span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = self.dropout2(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        output = F.log_softmax(x, dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">args, model, device, train_loader, optimizer, epoch</span>):</span></span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        data, target = data.to(device), target.to(device)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(data)</span><br><span class="line">        loss = F.nll_loss(output, target)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span> batch_idx % args.log_interval == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch, batch_idx * <span class="built_in">len</span>(data), <span class="built_in">len</span>(train_loader.dataset),</span><br><span class="line">                <span class="number">100.</span> * batch_idx / <span class="built_in">len</span>(train_loader), loss.item()))</span><br><span class="line">            <span class="keyword">if</span> args.dry_run:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">model, device, test_loader</span>):</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">            data, target = data.to(device), target.to(device)</span><br><span class="line">            output = model(data)</span><br><span class="line">            test_loss += F.nll_loss(output, target, reduction=<span class="string">&#x27;sum&#x27;</span>).item()  <span class="comment"># sum up batch loss</span></span><br><span class="line">            pred = output.argmax(dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>)  <span class="comment"># get the index of the max log-probability</span></span><br><span class="line">            correct += pred.eq(target.view_as(pred)).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nTest set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\n&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        test_loss, correct, <span class="built_in">len</span>(test_loader.dataset),</span><br><span class="line">        <span class="number">100.</span> * correct / <span class="built_in">len</span>(test_loader.dataset)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># Training settings</span></span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&#x27;PyTorch MNIST Example&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--batch-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">64</span>, metavar=<span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;input batch size for training (default: 64)&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--test-batch-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1000</span>, metavar=<span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;input batch size for testing (default: 1000)&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--epochs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">4</span>, metavar=<span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;number of epochs to train (default: 14)&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--lr&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">1.0</span>, metavar=<span class="string">&#x27;LR&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;learning rate (default: 1.0)&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--gamma&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.7</span>, metavar=<span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Learning rate step gamma (default: 0.7)&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--no-cuda&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;disables CUDA training&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--use_gpu&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;enable MPS&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--dry-run&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;quickly check a single pass&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--seed&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1</span>, metavar=<span class="string">&#x27;S&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;random seed (default: 1)&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--log-interval&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">10</span>, metavar=<span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;how many batches to wait before logging training status&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--save-model&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;For Saving the current Model&#x27;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    use_gpu = args.use_gpu</span><br><span class="line"></span><br><span class="line">    torch.manual_seed(args.seed)</span><br><span class="line"></span><br><span class="line">    device = torch.device(<span class="string">&quot;mps&quot;</span> <span class="keyword">if</span> args.use_gpu <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line">    train_kwargs = &#123;<span class="string">&#x27;batch_size&#x27;</span>: args.batch_size&#125;</span><br><span class="line">    test_kwargs = &#123;<span class="string">&#x27;batch_size&#x27;</span>: args.test_batch_size&#125;</span><br><span class="line">    <span class="keyword">if</span> use_gpu:</span><br><span class="line">        cuda_kwargs = &#123;<span class="string">&#x27;num_workers&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                       <span class="string">&#x27;pin_memory&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">                       <span class="string">&#x27;shuffle&#x27;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">        train_kwargs.update(cuda_kwargs)</span><br><span class="line">        test_kwargs.update(cuda_kwargs)</span><br><span class="line"></span><br><span class="line">    transform=transforms.Compose([</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">        ])</span><br><span class="line">    dataset1 = datasets.MNIST(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>,</span><br><span class="line">                       transform=transform)</span><br><span class="line">    dataset2 = datasets.MNIST(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">False</span>,</span><br><span class="line">                       transform=transform)</span><br><span class="line">    train_loader = torch.utils.data.DataLoader(dataset1,**train_kwargs)</span><br><span class="line">    test_loader = torch.utils.data.DataLoader(dataset2, **test_kwargs)</span><br><span class="line"></span><br><span class="line">    model = Net().to(device)</span><br><span class="line">    optimizer = optim.Adadelta(model.parameters(), lr=args.lr)</span><br><span class="line"></span><br><span class="line">    scheduler = StepLR(optimizer, step_size=<span class="number">1</span>, gamma=args.gamma)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, args.epochs + <span class="number">1</span>):</span><br><span class="line">        train(args, model, device, train_loader, optimizer, epoch)</span><br><span class="line">        test(model, device, test_loader)</span><br><span class="line">        scheduler.step()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t0 = time.time()</span><br><span class="line">    main()</span><br><span class="line">    t1 = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;time_cost:&#x27;</span>, t1 - t0)</span><br></pre></td></tr></table></figure>
<p>测试CPU：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure>

<p>测试MPS:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python main --use_gpu</span><br></pre></td></tr></table></figure>
<p>在M1机器上测试发现，训一个Epoch的MNIST，CPU耗时33.4s，而使用MPS的话耗时19.6s，加速1.7倍，好像没官方博客中说的那么多，估计是跟模型太小有关。</p>
<p>我又在Nvidia P100 GPU服务器上进行了测试，CPU耗时34.2s，使用CUDA 耗时20.4s，加速比1.67倍，跟M1差不多，整体速度略低于M1。<br>下面是一个总结表格：</p>
<table>
<thead>
<tr>
<th>机器</th>
<th>内存</th>
<th>CPU耗时</th>
<th>GPU耗时</th>
<th>加速比</th>
</tr>
</thead>
<tbody><tr>
<td>M1</td>
<td>16G</td>
<td>33.4s</td>
<td>19.6s</td>
<td>1.70</td>
</tr>
<tr>
<td>P100</td>
<td>256G</td>
<td>34.2s</td>
<td>20.4s</td>
<td>1.67</td>
</tr>
</tbody></table>
<h2 id="跑一下VAE模型"><a href="#跑一下VAE模型" class="headerlink" title="跑一下VAE模型"></a>跑一下VAE模型</h2><p>类似地，跑一下这个仓库里面地VAE模型，发现CPU模式正常，换成MPS后loss不断增大，最后到nan，看来还是有bug的 (毕竟是实验特性)，可以在Pytorch GitHub 仓库里面提issue，期待更好的Pytorch。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[W ParallelNative.cpp:229] Warning: Cannot <span class="built_in">set</span> number of intraop threads after parallel work has started or after set_num_threads call when using native parallel backend (<span class="keyword">function</span> set_num_threads)</span><br><span class="line">Train Epoch: 1 [0/60000 (0%)]   Loss: 550.842529</span><br><span class="line">Train Epoch: 1 [1280/60000 (2%)]        Loss: 330.613251</span><br><span class="line">Train Epoch: 1 [2560/60000 (4%)]        Loss: 4705.016602</span><br><span class="line">Train Epoch: 1 [3840/60000 (6%)]        Loss: 183532752.000000</span><br><span class="line">...</span><br><span class="line">Train Epoch: 6 [40960/60000 (68%)]      Loss: nan</span><br><span class="line">Train Epoch: 6 [42240/60000 (70%)]      Loss: nan</span><br></pre></td></tr></table></figure>

<h2 id="一个愿景"><a href="#一个愿景" class="headerlink" title="一个愿景"></a>一个愿景</h2><p>开头提到，关注这个特性挺久了，其实我最初的想法，是希望一台普通计算设备（不带GPU的笔记本，智能手机）都能训非常快的模型。因为GPU卡很昂贵，只有科研机构和大公司才有，普通人购买成本比较高，而云服务商提供的GPU按时收费，价格不菲。另一方面，所有普通笔记本和智能手机都有不错的CPU，算力不错，如果能将这部分性能合理地利用起来，就像深度学习前的时代一样，有一台笔记本就能用MatLab快速地进行科学实验，这样才能将AI推广到更多人，将AI平民化，也避免了大公司在硬件资源上的垄断和显卡巨大的能耗。</p>
<p>今天的Mac GPU训练至少是在降低深度学习能耗和深度学习模型训练的”轻量化”上面有了一个大的进步，你可以抱着笔记本在床上训练改变AI模型了 😊 。但以Mac笔记的价格，很难说在平民化方向上有任何的进展。</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Pytorch</tag>
        <tag>GPU</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>python的列表推导式和生成器表达式对比</title>
    <url>/2022/05/22/python-list-comprehension-vs-generator-expression/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Python中的列表推倒式(List Comprehension) 和 生成器表达式（Generator Expression）是两种很相似的表达式，但含义却不大不同，这里做一个对比。</p>
<span id="more"></span>
<h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>列表推导式是比较常用的技术，能将本来需要<code>for</code> loop和<code>if else</code>语句的情况简化成一条指令，最终得到一个列表对象:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">even = [e <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>具体细节不过多展开，相信很多使用Python的人都已经足够了解这种语法了。</p>
<p>需要注意的一点是，列表推导式不是惰性计算 ( Lazy Loading) 的，因此所有的列表成员都在声明完语句后立即计算 (Eager Loading)，因此在数组成员很多的情况下，速度会很慢，例如下面的在IPython环境里面的三个列表推导式的耗时统计:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: %timeit even = [e <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>) <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="number">5.5</span> ms ± <span class="number">24.8</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">100</span> loops each)</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: %timeit even = [e <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>) <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="number">58.9</span> ms ± <span class="number">440</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">10</span> loops each)</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: %timeit even = [e <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>) <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="number">5.65</span> s ± <span class="number">26.5</span> ms per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1</span> loop each)</span><br></pre></td></tr></table></figure>
<p>可以看到随着元素个数的增加，列表推导式执行的时间也相应变长，占用的内存也会变大。</p>
<p>有一种情况是，我们定义了很多很多的数组元素，但是最后并不是所有的元素都能用到，例如经过几条命令，最后可能只有列表里面的前10个元素会用到，或者只有符合某些条件的元素会用到，这样的话，Eager模式就白白花费了时间，白白花费了内存来创建很多用不到的元素，这显然有很大的改进空间。</p>
<h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>生成器能表达式解决上面的问题，它的元素迭代是惰性的，因此只有需要的时候才生产出来，避免了额外的内存开销和时间开销: 生成器表达式不管元素数目多大，创建时都是常数时间，因为它并没有立即创建元素。</p>
<p>那么生成器表达式的语法是怎么样的呢，很简单，只需要把列表推导式中的方括号改为圆括号:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">even_gen = (e <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>注意它的类型是生成器类型:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span>(<span class="title">even_gen</span>)</span></span><br><span class="line"><span class="meta"># generator</span></span><br></pre></td></tr></table></figure>
<p>创建生成器表达式的耗时统计:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">In [1]: %timeit even_gen = (e <span class="keyword">for</span> e <span class="keyword">in</span> range(100000) <span class="keyword">if</span> e % 2 == 0)</span><br><span class="line">376 ns ± 2.61 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)</span><br><span class="line"></span><br><span class="line">In [2]: %timeit even_gen = (e <span class="keyword">for</span> e <span class="keyword">in</span> range(10000000) <span class="keyword">if</span> e % 2 == 0)</span><br><span class="line">382 ns ± 1.63 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)</span><br><span class="line"></span><br><span class="line">In [3]: %timeit even_gen = (e <span class="keyword">for</span> e <span class="keyword">in</span> range(1000000000) <span class="keyword">if</span> e % 2 == 0)</span><br><span class="line">384 ns ± 2.85 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)</span><br></pre></td></tr></table></figure>
<p>可以看到随着元素的增加，创建时间基本不变，而且比列表推导式的耗时要低不少。</p>
<h2 id="使用场景选择"><a href="#使用场景选择" class="headerlink" title="使用场景选择"></a>使用场景选择</h2><p>那么是不是就是说使用中可以用生成器表达式替代列表推导式了呢，也不尽然，因为列表推导式得到的是一个列表，很多便捷操作（如slice等）可以作用到上面，而生成器表达式则不行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: even = [e <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: even[:<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">18</span>]: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: even_gen = (e <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: even_gen[:<span class="number">3</span>]</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">Input In [<span class="number">20</span>], <span class="keyword">in</span> &lt;cell line: <span class="number">1</span>&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> even_gen[:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">TypeError: <span class="string">&#x27;generator&#x27;</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> subscriptable</span><br></pre></td></tr></table></figure>
<p>而且两者有一个致命的区别：生成器表达式只能迭代一次，而列表推导式可以使用很多次，举例如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">22</span>]: even_gen = (e <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: <span class="keyword">for</span> e <span class="keyword">in</span> even_gen:</span><br><span class="line">    ...:     <span class="built_in">print</span>(e)</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: <span class="keyword">for</span> e <span class="keyword">in</span> even_gen:</span><br><span class="line">    ...:     <span class="built_in">print</span>(e)</span><br><span class="line">    ...:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到生成器表达式在第二次迭代的时候，里面已经没有元素了！即第一次迭代已经全部生成出来了，而列表推导式是每次迭代都是有相同的内容:</p>
<figure class="highlight stan"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: even = [<span class="built_in">e</span> <span class="keyword">for</span> <span class="built_in">e</span> <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> <span class="built_in">e</span> % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: <span class="keyword">for</span> <span class="built_in">e</span> <span class="keyword">in</span> even:</span><br><span class="line">    ...:     <span class="built_in">print</span>(<span class="built_in">e</span>)</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: <span class="keyword">for</span> <span class="built_in">e</span> <span class="keyword">in</span> even:</span><br><span class="line">    ...:     <span class="built_in">print</span>(<span class="built_in">e</span>)</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>因此总结来说，</p>
<ul>
<li>如果要多次迭代时，建议使用列表推导式</li>
<li>如果数组很大或者有无穷个元素，建议使用生成器表达式</li>
<li>其他场景：两者均可，自己看情况使用一个，如果没有速度和方便度的问题即可，如果有问题换另一个再试试</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://stackoverflow.com/questions/47789/generator-expressions-vs-list-comprehensions">https://stackoverflow.com/questions/47789/generator-expressions-vs-list-comprehensions</a></li>
<li><a href="https://docs.python.org/3/howto/functional.html#generator-expressions-and-list-comprehensions">https://docs.python.org/3/howto/functional.html#generator-expressions-and-list-comprehensions</a></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python转换elif语句为列表推导式</title>
    <url>/2022/06/28/python-list-comprehension-with-elif/</url>
    <content><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>今天才发现，在Python的列表推导式里面，也可以使用多个else，也就是elif的情况，具体来说，可以将下面的一长串的elif 语句转换成一句列表推导式，大大简化代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> cond1:</span><br><span class="line">	do1</span><br><span class="line"><span class="keyword">elif</span> cond2:</span><br><span class="line">	do2</span><br><span class="line"><span class="keyword">elif</span> cond3:</span><br><span class="line">	do3</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	do4</span><br></pre></td></tr></table></figure>
<p>转换成列表推导式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = [do1 <span class="keyword">if</span> cond1 <span class="keyword">else</span> do2 <span class="keyword">if</span> cond2 <span class="keyword">else</span> do3 <span class="keyword">if</span> cond3 <span class="keyword">else</span> do4][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>Python喜爱值+1，代码行数-N。</p>
<span id="more"></span>

<h2 id="2-几个例子"><a href="#2-几个例子" class="headerlink" title="2. 几个例子"></a>2. 几个例子</h2><p>原先代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a &gt; <span class="number">10</span>:</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;large&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> a &gt; <span class="number">5</span>:</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;middle&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;small&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以转换为下面的形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = [<span class="string">&#x27;large&#x27;</span> <span class="keyword">if</span> a &gt; <span class="number">10</span> <span class="keyword">else</span> <span class="string">&#x27;middle&#x27;</span> <span class="keyword">if</span> a &gt; <span class="number">5</span> <span class="keyword">else</span> <span class="string">&#x27;small&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>任意多个elif都是可以的，下面的代码验证了两种写法结果是一致的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">if</span> a &gt; <span class="number">0.9</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> a &gt; <span class="number">0.7</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;b&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> a &gt; <span class="number">0.5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;c&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> a &gt; <span class="number">0.3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;d&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> a &gt;= <span class="number">0.1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;e&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span> <span class="keyword">if</span> a &gt; <span class="number">0.9</span> <span class="keyword">else</span> <span class="string">&#x27;b&#x27;</span> <span class="keyword">if</span> a &gt; <span class="number">0.7</span> <span class="keyword">else</span> <span class="string">&#x27;c&#x27;</span> <span class="keyword">if</span> a &gt; <span class="number">0.5</span> <span class="keyword">else</span> <span class="string">&#x27;d&#x27;</span> <span class="keyword">if</span> a &gt; <span class="number">0.3</span> <span class="keyword">else</span> <span class="string">&#x27;e&#x27;</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr = np.random.rand(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="built_in">print</span>(func1(a) == func2(a))</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>使用rdesktop来在Windows和Linux之间共享数据</title>
    <url>/2017/02/18/rdesktop-share-file/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><a href="http://www.rdesktop.org/">rdesktop</a>是一个开源的远程桌面客户端，用来从Linux机器连接到Windows机器。它遵循RDP协议（Remote Desktop Protocol），并且操作简洁，功能比较完备。</p>
<span id="more"></span>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在Debian发行版上，可以直接用<code>apt-get</code>命令安装:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install rdesktop</span><br></pre></td></tr></table></figure>
<p>别的发行版的安装方式请参看rdesktop项目的GitHub页面:<a href="https://github.com/rdesktop/rdesktop">https://github.com/rdesktop/rdesktop</a>。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>最简单的情况，如果你要连接到的Windows机器的IP地址是a.b.c.d, 需要以用户username登录，则可以这样运行rdesktop命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rdesktop -u username a.b.c.d</span><br></pre></td></tr></table></figure>
<p>如果你想直接在命令里面使用用户的登录密码，则使用<code>-p</code>选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rdesktop -u username a.b.c.d -p my-password</span><br></pre></td></tr></table></figure>
<p>如果你想设置登录后的窗口的大小，则采用<code>-g</code>选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rdesktop -u username a.b.c.d -p my-password -g 1200x900</span><br></pre></td></tr></table></figure>
<p>登录后你会感觉字体显示比较怪，看着很不舒服，可以使用<code>-x</code>选项来是字体变得光滑:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rdesktop -u username a.b.c.d -p my-password -g 1200x900 -x 0x80</span><br></pre></td></tr></table></figure>
<p>其中<code>0x80</code>还可以改为<code>0x81</code>, <code>0x8F</code>,分别表示LAN default mode， broadband default mode 和 modem default mode,为不同的”RDP5 experience”。<br>以上就是基本的连接选项，也可以通过运行<code>rdesktop -h</code>命令来查看所有选项。  </p>
<h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><p>一个常见的需求是在Windows和Linux系统上共享文件。Samba服务可以解决这个问题，但配置比较复杂。这里我们采用rdesktop来完成这个任务。<br>首先在Linux系统下创建一个目录，例如:<code>/home/username/Pictures</code>，然后在连接的时候采用<code>-r disk</code>选项来进行文件的共享：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rdesktop -u username a.b.c.d -p my-password -g 1200x900 -x 0x80 -r sound:<span class="built_in">local</span> -r disk:LinuxPictures=/home/username/Pictures</span><br></pre></td></tr></table></figure>
<p>这样在连接到Windows的时候，会在文件资源管理器里面，显示<code>LinuxPictures</code>目录。<br>这里有两个地方需要注意：</p>
<ol>
<li>命令中Linux目录的路径必须采用绝对路径，否则会出错。如上例中，将<code>/home/username/Pictures</code>改成<code>~/Pictures</code>则会报错。</li>
<li>为了正常工作，需要同时设置<code>-r sound:local</code>，虽然看起来好像没什么关系。关于这个问题的讨论见<a href="http://askubuntu.com/questions/74713/how-can-i-copy-paste-files-via-rdp-in-kubuntu">这里</a>和<a href="https://github.com/FreeRDP/Remmina/issues/243">这里</a>。</li>
</ol>
<p>设置好之后，就可以在Windows和Linux之间通过Pictures目录传输和共享文件了。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>rdesktop</tag>
        <tag>RDP</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Caffe中的Siamese网络</title>
    <url>/2016/12/13/siamese-caffe/</url>
    <content><![CDATA[<p>Siamese原意是”泰国的，泰国人”，而与之相关的一个比较常见的词是”Siamese twin”， 意思是是”连体双胞胎”，所以Siamemse Network是从这个意思转变而来，指的是结构非常相似的两路网络，分别训练，<strong>但共享各个层的参数</strong>，在最后有一个连接的部分。Siamese网络对于相似性比较的场景比较有效。此外Siamese因为共享参数，所以能减少训练过程中的参数个数。<a href="http://vision.ia.ac.cn/zh/senimar/reports/Siamese-Network-Architecture-and-Applications-in-Computer-Vision.pdf">这里</a>的slides讲解了Siamese网络在深度学习中的应用。这里我参照Caffe中的<a href="https://github.com/BVLC/caffe/tree/master/examples/siamese">Siamese文档</a>， 以LeNet为例，简单地总结下Caffe中Siamese网络的prototxt文件的写法。 </p>
<span id="more"></span>

<h3 id="1-Data层"><a href="#1-Data层" class="headerlink" title="1. Data层"></a>1. Data层</h3><p>Data层输入可以是LMDB和LevelDB格式的数据，这种格式的数据可以通过参照<code>$CAFFE_ROOT/examples/siamese/create_mnist_siamese.sh</code>来生成（该脚本是从MNIST原先的格式生成DB文件，如果要从JPEG格式的图片来生成DB文件，需要进行一定的修改）。<br>Data层有2个输出，一个是<code>pair_data</code>，表示配对好的图片对;另一个是<code>sim</code>，表示图片对是否属于同一个label。 </p>
<h3 id="2-Slice层"><a href="#2-Slice层" class="headerlink" title="2. Slice层"></a>2. Slice层</h3><p>Slice层是Caffe中的一个工具层，功能就是把输入的层(bottom)切分成几个输出层(top)。官网给出的如下例子:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;slicer_label&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;Slice&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;label&quot;</span></span><br><span class="line">  <span class="comment">## Example of label with a shape N x 3 x 1 x 1</span></span><br><span class="line">  top: <span class="string">&quot;label1&quot;</span></span><br><span class="line">  top: <span class="string">&quot;label2&quot;</span></span><br><span class="line">  top: <span class="string">&quot;label3&quot;</span></span><br><span class="line">  slice_param &#123;</span><br><span class="line">    axis: 1</span><br><span class="line">    slice_point: 1</span><br><span class="line">    slice_point: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成的功能就是把slicer_label划分成3份。<code>axis</code>表示划分的维度，这里1表示在第二个维度上划分;<code>slice_point</code>表示划分的中间的点，分别是<code>1</code>，<code>2</code>表示在1-2层和2-3层之间进行一个划分。<br>在Siamese网络中，为了对数据对进行单独的训练，需要在Data层后面接一个Slice层，将数据均匀地划分为2个部分。 </p>
<h3 id="3-共享层"><a href="#3-共享层" class="headerlink" title="3. 共享层"></a>3. 共享层</h3><p>后面的卷积层，Pooling层，Relu层对于两路网络是没有区别的，所以可以直接写好一路后，复制一份在后面作为另一路，不过得将name，bottom和top的名字改成不一样的(示例中第二路的名字都是在第一路对应层的名字后面加了个<code>_p</code>表示pair)。 </p>
<h3 id="4-如何共享参数"><a href="#4-如何共享参数" class="headerlink" title="4. 如何共享参数"></a>4. 如何共享参数</h3><p>两路网络如何共享参数呢？Caffe里是这样实现的:在每路中对应的层里面都定义一个同名的参数，这样更新参数的时候就可以共享参数了。如下面的例子:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">layer &#123;                                                                         </span><br><span class="line">  name: <span class="string">&quot;ip2&quot;</span>                                                                   </span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;InnerProduct&quot;</span>                                                          </span><br><span class="line">  bottom: <span class="string">&quot;ip1&quot;</span>                                                                 </span><br><span class="line">  top: <span class="string">&quot;ip2&quot;</span>                                                                    </span><br><span class="line">  param &#123;                                                                       </span><br><span class="line">    name: <span class="string">&quot;ip2_w&quot;</span>                                                               </span><br><span class="line">    lr_mult: 1                                                                  </span><br><span class="line">  &#125;                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">layer &#123;                                                                         </span><br><span class="line">  name: <span class="string">&quot;ip2_p&quot;</span>                                                                 </span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;InnerProduct&quot;</span>                                                          </span><br><span class="line">  bottom: <span class="string">&quot;ip1_p&quot;</span>                                                               </span><br><span class="line">  top: <span class="string">&quot;ip2_p&quot;</span>                                                                  </span><br><span class="line">  param &#123;                                                                       </span><br><span class="line">    name: <span class="string">&quot;ip2_w&quot;</span>                                                               </span><br><span class="line">    lr_mult: 1                                                                  </span><br><span class="line">  &#125;              </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面例子中，两路网络对应层都定义了<code>ip2_w</code>的参数，这样训练的时候就可以共享这个变量的值了。 </p>
<h3 id="5-feature层"><a href="#5-feature层" class="headerlink" title="5. feature层"></a>5. feature层</h3><p>在2个全连接层后，我们将原来的分类的sofatmax层改为输出一个2维向量的全连接层:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">layer &#123;                                                                         </span><br><span class="line">  name: <span class="string">&quot;feat&quot;</span>                                                                  </span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;InnerProduct&quot;</span>                                                          </span><br><span class="line">  bottom: <span class="string">&quot;ip2&quot;</span>                                                                 </span><br><span class="line">  top: <span class="string">&quot;feat&quot;</span>                                                                   </span><br><span class="line">  param &#123;                                                                       </span><br><span class="line">    name: <span class="string">&quot;feat_w&quot;</span>                                                              </span><br><span class="line">    lr_mult: 1                                                                  </span><br><span class="line">  &#125;                                                                             </span><br><span class="line">  param &#123;                                                                       </span><br><span class="line">    name: <span class="string">&quot;feat_b&quot;</span>                                                              </span><br><span class="line">    lr_mult: 2                                                                  </span><br><span class="line">  &#125;                                                                             </span><br><span class="line">  inner_product_param &#123;                                                         </span><br><span class="line">    num_output: 2                                                               </span><br><span class="line">    weight_filler &#123;                                                             </span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;xavier&quot;</span>                                                            </span><br><span class="line">    &#125;                                                                           </span><br><span class="line">    bias_filler &#123;                                                               </span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;constant&quot;</span>                                                          </span><br><span class="line">    &#125;                                                                           </span><br><span class="line">  &#125;                                                                             </span><br><span class="line">&#125;                      </span><br></pre></td></tr></table></figure>

<h3 id="6-ContrastiveLoss层"><a href="#6-ContrastiveLoss层" class="headerlink" title="6. ContrastiveLoss层"></a>6. ContrastiveLoss层</h3><p>在两个feature产生后，就可以利用2个feature和前面定义的<code>sim</code>来计算loss了。Siamese网络采用了一个叫做<a href="http://yann.lecun.com/exdb/publis/pdf/hadsell-chopra-lecun-06.pdf">“ContrastiveLoss”</a>的loss计算方式，如果两个图片越相似，则loss越小;如果越不相似，则loss越大。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">layer &#123;                                                                         </span><br><span class="line">  name: <span class="string">&quot;loss&quot;</span>                                                                  </span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;ContrastiveLoss&quot;</span>                                                       </span><br><span class="line">  bottom: <span class="string">&quot;feat&quot;</span>                                                                </span><br><span class="line">  bottom: <span class="string">&quot;feat_p&quot;</span>                                                              </span><br><span class="line">  bottom: <span class="string">&quot;sim&quot;</span>                                                                 </span><br><span class="line">  top: <span class="string">&quot;loss&quot;</span>                                                                   </span><br><span class="line">  contrastive_loss_param &#123;                                                      </span><br><span class="line">    margin: 1                                                                   </span><br><span class="line">  &#125;                                                                             </span><br><span class="line">&#125;                </span><br></pre></td></tr></table></figure>

<h3 id="7-网络结构的可视化"><a href="#7-网络结构的可视化" class="headerlink" title="7. 网络结构的可视化"></a>7. 网络结构的可视化</h3><p>上面就是所有的网络结构，利用<code>$CAFFE_ROOT/python/draw_net.py</code>这个脚本可以画出网络结构，如图所示:<br><img src="/imgs/prototxt.jpg" alt="Lenet的Siamese网络结构"></p>
<p>整个网络的完整内容如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name: <span class="string">&quot;mnist_siamese_train_test&quot;</span></span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;pair_data&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;Data&quot;</span></span><br><span class="line">  top: <span class="string">&quot;pair_data&quot;</span></span><br><span class="line">  top: <span class="string">&quot;sim&quot;</span></span><br><span class="line">  include &#123;</span><br><span class="line">    phase: TRAIN</span><br><span class="line">  &#125;</span><br><span class="line">  transform_param &#123;</span><br><span class="line">    scale: 0.00390625</span><br><span class="line">  &#125;</span><br><span class="line">  data_param &#123;</span><br><span class="line">    <span class="built_in">source</span>: <span class="string">&quot;examples/siamese/mnist_siamese_train_leveldb&quot;</span></span><br><span class="line">    batch_size: 64</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;pair_data&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;Data&quot;</span></span><br><span class="line">  top: <span class="string">&quot;pair_data&quot;</span></span><br><span class="line">  top: <span class="string">&quot;sim&quot;</span></span><br><span class="line">  include &#123;</span><br><span class="line">    phase: TEST</span><br><span class="line">  &#125;</span><br><span class="line">  transform_param &#123;</span><br><span class="line">    scale: 0.00390625</span><br><span class="line">  &#125;</span><br><span class="line">  data_param &#123;</span><br><span class="line">    <span class="built_in">source</span>: <span class="string">&quot;examples/siamese/mnist_siamese_test_leveldb&quot;</span></span><br><span class="line">    batch_size: 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;slice_pair&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;Slice&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;pair_data&quot;</span></span><br><span class="line">  top: <span class="string">&quot;data&quot;</span></span><br><span class="line">  top: <span class="string">&quot;data_p&quot;</span></span><br><span class="line">  slice_param &#123;</span><br><span class="line">    slice_dim: 1</span><br><span class="line">    slice_point: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;conv1&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;Convolution&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;data&quot;</span></span><br><span class="line">  top: <span class="string">&quot;conv1&quot;</span></span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;conv1_w&quot;</span></span><br><span class="line">    lr_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;conv1_b&quot;</span></span><br><span class="line">    lr_mult: 2</span><br><span class="line">  &#125;</span><br><span class="line">  convolution_param &#123;</span><br><span class="line">    num_output: 20</span><br><span class="line">    kernel_size: 5</span><br><span class="line">    stride: 1</span><br><span class="line">    weight_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;xavier&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    bias_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;constant&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;pool1&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;Pooling&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;conv1&quot;</span></span><br><span class="line">  top: <span class="string">&quot;pool1&quot;</span></span><br><span class="line">  pooling_param &#123;</span><br><span class="line">    pool: MAX</span><br><span class="line">    kernel_size: 2</span><br><span class="line">    stride: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;conv2&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;Convolution&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;pool1&quot;</span></span><br><span class="line">  top: <span class="string">&quot;conv2&quot;</span></span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;conv2_w&quot;</span></span><br><span class="line">    lr_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;conv2_b&quot;</span></span><br><span class="line">    lr_mult: 2</span><br><span class="line">  &#125;</span><br><span class="line">  convolution_param &#123;</span><br><span class="line">    num_output: 50</span><br><span class="line">    kernel_size: 5</span><br><span class="line">    stride: 1</span><br><span class="line">    weight_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;xavier&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    bias_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;constant&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;pool2&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;Pooling&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;conv2&quot;</span></span><br><span class="line">  top: <span class="string">&quot;pool2&quot;</span></span><br><span class="line">  pooling_param &#123;</span><br><span class="line">    pool: MAX</span><br><span class="line">    kernel_size: 2</span><br><span class="line">    stride: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;ip1&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;InnerProduct&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;pool2&quot;</span></span><br><span class="line">  top: <span class="string">&quot;ip1&quot;</span></span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;ip1_w&quot;</span></span><br><span class="line">    lr_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;ip1_b&quot;</span></span><br><span class="line">    lr_mult: 2</span><br><span class="line">  &#125;</span><br><span class="line">  inner_product_param &#123;</span><br><span class="line">    num_output: 500</span><br><span class="line">    weight_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;xavier&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    bias_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;constant&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;relu1&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;ReLU&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;ip1&quot;</span></span><br><span class="line">  top: <span class="string">&quot;ip1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;ip2&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;InnerProduct&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;ip1&quot;</span></span><br><span class="line">  top: <span class="string">&quot;ip2&quot;</span></span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;ip2_w&quot;</span></span><br><span class="line">    lr_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;ip2_b&quot;</span></span><br><span class="line">    lr_mult: 2</span><br><span class="line">  &#125;</span><br><span class="line">  inner_product_param &#123;</span><br><span class="line">    num_output: 10</span><br><span class="line">    weight_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;xavier&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    bias_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;constant&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;feat&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;InnerProduct&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;ip2&quot;</span></span><br><span class="line">  top: <span class="string">&quot;feat&quot;</span></span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;feat_w&quot;</span></span><br><span class="line">    lr_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;feat_b&quot;</span></span><br><span class="line">    lr_mult: 2</span><br><span class="line">  &#125;</span><br><span class="line">  inner_product_param &#123;</span><br><span class="line">    num_output: 2</span><br><span class="line">    weight_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;xavier&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    bias_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;constant&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;conv1_p&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;Convolution&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;data_p&quot;</span></span><br><span class="line">  top: <span class="string">&quot;conv1_p&quot;</span></span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;conv1_w&quot;</span></span><br><span class="line">    lr_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;conv1_b&quot;</span></span><br><span class="line">    lr_mult: 2</span><br><span class="line">  &#125;</span><br><span class="line">  convolution_param &#123;</span><br><span class="line">    num_output: 20</span><br><span class="line">    kernel_size: 5</span><br><span class="line">    stride: 1</span><br><span class="line">    weight_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;xavier&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    bias_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;constant&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;pool1_p&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;Pooling&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;conv1_p&quot;</span></span><br><span class="line">  top: <span class="string">&quot;pool1_p&quot;</span></span><br><span class="line">  pooling_param &#123;</span><br><span class="line">    pool: MAX</span><br><span class="line">    kernel_size: 2</span><br><span class="line">    stride: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;conv2_p&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;Convolution&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;pool1_p&quot;</span></span><br><span class="line">  top: <span class="string">&quot;conv2_p&quot;</span></span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;conv2_w&quot;</span></span><br><span class="line">    lr_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;conv2_b&quot;</span></span><br><span class="line">    lr_mult: 2</span><br><span class="line">  &#125;</span><br><span class="line">  convolution_param &#123;</span><br><span class="line">    num_output: 50</span><br><span class="line">    kernel_size: 5</span><br><span class="line">    stride: 1</span><br><span class="line">    weight_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;xavier&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    bias_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;constant&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;pool2_p&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;Pooling&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;conv2_p&quot;</span></span><br><span class="line">  top: <span class="string">&quot;pool2_p&quot;</span></span><br><span class="line">  pooling_param &#123;</span><br><span class="line">    pool: MAX</span><br><span class="line">    kernel_size: 2</span><br><span class="line">    stride: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;ip1_p&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;InnerProduct&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;pool2_p&quot;</span></span><br><span class="line">  top: <span class="string">&quot;ip1_p&quot;</span></span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;ip1_w&quot;</span></span><br><span class="line">    lr_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;ip1_b&quot;</span></span><br><span class="line">    lr_mult: 2</span><br><span class="line">  &#125;</span><br><span class="line">  inner_product_param &#123;</span><br><span class="line">    num_output: 500</span><br><span class="line">    weight_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;xavier&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    bias_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;constant&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;relu1_p&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;ReLU&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;ip1_p&quot;</span></span><br><span class="line">  top: <span class="string">&quot;ip1_p&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;ip2_p&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;InnerProduct&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;ip1_p&quot;</span></span><br><span class="line">  top: <span class="string">&quot;ip2_p&quot;</span></span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;ip2_w&quot;</span></span><br><span class="line">    lr_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;ip2_b&quot;</span></span><br><span class="line">    lr_mult: 2</span><br><span class="line">  &#125;</span><br><span class="line">  inner_product_param &#123;</span><br><span class="line">    num_output: 10</span><br><span class="line">    weight_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;xavier&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    bias_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;constant&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;feat_p&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;InnerProduct&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;ip2_p&quot;</span></span><br><span class="line">  top: <span class="string">&quot;feat_p&quot;</span></span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;feat_w&quot;</span></span><br><span class="line">    lr_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    name: <span class="string">&quot;feat_b&quot;</span></span><br><span class="line">    lr_mult: 2</span><br><span class="line">  &#125;</span><br><span class="line">  inner_product_param &#123;</span><br><span class="line">    num_output: 2</span><br><span class="line">    weight_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;xavier&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    bias_filler &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;constant&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;loss&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;ContrastiveLoss&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;feat&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;feat_p&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;sim&quot;</span></span><br><span class="line">  top: <span class="string">&quot;loss&quot;</span></span><br><span class="line">  contrastive_loss_param &#123;</span><br><span class="line">    margin: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-训练过程"><a href="#8-训练过程" class="headerlink" title="8. 训练过程"></a>8. 训练过程</h3><p>训练过程与别的网络是一样的，这里就不具体展开了。</p>
<h3 id="9-参考内容"><a href="#9-参考内容" class="headerlink" title="9. 参考内容"></a>9. 参考内容</h3><ol>
<li><a href="https://www.quora.com/What-are-Siamese-neural-networks-what-applications-are-they-good-for-and-why">https://www.quora.com/What-are-Siamese-neural-networks-what-applications-are-they-good-for-and-why</a></li>
<li><a href="http://vision.ia.ac.cn/zh/senimar/reports/Siamese-Network-Architecture-and-Applications-in-Computer-Vision.pdf">http://vision.ia.ac.cn/zh/senimar/reports/Siamese-Network-Architecture-and-Applications-in-Computer-Vision.pdf</a></li>
</ol>
]]></content>
      <tags>
        <tag>Caffe</tag>
        <tag>Siamese Network</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>一些新看到的诗词</title>
    <url>/2014/12/31/some-new-poems/</url>
    <content><![CDATA[<p><span style="color: #000000;"> </span></p>
<p><span style="color: #000000;">今天是2014年的最后一天。昨天无聊的时候，翻着手机里面的照片，看到了玩么么答游戏时，不会的题目的截屏。其中大多数是诗词这个类别的题目，于是我便百度了这些诗词的完整的内容。因为这些诗词都是我之前不知道的，所以记录下来，用手敲一遍可能会对记忆有帮助吧，说不定以后就能融为自身的一部分呢。所以就抄录如下了。</span></p>
<span id="more"></span>

<p><span style="color: #000000;"> </span></p>
<span style="color: #000000;">
<span style="color: #008080;">摊破浣溪沙</span></span>
<span style="color: #008080;"> 李璟</span>
<span style="color: #008080;"> 手卷真珠上玉钩，依前春恨锁重楼。风里落花谁是主？思悠悠。</span>
<span style="color: #008080;"> 青鸟不传云外信，丁香空结雨中愁。回首绿波三楚暮，接天流。</span>

<p>&nbsp;</p>
<p><span style="color: #008080;">代赠</span></p>
<p><span style="color: #008080;">李商隐</span></p>
<p><span style="color: #008080;">楼上黄昏欲望休</span></p>
<p><span style="color: #008080;">玉梯横绝月如钩</span></p>
<p><span style="color: #008080;">芭蕉不展丁香结</span></p>
<p><span style="color: #008080;">同向春风各自愁</span></p>
<p>&nbsp;</p>
<p><span style="color: #008080;">宿骆氏亭寄怀崔雍崔衮</span></p>
<p><span style="color: #008080;">李商隐</span></p>
<p><span style="color: #008080;">竹坞无尘水槛清</span></p>
<p><span style="color: #008080;">相思迢递隔重城</span></p>
<p><span style="color: #008080;">秋阴不散霜飞晚</span></p>
<p><span style="color: #008080;">留得枯荷听雨声</span></p>
<p>&nbsp;</p>
<p><span style="color: #008080;">采桑子·塞上咏雪花</span></p>
<p><span style="color: #008080;">纳兰性德</span></p>
<p><span style="color: #008080;">非关癖爱轻模样，冷处偏佳。别有根芽，不是人间富贵花。</span></p>
<p><span style="color: #008080;">谢娘别后谁能惜，漂泊天涯。寒月悲笳，万里西风瀚海沙。</span></p>
<p>&nbsp;</p>
<p><span style="color: #008080;">节妇吟</span></p>
<p><span style="color: #008080;">张籍</span></p>
<p><span style="color: #008080;">君知妾有夫，赠妾双明珠。</span></p>
<p><span style="color: #008080;">感君缠绵意，系在红罗襦。</span></p>
<p><span style="color: #008080;">妾家高楼连苑起，良人执戟明光里。</span></p>
<p><span style="color: #008080;">知君用心同明月，事夫誓拟同生死。</span></p>
<p><span style="color: #008080;">还君明珠双泪垂，恨不相逢未嫁时。</span></p>
<p>&nbsp;</p>
<p><span style="color: #008080;">浣溪沙</span></p>
<p><span style="color: #008080;">纳兰性德</span></p>
<p><span style="color: #008080;">谁念西风独自凉，萧萧黄叶闭疏窗。沉思往事立残阳。</span></p>
<p><span style="color: #008080;">被酒莫惊春睡重，赌书消得泼茶香，当时只道是寻常。</span></p>
<p>&nbsp;</p>
<p><span style="color: #008080;">踏莎行</span></p>
<p><span style="color: #008080;">姜夔</span></p>
<p><span style="color: #008080;"><em>自沔东来，丁未元日至金陵，江上感梦而作。</em></span></p>
<p><span style="color: #008080;">燕燕轻盈，莺莺娇软，分明又向华胥见。夜长争得薄情知？春初早被相思染。</span></p>
<p><span style="color: #008080;">别后书辞，别时针线，离魂暗逐郎行远。淮南皓月冷千山，冥冥归去无人管。</span></p>
<p>&nbsp;</p>
<p><span style="color: #008080;">送柴侍御</span></p>
<p><span style="color: #008080;">王昌龄</span></p>
<p><span style="color: #008080;">沅水通波接武冈</span></p>
<p><span style="color: #008080;">送君不觉有离伤</span></p>
<p><span style="color: #008080;">青山一道同云雨</span></p>
<p><span style="color: #008080;">明月何曾是两乡</span></p>
<p>&nbsp;</p>
<p><span style="color: #008080;">积雨辋川庄作</span></p>
<p><span style="color: #008080;">王维</span></p>
<p><span style="color: #008080;">积雨空林烟火迟，蒸藜炊黍饷东葘。</span></p>
<p><span style="color: #008080;">漠漠水田飞白鹭，阴阴夏木啭黄鹂。</span></p>
<p><span style="color: #008080;">山中习静观朝槿，松下清斋折露葵。</span></p>
<p><span style="color: #008080;">野老与人争席罢，海鸥何事更相疑。</span></p>
<p>&nbsp;</p>
<p><span style="color: #008080;">木兰花</span></p>
<p><span style="color: #008080;">晏殊</span></p>
<p><span style="color: #008080;">燕鸿过后莺归去，细算浮生千万绪。长于春梦几多时， 散似秋云无觅处。</span></p>
<p><span style="color: #008080;">闻琴解佩神仙侣，挽断罗衣留不住。劝君莫作独醒人，烂醉花间应有数。</span></p>
<p>&nbsp;</p>
<p><span style="color: #008080;">八至</span></p>
<p><span style="color: #008080;">李冶</span></p>
<p><span style="color: #008080;">至近至远东西</span></p>
<p><span style="color: #008080;">至深至浅清溪</span></p>
<p><span style="color: #008080;">至高至明日月</span></p>
<p><span style="color: #008080;">至亲至疏夫妻</span></p>
<p>&nbsp;</p>
<p><span style="color: #008080;">论诗三十首·其四</span></p>
<p><span style="color: #008080;">元好问</span></p>
<p><span style="color: #008080;">一语天然万古新</span></p>
<p><span style="color: #008080;">豪华落尽见真淳</span></p>
<p><span style="color: #008080;">南窗白日羲皇上</span></p>
<p><span style="color: #008080;">未害渊明是晋人</span></p>
<p>&nbsp;</p>
<p><span style="color: #008080;">题龙阳县青草湖</span></p>
<p><span style="color: #008080;">唐温如</span></p>
<p><span style="color: #008080;">西风吹老洞庭波</span></p>
<p><span style="color: #008080;">一夜湘君白发多</span></p>
<p><span style="color: #008080;">醉后不知天在水</span></p>
<p><span style="color: #008080;">满船清梦压星河</span></p>
<p>&nbsp;</p>
<p><span style="color: #008080;">听蜀僧濬弹琴</span></p>
<p><span style="color: #008080;">李白</span></p>
<p><span style="color: #008080;">蜀僧抱绿绮，西下峨眉峰。</span></p>
<p><span style="color: #008080;">为我一挥手，如听万壑松。</span></p>
<p><span style="color: #008080;">客心洗流水，余响入霜钟。</span></p>
<p><span style="color: #008080;"> 不觉碧山暮，秋云暗几重。</span></p>
<p>&nbsp;</p>
<p><span style="color: #008080;">春江花月夜</span></p>
<p><span style="color: #008080;">杨广（隋炀帝）</span></p>
<p><span style="color: #008080;">暮江平不动</span></p>
<p><span style="color: #008080;">春花满正开</span></p>
<p><span style="color: #008080;">流波将月去</span></p>
<p><span style="color: #008080;">潮水带星来</span></p>
<p>&nbsp;</p>
<p><span style="color: #008080;">和子由渑池怀旧</span></p>
<p><span style="color: #008080;">苏轼</span></p>
<p><span style="color: #008080;">人生到处知何似，应似飞鸿踏雪泥。</span></p>
<p><span style="color: #008080;">泥上偶然留指爪，鸿飞那复计东西。</span></p>
<p><span style="color: #008080;">老僧已死成新塔，坏壁无由见旧题。</span></p>
<p><span style="color: #008080;">往日崎岖还记否，路长人困蹇驴嘶。</span></p>
<p>&nbsp;</p>
<p><span style="color: #000000;">最后这首是苏轼和苏辙的，我也找到了苏辙的原诗，记录如下。</span></p>
<p>&nbsp;</p>
<p><span style="color: #008080;">怀渑池寄子瞻兄</span></p>
<p><span style="color: #008080;">苏辙</span></p>
<p><span style="color: #008080;">相携话别郑原上， 共道长途怕雪泥。</span></p>
<p><span style="color: #008080;"> 归骑还寻大梁陌， 行人已度古崤西。</span></p>
<p><span style="color: #008080;">曾为县吏民知否？旧宿僧房壁共题。</span></p>
<p><span style="color: #008080;">遥想独游佳味少，无方骓马但鸣嘶。</span></p>
<p>&nbsp;</p>
<p><span style="color: #000000;">最后，今天是2014年的最后一天，找到了谢灵运的《岁暮》，借此警戒，希望未来日子能过得充实。</span></p>
<p>&nbsp;</p>
<p><span style="color: #008080;">岁暮</span></p>
<p><span style="color: #008080;">谢灵运</span></p>
<p><span style="color: #008080;">殷忧不能寐， 苦此夜难颓。</span></p>
<p><span style="color: #008080;">明月照积雪， 朔风劲且哀。</span></p>
<p><span style="color: #008080;">运往无淹物，年视觉已催。</span></p>
<p><span style="color: #008080;"> </span></p>
]]></content>
      <categories>
        <category>四季风物</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 下的source命令学习</title>
    <url>/2015/07/03/source-command/</url>
    <content><![CDATA[<p>前些天在装opencl的<a href="http://www.freedesktop.org/wiki/Software/Beignet/">beignet</a>实现版本时，发现wiki中里面有个点命令.，不知道具体含义就百度了下，结果学了一些相关的知识，记录如下。</p>
<span id="more"></span>

<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>source</code>命令是bash的内置命令，与点命令.等效，唯一不同的是点命令是[在POXIS下定义的]](<a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#dot)%E3%80%82%60source%60%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E6%A0%BC%E5%BC%8F%E6%98%AF%60source">http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#dot)。`source`命令的执行格式是`source</a> script<code>，是在当前shell进程中依次执行script文件中的语句。那么与普通的 </code>sh script<code>和</code>./script`有什么不同呢？主要有两个不同点：</p>
<ol>
<li><code>source</code> 的执行是在当前进程中执行，而<code>sh script</code>和<code>./script</code>在执行的时候，当前进程会开辟一个新的子进程，然后在子进程中执行script中的语句。</li>
<li>使用<code>source</code>命令的文件不需要有执行权限，而./script方式执行的方式需要script文件有可执行权限（注意：<code>sh script</code> 不需要script文件有可执行权限）。</li>
</ol>
<h2 id="2-测试实例"><a href="#2-测试实例" class="headerlink" title="2. 测试实例"></a>2. 测试实例</h2><p>我们可以举几个例子来展示上面提到的不同点(例子都摘自参考内容中的第1个链接)。</p>
<h3 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h3><p>编写脚本test.sh如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $$</span><br></pre></td></tr></table></figure>

<p>需要说明一下，在Linux中，每个进程都有一个独一无二的进程号，简称为<code>PID</code>。而<code>$$</code>就表示当前进程的<code>PID</code>。所以上述脚本的作用就是输出当前进程的<code>PID</code>。<br>我们可以用两种方式来执行这个脚本，先使用<code>source</code>命令来执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">source</span> test.sh</span><br><span class="line">3824</span><br><span class="line">&gt; <span class="built_in">source</span> test.sh</span><br><span class="line">3824</span><br><span class="line">&gt; <span class="built_in">source</span> test.sh</span><br><span class="line">3824</span><br></pre></td></tr></table></figure>

<p>可以看到每次输出的结果都是3824。然后使用<code>sh script</code>方式来执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; sh test.sh</span><br><span class="line">3884</span><br><span class="line">&gt; sh test.sh</span><br><span class="line">3889</span><br><span class="line">&gt; sh test.sh</span><br><span class="line">3894</span><br></pre></td></tr></table></figure>

<p>可以看到每次输出的结果都在改变。<br>这个测试说明：使用<code>source</code>命令在当前进程执行，而使用<code>sh script</code>命令则每次执行时都生成不同的子进程，在子进程中执行，执行完后面文件中的指令后再返回主进程。</p>
<h3 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h3><p>编写测试脚本<code>test.sh</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;FOO:&quot;</span>$(env | grep FOO)</span><br><span class="line"><span class="built_in">export</span> FOO=foo</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;FOO:&quot;</span>$(env | grep FOO)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PWD:&quot;</span><span class="variable">$PWD</span></span><br><span class="line"><span class="built_in">cd</span> mydir</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PWD:&quot;</span><span class="variable">$PWD</span></span><br></pre></td></tr></table></figure>

<p>这个脚本先是测试环境变量中是否包含名为<code>FOO</code>的环境变量，然后新建的环境变量<code>Foo=foo</code>。然后是输出当前所在目录，接着切换到当前目录的<code>mydir</code>子目录，然后再输出当前所在目录。<br>在执行这个脚本前，我们先检查下当前环境:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; env | grep FOO</span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$PWD</span></span><br><span class="line">/home/yunfeng</span><br></pre></td></tr></table></figure>

<p>这说明当前环境中没有名为<code>FOO</code>的变量，当前所在路径为<code>/home/yunfeng</code>。<br>然后我们执行<code>sh test.sh</code>，输出为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FOO:</span><br><span class="line">FOO:FOO=foo</span><br><span class="line">PWD:/home/yunfeng</span><br><span class="line">PWD:/home/yunfeng/mydir</span><br></pre></td></tr></table></figure>

<p>然后我们再检查下当前环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; env | grep FOO</span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$PWD</span></span><br><span class="line">/home/yunfeng</span><br></pre></td></tr></table></figure>

<p>这说明使用<code>sh test.sh</code>执行的时候，并没有改变当前进程的环境变量和所在路径，而只是改变了新建的子进程的环境变量和所在路径。此外我们还可以得出结论：当前进程新建shell子进程的时候为子进程复制了当前进程的环境变量（包括路径）。<br>然后使用<code>source</code>命令执行<code>test.sh</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> test.sh</span><br><span class="line">FOO:</span><br><span class="line">FOO:FOO=foo</span><br><span class="line">PWD:/home/yunfeng</span><br><span class="line">PWD:/home/yunfeng/mydir</span><br></pre></td></tr></table></figure>

<p>然后检查当前环境：(其实可以发现，当前目录已经切换到<code>mydir</code>了)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; env | grep FOO</span><br><span class="line">FOO=foo</span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$PWD</span></span><br><span class="line">/home/yunfeng/mydir</span><br></pre></td></tr></table></figure>

<p>可以看出使用<code>source</code>命令时，会改变当前进程的环境变量。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>提高你的信息获取信噪比：RSS in 2022</title>
    <url>/2022/05/29/rss-2022/</url>
    <content><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在上学的时候，有一次听boj师兄介绍博客，至今还记得讲座中的一句话，博客能提高获取信息的信噪比。</p>
<p>在今天网络和社交媒体信息严重过载的情况下，如何集中自己的精力，将时间花到有用的事情上，进而提高工作效率，对我们每个人来说，都很有挑战。</p>
<p>为了获取真正有用的信息，第一步是过滤信息来源。最近发现基于RSS的信息获取方式是比较高效的，这里大致描述一下我目前采用的信息获取方案。</p>
<span id="more"></span>

<h1 id="2-RSS-介绍"><a href="#2-RSS-介绍" class="headerlink" title="2. RSS 介绍"></a>2. RSS 介绍</h1><p>基于RSS的信息获取需要有两个东西，一个是RSS阅读器，另一个就是订阅源。通过订阅，每次订阅源有新内容发表的话，阅读器都可以爬取，因此打开阅读器就能阅读最新的订阅内容，避免了一个个/一次次检查网站的问题，也能最快地看到感兴趣的内容。如果一个订阅源的内容长期不喜欢的话，可以取消订阅，减少噪声。（但这个是不是也会加剧信息茧房现象？)</p>
<p>RSS阅读器我目前采用的是inoreader，之前也用过feedly，不过都需要科学上网。如果你有更好的方案，欢迎评论指出。</p>
<p>订阅源就是内容的生产方的RSS链接，一般博客网站都有会RSS标志，点击复制网页，添加到阅读器中即可。</p>
<p>这里是我的一些订阅源和平时会看的网站，欢迎寻找对你有用的内容.</p>
<h3 id="2-1-纯粹的技术网站"><a href="#2-1-纯粹的技术网站" class="headerlink" title="2.1 纯粹的技术网站"></a>2.1 纯粹的技术网站</h3><p>hacker news是大家提到比较多的网站，内容挺丰富的。而lobste.rs是一个没怎么被提到但社区和谐、内容优质的computing为主的社区，很喜欢这种纯粹地讨论技术的网站，很多大牛也在其中出没。不过由于采用邀请制，门槛很高，像我们这样的一般人很难参与他们的讨论。</p>
<h3 id="2-2-知乎上大佬总结的订阅源"><a href="#2-2-知乎上大佬总结的订阅源" class="headerlink" title="2.2 知乎上大佬总结的订阅源"></a>2.2 知乎上大佬总结的订阅源</h3><p><a href="https://zhuanlan.zhihu.com/p/472781319">这里</a>是知乎上大佬总结的优质RSS源，可以根据你的喜爱添加到自己的阅读器。</p>
<h3 id="2-3-独立博客汇总"><a href="#2-3-独立博客汇总" class="headerlink" title="2.3 独立博客汇总"></a>2.3 独立博客汇总</h3><p><a href="https://github.com/timqian/chinese-independent-blogs">这里</a>是GitHub上开发者总结的中文独立博客列表，很长，但应该是有很多优质内容的，值得一一阅读品味再订阅。阅读个人的独立博客，像是认识跟自己有同样爱好的一个好友，看ta看问题的角度，解决问题的思路，分享的创造，都会带来惊喜。</p>
<p>最后愿这篇博客对你高效获取信息有所帮助!</p>
]]></content>
      <tags>
        <tag>总结</tag>
        <tag>RSS</tag>
        <tag>非技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text 使用技巧1</title>
    <url>/2015/05/27/sublime-text-summary-1/</url>
    <content><![CDATA[<p>Sublime Text 是一款功能很强大的编辑器，用起来很爽，界面也很华丽。但我看了一系列的学习视频时候，才发现为我对Sublime Text 2的许多功能还是不了解，这里记录下来，记性不好，只能通过别的方法来补充了。下面是一些小技巧。</p>
<h2 id="1-打开文件夹并保存为sulime-project"><a href="#1-打开文件夹并保存为sulime-project" class="headerlink" title="1.打开文件夹并保存为sulime-project"></a>1.打开文件夹并保存为sulime-project</h2><p>将整个文件夹拖进打开着的Sublime Text 中，然后在工具栏上选择<strong>View-&gt;Side Bar-&gt;Show Side Bar</strong>，即可看到打开的文件夹了。也可以用快捷键<code>Ctrl-K,Ctrl-B</code>来完成该操作。 要将打开的文件夹保存为sublime-project，在工具栏上选择**Project-&gt;Save Project As…**然后在打开的对话框中填写保存的项目名，后缀是<code>sublime-project</code>。</p>
<span id="more"></span>

<h2 id="2-设置首选项"><a href="#2-设置首选项" class="headerlink" title="2.设置首选项"></a>2.设置首选项</h2><p>Sublime Text里面有许多的默认选项，如字体大小、tab缩进几个空格等，这些设置都是以类似Json的文本格式保存的。默认的设置文件可以这样打开：工具栏上选择<strong>Preferences-&gt;Settings-Defaults</strong>。在Window 7上，这个设置文件是只读的（视频教程里面用的是Mac，可以修改），因此用户可以设置自己的首选项，工具栏上选择<strong>Preferences</strong>-&gt;<strong>Settings-User</strong>，设置文件就会打开。建议先读懂默认设置里面的每一项设置的内容（每一项设置的内容都有非常详尽的注释，保证一看就懂），然后再复制到用户设置文件里面修改。</p>
<h2 id="3-设置外观"><a href="#3-设置外观" class="headerlink" title="3.设置外观"></a>3.设置外观</h2><ol>
<li><p> 设置配色方案 默认的配色方案有许多，可以通过<strong>Preferences-&gt;Color Scheme</strong>来选择。除了默认的方案，还可以通过<code>Package Control</code>命令安装喜欢的命令。</p>
</li>
<li><p> 设置显示布局 可以将窗口划分为许多小窗口，通过<strong>View-&gt;Layout</strong>，选择自己想要的布局，有<code>Single</code>，<code>Columns:2</code>，<code>Columns:3</code>，<code>Columns:4</code>，<code>Rows:2</code>，<code>Rows:2</code>，<code>Grid:4</code>几种选项。</p>
</li>
</ol>
<h2 id="4-多行选择"><a href="#4-多行选择" class="headerlink" title="4.多行选择"></a>4.多行选择</h2><p>多行选择是将多个行选定，然后对这些行一起执行操作，对HTML里面的标签操作很方便。选定多个行的方式是：按住<code>Ctrl</code>键，然后在想要操作的行的某个位置点击，即选定该位置。</p>
<h2 id="5-插件Emmet的使用"><a href="#5-插件Emmet的使用" class="headerlink" title="5.插件Emmet的使用"></a>5.插件Emmet的使用</h2><p>看了介绍，Emmet真是个提高效率的很有用的工具。Emmet利用HTML和CSS代码里面的规范的标签和较多的重复性内容，使用简单的标记方法来简洁地进行代码书写。可以通过<code>Package Control</code> 来搜索Emmet来安装。下面简要地介绍下Emmet的一些标记规则,全部规则见<a href="http://www.cnblogs.com/matchless/archive/2013/04/10/3010628.html">这篇博客</a>。</p>
<ol>
<li><p><code>#</code>：代表<code>id</code>，例如</p>
<p> <code>div#nav</code><br> 效果为</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;nav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>.</code> 代表<code>class</code>，例如<br> <code>div.nav  </code><br> 效果为</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">clas</span>=<span class="string">&quot;nav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>&gt;</code>代表包含，即子标签，如<br> <code>div&gt;p&gt;span  </code><br> 效果为</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>+</code>代表相邻标签，即<br> <code>div&gt;p+span  </code><br> 代表</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>*</code>代表多个标签，如<br> <code>ul&gt;li*3  </code><br> 代表</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>&#123;&#125;</code>代表文本内容，如<br> <code>ul&gt;li*3&gt;a&#123;Link&#125;  </code><br> 代表</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Sublime Text</category>
      </categories>
      <tags>
        <tag>Sublime Text</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH config使用教程和总结</title>
    <url>/2017/07/09/ssh-config/</url>
    <content><![CDATA[<p>SSH config是Linux系统下针对SSH客户端的一个参数配置方案，可以将一些关于SSH命令的参数放到配置文件中去，执行ssh命令的时候从文件中读取，简化命令行的操作。这篇短博客记录ssh config相关的配置问题和使用方法。</p>
<span id="more"></span>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SSH 参数配置有3个层次：</p>
<ol>
<li>命令行参数，如<code>-p 10086</code>, <code>-i /path/to/identity_file</code> 等选项来设置SSH的端口号或认证证书位置</li>
<li>针对某个用户的配置文件，所在路径为<code>~/.ssh/config</code>，默认是不存在的，需要手动创建</li>
<li>针对系统所有用户的配置文件，，所在路径为<code>/etc/ssh/ssh_config</code><br>参数重要性的顺序也是1&gt;2&gt;3，即越近的配置重要性越高。这里主要讲述第2种情况下的配置方式，即针对<code>~/.ssh/config</code>文件的写法进行说明。  </li>
</ol>
<p>一个示例的文件如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># configuration 1</span></span><br><span class="line">Host cluster</span><br><span class="line">	HostName 192.168.11.11</span><br><span class="line">	User tom</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># configuration 2</span></span><br><span class="line">Host=aliyun</span><br><span class="line">	Hostname=202.44.2.2</span><br><span class="line">	User tom</span><br></pre></td></tr></table></figure>
<p>主要的规则如下：</p>
<ol>
<li>每项配置都是<code>参数名 参数值</code>或<code>参数值=参数名</code>的形式，其中参数名不区分大小写，而参数值区分大小写，如上面的参数名<code>HostName</code>和<code>Hostname</code>是同一个参数</li>
<li>不同主机的配置通过<code>Host</code>参数来区分，一个配置文件里面可以有针对多个Host的配置</li>
<li>以<code>#</code>开头的是注释，会被忽略</li>
<li>同一个Host的配置内部，<code>参数名 参数值</code>和<code>参数值=参数名</code>的形式可以混用，如上例#2配置所示<br>下面详细展开常见的参数类型。</li>
</ol>
<h2 id="常见参数类型"><a href="#常见参数类型" class="headerlink" title="常见参数类型"></a>常见参数类型</h2><h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><p>类似昵称，用于标识某个特定的配置，在ssh命令中使用，例如我们想要ssh连接到上例中的#1配置的主机，则在命令行执行如下命令即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh cluster</span><br></pre></td></tr></table></figure>
<p>一个最有用的场景是使用scp在不同主机间传数据。没有配置之间，你得写很长的参数，如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp a.txt tom@192.168.11.11:~/</span><br></pre></td></tr></table></figure>
<p>尤其是IP地址记忆起来好麻烦啊。配置过上例中的文件后，这个任务可以简化成这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp a.txt cluster:~/</span><br></pre></td></tr></table></figure>
<p>省略了用户名和IP地址，方便多了。  </p>
<h3 id="HostName"><a href="#HostName" class="headerlink" title="HostName"></a>HostName</h3><p>需要ssh连接过去的主机名，一般是IP地址，也可以用<code>%h</code>来替代命令行参数，这种情况由于我用的不多，所以没有深入了解，具体情况可以参考参考链接。  </p>
<h3 id="User"><a href="#User" class="headerlink" title="User"></a>User</h3><p>登录主机的用户名</p>
<h3 id="IdentityFile"><a href="#IdentityFile" class="headerlink" title="IdentityFile"></a>IdentityFile</h3><p>认证证书文件，默认位置是<code>~/.ssh/id_rsa</code>, <code>~/ssh/id_dsa</code>等，如果采用默认的证书，可以不用设置此参数，除非你的证书放在某个自定义的目录，那么你就需要设置该参数来指向你的证书</p>
<h3 id="Port"><a href="#Port" class="headerlink" title="Port"></a>Port</h3><p>SSH访问主机的端口号，默认是22端口，同上，只有在非默认情况下才需要设置该值</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>貌似常用的参数就这些，别的参数可以在命令行通过<code>man ssh_config</code>来查看，其实涉及的参数还是非常多的。 </p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a href="http://zlong.org/2015/06/08/ssh-config/">http://zlong.org/2015/06/08/ssh-config/</a></li>
<li><a href="https://www.hi-linux.com/posts/14346.html">https://www.hi-linux.com/posts/14346.html</a></li>
<li><a href="http://daemon369.github.io/ssh/2015/03/21/using-ssh-config-file">http://daemon369.github.io/ssh/2015/03/21/using-ssh-config-file</a></li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>总结</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>2016年终总结</title>
    <url>/2017/01/08/summary-2016/</url>
    <content><![CDATA[<p>这是我的2016年终总结,也是我第一次写技术相关的总结,希望以后每年我都能写一个总结，总结这一年来做的工作，反思有哪些做的不够好的地方，在新的一年里加油做好。  </p>
<span id="more"></span>

<p>在2016这一年来，我做了一些项目,给开源社区贡献了一些代码（大多数都是简单的代码格式和规范方面的改进），学习了一些新的技术。同时，在实验室的科研项目上，却没有太大的进展，我做的视频中动作识别的方向没有成果，实在是很担心下一年的情形。下面，我从开源贡献、自己做的项目、学习的技能、阅读的书籍、实验室研究进展5个方面做详细的总结。  </p>
<h2 id="1-开源贡献"><a href="#1-开源贡献" class="headerlink" title="1. 开源贡献"></a>1. 开源贡献</h2><p>在这一年里，我在GitHub上总共贡献了642个Contribution，如下图所示。<br><img src="/imgs/GitHub_Contributions_2016.png" alt="GitHub Contribution 2016"><br>给包括tensorflow、Paddle、C3D、tflearn等项目提交来一些代码，主要都是typo、格式上的问题，虽然实际意义不是很大，但总算开始能够参与到开源社区的活动中去， 这也是很值得高兴的事情。最激动的是在Tensorflow的0.10.0 RC0 和0.11.0 RC0发布的贡献者感谢中提到了我的名字，感觉还是挺有成就感的。<br><img src="/imgs/tf_0.10.0_thanks.png" alt="Tensorflow 0.10.0 RC0 thanks"><br><img src="/imgs/tf_0.11.0_thanks.png" alt="Tensorflow 0.11.0 RC0 thanks"></p>
<p>下面是今年我在开源项目中所做的代码修改(点击链接即可跳转到我的Commit)：</p>
<ol>
<li><a href="https://github.com/tensorflow/tensorflow/commits?author=vra">tensorflow</a></li>
<li><a href="https://github.com/PaddlePaddle/Paddle/commits?author=vra">Paddle</a></li>
<li><a href="https://github.com/tflearn/tflearn/commits?author=vra">tflearn</a></li>
<li><a href="https://github.com/facebook/C3D/commits?author=vra">facebook/C3D</a></li>
<li><a href="https://github.com/cs231n/cs231n.github.io/commits?author=vra">cs231n.github.io</a></li>
<li><a href="https://github.com/tensorflow/models/commits?author=vra">tensorflow/models</a></li>
<li><a href="https://github.com/openai/universe/commits?author=vra">openai/universe</a></li>
<li><a href="https://github.com/Gazler/githug/commits?author=vra">githug</a></li>
<li><a href="https://github.com/yeasy/docker_practice/commits?author=vra">docker_practice</a></li>
<li><a href="https://github.com/wusuopu/Ruby-tutorial/commits?author=vra">Ruby-tutorial</a></li>
<li><a href="https://github.com/adambard/learnxinyminutes-docs/commits?author=vra">learnxinyminutes-docs</a></li>
<li><a href="https://github.com/aymericdamien/TensorFlow-Examples/commits?author=vra">TensorFlow-Examples</a></li>
</ol>
<p>参与开源社区的活动，既可以提高自己的编程水平，也可以和世界各地的人们一起交流，提高自己的英语水平，也能了解到最新的技术，所以我觉得是一件很有意义的事情。但由于我水平有限，实质的改进并不多，希望在2017年努力提高自身水平，更多地参与到开源社区的活动中去。  </p>
<h2 id="2-我和小伙伴们做的项目"><a href="#2-我和小伙伴们做的项目" class="headerlink" title="2. 我和小伙伴们做的项目"></a>2. 我和小伙伴们做的项目</h2><h3 id="1-CaptchaLess"><a href="#1-CaptchaLess" class="headerlink" title="1. CaptchaLess"></a>1. CaptchaLess</h3><p>研一上学期在上《视频技术基础》课程的时候，我和蒲俊福、黄志华三个人做了一个Chrome插件<a href="https://chrome.google.com/webstore/detail/captchaless/claimmbgfkbkkjdibcghloeibcifnodn">CaptchaLess</a>，来完成我们学校网站的验证码的自动识别，蒲俊福负责算法，黄志华负责将算法部署到Django搭建的后台，我负责前端的Chrome的插件，包括和用户交互、验证码图片的提取、发送到服务器端、将服务器端识别的结果返回给网页、渲染出结果。<br>一开始我们针对比较简单的验证码（只有0-9这10个数字），采用来模板匹配的算法，即爬取一些验证码图片，手工标记是什么字符并保存为模板，当识别验证码的时候，先进行二值化、高斯模糊等处理，去除噪声，将验证码图片和标记好的图片进行比较，寻找模板中最相似的，作为识别结果。由于这一类验证码几乎没有形变，只有少量的噪声，所以使用这种方法就足够了，识别结果几乎是100%（到现在为止貌似我只遇到1,2次）。<br>然后我们又考察了另一类比较复杂的验证码，其中包含0-9和24个字母（为了避免和某些数字混淆，删去了一些字母），而且有比较大的旋转。我们是了一些基于匹配的改进算法，但识别率还是不高。当时由于时间比较紧，需要在课程结束前进行答辩，我们就先没有完善这部分。<br>$后来我又想起这回事，尝试来一次，没有成功。又过了很长时间，我又想起这个事，又尝试了一些方法，发现采用局部二值匹配能够较好地解决后面一种验证码的问题，所以改进了下代码，更新了插件。测试的时候，在比较复杂的验证码上，能够达到67%的准确率，单个字符的识别更高些，算是一个比较好的结果。当然还是可以再改进的。<br>所以从这个项目中，我发现对于一个暂时没能搞定问题，可能需要时不时地去思考怎么解决，有的时候思维比较局限，想不出法子来解决，可以先放一放，但不要忘掉，等思维比较活跃的时候再来看看，说不定可以很快就解决掉。正所谓“念念不忘，必有回响”，就是这个道理吧。  </p>
<h3 id="2-EasyDict"><a href="#2-EasyDict" class="headerlink" title="2. EasyDict"></a>2. EasyDict</h3><p>在做CaptchaLess项目的过程中，我熟悉了Chrome插件的开发方法，所以在后来用扇贝背单词的时候，看了看扇贝网的API，突然想，能不能做一个基于扇贝网的Chrome查词插件呢？于是这个功能简单的查词工具<a href="https://chrome.google.com/webstore/detail/easydict/ejlckbajejjeoieicimfoijkcfloeded">EasyDict</a>就产生了。目前提供的功能比较少，仅仅包括中文释义、英文释义、英式发音、美式发音。<strong>期望的后续工作还包括：增加浏划词查询，鼠标右键查询。</strong>  </p>
<h3 id="3-cool-certificate"><a href="#3-cool-certificate" class="headerlink" title="3. cool_certificate"></a>3. cool_certificate</h3><p>某次有同学给我发了一个网页，上面时一张无人机驾驶证的图片，只要在网页下面的输入框上写上你的名字，就可以生成专属于自己的驾驶证，确实挺装逼的哈哈。我在想，能不能自己做一个呢？于是想了想，其实比较简单，只需要将用户输入的名字写入到照片上，然后生成新的照片即可。于是我立即动手，采用Python的PIL包和Django网站架构，制作了一个可以公开访问的站点，输入名字就可以生成酷酷的照片,包括无人机驾驶证，潜水证和帅哥证，你可以在<a href="http://115.28.30.25:8001/">这里</a>试着玩一玩。<br>总体来说这个项目比较简单，比较好玩。<strong>还有两个可以改进的地方：一是字体写入到照片的时候可以进行一定的旋转，以显得更真实。二是采用与图片文字更相似的字体，同样可以提高真实性。</strong>  </p>
<h3 id="4-travel-record"><a href="#4-travel-record" class="headerlink" title="4. travel_record"></a>4. travel_record</h3><p>某天实验室的小伙伴告诉我有个叫ClustrMaps的工具，可以记录你的网站上的访客的IP地址，然后他说，能不能用这个来记录旅行的足迹呢？比如建立一个只有自己可以访问的网站，每到一个新的地方，就访问这个网站，这样地图上就可以显示自己的IP的所在地，这样等周有完世界后，就可以看到世界各地的属于自己的足迹了。于是我们就开始做了，采用Django框架，制作了一个简单的登录页面，输入正确的密码就跳转到一个包含ClustrMaps的代码的页面，就可以实现签到；如果输入密码不对，就一直跳转到登录页面，这样别人的IP就显示不到ClustrMaps地图上。  </p>
<h3 id="5-HackxFDU-黑客马拉松比赛"><a href="#5-HackxFDU-黑客马拉松比赛" class="headerlink" title="5. HackxFDU 黑客马拉松比赛"></a>5. HackxFDU 黑客马拉松比赛</h3><p>有一次在微博上我偶然看到了GitHub赞助的HackxFDU黑客马拉松比赛，在复旦大学举办，于是和伟哥一起报名，希望能组队取参加一下，增加一些项目经验。最后只有我入选了，去上海临时和4位复旦的学生组了队，想做一个基于大疆无人机和深度学习的行人跟踪应用。因为无人机是通过手机控制的，所以我们开始的设想是在手机上完成整个深度学习的计算，包括采集无人机发送的图片，将图片输入到深度学习的网络中，识别图片中的行人，对其进行tracking。<br><img src="/imgs/hackxfdu_team_with_nash" alt="我们团队的小伙伴和GitHub的工作人员"><br>因为我们听过tensorflow可以在Android设备上运行，所以在讨论方案的时候，我们觉得这个方案是可行的。后来在实现的时候，才发现有很多问题。一是Tensorflow在Android上面的程序也是在电脑上训练好model后，将model导入到Android应用中，所以在Android端是没有训练过程的。二是tensorflow从PC到Android的迁移问题很多，没有成熟的解决方案，向Bazel的编译很容易出错，而且错误不好解决。最后我们的很多时间都是花费在了解决各种奇怪的问题上，到项目结束的时候，我们组的完成度很低，几乎没办法展示，在最后的展示阶段，显得特别尴尬。不过最后我们组因为创意比较好，获得来大疆的企业奖，奖品是一个Osmo+手持拍摄云台。<br>这个项目过后，我思考了挺多东西，觉得要做好一个项目，我还有很长的路要走。<br>首先是“领导力”和自身想法的缺乏。因为在团队中，我是年级最高的，而且技术了解比其他几位队友稍微多一点，如果在选择项目的时候，说出自己的想法，选择比较成熟的方法，可能后面做起来会容易些。因为我平时习惯了听别人的做法，没有思考过自己的想法，很多时候都是选择沉默或者跟随别人的意见，所以在关键时刻也没能站出来，这是我以后一定要改进的地方，否则真的成不了大事。<br>还有和队友沟通太少或者沟通效果不佳。因为我们是当时才组建的队伍，之间大家相互都不认识，所以在讨论项目的时候都比较含蓄，没有太直接地提出自己的想法。这也是我以后应该改善的地方。<br>还有最重要的是，对目标的坚持程度。整个黑客马拉松共经历了2天2夜，第一天晚上，在半夜2,3点，实在不知道接下来该怎么做的时候，开始思考人生了。从大学期间开始，我陆陆续续做了一些项目，有大有小，大多数项目都算失败了，做着做着就没有下文了，我想这次也估计是这样了。为什么最后都做不下去呢？有各种各样的表面上的原因，但归根结底，还是自己对目标的坚持程度不够吧，习惯了惰性心理，不肯花太多时间，习惯避重就轻，遇到困难很容易退缩，没有坚持下去的决心。想想确实挺担心，如果一直这样下去的话，我这一辈子肯定做不成什么大事。更悲哀的是，在平日许许多多的日子里，我完全每想过这些事情，而是在茫茫小事中度过了一年又一年。新的一年里面，改进这些方面吧。  </p>
<h2 id="3-学习到的技能"><a href="#3-学习到的技能" class="headerlink" title="3. 学习到的技能"></a>3. 学习到的技能</h2><p>其实想了想，我几年没有学到特别多的大的技能，所以将一些细小的方面也都列出来吧。 </p>
<ol>
<li>Chrome 插件开发，只能算是简单了解</li>
<li>TensorFlow, 只能算简单了解</li>
<li>RCNN, fast RCNN, faster RCNN, 了解了论文，大概看懂了代码</li>
<li>Torch， 只知道怎么安装，跑了简单的示例程序</li>
<li>Paddle， 只会安装</li>
<li>Ruby, 学习了一段时间，现在又忘记了……</li>
<li>Ruby on Rails, 学习来一段时间</li>
<li>Lua, 在看Torch的时候学习了一下，现在忘差不多了……</li>
<li>PIL, 大概了解简单用法</li>
<li>Numpy, 了解基本数据类型和简单用法</li>
<li>Git, 了解比之前加深了一些</li>
<li>GAN, 了解了概念</li>
<li>CUDA, 了解一些</li>
<li>Spark, 跑了跑教程里面的例子</li>
<li>OpenMP和MPI， 也是大概了解</li>
</ol>
<p>发现我基本都是只了解一些，没有完全地静下心去掌握……</p>
<h2 id="4-阅读的书籍"><a href="#4-阅读的书籍" class="headerlink" title="4. 阅读的书籍"></a>4. 阅读的书籍</h2><p>今年偶然的机会了解到了微信读书这个app，用了一段时间后发现很不错，在手机上读书比读纸质书更方便，随时随地都可以看书，毕竟手机已经完全融入到每时每刻的生活中了。下面就是今年我所读完的书籍（包括微信读书上看的和电脑上看的PDF版和纸质版）。  </p>
<ol>
<li>《Pro Git中文版》, 非常棒的一本介绍Git的书，写的特别清楚，个人认为和《The Django Book中文版》是我看过的写得最好的技术书籍</li>
<li>《白鹿原》,熟悉的西北地域，陌生的魔幻现实风格</li>
<li>《呼兰河传》: 小孩子童年的记忆，小城里小人物的故事，和风土人情。全书笼罩在悲凉的气氛下</li>
<li>《边城》： 湘西风情画，赛舟，吊脚楼，山歌，河流，淳朴的水乡人民，单纯的爱情故事，描写方式很独特，所有的故事发展好像都是从写环境来展开的</li>
<li>《查令十字街84号》： 落魄美国女作家和英国书店绅士因购买书籍而开始的的书信集，活泼的女作家和谦谦有礼的已婚男绅士的反差很有趣，困境中相互帮助和美好的心灵。</li>
<li>《芙蓉镇》: 南方小镇的文革风云。</li>
<li>《追风筝的人》：阿富汗风情录，在历史变幻下的一个人的救赎之路，看完之后就会明白为什么评价这么高了<br>2017年继续坚持阅读，希望能读一些关于商业和理财知识方面的书籍，了解基本知识，拓展视野。  </li>
</ol>
<h2 id="5-实验室的进展"><a href="#5-实验室的进展" class="headerlink" title="5. 实验室的进展"></a>5. 实验室的进展</h2><p>其实这一年来实验室的工作进展很小，这一年里沿着2个思路做了工作，但结果都不好，实在不知道接下来该怎么走。  </p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>新的一年，继续加油，努力做好每件小事，改正前面提到的问题，相信肯定会有收获的。  </p>
]]></content>
      <tags>
        <tag>年终总结</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text 使用技巧2</title>
    <url>/2015/05/29/sublime-text-summary-2/</url>
    <content><![CDATA[<h2 id="1-安装包管理工具Package-Control"><a href="#1-安装包管理工具Package-Control" class="headerlink" title="1. 安装包管理工具Package Control"></a>1. 安装包管理工具Package Control</h2><p>包管理工具是安装插件的一个简单有效的方法，安装完Package Control后，就可以用<strong>Ctrl-Shift-P</strong> 快捷键来安装插件了。<br>包管理器的安装方式:用_Ctrl-`_快捷键打开命令行，然后在命令行中输入如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2,os,hashlib; h = <span class="string">&#x27;eb2297e1a458f27d836c04bb0cbaf282&#x27;</span> + <span class="string">&#x27;d0e7a3098092775ccb37ca9d6b2e4b7d&#x27;</span>; pf = <span class="string">&#x27;Package Control.sublime-package&#x27;</span>; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(ipp) <span class="keyword">else</span> <span class="literal">None</span>; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( <span class="string">&#x27;http://packagecontrol.io/&#x27;</span> + pf.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;%20&#x27;</span>)).read(); dh = hashlib.sha256(by).hexdigest(); <span class="built_in">open</span>( os.path.join( ipp, pf), <span class="string">&#x27;wb&#x27;</span> ).write(by) <span class="keyword">if</span> dh == h <span class="keyword">else</span> <span class="literal">None</span>; <span class="built_in">print</span>(<span class="string">&#x27;Error validating download (got %s instead of %s), please try manual install&#x27;</span> % (dh, h) <span class="keyword">if</span> dh != h <span class="keyword">else</span> <span class="string">&#x27;Please restart Sublime Text to finish installation&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>然后按回车，之后重启Sublime Text 2，如果在<strong>Preferences-&gt;Package Setttings</strong>菜单里出现<strong>Package Control</strong>，就说明安装成功了。如果使用的是Sublime Text 3，可以看着<a href="https://packagecontrol.io/installation">这个链接</a>。</p>
<span id="more"></span>

<h2 id="2-安装插件Terminal"><a href="#2-安装插件Terminal" class="headerlink" title="2. 安装插件Terminal"></a>2. 安装插件Terminal</h2><p>这个插件用来打开一个命令终端，而且这个命令终端的路径就是当前编辑文件或项目所在路径，所以这条命令非常实用，可以在Sublime Text 2里面编辑好文件后，立即在命令行里面编译什么的，很方便。<br>安装方法：用<strong>Ctrl-Shift-P</strong>打开窗口，输入<strong>Package Control Install</strong>，按回车，再输入<strong>Terminal</strong>，回车之后就开始安装，可以通过左下角的小字查看进度。</p>
<h2 id="3-安装主题Theme"><a href="#3-安装主题Theme" class="headerlink" title="3. 安装主题Theme"></a>3. 安装主题Theme</h2><p>在包安装界面，输入<strong>Theme</strong>，即可看到所有的主题，选择自己喜欢的下载。下载后，修改<strong>Preferences-&gt;Settings-User</strong>，在打开的文件中加入下面一行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;theme&quot;</span>: <span class="string">&quot;Nexus.sublime-theme&quot;</span>,</span><br></pre></td></tr></table></figure>

<p>保存配置文件，主题立即改变。</p>
<h2 id="4-SublimeLinter：代码检查插件"><a href="#4-SublimeLinter：代码检查插件" class="headerlink" title="4. SublimeLinter：代码检查插件"></a>4. SublimeLinter：代码检查插件</h2><p>SublimeLinter据说是一个很好用的代码检查插件，但没用过，所以就只是记录下……</p>
<h2 id="5-SFTP插件"><a href="#5-SFTP插件" class="headerlink" title="5. SFTP插件"></a>5. SFTP插件</h2><p>sftp是一个在Sublime Text 2里面可以直接登陆sftp和ftp账号的插件，登陆还可以浏览、修改账号上的内容，有了sftp，就再也不需要FileZilla了~<br><strong>突然惊喜地发现，SFTP插件也支持SSH，所以以后freeshell可以比较随意地登了。</strong></p>
<ol>
<li> 安装：插件安装，搜索sftp，安装即可。</li>
<li> 安装后，按<strong>Ctrl-Shift-P</strong>，输入sftp，可以看到有<code>Browser Server</code>，<code>Delete Server</code>，<code>Edit Server</code>，<code>Setup Server</code>等命令，首先选择<strong>Setup Server</strong>来增加第一个连接。修改默认的配置文件并保存，即为一个连接。配置文件主要有如下内容：</li>
</ol>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// sftp, ftp or ftps</span><br><span class="line"><span class="string">&quot;type&quot;</span>: <span class="string">&quot;sftp&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;host&quot;</span>: <span class="string">&quot;ssh.freeshell.ustc.edu.cn&quot;</span>,</span><br><span class="line"><span class="string">&quot;user&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line"><span class="string">&quot;password&quot;</span>: <span class="string">&quot;password&quot;</span>,</span><br><span class="line"><span class="string">&quot;port&quot;</span>: <span class="string">&quot;88888&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;remote_path&quot;</span>: <span class="string">&quot;/&quot;</span>,</span><br></pre></td></tr></table></figure>

<p> 其中</p>
<ol>
<li> <code>type</code>表示连接的会话协议类型，<strong>注意ssh设置成sftp即可进行连接</strong></li>
<li> <code>host</code>是要连接的主机名</li>
<li> <code>user</code>是要进行连接的用户名</li>
<li> <code>password</code>是用户的密码</li>
<li> <code>port</code>是进行连接的端口，ftp默认是22端口</li>
</ol>
<h2 id="6-论文还没改完，去写论文了，下次再写"><a href="#6-论文还没改完，去写论文了，下次再写" class="headerlink" title="6. 论文还没改完，去写论文了，下次再写~"></a>6. 论文还没改完，去写论文了，下次再写~</h2>]]></content>
      <categories>
        <category>Sublime Text</category>
      </categories>
      <tags>
        <tag>Sublime Text</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text 使用技巧3</title>
    <url>/2015/06/02/sublime-text-summary-3/</url>
    <content><![CDATA[<h2 id="主题管理插件Themr"><a href="#主题管理插件Themr" class="headerlink" title="主题管理插件Themr"></a>主题管理插件Themr</h2><p>这个插件用命令的形式来管理、设置主题Theme，省去了点击按钮的繁琐操作，对喜爱简单操作的用户来说很有用。<br>安装方式：<strong>Package Control Install</strong>-&gt;输入<strong>Themr</strong>安装即可。</p>
<span id="more"></span>

<h2 id="文件和文件夹的不显示"><a href="#文件和文件夹的不显示" class="headerlink" title="文件和文件夹的不显示"></a>文件和文件夹的不显示</h2><p>之前提到过，Sublime Text可以打开一个文件夹，并将文件夹中所有内容列出到左侧。我们可以进行设置，使一些文件夹和文件不显示出来。具体做法如下：</p>
<ol>
<li><p>先将文件夹保存为<code>sublime-project</code>: <strong>Project-&gt;Save Project As…</strong>，选择保存位置</p>
</li>
<li><p>重新打开保存的sublime-project文件，就弹出了文件列表和一个配置文件，在配置文件里面添加下面语句：</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;folders&quot;</span>:</span><br><span class="line">	[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//added part</span></span><br><span class="line">			<span class="string">&quot;folder_exclude_patterns&quot;</span>:[<span class="string">&quot;figures&quot;</span>],</span><br><span class="line">			<span class="string">&quot;file_exclude_patterns&quot;</span>:[<span class="string">&quot;*.md&quot;</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存后，可以看到，文件列表里面<code>figures</code>文件夹已经不见了，所有<code>md</code>格式的文件也步显示了。<br>注意：设置了不显示后，使用<strong>Ctrl-P</strong>命令搜索内容的时候，被屏蔽的文件夹和文件中的内容是搜不到的。</p>
<p>上面这种方法只能设置当前打开的项目的情况，如果要对所有的工程都屏蔽某一类文件，则可以在<strong>Preferences-&gt;Settings-User</strong>中添加上面两条语句，则对所有项目都适用。</p>
<h2 id="快速书写CSS代码的插件hayaku"><a href="#快速书写CSS代码的插件hayaku" class="headerlink" title="快速书写CSS代码的插件hayaku"></a>快速书写CSS代码的插件hayaku</h2><p>这个插件可以帮助你快速地书写css代码，可以使用简单的几个字母组合就能写出很长的css格式代码，如<code>ml10</code>会被解析成<code>margin-left:10px;</code>。<br>安装方法：搜索<strong>hayaku</strong>进行安装即可。</p>
<h2 id="Sublime-Text-3中的代码提示SublimeLinter，注意与Sublime-Text-2中很不相同"><a href="#Sublime-Text-3中的代码提示SublimeLinter，注意与Sublime-Text-2中很不相同" class="headerlink" title="Sublime Text 3中的代码提示SublimeLinter，注意与Sublime Text 2中很不相同"></a>Sublime Text 3中的代码提示SublimeLinter，注意与Sublime Text 2中很不相同</h2><p>Sublime Text 3中的代码提示插件<strong>SublimeLinter</strong>改进较大，安装方式也不一样，安装<strong>SublimeLinter</strong>后单独安装针对每一种语言的<code>linter</code>，可以先安装<strong>SublimeLinter</strong>，然后看<code>Readme</code>文档查看如何安装剩余的部分。<br>关掉代码提示可以在<code>Ctrl-Shift-P</code>搜<strong>SublimeLinter:Toggle</strong> 来设置开启或关闭</p>
<h2 id="颜色提示插件Color-Hightlight"><a href="#颜色提示插件Color-Hightlight" class="headerlink" title="颜色提示插件Color Hightlight"></a>颜色提示插件Color Hightlight</h2><p>在编写代码时，颜色的标记常常和颜色对应不上，给出一个颜色标记<code>#955278</code>，很难一下子想象到对应的是什么颜色。于是，<strong>Color Hightlight</strong>出现了。安装了这个插件之后，只要点击代码中的颜色标记，就会在该标记上显示对应的颜色，确实很有用的～<br>安装：搜索<strong>Color Hightlight</strong>安装即可。</p>
<h2 id="取色器插件ColorPicker"><a href="#取色器插件ColorPicker" class="headerlink" title="取色器插件ColorPicker"></a>取色器插件ColorPicker</h2><p>这个插件可以获取颜色，然后直接在代码中使用。启动插件的快捷键：<code>Ctrl-Shift-c</code>。面板出来后一看就知道咋用了。</p>
]]></content>
      <tags>
        <tag>Sublime Text</tag>
      </tags>
  </entry>
  <entry>
    <title>2018年终总结</title>
    <url>/2019/01/22/summary-2018/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>拖了近20天的18年总结，今晚终于出炉了。很久没有像在实验室那会一样，打开Vim，新建一个.md文件，写一个总结，很晚才写完，执行<code>hexod</code>一键上传，打开浏览器访问<code>vra.github.io</code>，发现一切OK，才收拾东西往宿舍走，一路上异常满足。现在想想，记录所学的知识，并与人分享，我觉得算是很能提升幸福感的事情了。因此在空闲的时间，我还是会将我学的东西整理后写到这里，一方面是方便自己以后回顾，另一方面是希望能帮到别人，最后的私心是希望以这种方式记录时间的一部分，等到老了，慢慢翻阅，回想某年某月某个夜晚，写完了一个总结，回去的路上隐隐有些欣喜，那种情景，想想也觉得很美好。</p>
<span id="more"></span>
<p>2018年发生了很多事情，总体来说就是研究生毕业和入职旷视已半年。在6月初的时候，离开待了7年的科大，来到北京，租房，开始工作。研究生阶段没有好的成果，现在想想，有些惭愧，也有些后悔；工作半年，感觉学到了很多东西，不过总感觉可以做得更好，希望2019年的自己能让自己满意。下面我试试按时间顺序，整理每个月做了哪些事情，这里主要参考邮件、照片、朋友圈、QQ空间说说来回忆。</p>
<h3 id="1月"><a href="#1月" class="headerlink" title="1月"></a>1月</h3><p>元旦和云亮去北京玩，去了天安门、故宫、恭王府、鸟巢，去沸炉吃了火锅。冬天天黑的比较早，太阳要落山的时候我们才爬上鸟巢顶，上面的大风，吹得耳朵刺拉拉的疼。</p>
<p>1月26日栾京来北京，我和陈仁爱、张凯陪他玩了一天，大雪纷纷，在校园里面漫步拍照，“四只小船”又重聚了～</p>
<p>别的时间在准备3月份的中期答辩，此外好像没有什么别的事情。。</p>
<h3 id="2月"><a href="#2月" class="headerlink" title="2月"></a>2月</h3><p>我之前在2017年的12月份的时候，已经将之前的工作投了2篇ICME，担心这两篇也中不了，因此又做了一个改进“Attention Pooling”的工作，投了ICIP，主要是周老师和张岐林师兄帮我修改。2月15日是春节，而ICIP的投稿截止时间是2月14日。我在2月8号到家后，又花了一个星期在改论文，还麻烦远在美国的岐林师兄每天和我讨论数次。想要多跑些实验，但是家里总是各种琐事，联网又很不方面，笔记本联网得去邻居永茂家，天天去也不好意思了。最后煎熬了一星期后，还是只写了一个数据集的结果上去。投完后岐林师兄就跟我说，现在做CV和DL的人越来越多，ICIP标准也越来越高，实验部分一个数据集还是太少了。我当时也没想太多，可能还是对大会的投稿量和投稿质量有明显的认识吧。后面又赶上ICME出Rebuttal，在天水和高中室友聚会的时候还在和师兄改回复内容。</p>
<p>春节在家感觉还是很好，暂时忘掉毕业的压力和论文中不了的焦虑，脱离节奏快的城市生活，在世外桃源般的家乡体验另一种慢生活。去看望了姥爷，去河边走了几趟，陪渐渐长大的外甥们玩耍，过年去各家亲戚家拜年，和小学同学初中同学一起坐坐，聊聊，感觉挺好的。  </p>
<p>2月24日我从家里出发回学校。临走那天晚上，已经很晚了，外甥还要和我们玩，不想睡觉。我妈对她说：”你舅舅明天要去坐车，让他今晚早点睡吧，等暖天个放假来了再和你玩耍“，结果外甥一下子就哭了起来。可能对于四岁多的她来说，没有太多的时间概念，“暖天个”还要很久很久，仿佛远得等不到一样。看着她哭我也有些心酸，只盼望他们能够健康快乐的成长，别从小就缺少家人的关爱。</p>
<h3 id="3月"><a href="#3月" class="headerlink" title="3月"></a>3月</h3><p>毕设中期检查</p>
<h3 id="4月"><a href="#4月" class="headerlink" title="4月"></a>4月</h3><p>ICME没有中，改投Workshop，4月30号才收到录取的消息，而距离毕业也就一个月的时间了。这段时间心态真的是要崩溃了，也不知道是什么熬过来的。</p>
<h3 id="7月"><a href="#7月" class="headerlink" title="7月"></a>7月</h3><p>7月12日是入职时间，我在家待到7月8号就去北京了，搬进了租好的房子里。<br>7月12日开始上班，开始学习旷厂的各项技术框架和工具链，做视频分割的任务，懵逼了好久才找到点感觉。</p>
<h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><p>9月去参加了在德国慕尼黑召开的ECCV会议。<br>在9月中旬从六里桥搬到离公司比较近的学院路，从此再也不用早起2个小时了。</p>
<h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><p>国庆节和彤彤去了兰州，双方家长见了面，人生大事提上日程。</p>
<h3 id="12月"><a href="#12月" class="headerlink" title="12月"></a>12月</h3><p>入职半年时间，逐渐掌握公司的工具链，技术水平有所提高，也能跑可用的模型，不过论文阅读、理论创新方面仍不够，还需要继续加强。<br>还有有效沟通的技能我感觉自己还是很欠缺的，希望今年能有更好的提升。</p>
<h2 id="2018年阅读的书籍"><a href="#2018年阅读的书籍" class="headerlink" title="2018年阅读的书籍"></a>2018年阅读的书籍</h2><ol>
<li>雷军传：顺势而为</li>
<li>围城</li>
<li>渔翁对韵</li>
<li>菜根谭</li>
<li>步履不停</li>
<li>黑客与画家</li>
<li>自卑与超越</li>
<li>牛虻</li>
<li>声律启蒙</li>
<li>明朝那些事</li>
<li>天龙八部</li>
<li>笑傲江湖</li>
<li>射雕英雄传</li>
<li>革命时期的爱情</li>
<li>简明美国史</li>
</ol>
<p>受好友影响，今年也开始看金庸的小说，真的是一看就停不下来了，为其中的人物故事所吸引，久久不能忘怀。</p>
<h2 id="2018年观看的电影"><a href="#2018年观看的电影" class="headerlink" title="2018年观看的电影"></a>2018年观看的电影</h2><ol>
<li>诺丁山：异常真实的浪漫奇缘</li>
<li>天使爱美丽</li>
<li>复联3：最佳反派</li>
<li>无名之辈</li>
<li>风味人间</li>
<li>碟中谍6</li>
<li>邪不压正</li>
<li>死侍2</li>
<li>红海行动</li>
<li>寂静之地</li>
<li>黑豹</li>
<li>后来的我们</li>
<li>古墓丽影：源起之战</li>
<li>神秘巨星</li>
<li>勇敢者游戏</li>
<li>伯德小姐</li>
<li>至暗时刻</li>
<li>了不起的麦瑟尔夫人</li>
<li>哆啦A梦：大雄的金银岛</li>
<li>寻梦环游记</li>
<li>游侠索罗：星球大战外传</li>
</ol>
<h2 id="展望2019"><a href="#展望2019" class="headerlink" title="展望2019"></a>展望2019</h2><p>其实进入2019已经好多天了。2019年，希望能静得下心，多做研究和技术上的积累，将工作做solid。</p>
]]></content>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年终总结</title>
    <url>/2020/01/01/summary-2019/</url>
    <content><![CDATA[<h2 id="2019-大事记录"><a href="#2019-大事记录" class="headerlink" title="2019 大事记录"></a>2019 大事记录</h2><p>个人生活上，在2019，我结婚了。领证，订婚，两周后的结婚都是今年重大的事情。有的时候，觉得这些都是重大的神圣时刻，而更多的时候，真正经历其中的时候，发现这些都是由一个个平常普通的事件构成的。生活的大多数美好，是否只有在成为记忆，再次回想的时候，才会展现出来？我不知道，不过确实有些美好是在经历时就能感受到的。</p>
<p>今年和家人好友相聚的次数多了，而且内心非常珍惜每一次相聚的机会。大家天南海北，相聚到一起，面对面地坐下聊天，似乎也是非常难得的时刻。因此我将今年的每一次相聚都记录下来，因为这是我所珍视的东西。</p>
<p>在上下班的公交上，继续用微信阅读来读书。除了《飞狐外传》，《侠客行》和《越女剑》，别的金庸的小说都看完了。射雕里面的剧情经常浮现出来，仿佛久远的记忆般。神雕居然给我感动到了，原来真正地爱情确实有打动人心的力量。看了《连城诀》，想体验一次雪崩……</p>
<p>电影院今年很少去，基本都是在笔记本看完的电影和美剧。有时候，周末的午后，看一部怀旧电影，那这个周末就很满足了。</p>
<p>当然，作为一个上班族，今年的大多数时间都是在公司度过的，而其实我对自己这一年的工作表现并不满意。总得来说，沟通做的不够好，思考不够深入，没有解决一些创新性问题或本质问题。希望2020年在这些方面能做更好。</p>
<p>下面从几个方面总结下2019这一年。</p>
<span id="more"></span>

<h2 id="和家人好友在一起"><a href="#和家人好友在一起" class="headerlink" title="和家人好友在一起"></a>和家人好友在一起</h2><p>年初和高中室友在兰州相聚了。老六调到汉中了，明年也准备结婚了，王斌也见家长了，参和朝哥都挺好。再次来到兰州，还是很有熟悉的感觉，冬天有点冷。</p>
<p>年初我和彤彤去了碑刻博物馆，即五塔寺。那会玉兰花刚开始开放花苞， 别的树绿叶还没开始生长，而至今已经有五百多年的五塔寺，和塔周围古老的银杏树，都让人有一种历史的岁月感，所以有感而发写了下面的字：</p>
<pre><code>春日游五塔寺

长河浅波碧水流，河畔古刹少人游。
明代初修真觉寺，今朝重建博物楼。
五塔独立六百载，双杏攀援多少秋。
志铭碑刻斜阳里，春上玉兰满枝头。
</code></pre>
<p>后面我们还去了雕塑公园，看了玉兰花，不过感觉北京的玉兰，比合肥的玉兰还是不一样的，可能去的有点早了。</p>
<p>在海棠盛开的季节，我们去元大都城垣遗址公园看花。那时候，真是游人如织，小月河两边都是拍照的人，海棠花热闹地开放在温暖的春天里。那天我们走到最东边的出口，吃了徽州菜，臭鳜鱼有点太咸了。然后在小月河南边往回走，到家已经很晚了。以后每年都去看海棠。</p>
<p>刘旸来北京，我们本科宿舍又聚了一波，政哥也入职百度了，就等策哥博士毕业了。</p>
<p>夏天来临的时候，周末我们基本就没出去了，在家度过。我们尝试了煎韭菜盒子，和面包饺子，浆水面，大盘鸡，疙瘩汤，红豆粥，绿豆汤等美食，感觉随便做些饭都比外面吃起来香。一般都是彤彤做饭，我洗锅。</p>
<p>暑假和彤彤回家领证订婚，去爬了山，去和舅舅家的两个侄子在河边捞鱼划水打水漂，七月十二庙会，和家人去看了戏，爷爷也在戏场里。婷婷参加了舞蹈班，会在场戏结束后上台表演。她爷爷开着车拉她到戏场，她见到我，很羞涩，半天不说话，好像已经忘了我似的。</p>
<p>我们还去了姨娘家。那会大表哥在加拿大出差，二表哥也在陇西单位上班，姨夫也去上班了，姨娘做了好吃的，我们也吃得很好，吃了好多葡萄。每次去姨娘家都是很开心，每年能聚一次就感觉很开心。</p>
<p>临走前一天，我和彤彤去了爷爷家，和爷爷聊了挺久的天。 爷爷给彤彤讲家里的事情，我也在回想这些年在爷爷家度过的时光，每年大年第一天第一个去的地方就是爷爷家，以前都是爷爷给我们给红包，一直到研究生毕业。能陪爷爷聊会，整个人会好点吧，一个人过应该也挺不容易的。</p>
<p>周浩来百度实习了，我们和孙可一起去吃了烤鱼。</p>
<p>俊福来北京办签证，我们一起吃了饭，在融科楼底下的小吊梨汤。我被工作各种事情搞得很慌乱，他中了论文还是挺好的。我想以后我们每年能见一次就挺好的。</p>
<p>王如凡请我俩在三里屯的海底捞吃火锅。两个天水老乡在北京相聚了，这次吃饭说了大概有一年多了哈哈。</p>
<p>端午节前，永荣哥和晓丽姐来北京学习，我们在西直门商场的云南菜馆聚了一次餐，然后去书店逛了逛。和表哥聊了很多深入的话题，很明显能感觉到表哥是有自己的一套生活理念的，这种理念既有我们家乡的淳朴传统，也结合了进城市发展的知识分子的思考，而这是我所欠缺的。表哥一直以来都是我的榜样，继续向他学习，努力向他看齐。</p>
<p>云亮后面也来北京上班了，田明高考志愿报到北邮，也成功被录取，九月也来北京上学了。算了彤彤的话，苗家庄现在有四个人在北京了。周末我们去爬了百望山，然后回家自己煮火锅，简直不要太开心。</p>
<p>爬了西山，看日落。和云亮一起爬香山，看红衣，晚秋的香山还是很好看的，不虚此行，不过确实比较累。</p>
<p>志超来北京学习，晚上我俩去吃了全聚德，体验极差。我们聊到各自的工作，虽然已经不是初中那会在教室里学习加玩耍的样子，还是说好要努力在未知的世界里奋斗。</p>
<p>组内同事聚餐，去了新中关的一家自助铁板烧。肉很好吃，大家也很开心，团队一起嗨，一起庆祝的感觉很棒。</p>
<p>和文强，俞飞，杨雯鑫，王如凡去吃了涮肉，攒局的雪铖因为当晚开会所以没来。  那会有些事，不过有同学周六中午就要走了，聚一次也不容易，因此我起点从公司出发，坐地铁然后骑共享单车到店里，进去热得流了一阵汗。文强晚点才到，我们等了很久，差不多九点才上菜，我和文强九点半就坐地铁回去了。 跟大家聚聚还是很开心，不过大家都成了为工作和加班奔波的人了。  </p>
<p>后面和彤彤，王斌和周温婧去吃了学院南路的铜锅涮肉。也是等了很久，王斌在实习，开始做 Python 和 C++ 的项目了，以后可以一起讨论技术问题了。 大家还说了2020年博士毕业，顺便在兰州办一个高中同学毕业十周年聚会，想想挺不错的。</p>
<p>抓住2019的尾巴，和来北京出差的小爱聚了下。在涮肉点，我们两人吃了三大盘肉，很多菜，而我仿佛说了这一年来最多的一次话。我们从学校、工作聊到小时候，过年的习俗，结婚的习俗，读书，游玩等等。吃完后去天桥拍了照，小爱第二天就回成都了，而我当晚也想了很久，以后的计划。</p>
<h2 id="开源贡献"><a href="#开源贡献" class="headerlink" title="开源贡献"></a>开源贡献</h2><p>今年在开源上的贡献比较少，主要做了下面两个小工具，个人感觉 dompare 在一些服务器无图形界面的环境下，还是有一些应用场景的。</p>
<ol>
<li><a href="https://github.com/vra/dompare">dompare</a>: 一个递归比较文件目录的小工具</li>
<li><a href="https://github.com/vra/flopth">flopth</a>: 计算 pytorch 模型 FLOPs 的工具</li>
</ol>
<h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><p>和组内的同事一起投了两篇论文，坚持每年都能赶1-2次论文。另外感觉论文阅读还是不够，没有养成定期阅读的习惯，靠心血来潮读一读，总是不行的。</p>
<h2 id="书籍阅读"><a href="#书籍阅读" class="headerlink" title="书籍阅读"></a>书籍阅读</h2><p>在上班的公交上，我还是用微信读书 app 来阅读书籍。周末有时候也会在上面花费很多时间在上面。除了信息流中很多低俗的内容外，别的方面都挺好，我甚至觉得这个 app 可能是这几年对我帮助最大的一个手机程序。下面记录今年看的书，作为对年初目标的「清算」。</p>
<ol>
<li>《列奥拉多·达·芬奇传》: 达芬奇的手稿和绘画为主，写得很清晰</li>
<li>《鹿鼎记》</li>
<li>《卓有成效的管理者》</li>
<li>《青年变革者：梁启超（1873-1898）》:说实话条理有点乱</li>
<li>《非暴力沟通》</li>
<li>《你一定爱读的极简欧洲史》</li>
<li>《活着》</li>
<li>《我们仨》</li>
<li>《连城诀》:有种「暴力美学」的感觉</li>
<li>《人生》</li>
<li>《2001：太空漫游》:猿人观察降临物那部分写得太好了</li>
<li>《海蒂》: 很治愈</li>
<li>《我可以咬你一口吗》</li>
<li>《鱼乐·忆顾城》</li>
<li>《梁启超传（全集）》</li>
<li>《不忍细看的五代十国史》</li>
<li>《丰乳肥臀》</li>
<li>《乡村教师》</li>
<li>《早晨从中午开始》</li>
<li>《雪山飞狐》</li>
<li>《杜甫诗选》</li>
<li>《碧血剑》</li>
<li>《神雕侠侣》:本来以为杨过和小龙女的故事没法打动到我，没想到最后居然落泪了，真情写的好，你是能感觉出来的</li>
<li>《倚天屠龙记》</li>
<li>《白马啸西风》</li>
<li>《一本书读完人类一战的历史》</li>
<li>《邓小平时代》</li>
</ol>
<h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><ol>
<li>《好莱坞往事》: 喜欢怀旧的那种感觉，以及小李在剧中的中年危机下的痛哭</li>
<li>《爱尔兰人》</li>
<li>《硅谷 第六季》:非常 exciting</li>
<li>《蜘蛛侠2》</li>
<li>《小丑》</li>
<li>《流浪地球》</li>
<li>《速度与激情：特别行动》</li>
<li>《复仇者联盟4：终局之战》: 感觉要比3感情上弱些，搞笑气氛多了</li>
<li>《湮灭》</li>
<li>《雷霆沙赞》</li>
<li>《布达佩斯大饭店》:非常有意思，看完感觉很爽，</li>
<li>《中国新疆 反恐前沿》</li>
<li>《切尔诺贝利》</li>
<li>《完美陌生人》</li>
<li>《性爱自修室 第一季》:治好你我的「恐同症」</li>
<li>《玩具总动员 1-4》: 非常超出预期的电影，本来以为后面会越来越次，结果每一部都不落窠臼，有新意，能引发人的思考</li>
<li>《走进比尔：解码比尔·盖茨》</li>
<li>《城市之光》： 爱情很美，搞笑的地方也很搞笑</li>
</ol>
<h2 id="胡思乱想"><a href="#胡思乱想" class="headerlink" title="胡思乱想"></a>胡思乱想</h2><p>平常有时候会胡乱地想一些东西，但是很多时候思考是漫无目的的，针对性地深入思考某个问题，还需要锻炼，下面记录一些自己不成熟，没缘由的想法，或许写着写着就慢慢地变得有条理了。</p>
<ol>
<li>手机和移动互联网的存在，减少了男女对对对方的需要，因为以前很多男女一起干的事情，现在都可以用手机来干了;而且手机上的应用和游戏占据了很多人的空余时间，没时间来想人际交往，所以会造成单身人口的增加，进而造成生育率的降低。</li>
<li>还是关于手机和互联网，现在的游戏和手机太好玩，很容易沉迷，很多时间都被占据了，别的各方面的诱惑也太多，没有时间来思考人生或专业研究，而要有所大成，必须花费大量的时间和心血到上面，所以现在的我们是不是很少能达到前互联网时代的人那样高的成就？ </li>
<li>看了比尔·盖茨的纪录片，再次燃起了想要一个墙那样高的藏书架的愿望，年初淘了几本旧书，后面没有再积攒，目前藏书可能还是个位数，明年争取淘到50本值得收藏的书，书架，还是先等等再买吧。</li>
<li>去大觉寺，法源寺，百望山和陶然亭，看到很多碑刻，上面的字有些能看懂，有些看不懂，不过这样，读起来也很有意思。想学学繁体字，把每个碑刻上的文字转换成文本来阅读。</li>
<li>想去合肥的大蜀山旁的小湖边再看一次玉兰花的盛开。</li>
<li>有时候会想，我到底适合做什么呢，做什么才能体现人生的价值呢（暂且不考虑买房买车这种物质上的实现）？去小学当个老师，是不是比在大公司做一个toB的产品，有更高的社会价值？</li>
</ol>
]]></content>
      <tags>
        <tag>年终总结</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年终总结</title>
    <url>/2021/01/02/summary-2020/</url>
    <content><![CDATA[<h2 id="2020流水记录"><a href="#2020流水记录" class="headerlink" title="2020流水记录"></a>2020流水记录</h2><p>新的一年又开始了，记录一下2020年发生的一些事情，作为对这不平凡的一年的简单的回顾。</p>
<p>1月14日，农历腊月二十，我和彤彤在我家结婚了，作为主人翁参与其中，是一种很神奇却很美好的感觉，结婚的大小事情都是爸妈和村里的亲戚邻居一起来做的，很感谢爸妈亲戚邻居们的付出，让寒冬里面的腊月二十热闹而温暖。</p>
<p>关于结婚几天发生的事情，我写了一些流水账记录，不过后面没有完全写完，等有空了再回忆回忆，完全写完再发出来吧，也算是给自己一个交代。</p>
<p>总之非常感谢所有人的帮助和支持。</p>
<span id="more"></span>

<p>结完婚没多久就过年了，因为疫情影响，各个村都封路了，因此很多亲戚都没能走成，一年一度的见面也落空了。那段时间只能待在家里，每天看关于疫情的新闻，心里很紧张，担心疫情失控。我甚至还想过，疫情会不会让人像恐龙一样，因为突发事件而灭绝，现在看来是太悲观了，而且杞人忧天不止一星半点。</p>
<p>转眼春节假期结束了，关于开工的问题，公司决定远程上班两周，再回北京到办公室上班。彤彤和云亮的单位也是类似的政策。因此我们体验了在家里上班的有趣的日子。</p>
<p>每天早上起来，妈已经做好了早饭，吃完后就去上阁房的桌子前办公，网不好时去中间屋子看看网。一早上是电话开会，开完会开始干活，晚上写日报。云亮和彤彤也是类似的样子，开会，看资料，写总结。</p>
<p>这次疫情证明了远程办公其实是可行的，这让我不禁想，也许未来我就在老家的房子里，烤着温暖的炉子，吃着妈做的好吃的饭，远程为某个遥远的大城市的公司干活。这样家人和工作都能两全，是我理想中想要的生活。当然还有一些需要解决的问题，比如远程工作如何保证效率等等。</p>
<p>两周后，农历二月二一过，我和云亮就在包叔的车的接送下，穿过封锁状况未知的村村镇镇，达到陇西火车站，坐上了回北京的车。走之前爸专门去村里的大队部开了一个类似通行证的材料，证明我们没有接触过感染人员，请让我们通行，有种类似护照的感觉，也算是今年这个特殊时刻特别的纪念物品了吧。</p>
<p>我还记得刚到北京，地铁里面空荡荡的，大街上也没有多少人，有点像一座空城。</p>
<p>后来渐渐地，在强大的国家的有效管控以及医护人员巨大的付出下，疫情受到控制，小区也从进出严格登记，到检查通行证，到最后基本不检查，年中的时候带口罩就好了。</p>
<p>因为结婚了，我俩开始更具体地想以后的生活，最直接的是，去哪座城市定居。我们考虑过成都，西安，杭州，南京这些地方，最后因为一些机遇，我俩决定去杭州，后面的规划和目标也渐渐清晰了起来。</p>
<p>6在月底的时候，我们转移到杭州了。还好有云亮在北京，我们这次转移才比较容易，很多东西都是他后面给我们寄过来的。</p>
<p>还记得刚到杭州的那天晚上，出永福地铁站的时候，天已经全黑了，外面下着小雨，我俩看着陌生的地方，想着要开始一段全新的旅程，心里激动不已。</p>
<p>然后我们开始租房子，确定住哪边。在梅雨季节里，我们体验了杭州的潮湿和闷热，好在出梅后，一切都还算适应。</p>
<p>然后开始上班，周末和假日也去玩了很多地方，包括云栖竹径，五云寺，北高峰，杭州植物园，良渚文化村，西溪湿地，还有西湖。</p>
<p>七月份组内出游活动，我们组去了爬了黄山，去宏村参观了古村落，还去屯溪老街转了转。当然出去玩是一方面，更重要的是团队建设，也是了解组内氛围的好机会，确实借此机会，我也了解到组内公开透明，相互尊重的氛围，让我印象很深刻，也确信是值得加入的。</p>
<p>国庆假期，我和彤彤在秦安下高铁后，坐出租去庄浪，一路上听出租车司机讲了很多有意思的事情。晚上9点多到县城，少华已经在等我们了。到家后很晚了，家人们都在，团聚在一起，聊了很多。</p>
<p>让我印象很深的是，第二天少华，爸还有我去楼下吃牛肉面。那家店味道很好，而且一大早一起吃牛肉面的经历，也让我觉得值得记录，是家的另一种存在形式吧。</p>
<p>第二天高中室友老六结婚，我一大早过去，和朝哥，彦斌帮了下忙，也见到了好几年没有见的老六的爸妈和姐。高中那会他们经常来兰州看老六，每次来都请我们吃饭，带很多水果给我们，我心里很感激。高中毕业那年，我们宿舍组团来庄浪玩，度过了一个快乐又难忘的夏天。</p>
<p>国庆第四天彤彤家新房入住，来了很多亲戚，很热闹。这是岳父岳母自己这些年辛苦赚钱买的房子，是一个了不起的人生成就。能感觉到他们还是很自豪很开心的。我和大姐的孩子奥博玩了很久，很感叹他的学习能力。下午全家人和亲戚去饭店吃饭，我和彤彤提前离开，去坐回家的车。晚上到我家。到家后和全家人团聚在一起，是开心幸福的。</p>
<p>家里的葡萄成熟了，而且今年长得比较繁，吃起来比外面买的葡萄甜多了，也好吃。</p>
<p>在家的几天，和姨夫聊了聊，因为疫情原因过年也没见面。也和三舅三妗子聊了聊，聊了一些跑计划生育时在我家暂住时的事情。和小学同学斌斌结婚，去他家和小学同学聊了聊。去带婷婷和豪豪爬了一次山，所以才有了封面的这张照片。</p>
<p>国庆结束后，10月8号就回杭州继续上班了。</p>
<p>后面有段时间工作很忙，遇到了很难解决的问题，一行行调试代码，两三周没搞出来，心态快要崩了。某个周末，搞了两天，还是没能解决，周日晚上搞到很晚，头脑一片混乱，不得不在不甘中睡下。周一早上起来发现居然神奇地解决了，激动地哭了。后来塞远请我们吃饭，犒劳我们辛苦的几周.</p>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3><p>今年只写了一个标注图像的工具，<a href="https://github.com/vra/easybox">https://github.com/vra/easybox</a>，可以对图像中的物体进行矩形框标注，特色是即插即用，支持多平台，支持文件夹标注，每张图片支持任意个标注框，可以通过 <code>pip install easybox</code> 来安装使用。</p>
<h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><p>今年又是命途多舛的一年，和飞哥，鑫焱去年投的CVPR没有中，今年先是改投eccv，没中后又改投accv，仍没有中，最后就放到了arxiv上。总之还是感谢飞哥和鑫焱的辛勤付出，大家都付出了很多，很不容易。</p>
<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>今年读书有点少，只看完了不到五本，flag倒的有点厉害。分析发现，通勤时间没了，所以平均每天看书时间减少了20分钟；而且周末大部分时间在看电影和剧集，读书的时间就更少了。不过《中共党史珍闻录》对我触动很大，从第三者的角度反思了历史上的一些事件，没有粉饰也没有诋毁，太难得了。同时也让我开始思考，伟大如斯的人物都难免犯错，如我等平凡人，做错事更是容易，所以更需要跳出自我麻痹，正视自己的正确与错误，努力改进。</p>
<ol>
<li>《人体简史》</li>
<li>《山核桃大街谋杀案》</li>
<li>《流畅的Python》</li>
<li>《中共党史珍闻录》</li>
<li>《三少爷的剑》</li>
<li>《白发魔女传》</li>
</ol>
<h2 id="影视"><a href="#影视" class="headerlink" title="影视"></a>影视</h2><p>今年周末看了很多电影和剧集，最喜欢《小谢尔顿》了，温暖的家庭剧，大部分时候是搞笑的，有时候家人和成长的故事还是很让人动容。</p>
<h3 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h3><ol>
<li>《Hello!树先生》：小县城的场景太熟悉了，主角有点魔幻</li>
<li>《Her》</li>
<li>《树上有个好地方》：想起了小学的很多事情</li>
<li>《星球大战8》</li>
<li>《星球大战9》</li>
<li>《1917》：唯美的战争画面</li>
<li>《他们已不再变老》</li>
<li>《异形系列》</li>
<li>《真心半解》</li>
<li>《绅士们》</li>
<li>《八恶人》</li>
<li>《无耻混蛋》</li>
<li>《拯救大兵瑞恩》</li>
<li>《小妇人》</li>
<li>《婚姻故事》</li>
<li>《乔乔的异想世界》：感动到哭的电影</li>
<li>《利刃出鞘》：好的故事，引人入胜</li>
<li>《婚姻故事》</li>
<li>《绿皮书》</li>
<li>《波西米亚狂想曲》：主角塑造的太好了</li>
<li>《华盛顿邮报》</li>
<li>《楚门的世界》</li>
<li>《闻香识女人》</li>
<li>《银翼杀手2049》</li>
<li>《双子杀手》</li>
<li>《阿拉丁》</li>
<li>《白蛇·缘起》</li>
<li>《哪吒之魔瞳降世》</li>
<li>《星际探索》</li>
</ol>
<h3 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h3><ol>
<li>《小谢尔顿1-4季》</li>
<li>《爱，死亡与机器人第1季》</li>
<li>《曼达洛人1-2季》</li>
<li>《性教育第2季》</li>
<li>《异星灾变第1季》</li>
<li>《环形物语第1季》</li>
<li>《我们的父辈》</li>
<li>《生活大爆炸第12季》</li>
</ol>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>周末我们都会自己做饭，因为自己做的好吃也便宜。我也尝试了自己做饭，做出来味道还不坏，心里还是挺开心的。</p>
<p>年末的时候开始和彤彤跳绳了，每天500到1000个，感受肌肉劳累然后完成任务放松的感觉，也许跟做事情一样的道理，no pain, no gain。希望我们能坚持。</p>
<p>我们租的房子在12层，往西看就是很高的欧美金融城，晴天傍晚的风光很美。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>今年一直在想的一个问题是，我们是否会想现在一样，衣食无忧，每天辛勤工作，最后也会买房子生孩子，养家糊口，但最终没能给这个世界带去大的改变？<br>如果要做更多贡献，该从哪里开始改变这条常规之路呢？</p>
]]></content>
      <tags>
        <tag>年终总结</tag>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title>2017年终总结</title>
    <url>/2018/01/05/summary-2017/</url>
    <content><![CDATA[<p>2017年过去已经有几天了，这几天我总结了2017年的学习、找工作、阅读和影视方面的大大小小的事情，希望坚持每年写一个年终总结，整理去年发生的事，更好地认识自我，做更好的自己。</p>
<span id="more"></span>
<h3 id="开源社区贡献"><a href="#开源社区贡献" class="headerlink" title="开源社区贡献"></a>开源社区贡献</h3><p>今年也没有太多的贡献，主要还是改改小错误，希望2018年有进步吧。下面是我今年贡献过的项目（点击链接可以直接访问我贡献过的代码）：</p>
<ol>
<li><a href="https://github.com/facebook/C3D/commits?author=vra">C3D</a></li>
<li><a href="https://github.com/pytorch/pytorch/commits?author=vra">pytorch</a></li>
<li><a href="https://github.com/sunshaoyan/ISeeNN/commits?author=vra">ISeeNN</a></li>
<li><a href="https://github.com/pengxj/action-faster-rcnn/commits?author=vra">action-faster-rcnn</a></li>
<li><a href="https://github.com/KaiserY/rust-book-chinese/commits?author=vra">rust-book-chinese</a></li>
<li><a href="https://github.com/ClementPinard/FlowNetPytorch/commits?author=vra">FlowNetPytorch</a></li>
<li><a href="https://github.com/liruoteng/FlowNet/commits?author=vra">FlowNet</a></li>
<li><a href="https://github.com/yjxiong/temporal-segment-networks/commits?author=vra">temporal-segment-networks</a></li>
<li><a href="https://github.com/chenxinpeng/S2VT/commits?author=vra">S2VT</a></li>
<li><a href="https://github.com/MoyanZitto/keras-cn/commits?author=vra">keras-cn</a></li>
<li><a href="https://github.com/yjxiong/caffe/commits?author=vra">yjxiong/caffe</a></li>
<li><a href="https://github.com/rohitgirdhar/AttentionalPoolingAction/commits?author=vra">AttentionalPoolingAction</a></li>
<li><a href="https://github.com/isht7/pytorch-deeplab-resnet/commits?author=vra">pytorch-deeplab-resnet</a></li>
<li><a href="https://github.com/escorciav/daps/commits?author=vra">daps</a></li>
</ol>
<h3 id="和同学参加的比赛活动"><a href="#和同学参加的比赛活动" class="headerlink" title="和同学参加的比赛活动"></a>和同学参加的比赛活动</h3><h4 id="1-English-Learning-在线英语听力学习网站"><a href="#1-English-Learning-在线英语听力学习网站" class="headerlink" title="1. English-Learning: 在线英语听力学习网站"></a>1. English-Learning: 在线英语听力学习网站</h4><p>这是年初郑天琦师兄做的一个项目，在线英语听力练习网站，希望解决大多数在线英语学习网站听力练习不够的问题，增加了听力练习的模式。我只给师兄帮忙做了一些爬取英语资源的简单工作。  </p>
<h4 id="2-Hackx-SJTU"><a href="#2-Hackx-SJTU" class="headerlink" title="2. Hackx SJTU"></a>2. Hackx SJTU</h4><p>这是和实验室同学去上交参加的黑客马拉松项目，我们在这个项目里面，做了深度学习相关的一些相关内容，包括超分辨率和视频描述生成,项目地址是<a href="https://www.hackx.org/projects/76">https://www.hackx.org/projects/76</a>, 最后获得了IBM的企业奖，还是挺开心的。</p>
<h4 id="3-HackNanjing"><a href="#3-HackNanjing" class="headerlink" title="3. HackNanjing"></a>3. HackNanjing</h4><p>参加完上交的马拉松后，过不了多久就去南京参加了这个马拉松。这个项目我们做的是环保主题的网站，针对周围的环境污染问题，进行上报，相关单位进行处理。项目地址：<a href="https://github.com/HackNanjing-Team/GreenWorld">https://github.com/HackNanjing-Team/GreenWorld</a></p>
<h4 id="4-百度西交大数据竞赛-宠物狗种类识别"><a href="#4-百度西交大数据竞赛-宠物狗种类识别" class="headerlink" title="4. 百度西交大数据竞赛-宠物狗种类识别"></a>4. 百度西交大数据竞赛-宠物狗种类识别</h4><p>这是一个物体细分类的比赛，同大家一样，我们也采用了深度学习的方法来做，刚开始尝试了Inception V4和ResNet等模型，效果不太高，最后使用了参赛选手开源的代码，改进了下，最后排名前100勉强进了复赛。后面就没有再做。</p>
<h4 id="5-HackxFDU-2017"><a href="#5-HackxFDU-2017" class="headerlink" title="5. HackxFDU 2017"></a>5. HackxFDU 2017</h4><p>这也是Hackx举办的比赛，是第二次在复旦大学举行，我们制作了一个健身教练机器人，利用IBM Waston平台的语音和文字转换来进行指令的采集和输出，然后利用OpenPose来对人体骨架点进行采集，然后分析动作的完成度和个数。这个比赛中我了解到了Waston平台强大的性能和聊天机器人制作的简易性，上手不要太容易，但是收费还是挺贵的。比赛结束后我想利用Waston制作一个聊天机器人，包括软件和硬件，但是一直没有做。。</p>
<h3 id="应聘工作"><a href="#应聘工作" class="headerlink" title="应聘工作"></a>应聘工作</h3><p>今年很大一部分时间花在了准备工作上。毕竟这是人生很重要的一步。幸运地是通过了旷视科技的笔试和面试，能够有机会加入旷视。整个笔试面试，从6月底开始，一直持续到11月，将近5个月，想来一路走来还是不容易。</p>
<h4 id="1-搜狗"><a href="#1-搜狗" class="headerlink" title="1. 搜狗"></a>1. 搜狗</h4><p>搜狗来得比较早，大概是7月初就来学校提前招聘，在招聘的最后一天，他们打电话叫我去面试，是语音组，显示科大的宋洋师兄面试了我，然后是陈伟，搜狗语音的负责人面试的，最后是一个HR面试。面试过了2个月才通知结果。</p>
<h4 id="2-360"><a href="#2-360" class="headerlink" title="2. 360"></a>2. 360</h4><p>8月14日，我去360进行了面试，他们做的是Feed流中的数据分析和数据挖掘，刚开始是一个科大师兄面试，后面是一个负责人面试，没有问太多技术问题，让介绍下CNN，然后问推荐系统了解哪些知识，我提了下协同过滤。最后是个HR面试，问为什么来北京，对北京户口怎么看。</p>
<h4 id="3-京东"><a href="#3-京东" class="headerlink" title="3. 京东"></a>3. 京东</h4><p>京东我是在6月26日就去北京亦庄参加了面试。当时真的是害怕找不到工作，遇见一个机会就得去试。我去面试的部门是京东智能部，希望做图像的算法。可做的空间比较小，而且现在同意进入这个部门的面试流程的话，就不能参加后面别的部分的招聘了。面试官让我回去考虑下，我在回去的地铁上，考虑好就给这边说先不参加招聘流程了。<br>后面校招的时候，笔试完就挂了，因此和京东无缘了。</p>
<h4 id="4-百度"><a href="#4-百度" class="headerlink" title="4. 百度"></a>4. 百度</h4><p>8月15日下午我去百度科技园参加了面试。这次面试的部门是IDL，方向是算法工程师。刚进去是一个穿着拖鞋的工程师面试的我。在上楼后找了好几个会议室都有人，最后在某个词牌名的会议室里进行了面试。面试官比较严肃，问我光流具体是什么，我说了光流方程，也解释了几种光流算法，但是他好像很不满意，最后让写编程题，也没写好。第二个面试官比较放松，聊了些实验室做的东西，问了论文的情况，说担心不能正常毕业，最后通知没有过。<br>当时为了准备360和百度的面试，我在马连洼地铁站旁边的小区租了几天的地下室，白天要么去面试，要么就在屋里看书，饭点就去旁边中发百旺商城后面的牛肉面馆吃个味道很棒的炒面。有的时候早饭就去百旺商城的肯德基吃，豆浆和油条都很好吃。后来我就回家了，在家待了不到四天，然后就又回到学校，准备招聘的事情。</p>
<h4 id="5-美丽联合"><a href="#5-美丽联合" class="headerlink" title="5. 美丽联合"></a>5. 美丽联合</h4><p>美丽联合招聘的也比较早，8月28第一次电话面试，感觉还可以，后来9月4号面试，再后来9月20号是视频面试，他们的一个副总裁面试的我。总体面试感觉还可以，但最后也没有说通过没通过，可能本来他们也招人不多吧。</p>
<h4 id="6-阿里"><a href="#6-阿里" class="headerlink" title="6. 阿里"></a>6. 阿里</h4><p>阿里我实习的时候就投了张鹏师兄所在的部门，但是因为准备不充分，复习不够认真，面试没通过。后来正式招聘的时候没有给面试机会。后来师兄说看能不能帮我换到新零售部，但是因为我确定去北京了，而这个部门没有在北京的岗位，因此就没有换。所以没能去阿里。</p>
<h4 id="7-腾讯"><a href="#7-腾讯" class="headerlink" title="7. 腾讯"></a>7. 腾讯</h4><p>腾讯的笔试比较难，考很多数学的东西，我本科学的不扎实，所以笔试没有过，后面一直没有面试通知。因此也与腾讯失之交臂。</p>
<h4 id="8-地平线"><a href="#8-地平线" class="headerlink" title="8. 地平线"></a>8. 地平线</h4><p>地平线因为有韶言师兄的内推，所以没有做笔试题，只参加了面试。在9月16日，我去高速开元大酒店面试，当时很紧张，因为之前的面试都没有出确定的结果，还是0 offer的状态。前三面试技术面试，第三面是黄畅面试的，很佩服他的眼界，了解最新的东西，还给我说了下FlowNet的最新进展。很庆幸能够通过前面的面试，最后是和HR聊下公司的情况，什么时候给offer等等。对地平线很有好感，一是他们做的事情是充满理想的，要做软硬结合的人工智能。还有面试官给人的印象是非常随和的，很nice。最后在地平线和旷视之间犹豫了很久，还是打算去专门做CV的公司，先提升自己的CV水平。</p>
<h4 id="9-虹软"><a href="#9-虹软" class="headerlink" title="9. 虹软"></a>9. 虹软</h4><p>虹软是9月21日进行的面试，前一天的笔试我做的比较好，所以最后加了一个CTO面试。第一面是大实验室的一个师兄面的，指出了我描述的网络中的一些问题，第二面没有印象了。第三面是HR面试，问了对于互联网公司加班很严重现象的看法。后来又去面试了CTO面，CTO比较年长，说公司还是要低调发展，不能炒作，顺便黑了一些当红的科技公司。。</p>
<h4 id="10-今日头条"><a href="#10-今日头条" class="headerlink" title="10. 今日头条"></a>10. 今日头条</h4><p>头条9月底来学校招聘，合肥站只有两天时间，第一天笔试，结果晚上12点打电话通知，第二天面试。第二天面试的时候，总共应该有3-4面，我参加了2面就挂了，每一面都会问2-3道编程题，我还是编程太弱，就没通过。头条估计是所有我面试过的公司里面最注重编程题的公司吧。</p>
<h4 id="11-旷视"><a href="#11-旷视" class="headerlink" title="11. 旷视"></a>11. 旷视</h4><p>旷视在2017年上半年就来过我们学校进行过一次学术报告，当时孙剑老师也来了，那次报告厅人满满的。后来在内推阶段我投递了算法岗的简历，在在8月30进行了电话面试，第一个面试官比较直接，问了很多深度学习的内容，包括物体检测算法、ImageNet历年模型的错误率等等，我当时就懵了，面试的很不好。第二面是考察数理知识。也没答上。所以就挂了。后来10月11在西活进行了笔试，当时笔试题目比较难，没答好，后来在和王宁的讨论中基本都解决了，因此面试的时候表现还行，所以最后幸运地录取了。最后也决定去旷视，成为旷工的一员。</p>
<h4 id="12-商汤"><a href="#12-商汤" class="headerlink" title="12. 商汤"></a>12. 商汤</h4><p>商汤面试比较晚，两个电话面试，最后没有通过。商汤技术面试还是很难。</p>
<h4 id="14-网易"><a href="#14-网易" class="headerlink" title="14. 网易"></a>14. 网易</h4><p>三次笔试都没有通过，真的与网易无缘(主要还是自己基础太差)。</p>
<h4 id="15-搜狐"><a href="#15-搜狐" class="headerlink" title="15. 搜狐"></a>15. 搜狐</h4><p>搜狐我先是在网上做了笔试，然后在三教做了现场的笔试，最后没通过。</p>
<h4 id="16-海康"><a href="#16-海康" class="headerlink" title="16. 海康"></a>16. 海康</h4><p>海康来得也比较早，而且线上组织的比较好，HR一直在群里回答问题，而且针对一些岗位设置了小型见面会，之后参加了面试，也通过了。但是因为我面试表现不好，因此最后薪资也偏低，所以没有去。</p>
<p>现在想来，那段时间一方面是担心找不到好的工作，另一方却没能静下心来认真地复习，每天比较迷糊，因此到最后也没复习好，编程还是迷迷糊糊不会。哎。</p>
<h3 id="科研和论文"><a href="#科研和论文" class="headerlink" title="科研和论文"></a>科研和论文</h3><p>今年总算是把论文投出去了，虽然到现在还不知道能否收录。先是在3月份的时候，投了ICCV，结果评审意见不好，后面又改投了AAAI，同样没有中。在12月份的时候，投了ICME，2018年3月份出结果。总结研究生这几年，还是动手不够勤，惰性太重，知难而退，没有努力地去思考去探索，偷懒和只会享受不会付出的习惯毁一生啊。 希望在这剩下的半年里逐渐改正，做出一些东西吧。<br>下面是今年阅读的一些论文：</p>
<ol>
<li>RstarCNN</li>
<li>Charades dataset</li>
<li>Kinetics</li>
<li>NetVLAD</li>
<li>AttentionPooling</li>
<li>TField</li>
<li>Capsule</li>
<li>Non-local</li>
<li>LinkNet</li>
<li>FlowNet</li>
<li>SSN</li>
<li>YOLO9000</li>
<li>SENet</li>
<li>MaskRCNN</li>
<li>P3D</li>
<li>One Model To Learn Them All</li>
<li>ActionVLAD</li>
<li>DeepLab</li>
<li>DPN</li>
<li>MobileNet</li>
<li>Xception</li>
</ol>
<h3 id="2017读书记录"><a href="#2017读书记录" class="headerlink" title="2017读书记录"></a>2017读书记录</h3><p>今年在微信读书上坚持每个月看一本以上书，总共下来看了20本书，有些有趣，有些也无聊，有些深刻，有些也无聊，希望明年继续保持阅读的习惯吧。下面是阅读的书籍：</p>
<ol>
<li>芳华： 残酷军旅青春，比电影更现实些</li>
<li>梁启超传： 梁启超，近代史处处有其痕迹</li>
<li>望春风： 农村怪谈，结局很美好</li>
<li>从文自传： 沈从文写的从出生到来北京前，在学堂，在军旅中的人生事迹，笔触引人入胜，虚实难辨</li>
<li>我这一辈子： 老舍的一些短篇和中篇小说集，了解其生活时代的绝好材料，其中《微神》写得太妙，《不成问题的问题》没看太懂。。</li>
<li>月亮和六便士： 读完，觉得主角斯克里克兰还是挺让人憎恶的，无情，冷血。或许还是因为我境界太低吧</li>
<li>杀死一只知更鸟： 美国南部小城的童年趣事、种族冲突、家庭教育等等。作者的文笔很有趣，前半部分是充满欢乐的。</li>
<li>小王子： 简单而美妙的童话</li>
<li>大中东行纪：世界并非静悄悄： 了解中东和周围国家的历史和人文宗教的好书，读完终于分清楚了阿拉伯、伊斯兰和中东的区别。</li>
<li>另类日本文化史：作者选择一些点来展开讲日本的文化，从表象到内核，窥一斑而能够了解若干文化基因。</li>
<li>马伯庸笑翻中国简史：从五行的角度讲述中国历史上各个朝代的变迁，角度异常独特。</li>
<li>腾讯传1998-2016：中国互联网公司进化论：吴晓波写的腾讯公司的发展记录，是了解这个中国现在最重要的互联网公司的好材料。</li>
<li>你今天真好看： 简短的动物人物化漫画，通过简短的对话来展示生活有趣的细节。</li>
<li>苏轼：叙述一种： 比较独特的苏轼传记，没什么优点。。</li>
<li>大师：寻找那些远去的大师才子：介绍民国十位大师生平的书，普普通通</li>
<li>茶馆：老舍话剧，小说和散文合集，老舍的文字还是让人喜欢不已。</li>
<li>段祺瑞政权：民国史军阀篇： 唐德刚著，对民国成立到新中国成立这段时期的历史很感兴趣，这本书还是很好地满足了我对这段历史的求知欲。</li>
<li>杜甫（名人传记丛书）：杜甫简要传记</li>
<li>李白（名人传记丛书）： 李白简要传记</li>
<li>中国十大文豪白居易： 白居易传记</li>
</ol>
<h3 id="2017观影总结"><a href="#2017观影总结" class="headerlink" title="2017观影总结"></a>2017观影总结</h3><h4 id="2017在电影院看的电影"><a href="#2017在电影院看的电影" class="headerlink" title="2017在电影院看的电影"></a>2017在电影院看的电影</h4><ol>
<li>妖铃铃：第一次看电影想中途离场并在电影院里打了一局王者荣耀</li>
<li>芳华： 几次差点掉下眼泪</li>
<li>战狼2： 中国电影枪战特效的标杆，估计几年内没法超越吧，第一次在电影院这么自豪</li>
<li>蜘蛛侠英雄归来： 今年等待最久的电影，从美队3中小蜘蛛的亮相开始就期待，今年夏天终于有机会看了，结果在北京天幕新彩云和彤彤看的时候，放映机烧了，影院经理说这么多年也是头一次遇到，最后给我们退钱了</li>
<li>猩球崛起3： 终极之战： 特效貌似没第二部好，反派好像也死得比较easy。。</li>
<li>闪光少女：第一次在电影院看到二次元迷的角色，整个电影很青春，喜欢音乐学校这种场景，可以一饱耳福。</li>
<li>摔跤吧爸爸： 亲情，从年少成名、从小地方到大城市的迷失，无助，不由地掉下泪来。很庆幸有个父亲可以让大女儿及时找到返璞归真的道路。</li>
<li>金刚狼3： 殊死一战： 万年的金刚狼有点惨，X教授也貌似回归平凡人，小女孩演的很好，在那户人家里吃完饭的场面，聊天很温馨。</li>
<li>速度与激情8： 为特效而生， 郭达斯坦森和巨石杰森互怼很有意思</li>
<li>乘风破浪： 那些年陪我一起度过青春岁月的的父亲。</li>
<li>金刚骷髅岛：只记得抖森奇怪的声音和景甜尴尬的表演</li>
<li>加勒比海盗5：死无对证: 还行吧，没有太多让人记忆的地方。</li>
<li>西游伏妖篇： 特效很棒，剧情创新很多，跟西游降魔篇比较类似，女主角为了男主而死，男主才醒悟。但是无厘头现在在电影院里看到，总感觉有些尴尬。</li>
<li>八月： 旧时光大院子里的夏天，家庭争吵、单位矛盾、地里的西瓜、晚上的电影院。。</li>
</ol>
<h4 id="2017在在电脑-手机上看的电影："><a href="#2017在在电脑-手机上看的电影：" class="headerlink" title="2017在在电脑/手机上看的电影："></a>2017在在电脑/手机上看的电影：</h4><ol>
<li>霸王别姬： 好看，更喜欢菊仙小姐，处境不容易但是做的那么好</li>
<li>英伦对决： 没看完，觉得成龙饰演的角色有点“恶意作怪”的感觉</li>
<li>王牌特工2-黄金圈： 效果好看，剧情还行</li>
<li>敦刻尔克： 没看完。。</li>
<li>羞羞的铁拳： 没看完，笑点挺多，但是吸引力并不够</li>
<li>请以你的名字呼唤我： 唯美的爱情电影，夏天，溪流，杏子，自行车，芳草古道，文艺古城，浪漫至极</li>
<li>神奇女侠：在蝙超大战中看到神奇女侠时，确实被惊艳到了，一直很期待这部电影，但是没能去电影院看，最后在腾讯视频看的时候，还是没有影院的效果，最后有事没看完。。</li>
<li>王牌保镖： 很喜欢这种风格的电影， 死侍无奈的表情，神盾局长的狂笑，将人物特点表现得很好，特效也很棒</li>
<li>极寒之城： 塞隆打戏很精彩，剧情也比较复杂，很带感。</li>
<li>天才少女： 小女孩演的很好</li>
<li>绝世高手： 熟悉的星爷的感觉，但是没有小人物命运中的感人成分。</li>
<li>乐高蝙蝠侠大电影： 喜欢这种自黑类型的搞笑电影，但是乐高块有的时候看不清楚是什么人物。</li>
<li>英格丽向西行： 结局挺无聊的，整个片子也不知道讲的是什么，只有猩红女巫可以看了</li>
<li>真爱至上： 温馨的圣诞电影。</li>
<li>有完没完： 搞笑+亲情</li>
<li>我心雀跃： “少女心”爆棚的电影</li>
<li>1942： 逃荒路上的悲歌</li>
</ol>
<h4 id="2017错过的电影："><a href="#2017错过的电影：" class="headerlink" title="2017错过的电影："></a>2017错过的电影：</h4><ol>
<li>天才捕手</li>
<li>美女与野兽</li>
<li>银翼杀手2049</li>
<li>雷神3： 诸神黄昏</li>
<li>东方快车谋杀案</li>
<li>正义联盟</li>
<li>寻梦环游记</li>
<li>帕丁顿熊2</li>
<li>至爱梵高： 星空之谜</li>
<li>老兽</li>
<li>嘉年华</li>
<li>二十二</li>
<li>星际特工： 千星之城</li>
</ol>
<h4 id="2018年期待的电影："><a href="#2018年期待的电影：" class="headerlink" title="2018年期待的电影："></a>2018年期待的电影：</h4><ol>
<li>至暗时刻</li>
<li>伯德小姐</li>
<li>三块广告牌</li>
<li>维京：王者之战</li>
<li>佛罗里达乐园</li>
<li>星球大战： 最后的绝地武士</li>
<li>第一夫人</li>
<li>神秘巨星</li>
<li>勇敢者游戏</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果要用一个字来总结我的2017的话，我觉得是“难”。几次论文都没能中，找工作一路受挫，到怀疑人生。至今还不知道能否正常毕业。大概这就是“可怜之人必有可恨之处”吧，所有的现状都跟不努力的过去相关。希望2018年，过得更充实。</p>
]]></content>
      <tags>
        <tag>年终总结</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title>surface-simplification-using-quadric-error-metrics</title>
    <url>/2022/06/29/surface-simplification-using-quadric-error-metrics/</url>
    <content><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>顶点可以看作是三角面片所在的平面的交集</p>
]]></content>
      <tags>
        <tag>总结</tag>
        <tag>Graphic</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年终总结</title>
    <url>/2021/12/31/summary-2021/</url>
    <content><![CDATA[<p>2021快结束了，看的年初定的14条大大小小的目标，完成的只有三四条，惨不忍睹。这里总结一下这一年的大大小小的事情，留一个纪念。</p>
<span id="more"></span>

<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><p>总体来说2021是平稳的一年，工作大部分时候有序进行，同事和领导们待人友善，团队氛围和谐，夫妻感情和睦，家人身体都还算好，收入够日常开销，在一个城市的同学朋友们能偶尔聚聚，聊天吃饭，这样想想就已经很知足了。</p>
<p>工作方面还是有很多可以改进的地方的。<br>之前的工作思维是快速完成功能，导致很多代码都未经打磨，充满各种问题。今年也看到一些比较好的身边的例子，决定放慢速度，以创造作品的方式来写代码，多考虑可用性，边界条件和文档。团队整体的节奏其实是允许这样做的，只不过以前做了一个粗糙版本就去干别的了，没有真正地做好它。</p>
<p>还有一个是对偏理论的知识的畏惧感需要克服。总体来说这还是惰性思维的表现，不愿意深入地探索背后的原理。</p>
<p>更多的时间去改造自己，学习新知，更好地为社会创造价值。</p>
<h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><p>今年团队参加了一个ICCV比赛，并且拿到了第一名，算是在技术上取得了一个成果，真诚地感谢一起努力的小伙伴。  </p>
<p>开源项目上，没有新的进展，前一段时间把flopth的功能加强了一下，后面会写一个更全面的说明。  </p>
<p>博客更新了14篇，总体达到每个月一篇的目标了，但质量还需要提高。  </p>
<h4 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h4><p>年初定了读书202.1小时的目标，不过没达到，新的一年继续努力。<br>读完了的几本书：</p>
<ul>
<li> 老残游记》</li>
<li>儒林外史》</li>
<li>《毛泽东的书单》</li>
<li>《万历十五年》</li>
<li>《老舍和他的作品》</li>
</ul>
<p>读了一部分的书:</p>
<ul>
<li>《雨》</li>
<li>《我的个天》</li>
<li>《西行漫记》</li>
<li>《能人》</li>
<li>《中外名画彩图馆》</li>
</ul>
<h4 id="影视"><a href="#影视" class="headerlink" title="影视"></a>影视</h4><p>周末大部分时间会刷一刷剧，所以今年电影和剧集看的挺多的。还是有许多好看的电影，给人感动。</p>
<ul>
<li>《苍穹浩瀚》惊喜连连的太空剧，强烈推荐</li>
<li>《健听女孩》</li>
<li>《基地》</li>
<li>《鹰眼》</li>
<li>《假如…？》</li>
<li>《洛基》</li>
<li>《猎鹰与冬兵》</li>
<li>《旺达幻视》</li>
<li>《x特遣队》</li>
<li>《倒数时刻》</li>
<li>《芬奇》</li>
<li>《性教育第三季》</li>
<li>《黑寡妇》</li>
<li>《尚气与十环传奇》</li>
<li>《红色通缉令》</li>
<li>《大佛普拉斯》</li>
<li>《同学麦娜丝》</li>
<li>《杀手妻子的保镖2》</li>
<li>《寂静之地2》</li>
<li>《爱，死亡与机器人2》</li>
<li>《雪国列车》</li>
<li>《活着》</li>
</ul>
<h4 id="相聚时刻"><a href="#相聚时刻" class="headerlink" title="相聚时刻"></a>相聚时刻</h4><p>这一年，和同学，同事，家人相聚的次数还比较多，每次相聚都值得纪念，这里把这些欢聚时刻都记录下来。</p>
<ul>
<li>1.3日，和研究生张鹏师兄，孙翠蓉师姐，吕玥和sun可在张鹏师兄家聚餐</li>
<li>2月12日，在杭州和彤彤过春节</li>
<li>3月27日，清明前一周，我回家里,和爸还有外甥女听听去上坟。这是爷爷奶奶去世十余年，第一次去给他们上坟。</li>
<li>4月11日，和高中同学马仲海在西湖边的清真餐厅聚餐，他来杭州参加会议。</li>
<li>6月5日，我去吉林榆树参加大学同学栾京的婚礼，这也是我第一次去东北。东北一望无际的平原让人印象深刻。第二天我们凌晨2点起来去准备接亲，那边凌晨四点天就亮了。</li>
<li>6月14日，和旸哥杨珈蒙在公司打羽毛球，打完后去陕西面馆吃了大盘鸡。</li>
<li>6月15日，和在阿里的武山老乡聚了餐，加了初中同级同学孙健的微信。</li>
<li>6月26日，天琦师兄来附近找房子，我带他们看了房子，然后去亲橙里吃了烤鱼。</li>
<li>7月2日，团队组织去舟山市的普陀山和东极岛团建，在祖国的最东边度过了几天难忘的日子。</li>
<li>7月24日，和彤彤回庄浪，参加彤彤大姐的婚礼。爸妈在岳父岳母的邀请下，也到庄浪了，彤彤妹妹和妹夫也从江苏赶过来，我们在庄浪待了逛了好几天。因为疫情的原因多请了一天假。</li>
<li>8月15日，我和彤彤和刘凯旋夫妻俩还有华哥在天街吃了饭。</li>
<li>国庆节，我和彤彤回家了，云亮也回家了，全家给云亮过了生日。回家搬玉米，剥玉米，劳动了一下。</li>
<li>10月10日，实验室师弟鹤臻来参加VALSE，我也赶过去参加了这次会议，结束后我们去吃了饭，聊了聊实验室最近的事情。</li>
<li>11月16日，高中同学小雨来杭州出差，我下班后去找他，他请我们吃了烤肉，吃完后我们去星巴克坐了会，聊了很多关于创业的事情，他现在是在投资机构上班。</li>
<li>11月20日，实验室师弟周浩来杭州参加校招活动，我们召集了小天和师妹魏承承，在新榆园吃了饭，后面又和周浩在园区食堂吃了饭</li>
<li>11月22日，和张鹏师兄，孙可在园区吃了面。</li>
<li>12月29日，小组去爬了西湖群山，从老和云起到秦亭，再到灵峰山，最后去了北高峰，然后下山。</li>
</ul>
<p>除了这些具体的相聚时刻，公司小组时常在开完组会后去聚餐，塞远带我们吃遍了周围的各种饭店，这些时刻都值得纪念。一个温和的团队值得珍惜，给了我们稳定的工作环境，可以专心做自己喜欢的事情，确实很难得，因此更要倍加珍惜。</p>
<h4 id="最后的感想"><a href="#最后的感想" class="headerlink" title="最后的感想"></a>最后的感想</h4><p>相比去年，今年的我多了一些笃定吧。这一年发生了很多事情，个人，公司，国家。总体来说，这是往好发展的一年，通过一年的工作，渐渐想通了，通过现在的工作，积累的知识和能力，会在未来某个时间点达到质变，因此别太着急，努力地去做好每件事情，写好每行代码，写好每个注释，写好每个文档，搞懂每个疑惑，弄懂每个知识点，会往好的方向发展的。</p>
<p>最近读了《西行漫记》，为其中的红军的精神所感染，反观自己现在的状态，用文中的话来说，是“消极的满足”，没有持久的梦想驱动。这种状态确实挺可怕的，所以新的一年，要想清楚未来几年的目标，持续地朝这个目标努力，保持积极的求索，跳出消极的满足的温水煮青蛙陷阱。</p>
<p>毕业已经三年，刚毕业定了一个三年的目标，现在看来基本都没实现。这还是对我有很大的警醒作用的。下一个三年，是不是还会继续这样失败呢，如何才能定好三年目标并一步步完成它呢？</p>
]]></content>
      <tags>
        <tag>年终总结</tag>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark简介</title>
    <url>/2016/06/16/spark/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这篇文章是我通过学习了Spark官网上的一些内容，参考了许多博客和文章，也尝试进行了一些初级的Spark编程后写的关于Spark的简要的说明，希望能讲明白Spark这个框架的一些原理，提供一个基础的入门教程。  </p>
<p><img src="http://spark.apache.org/images/spark-logo-trademark.png">    </p>
<span id="more"></span>

<p>Spark是一个用于分布式数据处理和并行计算的开源项目，最早由UC Berkeley 的AMP 实验室开发，现在已经交由Apache开源项目组管理。Spark目前变得非常流行，跟其高效性，通用性和易于编程性都有很大关系。Spark在机器学习，大数据处理和实时数据处理，以及分布式的应用场景中都能充分发挥作用。  </p>
<p><strong>Spark程序计算很快。</strong> 根据<a href="http://spark.apache.org/">Spark主页</a>上的描述，Spark程序比基于Memory的<a href="http://hadoop.apache.org/">Hadoop</a>(一个分布式系统基础架构)的MapReduce要快100倍，比基于硬盘的Hadoop MapReduce 快10倍。Spark之所以有如此快的速度，是因为采用了很多高效的方案，如采用懒惰模式，基于内存进行操作，对数据进行多种方式的缓存等等。  </p>
<p><strong>Spark程序易于编写。</strong> Spark 原生是由Scala编写，现在支持Java，Scala，Python和R四种语言。这四种语言可以覆盖较大的开发者范围，像R是数据处理专家的拿手语言，而Java是Hadoop的开发语言，而且由于Spark对Hadoop的一定程度的兼容性，使得Hadoop开发者可以快速地转到Spark平台上来。而Python和Scala是现代化的编程语言，编程风格优雅，入门简单，所以开发者可以快速地开发出可以实际应用的程序。  </p>
<p><strong>Spark统一了本地和分布式情形下的数据访问模式</strong>。在本地电脑上，Spark会开多个进程来模拟分布式环境下的任务计算，所以即使在单机环境下，开发者也可以编写适用于分布式环境的程序，这大大地简化了程序的调试难度，也进一步加快了项目的开发进程。另外，Spark提出了弹性分布式数据集（RDD， Resilient Distributed Dataset）的数据格式,这种格式的数据默认就是分布式分布地，但是操作方式却和本地操作方式一样，即替开发者完成了运算节点之间拷贝数据的操作，使得开发人员像编写本地程序一样来编写分布式程序，毫无疑问这是一个很大的优势。    </p>
<p>上面是一些比较大范围的说明，而我个人对Spark比较向往的地方则是相比Hadoop，Spark上手很容易，官网上提供的教程和说明非常详尽，自己写一个计算$\pi$的程序只需要以下几行Python代码即可完成（代码来自Spark官方给出的例子）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> add</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkContext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Usage: pi [partitions]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    sc = SparkContext(appName=<span class="string">&quot;PythonPi&quot;</span>)</span><br><span class="line">    partitions = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>]) <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">2</span></span><br><span class="line">    n = <span class="number">100000</span> * partitions</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">_</span>):</span></span><br><span class="line">        x = random() * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">        y = random() * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> x ** <span class="number">2</span> + y ** <span class="number">2</span> &lt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    count = sc.parallelize(<span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>), partitions).<span class="built_in">map</span>(f).reduce(add)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Pi is roughly %f&quot;</span> % (<span class="number">4.0</span> * count / n))</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br></pre></td></tr></table></figure>

<p>可以看到，核心代码不超过10行。    </p>
<p>而为了配置Hadoop，我花了2天的时间，也还没有搞好，实在是对入门者不够友好。此外Java编写的程序和XML编写的配置文件一开始就有一种很“重”的感觉，使人望而却步。   </p>
<p>上面这部分内容是关于Spark的一个大概的介绍，<strong>下面，我将从核心概念，集群模型和编程体验这三个大的方向进行详细的说明和我的理解。注意：下面的示例都以Spark的Python API为例。</strong></p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h2 id="1-SparkContext"><a href="#1-SparkContext" class="headerlink" title="1. SparkContext"></a>1. SparkContext</h2><p>Spark是管理集群和协调集群进程的对象。SparkContext就像任务的分配和总调度师一样，处理数据分配，任务切分这些任务。下图是Spark官网给出的集群之间的逻辑框架图，可以看到SparkContext在Driver程序中运行，这里的Driver就是主进程的意思。Worker Node就是集群的计算节点，计算任务在它们上完成。<br><img src="http://spark.apache.org/docs/latest/img/cluster-overview.png" alt="Spark集群逻辑框架"></p>
<p>Spark提供了Scala和Python的交互式命令环境，里面默认会创建一个<code>SparkContext</code>变量，并将其重命名为<code>sc</code>，所以在交互式环境下，可以用<code>sc</code>来方便地调用<code>SparkContext</code>的函数集合。下面示例中采用<code>sc</code>来代表<code>SparkContext</code>。  </p>
<h3 id="2-RDD"><a href="#2-RDD" class="headerlink" title="2. RDD"></a>2. RDD</h3><p>RDD是Resilient Distributed Datasets的缩写，中文翻译为弹性分布式数据集，它是Spark的数据操作元素，是具有容错性的并行的基本单元。<strong>RDD之于Spark，就相当于array之于Numpy，Matrix之于MatLab，DataFrames之于Pandas。</strong> 很重要的一个点是：RDD天然就是在分布式机器上存储的，比如对于下面这个RDD数据,可能Data1-3是存储在节点1的，Data4-6是存储节点2的，后面的数据也是这样，存储在集群中不同的机器上的。这种碎片化的存储使得任务的并行变得容易。    </p>
<p><img src="http://img.ptcms.csdn.net/article/201511/25/5655b0ea512a8.jpg" alt="RDD data"></p>
<p>RDD生成也很容易，可以由串行的List， Tuple等等来生成，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">dist_data = sc.parallelize(data)</span><br></pre></td></tr></table></figure>
<p>这两行代码就可以将串行的数据转换为并行的RDD。  </p>
<p>另一种生成RDD的方法是从外部的存储系统进行引用，如可以从硬盘上的文件（像‘data.txt’）,HDFS文件系统，HBase数据库，或者任何的提供Hadoop的InputFormat格式的数据来源都可以。对于各种格式的数据，Spark都有专门的处理函数，像<code>textFile</code>用来读取硬盘上的文本文件，按行返回文本中的内容；而<code>newAPIHadoopRDD</code>函数则可以保存/读取符合Haddoop输出/输入格式的文件。具体使用规则请参考<a href="http://spark.apache.org/docs/latest/programming-guide.html">Spark编程指南</a>。  </p>
<h3 id="3-Action-v-s-Transformation"><a href="#3-Action-v-s-Transformation" class="headerlink" title="3. Action v.s. Transformation"></a>3. Action v.s. Transformation</h3><p>RDD支持2种操作，一种是<code>Transformation</code>，这种操作的结果是生成一个新的RDD对象，即由RDD生成RDD，如Transformation操作<code>map</code>，就是对RDD中的每个数据，对应生成map函数中定义的数据，最后得到的还是一个RDD。举个具体的例子，假设map函数是：对RDD中的每个数据加1，假设原先的数据是[1,3,5,7,9],则这个map函数作用的结果是[2,4,6,8,10],仍然是个RDD（注意：这里为了方便解释，将RDD写出Python中的List形式，实际上要记得这里的RDD数据是保存在不同机器上的）。另一种操作叫做<code>Action</code>，这种操作的结果是得到一个值(Value)。即由RDD得到Value。如Action操作<code>reduce</code>，假设reduce函数设定为：求RDD中所有元素的和，则对该RDD作用reduce的结果是30,为一个值。  </p>
<p>常见的<code>Tranformation</code>操作包括<code>map，filter，flatMap,mapPartions, mapPartitionsWithIndex, sample, union, intersection, distinct, groupByKey, reduceByKey, aggregateByKey, sortByKey, join, pipe</code>等。<br>常见的<code>Action</code>操作包括<code>reduce，collect，count，first，take，takeSampke， takeOrdered， countByKey, foreach</code>等等。  </p>
<h3 id="4-Lazy-Evalution"><a href="#4-Lazy-Evalution" class="headerlink" title="4. Lazy Evalution"></a>4. Lazy Evalution</h3><p>Spark采用了惰性计算。所谓惰性计算，即对所有<code>transformation</code>，不会立即执行，而是等到某个<code>action</code>作用的时候，需要向Driver发送结果的时候再执行之前的所有<code>transformation</code>。简单来说，就是所有任务都拖到不能再拖的时候再执行。  </p>
<p>惰性计算能提高Spark运行的性能。试想，如果对所有的<code>transformation</code>操作，立即计算，然后向Dirver返回结果，则需要发送数目巨大的数据集；而如果采用惰性计算，则只需发送最后的一个值给Driver，传输开销会大大地减小。  </p>
<p><strong>需要指出的是：在Spark中，所有<code>transformation</code>操作都采用惰性模式，而所有<code>action</code>都是非惰性模式。</strong></p>
<h3 id="5-Closure"><a href="#5-Closure" class="headerlink" title="5. Closure"></a>5. Closure</h3><p>在Spark中执行某一项任务的时候，Spark driver程序会将RDD的的操作分配到各个计算节点上，Spark称这些计算节点为<code>executor</code>。而每个executor执行计算的变量和操作就称为这个executor的<code>Closure</code>。  </p>
<p>需要注意的是，各个executor的closure是不同的，刚开始的时候数据都从driver程序中克隆过来，之后这些数据就和driver程序中的数据没有任何关系了。这里可以类比<code>fork</code>操作，子进程和父进程之间的数据是隔离的，互不影响的。  </p>
<p><strong>由于各个executor和driver的数据是不同的，所以涉及到不同节点上同名变量的运算，结果结果是不确定的，也不要依赖于该运算结果。</strong></p>
<h3 id="6-Shuffle"><a href="#6-Shuffle" class="headerlink" title="6. Shuffle"></a>6. Shuffle</h3><p>在Spark中，有的时候为了执行某一个操作，需要从多个节点获取数据到一个节点，然后进行计算。计算后将计算结果再传给相应的计算节点。这个过程中，计算前后对应节点的数据是对应的，即节点1的计算结果还是返回到节点1,但是返回的顺序可能发生了改变，如节点1原先顺序是[2,3,4],可能结果是按[3,2,4]的计算结果返回的，这样就间接地完成了一个打乱顺序的操作，在Spark中称以上这个过程为<code>shuffle</code>。</p>
<p>由上述描述可以看出来，Shuffle操作是一个开销比较大的操作，需要较大量的硬盘IO，数据串行化操作，和网络IO。此外，为了在单个节点保存多个节点上传过来的数据，还需要消耗较大的内存空间。  </p>
<p>此外，Spark内部会隐式地<strong>在硬盘上</strong>保存该过程中产生的中间文件，以便于以后再次使用。过一定时间后，或者数据不再使用时，垃圾回收机器（GC，Garbage Collection）就会删除这些文件。由于GC回收的时间间隔会比较长，所以在运行Spark的过程中会产生很多的中间数据，占据很多的硬盘空间，所以Spark快，是以占据大量内存空间和磁盘空间作为代价的。  </p>
<h3 id="7-Persistance"><a href="#7-Persistance" class="headerlink" title="7. Persistance"></a>7. Persistance</h3><p>为了加快运行的速度，Spark提供了<code>persist</code>和<code>cache</code>函数由开发者来显式地缓存RDD数据。在初次执行某个<code>action</code>的时候，对RDD数据进行缓存，在以后的<code>action</code>操作中，直接读取缓存的RDD数据。这样下来，<code>action</code>的执行速度可以提升10倍。<br>Spark的缓存具有容错性，如果一个节点的RDD数据部分丢失了，则Spark会根据生成该部分RDD数据的<code>transformation</code>重新生成完全一样的数据。  </p>
<p>此外，Spark还允许设置不同的缓存存储级别（<code>StorageLevel</code>），如只缓存在内存中（<code>MEMORY_ONLY</code>），缓存在内存和硬盘中（<code>MEMORY_AND_DISK</code>），等等。这些参数可以通过<code>persist</code>函数进行设置。而<code>cache</code>函数则是<code>persist</code>函数指定<code>StorageLevel</code>为<code>MEMORY_ONLY</code>时的简写。    </p>
<p>本质上StorageLevel的选取，是在内存占用量和CPU高效性之间的平衡。Spark官方文档中推荐使用<code>MEMORY_ONLY</code>，如果不行，可以选用<code>MEMROY_ONLY_SER</code>，这中方式类似于前者，只不过是串行存储以节省开销。一般不建议用<code>DISK</code>相关的存储。  </p>
<p>Spark会自动监控缓存数据的使用情况，如果空间不够的话，就会使用最近使用次数最少算法（LRU，Least-Recently -Used）将部分缓存数据给删除掉。如果你想手动删除缓存，可以调用<code>RDD.unpersist()</code>函数。  </p>
<h3 id="8-Shared-Variables"><a href="#8-Shared-Variables" class="headerlink" title="8. Shared Variables"></a>8. Shared Variables</h3><p>通常情况下，当Driver程序给各个cluster节点分配后任务，复制完初始数据后，各个节点就在自己的本地空间上单独进行计算，再也不会和Driver程序之间发送数据了。但是为了几个非常常用的操作，Spark提供了2类共享变量：<code>broadcast variable</code>和<code>accumulator</code>。  </p>
<p>broadcast变量是一种只读的变量，在driver进程需要向多个机器发送相同数据的时候会用到。并且规定boroadcast变量在广播后不可以被改变。我们可以对变量<code>v</code>进行broadcast操作，对其进行广播，然后在各个机器上使用的时候，使用<code>.value</code>来读取，而不是直接读取<code>v</code>的值。如下例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">broadcastVar = sc.broadcast([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">broadcastVar.value </span><br><span class="line"><span class="comment">#结果：[1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>可以看到原理跟MPI里面的<code>MPI_Broadcast</code>函数的原理是比较类似的。  </p>
<p>另一种共享变量是Accumulator，通过<code>SparkContext.accumulator(v)</code>函数初始化为<code>v</code>，然后可以通过将各个进程中的值增加到这个变量上面，然后计算得到相应的值。Spark内置了数值类型的Accumulator变量，开发者可以自己实现别的类型的Accumulator变量。其值也通过<code>value</code>属性来获得。下面是一个计算各个节点上数据之和的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">accum = sc.accumulator(<span class="number">0</span>)</span><br><span class="line">sc.parallelize([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).foreach(<span class="keyword">lambda</span> x: accum.add(x))</span><br><span class="line">accum.value </span><br><span class="line"><span class="comment">#结果：10</span></span><br></pre></td></tr></table></figure>

<h2 id="集群模型"><a href="#集群模型" class="headerlink" title="集群模型"></a>集群模型</h2><p>结束了冗长而且枯燥的概念部分后，下面我来阐述一下关于Spark集群模型的一些理解。  </p>
<h3 id="1-Cluster模型"><a href="#1-Cluster模型" class="headerlink" title="1. Cluster模型"></a>1. Cluster模型</h3><p><img src="http://spark.apache.org/docs/latest/img/cluster-overview.png" alt="Spark Cluster Model"><br>上图是官网给出的Spark集群模型，Driver Program 是主进程，SparkContext运行在它上面，它跟Cluster Manager相连。Driver对Cluster Manager下达任务人，然后由Cluster Manager将任资源分配给各个计算节点(Worker Node)上的<code>executor</code>，然后Driver再将应用的代码发送给各个Worker Node。最后，Driver向各个节点发送<code>Task</code>来运行。  </p>
<p>这里有几个需要注意的点：</p>
<blockquote>
<ul>
<li>在Spark中，各个应用之间数据是隔离的，即不同的SparkContext之间互不可见。这样能有效地保护数据的局部性。  </li>
<li>Cluster Manager对Driver来说是不知的，透明的，只要能满足要求就可以。所以Spark可以在Mesos和YARN这些Cluster Manager上运行。  </li>
<li>在运行过程中，Driver需要随时准备好接收来自各个计算节点的数据，所以对各个executor来说，Driver必须是可寻址的，比如有公网IP，或者如果在同一个局域网的话，有固定的局域网IP。  </li>
<li>由于Driver需要随时接收消息和数据，所以最好Driver和各个节点比较邻近，这样数据传输会比较快。  </li>
</ul>
</blockquote>
<h3 id="2-Cluster-Manager-类型"><a href="#2-Cluster-Manager-类型" class="headerlink" title="2. Cluster Manager 类型"></a>2. Cluster Manager 类型</h3><p>当前Spark支持3种类型的Cluster Manager,分别是：</p>
<blockquote>
<ul>
<li><code>Apache Mesos</code>： <a href="http://spark.apache.org/docs/latest/running-on-mesos.html">Mesos</a>是一种通用的的集群管理系统，可以运行Hadoop和别的分布式计算。</li>
<li><code>Hadoop YARN</code>: 这是Hadoop 2 默认的资源管理系统。</li>
<li><code>Standalone </code>-这种类型是Spark单独设计的管理系统，比较简单，也没有太多的需要预先学习的东西。</li>
</ul>
</blockquote>
<h3 id="3-概念辨析"><a href="#3-概念辨析" class="headerlink" title="3. 概念辨析"></a>3. 概念辨析</h3><p>Spark集群模型有许多概念，之间的区别还是需要仔细辨析才能搞清楚。下面是从官方网站上抄录下来的一个定义，因为怕翻译后改变原意所以这里没有翻译，仅给出原文供参考：  </p>
<blockquote>
<ul>
<li><code>Application</code> : User program built on Spark. Consists of a driver program and executors on the cluster.  </li>
<li><code>Application jar</code> : A jar containing the user’s Spark application. In some cases users will want to create an “uber jar” containing their application along with its dependencies. The user’s jar should never include Hadoop or Spark libraries, however, these will be added at runtime.  </li>
<li><code>Driver program</code> : The process running the main() function of the application and creating the SparkContext  </li>
<li><code>Cluster manager</code> : An external service for acquiring resources on the cluster (e.g. standalone manager, Mesos, YARN)  </li>
<li><code>Deploy mode</code> : Distinguishes where the driver process runs. In “cluster” mode, the framework launches the driver inside of the cluster. In “client” mode, the submitter launches the driver outside of the cluster.</li>
<li><code>Worker node</code> : Any node that can run application code in the cluster</li>
<li><code>Executor</code> : A process launched for an application on a worker node, that runs tasks and keeps data in memory or disk storage across them. Each application has its own executors.</li>
<li><code>Task</code>: A unit of work that will be sent to one executor</li>
<li><code>Job</code> : A parallel computation consisting of multiple tasks that gets spawned in response to a Spark action (e.g. save, collect); you’ll see this term used in the driver’s logs.</li>
<li><code>Stage</code> : Each job gets divided into smaller sets of tasks called stages that depend on each other (similar to the map and reduce stages in MapReduce); you’ll see this term used in the driver’s logs.</li>
</ul>
</blockquote>
<h3 id="4-资源监控"><a href="#4-资源监控" class="headerlink" title="4. 资源监控"></a>4. 资源监控</h3><p>Spark在运行过程中，会在Driver程序所在机器的4040端口显示关于运行任务，存储情况和工作节点等等的Web UI。对于Standalone模式，在7070端口有类似的信息展示。开发者可以通过访问这个Web UI来了解更多信息。  </p>
<p>集群模型就这些内容，下面以Python编程为例，展示Spark编程的风格和思路。  </p>
<h2 id="编程体验"><a href="#编程体验" class="headerlink" title="编程体验"></a>编程体验</h2><p>在这部分，我以WordCount 和计算PI这2个程序作为例子，描述如何用Python进行Spark编程。</p>
<h3 id="1-下载Spark程序"><a href="#1-下载Spark程序" class="headerlink" title="1. 下载Spark程序"></a>1. 下载Spark程序</h3><p>从<a href="http://spark.apache.org/downloads.html">Spark官方下载页面</a>选择一个合适版本的Spark。建议在<code>package type</code>这一栏选择<code>Pre-built for Hadoop 2.x and later</code>，这样下载下来的版本会自带Hadoop相关的东西，不用自己单独再配Hadoop。<br>下载下来后，解压即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf spark-*.tgz</span><br></pre></td></tr></table></figure>

<h3 id="2-打开Python命令行"><a href="#2-打开Python命令行" class="headerlink" title="2. 打开Python命令行"></a>2. 打开Python命令行</h3><p>进入解压后的目录，输入<code>./bin/pyspark</code>即可打开Python交互式窗口。这里会采用系统默认的Python交互式界面，如果想用体验更好的IPython交互式界面，则可以在输入命令之前设置如下环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PYSPARK_DRIVER_PYTHON=ipython ./bin/pyspark</span><br></pre></td></tr></table></figure>
<p>然后输入<code>./bin/pyspark</code>即可进入IPython。<br>前面也提到过，在命令行下，SparkContext会自动创建好，并重命名为sc，所以下面可以直接使用sc来进行操作。  </p>
<h3 id="3-读取Spark根目录下REAMDE-md中出现Spark这个单词的行数"><a href="#3-读取Spark根目录下REAMDE-md中出现Spark这个单词的行数" class="headerlink" title="3. 读取Spark根目录下REAMDE.md中出现Spark这个单词的行数"></a>3. 读取Spark根目录下<code>REAMDE.md</code>中出现<code>Spark</code>这个单词的行数</h3><p>为了完成这个任务，我们首先读取<code>README.md</code>作为RDD数据。还记得RDD吗？这是Spark默认的处理类型，默认就是分布式存储的。读取本地文本文件使用<code>textFile</code>函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">readMeFile = sc.textFile(<span class="string">&#x27;README.md&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>读进来的文件存在readMeFile这个RDD类型数据中，按行存储，其中每行就是<code>README.md</code>文件中的一行。<br>然后可以使用<code>filter</code>操作来获取满足条件的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">linesWithSpark = readMeFile.<span class="built_in">filter</span>(<span class="keyword">lambda</span> line : <span class="string">&quot;Spark&quot;</span> <span class="keyword">in</span> line)</span><br></pre></td></tr></table></figure>
<p>这里<code>filter</code>函数返回满足里面lambda函数的新的RDD数据。lambda函数是Python中一种单行的函数，以一个语句来实现一个函数的功能。lambda后面紧跟的那个引号之前的变量为输入参数，引号后面的内容为输出结果，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x, y : x + y</span><br></pre></td></tr></table></figure>
<p>就是返回x和y之和的一个lambda函数。<br>要注意的是得到的RDD虽然是只包含字符串”Spark”的那些行，但还是分布式存储的。为了得到具体的行数，我们可以采用<code>count</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">linesWithSpark.count()</span><br><span class="line"><span class="comment">#结果：15</span></span><br></pre></td></tr></table></figure>
<p>此外，我们还可以把以上所有的<code>transformation</code>操作都以链式方式写在一起，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">readMeFile.<span class="built_in">filter</span>(<span class="keyword">lambda</span> line : <span class="string">&quot;Spark&quot;</span> <span class="keyword">in</span> line).count()</span><br></pre></td></tr></table></figure>
<p>如果将上述代码写成单独的可执行的Python文件，内容将会是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkContext</span><br><span class="line"></span><br><span class="line">sc = SparkContext(appName=<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line">readMeFile = sc.textFile(<span class="string">&#x27;README.md&#x27;</span>)</span><br><span class="line">readMeFile.<span class="built_in">filter</span>(<span class="keyword">lambda</span> line : <span class="string">&#x27;Spark&#x27;</span> <span class="keyword">in</span> line).count()</span><br></pre></td></tr></table></figure>

<p>可以看到，很简单吧，下面我们继续来看用Spark来计算Pi值的例子。  </p>
<h3 id="4-用Spark计算Pi（采用随机投点法）"><a href="#4-用Spark计算Pi（采用随机投点法）" class="headerlink" title="4. 用Spark计算Pi（采用随机投点法）"></a>4. 用Spark计算Pi（采用随机投点法）</h3><p>所谓随机投点法，是根据圆和其外接正方形的面积之比为PI/4，因此我们可以统计在这个单位正方形内随机投点时，落入圆的比例为多少，投点数量足够多时，这个比例近似为PI/4,然后这个比例*4即为PI值。实际投点时，采取第一象限的[0,1]x[0,1]区域即可。<br>首先我们定义一个函数<code>f</code>,这个函数进行每次随机投点的统计，是否落在圆内，落在圆内返回1,否则返回0：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">_</span>):</span></span><br><span class="line">    x = random() * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">    y = random() * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> x ** <span class="number">2</span> + y ** <span class="number">2</span> &lt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>之后，我们共进行10^6次试验，每次试验调用f函数，然后把所有结果相加，最后再*4/10^6即为PI的估计。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">10</span>**<span class="number">6</span></span><br><span class="line">count = sc.parallelize(<span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)).<span class="built_in">map</span>(f).reduce(<span class="keyword">lambda</span> x, y : x + y)</span><br><span class="line">pi = <span class="number">4.0</span> * count / n</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*****result: pi is :%f*****&#x27;</span> %(pi))  </span><br></pre></td></tr></table></figure>
<p>其中第2行为主要的计算任务，搞懂这一行的操作大概就能明白Spark是怎么工作的了。<br>将上述代码完成写出来，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#file name: calc_pi.py</span></span><br><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkContext</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">sc = SparkContext(appName=<span class="string">&#x27;CalcPi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">_</span>):</span></span><br><span class="line">    x = random() * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">    y = random() * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> x ** <span class="number">2</span> + y ** <span class="number">2</span> &lt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">10</span> ** <span class="number">6</span></span><br><span class="line">count = sc.parallelize(<span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>)).<span class="built_in">map</span>(f).reduce(<span class="keyword">lambda</span> x, y : x + y)</span><br><span class="line">pi = <span class="number">4.0</span> * count / n</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*****result: pi is :%f*****&#x27;</span> %(pi))  </span><br></pre></td></tr></table></figure>
<p>可以看到，内容很简洁，比MPI复杂的函数命名简洁多了。<br>之后，在Spark根目录中，使用如下命令开始运行Spark进行计算：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/spark-submit calc_pi.py</span><br></pre></td></tr></table></figure>
<p>可以看到会输出很多<code>INFO</code> 开头的信息，这里我将所有的输出都写下来，虽然内容很多，有些没有必要看，但我觉得如果仔细看这些输出的话，很能增加对Spark的理解，所以这里我还是不厌其烦地把所有输出信息都列出来了。  </p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">Using Spark&#x27;s default log4j profile: org/apache/spark/log4j-defaults.properties</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">56</span> INFO SparkContext: Running Spark version <span class="number">1</span>.<span class="number">6</span>.<span class="number">1</span></span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">56</span> WARN NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">56</span> WARN Utils: Your hostname, ustc resolves to a loopback address: <span class="number">127.0.1.1</span><span class="comment">; using 192.168.102.77 instead (on interface eth0)</span></span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">56</span> WARN Utils: Set SPARK_LOCAL_IP if you need to bind to another address</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">56</span> INFO SecurityManager: Changing view acls to: yunfeng</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">56</span> INFO SecurityManager: Changing modify acls to: yunfeng</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">56</span> INFO SecurityManager: SecurityManager: authentication disabled<span class="comment">; ui acls disabled; users with view permissions: Set(yunfeng); u</span></span><br><span class="line">sers with modify permissions: Set(yunfeng)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">56</span> INFO Utils: Successfully started service &#x27;sparkDriver&#x27; on port <span class="number">53174</span>.</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">56</span> INFO Slf4jLogger: Slf4jLogger started</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">56</span> INFO Remoting: Starting remoting</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">56</span> INFO Remoting: Remoting started<span class="comment">; listening on addresses :[akka.tcp://sparkDriverActorSystem@192.168.102.77:57025]</span></span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">56</span> INFO Utils: Successfully started service &#x27;sparkDriverActorSystem&#x27; on port <span class="number">57025</span>.</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">56</span> INFO SparkEnv: Registering MapOutputTracker</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO SparkEnv: Registering BlockManagerMaster</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO DiskBlockManager: Created local directory at /tmp/blockmgr-<span class="number">2</span>ace648a-<span class="number">937</span>b-<span class="number">4</span>a4c-b984-<span class="number">6</span>e4cd06b8273</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO MemoryStore: MemoryStore started with capacity <span class="number">511</span>.<span class="number">5</span> MB</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO SparkEnv: Registering OutputCommitCoordinator</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO Utils: Successfully started service &#x27;SparkUI&#x27; on port <span class="number">4040</span>.</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO SparkUI: Started SparkUI at http://<span class="number">192.168.102.77</span>:<span class="number">4040</span></span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO Utils: Copying /home/yunfeng/Downloads/spark-<span class="number">1</span>.<span class="number">6</span>.<span class="number">1</span>-bin-hadoop2.<span class="number">6</span>/calc_pi.py to /tmp/spark-<span class="number">6</span>cb08b18-<span class="number">143</span>f-<span class="number">42d</span>c-<span class="number">88</span>c<span class="number">3-2778646</span></span><br><span class="line"><span class="number">0836</span>b/userFiles-ae0a9fc0-<span class="number">65</span>cf-<span class="number">467</span>e-<span class="number">848</span>b-<span class="number">4</span>f3cf<span class="number">4e6e1c2</span>/calc_pi.py</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO SparkContext: Added file file:/home/yunfeng/Downloads/spark-<span class="number">1</span>.<span class="number">6</span>.<span class="number">1</span>-bin-hadoop2.<span class="number">6</span>/calc_pi.py at file:/home/yunfeng/Download</span><br><span class="line">s/spark-<span class="number">1</span>.<span class="number">6</span>.<span class="number">1</span>-bin-hadoop2.<span class="number">6</span>/calc_pi.py with timestamp <span class="number">1463405637243</span></span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO Executor: Starting executor ID driver on host localhost</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO Utils: Successfully started service &#x27;org.apache.spark.network.netty.NettyBlockTransferService&#x27; on port <span class="number">43770</span>.</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO NettyBlockTransferService: Server created on <span class="number">43770</span></span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO BlockManagerMaster: Trying to register BlockManager</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO BlockManagerMasterEndpoint: Registering block manager localhost:<span class="number">43770</span> with <span class="number">511</span>.<span class="number">5</span> MB RAM, BlockManagerId(driver, localhost</span><br><span class="line">, <span class="number">43770</span>)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO BlockManagerMaster: Registered BlockManager</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO SparkContext: Starting job: reduce at /home/yunfeng/Downloads/spark-<span class="number">1</span>.<span class="number">6</span>.<span class="number">1</span>-bin-hadoop2.<span class="number">6</span>/calc_pi.py:<span class="number">12</span></span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO DAGScheduler: Got job <span class="number">0</span> (reduce at /home/yunfeng/Downloads/spark-<span class="number">1</span>.<span class="number">6</span>.<span class="number">1</span>-bin-hadoop2.<span class="number">6</span>/calc_pi.py:<span class="number">12</span>) with <span class="number">8</span> output partiti</span><br><span class="line">ons</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO DAGScheduler: Final stage: ResultStage <span class="number">0</span> (reduce at /home/yunfeng/Downloads/spark-<span class="number">1</span>.<span class="number">6</span>.<span class="number">1</span>-bin-hadoop2.<span class="number">6</span>/calc_pi.py:<span class="number">12</span>)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO DAGScheduler: Parents of final stage: List()</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO DAGScheduler: Missing parents: List()</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO DAGScheduler: Submitting ResultStage <span class="number">0</span> (PythonRDD[<span class="number">1</span>] at reduce at /home/yunfeng/Downloads/spark-<span class="number">1</span>.<span class="number">6</span>.<span class="number">1</span>-bin-hadoop2.<span class="number">6</span>/calc_</span><br><span class="line">pi.py:<span class="number">12</span>), which has no missing parents</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO MemoryStore: Block broadcast_0 stored as values in memory (estimated size <span class="number">4</span>.<span class="number">3</span> KB, free <span class="number">4</span>.<span class="number">3</span> KB)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO MemoryStore: Block broadcast_0_piece0 stored as bytes in memory (estimated size <span class="number">2</span>.<span class="number">8</span> KB, free <span class="number">7</span>.<span class="number">1</span> KB)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO BlockManagerInfo: Added broadcast_0_piece0 in memory on localhost:<span class="number">43770</span> (size: <span class="number">2</span>.<span class="number">8</span> KB, free: <span class="number">511</span>.<span class="number">5</span> MB)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO SparkContext: Created broadcast <span class="number">0</span> from broadcast at DAGScheduler.scala:<span class="number">1006</span></span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO DAGScheduler: Submitting <span class="number">8</span> missing tasks from ResultStage <span class="number">0</span> (PythonRDD[<span class="number">1</span>] at reduce at /home/yunfeng/Downloads/spark-<span class="number">1</span>.<span class="number">6</span>.</span><br><span class="line"><span class="number">1</span>-bin-hadoop2.<span class="number">6</span>/calc_pi.py:<span class="number">12</span>)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO TaskSchedulerImpl: Adding task set <span class="number">0</span>.<span class="number">0</span> with <span class="number">8</span> tasks</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> WARN TaskSetManager: Stage <span class="number">0</span> contains a task of very large size (<span class="number">486</span> KB). The maximum recommended task size is <span class="number">100</span> KB.</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO TaskSetManager: Starting task <span class="number">0</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">0</span>, localhost, partition <span class="number">0</span>,PROCESS_LOCAL, <span class="number">497894</span> bytes)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO TaskSetManager: Starting task <span class="number">1</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">1</span>, localhost, partition <span class="number">1</span>,PROCESS_LOCAL, <span class="number">629219</span> bytes)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO TaskSetManager: Starting task <span class="number">2</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">2</span>, localhost, partition <span class="number">2</span>,PROCESS_LOCAL, <span class="number">629219</span> bytes)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO TaskSetManager: Starting task <span class="number">3</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">3</span>, localhost, partition <span class="number">3</span>,PROCESS_LOCAL, <span class="number">629219</span> bytes)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO TaskSetManager: Starting task <span class="number">4</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">4</span>, localhost, partition <span class="number">4</span>,PROCESS_LOCAL, <span class="number">629219</span> bytes)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO TaskSetManager: Starting task <span class="number">5</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">5</span>, localhost, partition <span class="number">5</span>,PROCESS_LOCAL, <span class="number">629219</span> bytes)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO TaskSetManager: Starting task <span class="number">6</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">6</span>, localhost, partition <span class="number">6</span>,PROCESS_LOCAL, <span class="number">629219</span> bytes)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO TaskSetManager: Starting task <span class="number">7</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">7</span>, localhost, partition <span class="number">7</span>,PROCESS_LOCAL, <span class="number">632117</span> bytes)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO Executor: Running task <span class="number">3</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">3</span>)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO Executor: Running task <span class="number">1</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">1</span>)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO Executor: Running task <span class="number">0</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">0</span>)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO Executor: Running task <span class="number">6</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">6</span>)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO Executor: Running task <span class="number">7</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">7</span>)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO Executor: Running task <span class="number">2</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">2</span>)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO Executor: Running task <span class="number">5</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">5</span>)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO Executor: Running task <span class="number">4</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">4</span>)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO Executor: Fetching file:/home/yunfeng/Downloads/spark-<span class="number">1</span>.<span class="number">6</span>.<span class="number">1</span>-bin-hadoop2.<span class="number">6</span>/calc_pi.py with timestamp <span class="number">1463405637243</span></span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">57</span> INFO Utils: /home/yunfeng/Downloads/spark-<span class="number">1</span>.<span class="number">6</span>.<span class="number">1</span>-bin-hadoop2.<span class="number">6</span>/calc_pi.py has been previously copied to /tmp/spark-<span class="number">6</span>cb<span class="number">08b18-143</span></span><br><span class="line">f-<span class="number">42d</span>c-<span class="number">88</span>c3-<span class="number">27786460836</span>b/userFiles-ae0a9fc0-<span class="number">65</span>cf-<span class="number">467</span>e-<span class="number">848</span>b-<span class="number">4</span>f3cf<span class="number">4e6e1c2</span>/calc_pi.py</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO PythonRunner: Times: total = <span class="number">340</span>, boot = <span class="number">226</span>, init = <span class="number">1</span>, finish = <span class="number">113</span></span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO Executor: Finished task <span class="number">7</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">7</span>). <span class="number">998</span> bytes result sent to driver</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO PythonRunner: Times: total = <span class="number">353</span>, boot = <span class="number">222</span>, init = <span class="number">2</span>, finish = <span class="number">129</span></span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO PythonRunner: Times: total = <span class="number">359</span>, boot = <span class="number">230</span>, init = <span class="number">1</span>, finish = <span class="number">128</span></span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO PythonRunner: Times: total = <span class="number">360</span>, boot = <span class="number">225</span>, init = <span class="number">3</span>, finish = <span class="number">132</span></span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO PythonRunner: Times: total = <span class="number">358</span>, boot = <span class="number">224</span>, init = <span class="number">1</span>, finish = <span class="number">133</span></span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO Executor: Finished task <span class="number">5</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">5</span>). <span class="number">998</span> bytes result sent to driver</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO Executor: Finished task <span class="number">4</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">4</span>). <span class="number">998</span> bytes result sent to driver</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO Executor: Finished task <span class="number">0</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">0</span>). <span class="number">998</span> bytes result sent to driver</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO PythonRunner: Times: total = <span class="number">373</span>, boot = <span class="number">248</span>, init = <span class="number">0</span>, finish = <span class="number">125</span></span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO Executor: Finished task <span class="number">1</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">1</span>). <span class="number">998</span> bytes result sent to driver</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO Executor: Finished task <span class="number">2</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">2</span>). <span class="number">998</span> bytes result sent to driver</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO TaskSetManager: Finished task <span class="number">7</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">7</span>) in <span class="number">420</span> ms on localhost (<span class="number">1</span>/<span class="number">8</span>)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO TaskSetManager: Finished task <span class="number">5</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">5</span>) in <span class="number">427</span> ms on localhost (<span class="number">2</span>/<span class="number">8</span>)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO PythonRunner: Times: total = <span class="number">385</span>, boot = <span class="number">245</span>, init = <span class="number">0</span>, finish = <span class="number">140</span></span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO Executor: Finished task <span class="number">6</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">6</span>). <span class="number">998</span> bytes result sent to driver</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO TaskSetManager: Finished task <span class="number">4</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">4</span>) in <span class="number">431</span> ms on localhost (<span class="number">3</span>/<span class="number">8</span>)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO TaskSetManager: Finished task <span class="number">1</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">1</span>) in <span class="number">439</span> ms on localhost (<span class="number">4</span>/<span class="number">8</span>)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO TaskSetManager: Finished task <span class="number">2</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">2</span>) in <span class="number">437</span> ms on localhost (<span class="number">5</span>/<span class="number">8</span>)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO TaskSetManager: Finished task <span class="number">6</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">6</span>) in <span class="number">430</span> ms on localhost (<span class="number">6</span>/<span class="number">8</span>)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO TaskSetManager: Finished task <span class="number">0</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">0</span>) in <span class="number">455</span> ms on localhost (<span class="number">7</span>/<span class="number">8</span>)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO PythonRunner: Times: total = <span class="number">390</span>, boot = <span class="number">246</span>, init = <span class="number">1</span>, finish = <span class="number">143</span></span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO Executor: Finished task <span class="number">3</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">3</span>). <span class="number">998</span> bytes result sent to driver</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO TaskSetManager: Finished task <span class="number">3</span>.<span class="number">0</span> in stage <span class="number">0</span>.<span class="number">0</span> (TID <span class="number">3</span>) in <span class="number">442</span> ms on localhost (<span class="number">8</span>/<span class="number">8</span>)</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO DAGScheduler: ResultStage <span class="number">0</span> (reduce at /home/yunfeng/Downloads/spark-<span class="number">1</span>.<span class="number">6</span>.<span class="number">1</span>-bin-hadoop2.<span class="number">6</span>/calc_pi.py:<span class="number">12</span>) finished in <span class="number">0</span>.<span class="number">467</span></span><br><span class="line"> s</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO TaskSchedulerImpl: Removed TaskSet <span class="number">0</span>.<span class="number">0</span>, whose tasks have all completed, from pool </span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO DAGScheduler: Job <span class="number">0</span> finished: reduce at /home/yunfeng/Downloads/spark-<span class="number">1</span>.<span class="number">6</span>.<span class="number">1</span>-bin-hadoop2.<span class="number">6</span>/calc_pi.py:<span class="number">12</span>, took <span class="number">0.569039</span> s</span><br><span class="line">*****result:pi is :<span class="number">3.140324</span>*****</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO SparkContext: Invoking stop() from shutdown hook</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO SparkUI: Stopped Spark web UI at http://<span class="number">192.168.102.77</span>:<span class="number">4040</span></span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO MapOutputTrackerMasterEndpoint: MapOutputTrackerMasterEndpoint stopped!</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO MemoryStore: MemoryStore cleared</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO BlockManager: BlockManager stopped</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO BlockManagerMaster: BlockManagerMaster stopped</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO OutputCommitCoordinator$OutputCommitCoordinatorEndpoint: OutputCommitCoordinator stopped!</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO SparkContext: Successfully stopped SparkContext</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO ShutdownHookManager: Shutdown hook called</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO ShutdownHookManager: Deleting directory /tmp/spark-<span class="number">6</span>cb08b18-<span class="number">143</span>f-<span class="number">42d</span>c-<span class="number">88</span>c3-<span class="number">27786460836</span>b/pyspark-<span class="number">33d22309</span>-ef12-<span class="number">45d6-9862</span>-<span class="number">2</span></span><br><span class="line"><span class="number">5</span>ceb8beadac</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO ShutdownHookManager: Deleting directory /tmp/spark-<span class="number">6</span>cb08b18-<span class="number">143</span>f-<span class="number">42d</span>c-<span class="number">88</span>c3-<span class="number">27786460836</span>b</span><br><span class="line"><span class="number">16/05/16 21</span>:<span class="number">33</span>:<span class="number">58</span> INFO RemoteActorRefProvider$RemotingTerminator: Shutting down remote daemon.</span><br></pre></td></tr></table></figure>

<p>可以看到在96行，输出了我们想要的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*****result:pi is :3.140324*****</span><br></pre></td></tr></table></figure>
<p>需要注意的是：Spark自动在本地开了8个进程，来模拟在分布式情况下的计算节点，这样就可以在单机情况下调试适用于分布式情况下的代码了。  </p>
<h3 id="5-在分布式环境下部署"><a href="#5-在分布式环境下部署" class="headerlink" title="5. 在分布式环境下部署"></a>5. 在分布式环境下部署</h3><p>在单机上调试好程序后，我们就可以将代码部署到分布式的机器上了。<strong>这里有个要求：每个分布式的机器节点上都必须安装相同版本的Spark。</strong>所以第一步就是再各个机器上安装Spark。  </p>
<p>安装完Spark后，我们就可以通过下面的命令来启动各个节点的Spark了：<br>1.在要运行Driver程序（master）的机器上，在Spark根目录下，执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./sbin/start-master.sh</span><br></pre></td></tr></table></figure>
<p>2.在<strong>各个Worker Node上</strong>，连接到主节点上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./sbin/star-slave.sh &lt;master-spark-URL&gt;</span><br></pre></td></tr></table></figure>

<p>这是一种手动启动的方式。此外，还可以通过在Driver 程序所在节点上执行下面的命令来自动地启动或停止所有节点的Spark程序：</p>
<ul>
<li><code>sbin/start-master.sh</code> ： 启动主进程 </li>
<li><code>sbin/start-slaves.sh</code> ： 启动<code>conf/slaves</code>文件里面的所有节点</li>
<li><code>sbin/start-all.sh</code> ： 启动主进程和所有计算节点</li>
<li><code>sbin/stop-master.sh</code>： 停止主进程</li>
<li><code>sbin/stop-slavers.sh</code> ： 停止所有计算节点</li>
</ul>
<p>配置完分布式环境后，就可以运行程序了。以上述的<code>calc_pi.py</code>为例，假设master程序运行在192.168.3.2:8080，则在运行master的主机上运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/spark-submit -master spark://192.168.3.2:8080 calc_pi.py</span><br></pre></td></tr></table></figure>
<p>这样就可以分布式地运行Spark了！</p>
<p>至此Spark的内容的总结就结束了，总的来说，Spark编程并没有想象中的那么复杂，恰恰相反，随着时间的推移，这些开发工具越来越对开发者友好，这也是使得Spark能轻易地上手的原因。  </p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>并行计算</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>在Hexo博客里面插入asciinema终端记录视频</title>
    <url>/2016/11/14/test-asciinema/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前几天发现了一个很有意思的记录终端操作的工具<a href="https://asciinema.org/">asciinema</a>,使用起来异常简单功能却很强大，很佩服开发者的想象力和创造力。<br>今天我在想，能否在Hexo博客里面插入asciinema录的视频呢？Google了一下，发现真的已经有人做出了该功能的插件<a href="https://github.com/narongdejsrn/hexo-tag-asciinema">hexo-tag-asciinema</a>,安装了下果然可以在博客里面插入asciinema，而且一个超级简单的命令即可完成。像下面就是一个例子(用C++编写一个简单的HelloWorld程序)：</p>
<script type="text/javascript" src="https://asciinema.org/a/92655.js" id="asciicast-92655" async></script>

<p>下面详细介绍每个步骤。</p>
<span id="more"></span>

<h2 id="asciinema安装"><a href="#asciinema安装" class="headerlink" title="asciinema安装"></a>asciinema安装</h2><p>参照<a href="https://asciinema.org/docs/installation">这里</a>的教程,常见的asciinema的安装方式有下面2种：</p>
<ol>
<li>通过系统的包管理软件安装<br>Debian:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install asciinema</span><br></pre></td></tr></table></figure>
Ubuntu:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-add-repository ppa:zanchey/asciinema</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install asciinema</span><br></pre></td></tr></table></figure></li>
</ol>
<p>2.通过pip3安装，需要先安装python3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip3 install asciinema</span><br></pre></td></tr></table></figure>

<h2 id="asciinema使用"><a href="#asciinema使用" class="headerlink" title="asciinema使用"></a>asciinema使用</h2><p>安装好后，打开终端,输入<code>asciinema rec</code> 开始记录，按<code>Ctrl-D</code>结束记录。<br>结束记录后，会让你选择是否需要上传数据，如果选择<code>Y</code>,则会给出一个URL，点击该URL即可访问你刚才录的视频。<br>另外，你也可以在asciinema官网上注册帐号，这样你所有记录的数据都可以保存在上面，你可以通过<code>asciinema auth</code>来验证帐号。</p>
<h2 id="在Hexo里面插入asciinema的视频"><a href="#在Hexo里面插入asciinema的视频" class="headerlink" title="在Hexo里面插入asciinema的视频"></a>在Hexo里面插入asciinema的视频</h2><p>假设你已经在本地安装好了Hexo博客系统而且已经通过asciinema录制好了视频<strong>并上传到asciinema网站上</strong>。<br>首先是通过<code>npm</code>安装<a href="https://github.com/narongdejsrn/hexo-tag-asciinema">hexo-tag-asciinema</a>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-tag-asciinema </span><br></pre></td></tr></table></figure>
<p>然后在Hexo博客的<code>markdown</code>文件里面，使用下面的命令来插入视频:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% asciinema video_id %&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>video_id</code>是你上传的视频的编号，比如你视频所在的页面是<code>https://asciinema.org/a/41100</code>, 那在<code>video_id</code>那里填<code>41100</code>。<br>然后保存markdown文件，执行<code>npm install</code>安装必要的包，再<code>hexo deploy</code>部署你的博客，就可以看到效果了。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>asciinema</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中使用pytorch保存的tensor</title>
    <url>/2021/03/21/torch-tensor-python-to-cpp/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近在学习Libtorch——即Pytorch的C++版本，需要使用 Pytorch 导出的 tensor 以便对模型进行 debug。下面是转换代码，总体原理是将 tensor 转换为二进制数据，再在 C++ 里面读入。</p>
<span id="more"></span>

<p>下面是 Pytorch 中的导出 tensor 示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_tensor</span>(<span class="params">device</span>):</span></span><br><span class="line">    my_tensor = torch.rand(<span class="number">3</span>, <span class="number">3</span>).to(device);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[python] my_tensor: &quot;</span>, my_tensor)</span><br><span class="line">    f = io.BytesIO()</span><br><span class="line">    torch.save(my_tensor, f, _use_new_zipfile_serialization=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;my_tensor_%s.pt&#x27;</span> % device, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> out_f:</span><br><span class="line">        <span class="comment"># Copy the BytesIO stream to the output file</span></span><br><span class="line">        out_f.write(f.getbuffer())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    save_tensor(<span class="string">&#x27;cpu&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这里以导出 cpu tensor 为例，cuda tensor 也是同理。</p>
<p>在 C++ 中的调用示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;torch/torch.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">char</span>&gt; <span class="title">get_the_bytes</span><span class="params">(std::string filename)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">input</span><span class="params">(filename, std::ios::binary)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">char</span>&gt; <span class="title">bytes</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        (std::istreambuf_iterator&lt;<span class="keyword">char</span>&gt;(input)),</span></span></span><br><span class="line"><span class="params"><span class="function">        (std::istreambuf_iterator&lt;<span class="keyword">char</span>&gt;()))</span></span>;</span><br><span class="line"></span><br><span class="line">    input.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">char</span>&gt; f = <span class="built_in">get_the_bytes</span>(<span class="string">&quot;my_tensor_cpu.pt&quot;</span>);</span><br><span class="line">    torch::IValue x = torch::<span class="built_in">pickle_load</span>(f);</span><br><span class="line">    torch::Tensor my_tensor = x.<span class="built_in">toTensor</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[cpp] my_tensor: &quot;</span> &lt;&lt; my_tensor &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ol>
<li>torch的Python和C++版本需要保持一致，否则转换可能不成功.</li>
</ol>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>最近在学习Libtorch——即Pytorch的C++版本，发现使用起来异常的丝滑，写C++有了Python的体验，妙不可言。<br>后面会更新一些关于libtorch使用的文章，敬请关注。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://discuss.pytorch.org/t/how-to-load-python-tensor-in-c/88813">https://discuss.pytorch.org/t/how-to-load-python-tensor-in-c/88813</a></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
        <tag>Pytorch</tag>
        <tag>Libtorch</tag>
      </tags>
  </entry>
  <entry>
    <title>TSN Usage——如何编译和使用temporal-segment-networks</title>
    <url>/2017/03/31/tsn-usage/</url>
    <content><![CDATA[<p><a href="https://github.com/yjxiong/temporal-segment-networks">TSN</a>是”temporal-segment-networks”的简称，是视频动作识别任务里面当前最好的方法。虽然这个结构是在ECCV2016的论文里面提出来的，代码也放出来挺长时间了，但是这个项目里面集合了Caffe， OpenCV，CUDA，CUDNN等几大神坑项目，不同版本之间的依赖、选择等问题很麻烦，因此我之前编译了好几次都没有能够编译成功。这次花了近一天的时间来重新编译了一下整个项目，虽然还是有些问题，例如MPI编译没有通过，CUDA8貌似不支持，CuDNN v5好像也不支持，但最后总算是编译通过，可以运行了。所以记录一下整个的过程，期望对自己和别人能够有所帮助。</p>
<span id="more"></span>

<h3 id="1-OpenCV编译"><a href="#1-OpenCV编译" class="headerlink" title="1. OpenCV编译"></a>1. OpenCV编译</h3><p>因为TSN这个项目里面有提取光流的code，其中利用的是OpenCV里面的利用GPU来提取光流的代码，所以需要用到OpenCV。虽然可以使用系统已经编译好的，但是在编译dense_flow的时候发现还依赖<a href="https://github.com/opencv/opencv_contrib">opencv_contrib</a>中的库，所以为了避免重新编译系统的OpenCV影响别的用户，我自己编译了一个新的版本的OpenCV，放在自己的目录下。<br>因为我们服务器上已经装过了3.1.0版本的OpenCV(可以通过<code>pkg-config --modversion opencv</code>命令来查看OpenCV的版本)，所以为了避免编译时寻找include目录中的文件的时候报错，这里在自己的目录下安装3.1.0版本的OpenCV和外部的库（因为dense_flow代码需要用到额外的库）。</p>
<h4 id="1-下载最新版本的OpenCV-和-opencv-contrib-确保两个库都切换到3-1-0这个分支"><a href="#1-下载最新版本的OpenCV-和-opencv-contrib-确保两个库都切换到3-1-0这个分支" class="headerlink" title="1. 下载最新版本的OpenCV 和 opencv_contrib, 确保两个库都切换到3.1.0这个分支:"></a>1. 下载最新版本的OpenCV 和 opencv_contrib, 确保两个库都切换到3.1.0这个分支:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data5/yunfeng/Dev/git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/opencv/opencv.git</span><br><span class="line"><span class="built_in">cd</span> opencv</span><br><span class="line">git checkout 3.1.0</span><br><span class="line"><span class="built_in">cd</span> ../</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/opencv/opencv_contrib.git</span><br><span class="line"><span class="built_in">cd</span> opencv_contrib</span><br><span class="line">git checkout 3.1.0</span><br></pre></td></tr></table></figure>
<h5 id="2-利用cmake和make命令来编译OpenCV"><a href="#2-利用cmake和make命令来编译OpenCV" class="headerlink" title="2. 利用cmake和make命令来编译OpenCV"></a>2. 利用cmake和make命令来编译OpenCV</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../opencv</span><br><span class="line">mkdir release; <span class="built_in">cd</span> release</span><br><span class="line">cmake -D OPENCV_EXTRA_MODULES_PATH=/data5/yunfeng/Dev/opencv_contrib/modules -D CMAKE_BUILD_TYPE=RELEASE -D WITH_TBB=ON -D BUILD_NEW_PYTHON_SUPPORT=ON -D INSTALL_C_EXAMPLES=ON -D INSTALL_PYTHON_EXAMPLES=ON -D BUILD_EXAMPLES=ON -D ENABLE_FAST_MATH=1 -D CUDA_FAST_MATH=1 -D WITH_CUBLAS=1 -D CMAKE_INSTALL_PREFIX=/data5/yunfeng/<span class="built_in">local</span> -D CUDA_TOOLKIT_ROOT_DIR=/usr/<span class="built_in">local</span>/cuda-7.5 ..</span><br><span class="line">make -j40</span><br><span class="line">make install -j40</span><br></pre></td></tr></table></figure>
<p>这里有几个地方需要注意:</p>
<ul>
<li>编译OpenCV的同时编译opencv_contrib，需要在cmake里面设置<code>-D OPENCV_EXTRA_MODULES_PATH=/path/to/opencv_contrib/modules</code>, 其中参数的值就是到opencv_contrib仓库的modules子目录的绝对路径</li>
<li>通过设置<code>-D CUDA_FAST_MATH=1</code> 和 <code>-D WITH_CUBLAS=1</code>来启用CUDA和CUBLAS</li>
<li>通过设置<code>-D CMAKE_INSTALL_PREFIX=/path/to/local</code>来设置编译生成的lib和bin目录存放的位置，如果不设置的话默认是在<code>/usr/local</code>目录里面，因此需要管理员权限才能执行最后的<code>make install</code></li>
<li>通过设置<code>-D CUDA_TOOLKIT_ROOT_DIR=/path/to/cuda</code>来设置CUDA的路径，不设置话cmake会在系统目录里面寻找，如果系统有多个CUDA版本的话，找到的可能不是我们需要的，所以还是显式地写到参数列表里比较稳妥</li>
<li>此外还可以设置<code>-D CUDNN_INCLUDE=&quot;/path/to/cuda/include&quot;</code> 和<code>-D CUDNN_LIBRARY=&quot;/path/to/cuda/lib64&quot;</code> 来设置CuDNN的路径</li>
</ul>
<p>cmake的时候报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- ICV: Downloading ippicv_linux_20151201.tgz...</span><br><span class="line">CMake Error at 3rdparty/ippicv/downloader.cmake:73 (file):</span><br><span class="line">  file DOWNLOAD HASH mismatch</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> file: [/path/to/opencv/3rdparty/ippicv/downloads/linux-808b791a6eac9ed78d32a7666804320e/ippicv_linux_20151201.tgz]</span><br><span class="line">      expected <span class="built_in">hash</span>: [808b791a6eac9ed78d32a7666804320e]</span><br><span class="line">        actual <span class="built_in">hash</span>: [f166287239920c4a16e6f8870e15ef79]</span><br></pre></td></tr></table></figure>
<p>这个问题可以通过直接在<a href="https://github.com/Itseez/opencv_3rdparty/tree/ippicv/master_20151201/ippicv">这里</a>下载ippicv_linux_20151201.tgz 文件，并放置到<code>opencv/3rdparty/ippicv/downloads/linux-808b791a6eac9ed78d32a7666804320e/</code>目录下，然后重新运行cmake即可。  </p>
<h3 id="2-编译TSN"><a href="#2-编译TSN" class="headerlink" title="2. 编译TSN"></a>2. 编译TSN</h3><p>TSN代码里面包含3个submodule，分别是opencv2.4.12, 提取光流的dense_flow和修改过的caffe caffe-action。我们这里已经编译过OpenCV，所以接下来编译dense_flow和caffe-action, 作者给出的<code>build_all.sh</code>执行会有些问题，我们可以参照这个文件的内容，自己一步步地编译各个部分。  </p>
<h4 id="1-编译dense-flow"><a href="#1-编译dense-flow" class="headerlink" title="1. 编译dense_flow"></a>1. 编译dense_flow</h4><p>dense_flow依赖于libzip-dev这个包，可以通过系统的包管理器安装。我本来是想自己编译的，但是编译后，在make dense_flow 的时候还是报错，最后还是让管理员老师装了这个包。<br>装完依赖后，开始执行cmake，使用<code>OpenCV_DIR</code>参数来设置OpenCV目录，指向我们自己刚才编译的OpenCV。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data5/yunfeng/Dev/git</span><br><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/yjxiong/temporal-segment-networks tsn</span><br><span class="line"><span class="built_in">cd</span> tsn</span><br><span class="line"><span class="built_in">cd</span> lib/dense_flow</span><br><span class="line">mkdir build; <span class="built_in">cd</span> build</span><br><span class="line">OpenCV_DIR=/data5/yunfeng/Dev/opencv/release cmake -D CUDA_TOOLKIT_ROOT_DIR=/usr/<span class="built_in">local</span>/cuda-7.5 ..</span><br><span class="line">make -j40</span><br><span class="line">make install -j40</span><br></pre></td></tr></table></figure>
<p>如果<code>libzip-dev</code>这个包是自己安装的，且没有放在系统目录下，你需要增加几个选项来执行cmake，像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OpenCV_DIR=/data10/yunfeng/Dev/git/opencv/release cmake -D CUDA_TOOLKIT_ROOT_DIR=/data1/yunfeng/cuda -D LIBZIP_LIBRARY=/data1/yunfeng/<span class="built_in">local</span>/lib -D LIBZIP_INCLUDE_DIR_ZIP=/data1/yunfeng/<span class="built_in">local</span>/include -D LIBZIP_INCLUDE_DIR_ZIPCONF=/data1/yunfeng/<span class="built_in">local</span>/lib/libzip/include ..</span><br></pre></td></tr></table></figure>
<h4 id="2-编译caffe-action"><a href="#2-编译caffe-action" class="headerlink" title="2. 编译caffe-action"></a>2. 编译caffe-action</h4><p>作者原来的代码是通过MPI来并行运行的，所以需要通过如下的cmake命令来编译caffe:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OpenCV_DIR=/data5/yunfeng/Dev/opencv/release cmake -DUSE_MPI=ON -D CUDA_TOOLKIT_ROOT_DIR=/usr/<span class="built_in">local</span>/cuda-7.5 -DMPI_CXX_COMPILER=<span class="string">&quot;/usr/bin/mpicxx&quot;</span> ..</span><br><span class="line">make -j40</span><br></pre></td></tr></table></figure>
<p>但是这样编译的时候，CuDNN会报错，没有办法，我就用常规的make来编译了caffe-action:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> lib/caffe-action</span><br><span class="line">cp Makefile.config.example Makefile.config</span><br><span class="line">vim Makefile.config <span class="comment"># change the settings</span></span><br><span class="line">make -j40</span><br></pre></td></tr></table></figure>
<p>这样整个工程就编译完了，好像也不是很复杂，但是出现问题解决不了的时候还是挺令人烦躁的。</p>
<h3 id="3-Troubleshoot"><a href="#3-Troubleshoot" class="headerlink" title="3. Troubleshoot"></a>3. Troubleshoot</h3><p>这里列出来一些编译和使用这个项目过程中常出现的问题，大多和OpenCV, Caffe, CUDA和CuDNN相关</p>
<ol>
<li>在使用OpenCV的CommandLineParser的时候，总提示” FATAL [default] Check failed: [video_stream.isOpened()] Cannot open video stream “true” for optical flow extraction.”,这是因为作者原来的代码<code>tsn/tools/build_of.py</code>文件里面，使用OpenCV的CommandLineParser的时候，参数是以空格分隔的，如<code>-f &#123;&#125; -x &#123;&#125; -y &#123;&#125; -i &#123;&#125; -b 20 -t 1 -d &#123;&#125; -s 1 -o &#123;&#125; -w &#123;&#125; -h &#123;&#125;</code>, 但是新版的OpenCV里面都是用等号<code>=</code>来分割的，不知道是不是某个版本修改了接口还是怎么回事，将空格改成等号即可，如<code>-f=&#123;&#125; -x=&#123;&#125; -y=&#123;&#125; -i=&#123;&#125; -b=20 -t=1 -d=&#123;&#125; -s=1 -o=&#123;&#125; -w=&#123;&#125; -h=&#123;&#125;</code>。  </li>
<li>在使用CUDA8来编译项目的时候，会提示”libnppi.so: undefined reference to `nppGetMaxThreadsPerSM”, 网上的回答也很少，可能是CUDA8出来没多久，讨论还不是很多吧。所以我暂时认为这个项目不支持CUDA8。  </li>
<li>使用OpenCV2.4.12编译的时候，会提示”/usr/include/opencv2/nonfree/features2d.hpp:81:5: error: ‘AlgorithmInfo’ does not name a type AlgorithmInfo* info() const;”。这是因为我们服务器上已经装了OpenCV3.1.0，所以在编译的时候，会找系统目录下的头文件，而3版本的头文件和2版本的头文件不一致，导致出现这个问题。按理来说，这个问题可以通过修改头文件寻找路径，使得编译器使用2版本的头文件即可，但是我不知道怎么在cmake的时候指定头文件。。所以没办法，还是采用了3版本的OpenCV来编译。有关的讨论见<a href="https://github.com/arrenglover/openfabmap/issues/14">https://github.com/arrenglover/openfabmap/issues/14</a>。</li>
</ol>
]]></content>
      <tags>
        <tag>Caffe</tag>
        <tag>OpenCV</tag>
        <tag>CUDA</tag>
        <tag>CNN</tag>
        <tag>Action Recongnition</tag>
        <tag>TSN</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu命令行显示中文</title>
    <url>/2018/01/13/ubuntu-chinese/</url>
    <content><![CDATA[<p>我们的Ubuntu服务器用命令行显示中文一直有问题，网上找资料说安装zhcon，依旧解决不了我们的问题。因此这里调查了下可能的原因，将其记录下来。</p>
<span id="more"></span>

<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>将如下的设置项放到<code>~/.bashrc</code>中，然后执行<code>source ~/.bashrc</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LANG=en_US.UTF-8</span><br><span class="line">LANGUAGE=</span><br><span class="line">LC_CTYPE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_NUMERIC=zh_CN.UTF-8</span><br><span class="line">LC_TIME=zh_CN.UTF-8</span><br><span class="line">LC_COLLATE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MONETARY=zh_CN.UTF-8</span><br><span class="line">LC_MESSAGES=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_PAPER=zh_CN.UTF-8</span><br><span class="line">LC_NAME=zh_CN.UTF-8</span><br><span class="line">LC_ADDRESS=zh_CN.UTF-8</span><br><span class="line">LC_TELEPHONE=zh_CN.UTF-8</span><br><span class="line">LC_MEASUREMENT=zh_CN.UTF-8</span><br><span class="line">LC_IDENTIFICATION=zh_CN.UTF-8</span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure>
<p>其中最重要的是最后一项设置<code>LC_ALL</code>，因为其默认设置是<code>LC_ALL=C</code>，<code>C</code>代表覆盖掉 LANG 和所有 LC_* 变量的值, 将其设置为系统默认值。因此该项设置为空即可采用自定义设置。</p>
<h3 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h3><ol>
<li><a href="https://wiki.archlinux.org/index.php/Locale_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">https://wiki.archlinux.org/index.php/Locale_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装NeoVim:一种最简单的方法</title>
    <url>/2019/03/13/ubuntu-install-neovim/</url>
    <content><![CDATA[<p><a href="https://neovim.io/">NeoVim</a>是Vim的一个拓展版本，用起来比Vim爽一些。下面简要记录下在Ubuntu 16.04上安装NeoVim的过程，其实比较简单。</p>
<span id="more"></span>

<p>为了使用<code>add-apt-repository</code>，需要先安装下面的包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br></pre></td></tr></table></figure>
<p>然后选择stable或者unstable版本进行安装，见下。</p>
<h2 id="安装stable版本-version-0-2-2"><a href="#安装stable版本-version-0-2-2" class="headerlink" title="安装stable版本, version=0.2.2"></a>安装stable版本, version=0.2.2</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:neovim-ppa/stable</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y neovim</span><br></pre></td></tr></table></figure>

<h2 id="安装unstable版本-version-0-4-0-dev"><a href="#安装unstable版本-version-0-4-0-dev" class="headerlink" title="安装unstable版本, version=0.4.0-dev"></a>安装unstable版本, version=0.4.0-dev</h2><p>因为某些插件只支持<code>0.3</code>及以上的版本，因此为了使用插件需要安装unstable版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:neovim-ppa/unstable</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y neovim</span><br></pre></td></tr></table></figure>

<p>安装后就可以使用了，用命令<code>nvim</code>即可打开Neovim，建议继续阅读<a href="http://vra.github.io/2019/03/12/vim-plug-intro/">vim-plug</a>来了解NeoVim的插件安装工具。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://launchpad.net/~neovim-ppa/+archive/ubuntu/stable">https://launchpad.net/~neovim-ppa/+archive/ubuntu/stable</a></li>
<li><a href="https://launchpad.net/~neovim-ppa/+archive/ubuntu/unstable">https://launchpad.net/~neovim-ppa/+archive/ubuntu/unstable</a></li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>总结</tag>
        <tag>Ubuntu</tag>
        <tag>Vim</tag>
        <tag>NeoVim</tag>
      </tags>
  </entry>
  <entry>
    <title>在ubuntu中进行core dump调试</title>
    <url>/2017/12/03/ubuntu-core-dump-debug/</url>
    <content><![CDATA[<p>在Linux环境下执行程序的时候，有的时候会出现段错误（‘segment fault’），同时显示core dumped,就像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[1]    15428 segmentation fault (core dumped)  ./a.out</span><br></pre></td></tr></table></figure>
<p>下面是我网上找到的段错误的定义和说明：  </p>
<pre><code>A segmentation fault (often shortened to segfault) is a particular error condition that can occur during the operation of computer software. In short, a segmentation fault occurs when a program attempts to access a memory location that it is not allowed to access, or attempts to access a memory location in a way that is not allowed (e.g., attempts to write to a read-only location, or to overwrite part of the operating system). Systems based on processors like the Motorola 68000 tend to refer to these events as Address or Bus errors.

Segmentation is one approach to memory management and protection in the operating system. It has been superseded by paging for most purposes, but much of the terminology of segmentation is still used, &quot;segmentation fault&quot; being an example. Some operating systems still have segmentation at some logical level although paging is used as the main memory management policy.

On Unix-like operating systems, a process that accesses invalid memory receives the SIGSEGV signal. On Microsoft Windows, a process that accesses invalid memory receives the STATUS_ACCESS_VIOLATION exception.
</code></pre>
<p>简单理解就是访问了不该访问的内存就会产生段错误。<br>而core dump是一种将出错时的调用堆栈等信息写入到一个文件中，方便后面调试。Ubuntu下需要进行一些设置才能正确地调试core dump，下面是详细的说明。  </p>
<span id="more"></span>
<h3 id="ulimit-设置"><a href="#ulimit-设置" class="headerlink" title="ulimit 设置"></a>ulimit 设置</h3><p>ulimit是对shell启动进程所占系统资源进行限制的一个工具，详细的使用说明可以看<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ulimit/">这里</a>。在这里我们需要对ulimit进行设置，因为在Ubuntu下，默认的core 文件的大小是0，可以通过执行<code>ulimit -a</code>查看所有的选项设置值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ulimit</span> -a</span><br><span class="line">-t: cpu time (seconds)              unlimited</span><br><span class="line">-f: file size (blocks)              unlimited</span><br><span class="line">-d: data seg size (kbytes)          unlimited</span><br><span class="line">-s: stack size (kbytes)             8192</span><br><span class="line">-c: core file size (blocks)         0</span><br><span class="line">-m: resident <span class="built_in">set</span> size (kbytes)      unlimited</span><br><span class="line">-u: processes                       2063144</span><br><span class="line">-n: file descriptors                1024</span><br><span class="line">-l: locked-in-memory size (kbytes)  64</span><br><span class="line">-v: address space (kbytes)          unlimited</span><br><span class="line">-x: file locks                      unlimited</span><br><span class="line">-i: pending signals                 2063144</span><br><span class="line">-q: bytes <span class="keyword">in</span> POSIX msg queues       819200</span><br><span class="line">-e: max nice                        0</span><br><span class="line">-r: max rt priority                 0</span><br><span class="line">-N 15:                              unlimited</span><br></pre></td></tr></table></figure>
<p>可以看到上面的结果中<code>-c: core file size (blocks)</code> 那项的值是0，因此在段错误发生core dump的时候，默认也不会生成core文件。<br>那应该怎么修改core文件的大小呢？<code>ulimit</code>的值都可以通过<code>ulimit -k v</code>的形式来设置，其中<code>-k</code>就是上面结果中的第一列，而<code>v</code>就是设置的值，最大可以设置为<code>unlimited</code>，所以我们可以这样来设置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure>
<p>再用 <code>ulimit -a</code>查看，发现对<code>-c</code>的修改已经生效了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ulimit</span> -a</span><br><span class="line">-t: cpu time (seconds)              unlimited</span><br><span class="line">-f: file size (blocks)              unlimited</span><br><span class="line">-d: data seg size (kbytes)          unlimited</span><br><span class="line">-s: stack size (kbytes)             8192</span><br><span class="line">-c: core file size (blocks)         unlimited</span><br><span class="line">-m: resident <span class="built_in">set</span> size (kbytes)      unlimited</span><br><span class="line">-u: processes                       2063144</span><br><span class="line">-n: file descriptors                1024</span><br><span class="line">-l: locked-in-memory size (kbytes)  64</span><br><span class="line">-v: address space (kbytes)          unlimited</span><br><span class="line">-x: file locks                      unlimited</span><br><span class="line">-i: pending signals                 2063144</span><br><span class="line">-q: bytes <span class="keyword">in</span> POSIX msg queues       819200</span><br><span class="line">-e: max nice                        0</span><br><span class="line">-r: max rt priority                 0</span><br><span class="line">-N 15:                              unlimited</span><br></pre></td></tr></table></figure>
<pre><code>注意：新开一个Shell的时候，ulimit选项都恢复了默认选项，需要重新设置该值
</code></pre>
<h3 id="设置core-pattern"><a href="#设置core-pattern" class="headerlink" title="设置core_pattern"></a>设置<code>core_pattern</code></h3><p>出了上面的ulimit设置，我们还需要设置<code>core_pattern</code>，即发送core dump后，对core文件执行什么操作，这个可以通过查看<code>/proc/sys/kernel/core_pattern</code>文件来得到，在Ubuntu 16.04上面，上述文件内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /proc/sys/kernel/core_pattern</span><br><span class="line">|/usr/share/apport/apport %p %s %c %P</span><br></pre></td></tr></table></figure>
<p>其中的<code>l</code>表示执行后面的命令，而后面的<code>apport</code>是Ubuntu的bug反馈的工具，因此在Ubuntu下，默认的core dump 段错误处理机制是将其作为一个bug，进行bug检查，如果是bug的话就进行上报。<br>在这种设定下，我们没法用gdb来调试我们程序的错误。<br>因此这里我们得修改<code>core_pattern</code>的内容，将其修改为<code>core</code>即可。但是没有找到修改<code>core_pattern</code>文件的方式，因为它本身不是一个实体的文件，所以这里有个小技巧来实现这个功能：暂停<code>apport</code>服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service apport stop</span><br></pre></td></tr></table></figure>
<p>然后查看<code>core_pattern</code>的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /proc/sys/kernel/core_pattern</span><br><span class="line">core</span><br></pre></td></tr></table></figure>
<p>可以看到这里的操作以及改成<code>core</code>，即生成core文件。  </p>
<h3 id="gcc-g-设置debug模式"><a href="#gcc-g-设置debug模式" class="headerlink" title="gcc/g++设置debug模式"></a>gcc/g++设置debug模式</h3><p>除了上面的两项设置，这里还需要在编译代码的时候通过加<code>-g</code>参数来启用debug模式，这样会在生成的可执行文件中加入调试信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -g xxx.cpp</span><br><span class="line">gcc -g xxx.c</span><br></pre></td></tr></table></figure>
<h3 id="采用gdb来调试程序"><a href="#采用gdb来调试程序" class="headerlink" title="采用gdb来调试程序"></a>采用gdb来调试程序</h3><p>完成上面的设置之后，就可以使用gdb来调试了，当程序发生段错误，而且core文件也生成后，通过执行下面的命令来开始调试：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">gdb ./<span class="selector-tag">a</span><span class="selector-class">.out</span> core</span><br></pre></td></tr></table></figure>
<p>其中<code>./a.out</code>是到可执行文件的路径，而<code>core</code>是core dump生成的文件。<br>之后执行在gdb调试环境里面执行<code>bt</code>命令，即可定位到报错的位置，然后再根据报错信息，利用搜索引擎查找解决方法。下面是我的一个调试现场信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gdb ./build/tools/caffe.bin core</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">&quot;show copying&quot;</span></span><br><span class="line">and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;x86_64-linux-gnu&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">Reading symbols from ./build/tools/caffe.bin...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">[New LWP 38035]</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line">Core was generated by `./build/tools/caffe.bin<span class="string">&#x27;.</span></span><br><span class="line"><span class="string">Program terminated with signal SIGSEGV, Segmentation fault.</span></span><br><span class="line"><span class="string">#0  0x00007f99b6ff5f66 in google::protobuf::Arena::AllocateAligned(std::type_info const*, unsigned long) () from /usr/local/lib/libopencv_dnn.so.3.3</span></span><br><span class="line"><span class="string">(gdb) bt</span></span><br><span class="line"><span class="string">#0  0x00007f99b6ff5f66 in google::protobuf::Arena::AllocateAligned(std::type_info const*, unsigned long) () from /usr/local/lib/libopencv_dnn.so.3.3</span></span><br><span class="line"><span class="string">#1  0x00007f99b6ff5f89 in google::protobuf::Arena::AddListNode(void*, void (*)(void*)) () from /usr/local/lib/libopencv_dnn.so.3.3</span></span><br><span class="line"><span class="string">#2  0x00007f99b70473ae in google::protobuf::FileDescriptorProto::New(google::protobuf::Arena*) const [clone .localalias.409] () from /usr/local/lib/libopencv_dnn.so.3.3</span></span><br><span class="line"><span class="string">#3  0x00007f99b6147038 in google::protobuf::MessageLite::ParseFromArray(void const*, int) () from /usr/lib/x86_64-linux-gnu/libprotobuf.so.9</span></span><br><span class="line"><span class="string">#4  0x00007f99b61901b6 in google::protobuf::EncodedDescriptorDatabase::Add(void const*, int) () from /usr/lib/x86_64-linux-gnu/libprotobuf.so.9</span></span><br><span class="line"><span class="string">#5  0x00007f99b61519b8 in google::protobuf::DescriptorPool::InternalAddGeneratedFile(void const*, int) () from /usr/lib/x86_64-linux-gnu/libprotobuf.so.9</span></span><br><span class="line"><span class="string">#6  0x00007f99b618048c in google::protobuf::protobuf_AddDesc_google_2fprotobuf_2fdescriptor_2eproto() () from /usr/lib/x86_64-linux-gnu/libprotobuf.so.9</span></span><br><span class="line"><span class="string">#7  0x00007f99b7e346ba in call_init (l=&lt;optimized out&gt;, argc=argc@entry=1, argv=argv@entry=0x7ffe8743a4d8, env=env@entry=0x7ffe8743a4e8) at dl-init.c:72</span></span><br><span class="line"><span class="string">#8  0x00007f99b7e347cb in call_init (env=0x7ffe8743a4e8, argv=0x7ffe8743a4d8, argc=1, l=&lt;optimized out&gt;) at dl-init.c:30</span></span><br><span class="line"><span class="string">#9  _dl_init (main_map=0x7f99b804b168, argc=1, argv=0x7ffe8743a4d8, env=0x7ffe8743a4e8) at dl-init.c:120</span></span><br><span class="line"><span class="string">#10 0x00007f99b7e24c6a in _dl_start_user () from /lib64/ld-linux-x86-64.so.2</span></span><br><span class="line"><span class="string">#11 0x0000000000000001 in ?? ()</span></span><br><span class="line"><span class="string">#12 0x00007ffe8743c1cb in ?? ()</span></span><br><span class="line"><span class="string">#13 0x0000000000000000 in ?? ()</span></span><br><span class="line"><span class="string">(gdb) </span></span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-gccrtl/index.html">https://www.ibm.com/developerworks/cn/linux/l-gccrtl/index.html</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ulimit/">https://www.ibm.com/developerworks/cn/linux/l-cn-ulimit/</a></li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>gdb</tag>
        <tag>gcc</tag>
        <tag>g++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux小知识:apt install什么时候会出现 Do you want to continue?的提示</title>
    <url>/2022/07/23/ubuntu-when-to-ask-do-you-want-to-continue/</url>
    <content><![CDATA[<h2 id="1-一个故事"><a href="#1-一个故事" class="headerlink" title="1. 一个故事"></a>1. 一个故事</h2><p>在大约十年以前，大二或大三的夏天，<a href="https://wzhd.org/">子浩</a> 在科大西区活动中心的自习室内，给我帮忙安装Linux系统。当时他问了一个问题，用<code>apt-get install</code> 安装包时，什么时候会弹出<code>Do you want to continue?Y/[n]</code>的提示呢？我当时说应该是包大小超过限制时会有这个提示吧，但我们随即验证了这个假设并不成立，安装一个很小的包也会有这个提示。当时没有得到明确的结论。</p>
<p>这个问题时不时在脑海中想起，每次想查一下弄个清楚，但始终是没做。这样十年过去了，近日终于又想起来，通过谷歌搜索，终于发现了StackOverflow上已经又同样疑问的人提问了，而且得到了解答。至此这个小疑问算是解决了，我也不用每次念念不忘了。</p>
<p>具体原因是什么，请见下节。</p>
<span id="more"></span>


<h2 id="2-谜底揭晓"><a href="#2-谜底揭晓" class="headerlink" title="2. 谜底揭晓"></a>2. 谜底揭晓</h2><p>根据<a href="https://superuser.com/questions/287348/why-does-apt-get-sometimes-asks-for-confirmation/287357#287357">这里</a>的回答，<code>Do you want to continue</code> 的提示会在下面几种情况下出现:</p>
<ol>
<li>当除了你要安装包外，有额外的依赖包需要被安装的时候，比如你执行的是<code>sudo apt install aaa</code>, 包 <code>aaa</code> 依赖 <code>bbb</code>，因此<code>bbb</code> 也需要被安装，这时候就会有提示</li>
<li>当现有包的版本要改变，比如机器上已经安装了<code>bbb-1.0.0</code>，而安装<code>aaa</code>需要安装<code>bbb-2.0.0</code>，这时候就会有提示</li>
<li>当基础包要被移除的时候，基础包大体意思是系统运行所需的最小软件包集，删除了就会导致系统运行出问题，详细的概念可以参考<a href="https://www.debian.org/doc/debian-policy/ch-binary.html#essential-packages">这里</a></li>
</ol>
<p>常见的情况应该是第一种和第二种，第三种情况应该是只有<code>apt remove</code>才会出现。</p>
<h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><ol>
<li><a href="https://superuser.com/questions/287348/why-does-apt-get-sometimes-asks-for-confirmation/287357#287357">https://superuser.com/questions/287348/why-does-apt-get-sometimes-asks-for-confirmation/287357#287357</a></li>
<li><a href="https://unix.stackexchange.com/questions/70651/when-does-apt-get-install-ask-me-to-confirm-whether-i-want-to-continue-or-not">https://unix.stackexchange.com/questions/70651/when-does-apt-get-install-ask-me-to-confirm-whether-i-want-to-continue-or-not</a></li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>VIM 查漏补缺</title>
    <url>/2021/08/28/vim-learn/</url>
    <content><![CDATA[<p>命令<br>shift-v： 选择一整行</p>
<p><code>*</code>：向下搜索光标所在的词<br><code>#</code>：向上搜索光标所在的词</p>
<p><code>w</code>: 移动到下一个单词<br><code>b</code>: 移动到上一个单词<br><code>F</code>: 搜索当前行光标前的字母<br><code>&lt;n&gt;G</code>: 移动到第n行行首<br><code>ctrl-e</code>: 屏幕向下移动，效果同<code>j</code></p>
<p><code>dgg</code>: 删除文档开头到当前行的内容<br><code>dG</code>: 删除当前行到文档末尾的内容<br><code>ggdG</code>: 删除文档所有内容</p>
<p><code>dip</code>: 删除当前行所在段落(到下一个空行)</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>vim-plug：简洁高效的Vim插件管理工具</title>
    <url>/2019/03/12/vim-plug-intro/</url>
    <content><![CDATA[<p>今天无意中发现了这个<a href="https://github.com/junegunn/vim-plug">vim-plug</a>这个简洁又高效的Vim插件管理工具，试了下，安装插件简直没法再容易，大大减小了配置难度，对于我这种既想要Vim及插件强大的功能但又不想花费太多时间到配置上的懒人来说，Vim-plug简直就是神器了。<br>借用作者的原话，Vim-plugin有下面的优点：</p>
<blockquote>
<ol>
<li>Easier to setup: Single file. No boilerplate code required.</li>
<li>Easier to use: Concise, intuitive syntax</li>
<li>Super-fast parallel installation/update (with any of +job, +python, +python3, +ruby, or Neovim)</li>
<li>Creates shallow clones to minimize disk space usage and download time</li>
<li>On-demand loading for faster startup time</li>
<li>Can review and rollback updates</li>
<li>Branch/tag/commit support</li>
<li>Post-update hooks</li>
<li>Support for externally managed plugins</li>
</ol>
</blockquote>
<p>既然配置又简单，功能又强大，为甚不小小折腾一番，提高工作效率呢？下面我以在Vim中安装一个Python的检查器为例，对Vim-plugin的使用进行说明。</p>
<span id="more"></span>
<p>实验环境：</p>
<ol>
<li>Ubuntu 16.04</li>
<li>Python 3.5</li>
<li>Vim 8.1.946</li>
</ol>
<p>别的操作系统和Vim版本（如NeoVim）的教程请参考<a href="https://github.com/junegunn/vim-plug">官方文档</a>。</p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>安装vim-plug很简单，下载<a href="https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim">plugin.vim</a>到<code>~/.vim/autoload</code>目录即可，可以使用下面的一行命令来下载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fLo ~/.vim/<span class="built_in">autoload</span>/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure>

<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><p>vim-plu通过在<code>~/.vimrc</code>中增加<code>call plugin#begin()</code>和<code>call plugin#end()</code>来定义和管理插件，插件以<code>Plug &#39;github_url&#39;</code>形式来描述, 格式如下：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> plug#begin()</span><br><span class="line"># 完整的GitHub仓库地址</span><br><span class="line">Plug <span class="string">&#x27;https://github.com/junegunn/vim-github-dashboard.git&#x27;</span></span><br><span class="line"># 简写形式，只写username/repo即可</span><br><span class="line">Plug <span class="string">&#x27;junegunn/fzf&#x27;</span></span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br></pre></td></tr></table></figure>
<p>配置文件写好后，重新打开Vim,在命令模式下输入<code>:PlugInstall</code>即可安装配置文件中设置的插件。<br>就这样，大功告成了，下面要做的就是探索各种强大或神奇的Vim插件了，这个可以通过搜索引擎搜索或在GitHub搜索或者找博客和文章发现自己想要的。</p>
<p>下面可以<a href="https://github.com/w0rp/ale">ALE</a>这个代码检查工具为例，进行vim-plug的简单示范。</p>
<h2 id="Vim-plug-安装ALE对Python代码进行检查"><a href="#Vim-plug-安装ALE对Python代码进行检查" class="headerlink" title="Vim-plug 安装ALE对Python代码进行检查"></a>Vim-plug 安装ALE对Python代码进行检查</h2><p>找到ALE的GitHub地址：<code>https://github.com/w0rp/ale</code>，以简写形式加入到<code>.vimrc</code>中：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> plug#begin()</span><br><span class="line">Plug <span class="string">&#x27;W0rp/ale&#x27;</span></span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_linters</span> = &#123;<span class="string">&#x27;python&#x27;</span>: [<span class="string">&#x27;flake8&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>最后的<code>let</code>语句是Vimscript的语法，这行表示对Python的代码检查工具，我们采用flake8这个Python包，因此需要用pip安装下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install --user flake8</span><br></pre></td></tr></table></figure>
<p>保存<code>.vimrc</code>后，打开Vim，在命令模式下，输入<code>:PlugInstall</code>，会出现一个新panel，上面显示安装的输出，包括从GitHub下载文件等等，如果发现比较慢，请多等会…<br>等安装完成后，打开一个Python文件，你那不符合规范的地方就被标出来了，光标移动到提示的那行，底下会出现报错的原因，可以根据提示信息修改你的代码，下面是一个效果图：<br><img src="/imgs/vim-plug-ale.png" alt="ALE报错信息"></p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>总结</tag>
        <tag>Vim</tag>
        <tag>NeoVim</tag>
      </tags>
  </entry>
  <entry>
    <title>python虚拟环境管理工具venv教程</title>
    <url>/2021/01/03/venv-intro/</url>
    <content><![CDATA[<h3 id="0-概述"><a href="#0-概述" class="headerlink" title="0. 概述"></a>0. 概述</h3><p>Python有各种各样的系统包和第三方开发的包，让我们的开发变得异常容易。不过也引入了一个问题，不同代码需要的包版本可能是不一样的，所以常常回出现这种情况，为了代码B修改了依赖包的版本，代码B能work了，之前使用的代码A就没法正常工作了。因此常常需要对不同的代码设置不同的Python虚拟环境。<a href="https://docs.python.org/zh-cn/3/tutorial/venv.html">venv</a>是Python自带的虚拟环境管理工具，使用很方便，这里简单记录一下使用方法。</p>
<span id="more"></span>
<p>需要注意的是，venv 工具没法创建不同版本的python环境，也就是如果你用python3.5没法创建python3.6的虚拟环境。如果想要使用不同python版本的虚拟环境，请安装 virtual env包。</p>
<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>python3.6及以上已经默认安装，python3.5需要通过系统的包管理工具安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-venv</span><br></pre></td></tr></table></figure>
<h3 id="2-创建虚拟环境"><a href="#2-创建虚拟环境" class="headerlink" title="2. 创建虚拟环境"></a>2. 创建虚拟环境</h3><p>在<code>~/test_env</code>目录下创建虚拟环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m venv test_env</span><br></pre></td></tr></table></figure>

<h3 id="3-启用虚拟环境"><a href="#3-启用虚拟环境" class="headerlink" title="3. 启用虚拟环境"></a>3. 启用虚拟环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/test_env/bin/activate</span><br></pre></td></tr></table></figure>
<p>可以看到，命令行的提示符前面会出现括号，里面是虚拟环境名称。</p>
<p>使用<code>pip</code>安装需要的包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install tensorflow</span><br></pre></td></tr></table></figure>
<p>注意这里不需要root权限，因此无需添加<code>sudo</code>。</p>
<p>安装的包会放在<code>~/test_env/lib/pythonx.x/site-packages</code> 目录下。</p>
<h3 id="4-退出虚拟环境"><a href="#4-退出虚拟环境" class="headerlink" title="4. 退出虚拟环境"></a>4. 退出虚拟环境</h3><p>退出虚拟的python环境，在命令行执行下面的命令即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
        <tag>venv</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 文本操作总结备忘</title>
    <url>/2017/02/27/vim-text-tricks/</url>
    <content><![CDATA[<p>在学习和科研工作中，我使用Vim比较多，而且常常遇到处理文本的情况，比如删除文本中的空行，每行前面增加行号等等这些需求。我一般是直接取Google搜索，但是有的时候也不一定能快速地搜索到，所以这里我把常用到的需求和对应的Vim下的解决方法列出来，自己查起来方便些，也希望能帮助到别人。<br><img src="/imgs/vim_logo.png"></p>
<span id="more"></span>

<p>下面我按每个需求来写，每条记录中，先是需求的介绍，然后是一个具体的例子，最后是解决方式。默认的解决方式是在Vim中的命令行模式下，按<code>：</code>后再敲入命令。  </p>
<h3 id="1-删除Vim中的空行"><a href="#1-删除Vim中的空行" class="headerlink" title="1. 删除Vim中的空行"></a>1. 删除Vim中的空行</h3><p>如下面的文本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line"></span><br><span class="line">b</span><br><span class="line">b</span><br><span class="line"></span><br><span class="line">c</span><br><span class="line"></span><br><span class="line">d</span><br></pre></td></tr></table></figure>
<p>操作后空行被删去，变成下面这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure>
<p>解决方案：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:g/^$/d <span class="comment"># 删除空白行，但是不删去包含withspace的行</span></span><br><span class="line">:g/^\s*$/d <span class="comment"># 删除空白行，包括删去包含withspace的行</span></span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="http://stackoverflow.com/questions/706076/vim-delete-blank-lines">http://stackoverflow.com/questions/706076/vim-delete-blank-lines</a></p>
<h3 id="2-每行前面加行号"><a href="#2-每行前面加行号" class="headerlink" title="2. 每行前面加行号"></a>2. 每行前面加行号</h3><p>如原来文本如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<p>则操作后变成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 a</span><br><span class="line">2 b</span><br><span class="line">3 b</span><br><span class="line">4 c</span><br></pre></td></tr></table></figure>
<p>解决方案：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:%s/^/\=<span class="built_in">printf</span>(<span class="string">&#x27;%d &#x27;</span>, line(<span class="string">&#x27;.&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>注意<code>%d</code>后面的空格，如果是要用点号<code>.</code>分割行号和内容的话，则将<code>%d </code>改成<code>%d.</code>即可。  </p>
<h3 id="3-重复每行中的某个部分"><a href="#3-重复每行中的某个部分" class="headerlink" title="3. 重复每行中的某个部分"></a>3. 重复每行中的某个部分</h3><p>例如原来文本为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name1/path1 </span><br><span class="line">name2/path2</span><br><span class="line">name3/path3</span><br></pre></td></tr></table></figure>
<p>想要变成如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name1/path1 path1</span><br><span class="line">name2/path2 path2</span><br><span class="line">name3/path3 path3</span><br></pre></td></tr></table></figure>
<p>即重复path部分。<br>解决方案：<br>这里的解决方法是找到需要重复的部分的特有的模式，通过正则表达式来匹配上，然后通过增加括号来引用。这个例子中，需要重复的部分的特征是前面有个<code>/</code>，所以可以通过匹配这个<code>/</code>来找到需要重复的部分。需要注意的是，<code>/</code>和<code>（</code>，<code>）</code>都需要进行转意，即在前面增加<code>\</code>。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:0,<span class="variable">$s</span>/\/\(.\+\)/\/\1 \1/g</span><br></pre></td></tr></table></figure>


<h3 id="4-在第i行最后插入数字i"><a href="#4-在第i行最后插入数字i" class="headerlink" title="4. 在第i行最后插入数字i"></a>4. 在第i行最后插入数字i</h3><p>原来文本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user</span><br><span class="line">user</span><br><span class="line">user</span><br><span class="line">user</span><br></pre></td></tr></table></figure>
<p>期望的结果是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user1</span><br><span class="line">user2</span><br><span class="line">user3</span><br><span class="line">user4</span><br></pre></td></tr></table></figure>
<p>解决方案：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:0,<span class="variable">$s</span>/$/\=prinf(<span class="string">&#x27;%d&#x27;</span>, line(<span class="string">&#x27;.&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="5-对每行的数字进行特定的加减乘除操作"><a href="#5-对每行的数字进行特定的加减乘除操作" class="headerlink" title="5. 对每行的数字进行特定的加减乘除操作"></a>5. 对每行的数字进行特定的加减乘除操作</h3><p>例如原先文本是这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wang 23</span><br><span class="line">zhang 100</span><br><span class="line">zhao 33</span><br></pre></td></tr></table></figure>
<p>希望对每行的数字都加10,即最终的结果是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wang 33</span><br><span class="line">zhang 110</span><br><span class="line">zhao 43</span><br></pre></td></tr></table></figure>
<p>解决方案：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:%s/\d\+/\=submatch(0)+10</span><br></pre></td></tr></table></figure>
<p>如果要进行减或者乘，则将上述命令中的最后面的加号改成减号和乘号即可，<strong>对于除法，直接改乘除号不行，这里就只能通过乘以它的倒数来实现。</strong><br>参考：<a href="http://vim.1045645.n5.nabble.com/Subtract-integer-value-from-column-td1184983.html">http://vim.1045645.n5.nabble.com/Subtract-integer-value-from-column-td1184983.html</a></p>
<h3 id="6-生成与行号又特定关系的文本"><a href="#6-生成与行号又特定关系的文本" class="headerlink" title="6. 生成与行号又特定关系的文本"></a>6. 生成与行号又特定关系的文本</h3><p>例如要生成下面的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 test1_name1 100</span><br><span class="line">2 test2_name2 200</span><br><span class="line">3 test3_name3 300</span><br><span class="line">4 test4_name4 400</span><br></pre></td></tr></table></figure>
<p>解决方案：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:put=map(range(1,4), <span class="string">&#x27;printf(&quot;%d test%d_name%d %d00&quot;,v:val,v:val,v:val,v:val)&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>参考： <a href="http://vim.wikia.com/wiki/Making_a_list_of_numbers">http://vim.wikia.com/wiki/Making_a_list_of_numbers</a></p>
<h3 id="7-利用put函数生成等规律序列"><a href="#7-利用put函数生成等规律序列" class="headerlink" title="7. 利用put函数生成等规律序列"></a>7. 利用put函数生成等规律序列</h3><p>例如想要生成如下序列：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PB11210245</span><br><span class="line">PB11210246</span><br><span class="line">PB11210247</span><br><span class="line">PB11210248</span><br><span class="line">PB11210249</span><br><span class="line">PB11210250</span><br><span class="line">PB11210251</span><br><span class="line">PB11210252</span><br><span class="line">PB11210253</span><br><span class="line">PB11210254</span><br><span class="line">PB11210255</span><br></pre></td></tr></table></figure>
<p>解决方案：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">for</span> i <span class="keyword">in</span> range(245,255) | put=<span class="string">&#x27;PB11210&#x27;</span>.i |endfor</span><br></pre></td></tr></table></figure>

<h3 id="8-只替换一行中的特定序号的匹配项"><a href="#8-只替换一行中的特定序号的匹配项" class="headerlink" title="8. 只替换一行中的特定序号的匹配项"></a>8. 只替换一行中的特定序号的匹配项</h3><p>例如原来文本是这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a a a a a</span><br></pre></td></tr></table></figure>
<p>替换奇数项为<code>b</code>，变成这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a b a b a </span><br></pre></td></tr></table></figure>
<p>解决方案：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:call feedkeys(<span class="string">&quot;nynyn&quot;</span>) | s/a/b/gc</span><br></pre></td></tr></table></figure>
<p>参考：<a href="http://unix.stackexchange.com/questions/27178/vim-s-replace-first-n-g-occurrences-on-a-line">http://unix.stackexchange.com/questions/27178/vim-s-replace-first-n-g-occurrences-on-a-line</a></p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>总结</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>VNC使用总结</title>
    <url>/2017/07/28/vnc-troubeshoot/</url>
    <content><![CDATA[<p>这是一些使用VNC连接服务器的总结，这些操作都是在Ubuntu操作系统下进行的。<br><img src="https://lh6.ggpht.com/RcRUeZKNRYaCfoNGMe8Ic8OORBN-_pXgNyNtvNfSQ-5DFl-7CTuTYC2m96BbbV5IQU0=w300"></p>
<span id="more"></span>
<h3 id="VNC使用-Gnome桌面系统"><a href="#VNC使用-Gnome桌面系统" class="headerlink" title="VNC使用 Gnome桌面系统"></a>VNC使用 Gnome桌面系统</h3><p>安装Gnome桌面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install --no-install-recommends ubuntu-desktop gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal     </span><br></pre></td></tr></table></figure>
<p>然后修改你的<code>~/.vnc/xstarup</code>文件为如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following two lines for normal desktop:</span></span><br><span class="line"><span class="comment"># unset SESSION_MANAGER</span></span><br><span class="line"><span class="comment"># exec /etc/X11/xinit/xinitrc</span></span><br><span class="line"></span><br><span class="line">[ -x /etc/vnc/xstartup ] &amp;&amp; <span class="built_in">exec</span> /etc/vnc/xstartup</span><br><span class="line">[ -r <span class="variable">$HOME</span>/.Xresources ] &amp;&amp; xrdb <span class="variable">$HOME</span>/.Xresources</span><br><span class="line">xsetroot -solid grey</span><br><span class="line">vncconfig -iconic &amp;</span><br><span class="line">x-terminal-emulator -geometry 80x24+10+10 -ls -title <span class="string">&quot;<span class="variable">$VNCDESKTOP</span> Desktop&quot;</span> &amp;</span><br><span class="line">x-window-manager &amp;</span><br><span class="line"></span><br><span class="line">gnome-panel &amp;</span><br><span class="line">gnome-settings-daemon &amp;</span><br><span class="line">metacity &amp;</span><br><span class="line">nautilus -n &amp;</span><br><span class="line">gnome-terminal &amp;</span><br></pre></td></tr></table></figure>
<h3 id="使用Xfce桌面"><a href="#使用Xfce桌面" class="headerlink" title="使用Xfce桌面"></a>使用Xfce桌面</h3><p>如果要使用xfce桌面的话，通过如下命令来安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install xfce4 xfce4-goodies       </span><br></pre></td></tr></table></figure>
<p>然后将<code>~/.vnc/xstartup</code>改为如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">xrdb <span class="variable">$HOME</span>/.Xresources</span><br><span class="line">startxfce4 &amp;</span><br></pre></td></tr></table></figure>
<h3 id="打开gnome-terminal显示“Input-Output-Error”"><a href="#打开gnome-terminal显示“Input-Output-Error”" class="headerlink" title="打开gnome-terminal显示“Input/Output Error”"></a>打开gnome-terminal显示“Input/Output Error”</h3><p>从<a href="https://bbs.archlinux.org/viewtopic.php?id=218510">这里</a>了解到，可以使用<code>journalctl -xe</code>查看报错，我在查看是发现下面的错误信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">org.gnome.Terminal[4882]: Non UTF-8 locale (ANSI_X3.4-1968) is not supported!</span><br></pre></td></tr></table></figure>
<p>从这里看到，应该是locale设置不对然后导致的错误，即Gnome-Terminal只支持UTF-8的编码。所以这里只需要将locale设置合适即可。有下面两种方法：</p>
<h4 id="1-修改-bashrc或-zshrc"><a href="#1-修改-bashrc或-zshrc" class="headerlink" title="1. 修改.bashrc或.zshrc"></a>1. 修改.bashrc或.zshrc</h4><p>在.bashrc或.zshrc里面增加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set LC</span></span><br><span class="line">LANG=en_US.UTF-8</span><br><span class="line">LANGUAGE=</span><br><span class="line">LC_CTYPE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_NUMERIC=zh_CN.UTF-8</span><br><span class="line">LC_TIME=zh_CN.UTF-8</span><br><span class="line">LC_COLLATE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MONETARY=zh_CN.UTF-8</span><br><span class="line">LC_MESSAGES=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_PAPER=zh_CN.UTF-8</span><br><span class="line">LC_NAME=zh_CN.UTF-8</span><br><span class="line">LC_ADDRESS=zh_CN.UTF-8</span><br><span class="line">LC_TELEPHONE=zh_CN.UTF-8</span><br><span class="line">LC_MEASUREMENT=zh_CN.UTF-8</span><br><span class="line">LC_IDENTIFICATION=zh_CN.UTF-8</span><br><span class="line">LC_ALL=</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LANG</span><br><span class="line"><span class="built_in">export</span> LANGUAGE=</span><br><span class="line"><span class="built_in">export</span> LC_CTYPE</span><br><span class="line"><span class="built_in">export</span> LC_NUMERIC</span><br><span class="line"><span class="built_in">export</span> LC_TIME</span><br><span class="line"><span class="built_in">export</span> LC_COLLATE</span><br><span class="line"><span class="built_in">export</span> LC_MONETARY</span><br><span class="line"><span class="built_in">export</span> LC_MESSAGES</span><br><span class="line"><span class="built_in">export</span> LC_PAPER</span><br><span class="line"><span class="built_in">export</span> LC_NAME</span><br><span class="line"><span class="built_in">export</span> LC_ADDRESS</span><br><span class="line"><span class="built_in">export</span> LC_TELEPHONE</span><br><span class="line"><span class="built_in">export</span> LC_MEASUREMENT</span><br><span class="line"><span class="built_in">export</span> LC_IDENTIFICATION</span><br><span class="line"><span class="built_in">export</span> LC_ALL=</span><br></pre></td></tr></table></figure>
<p>然后source下，删除之前的VNC会话，重新建立会话，查看是否正确。  </p>
<h4 id="2-修改系统的locale设置"><a href="#2-修改系统的locale设置" class="headerlink" title="2. 修改系统的locale设置"></a>2. 修改系统的locale设置</h4><p>如果你是管理员的话，可以修改系统的locale设置，使得所有用户都能正确地使用VNC。具体的代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-locale LANG=en_US.UTF-8</span><br><span class="line">sudo update-locale LANGUAGE=</span><br><span class="line">sudo update-locale LC_CTYPE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">sudo update-locale LC_NUMERIC=zh_CN.UTF-8</span><br><span class="line">sudo update-locale LC_TIME=zh_CN.UTF-8</span><br><span class="line">sudo update-locale LC_COLLATE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">sudo update-locale LC_MONETARY=zh_CN.UTF-8</span><br><span class="line">sudo update-locale LC_MESSAGES=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">sudo update-locale LC_PAPER=zh_CN.UTF-8</span><br><span class="line">sudo update-locale LC_NAME=zh_CN.UTF-8</span><br><span class="line">sudo update-locale LC_ADDRESS=zh_CN.UTF-8</span><br><span class="line">sudo update-locale LC_TELEPHONE=zh_CN.UTF-8</span><br><span class="line">sudo update-locale LC_MEASUREMENT=zh_CN.UTF-8</span><br><span class="line">sudo update-locale LC_IDENTIFICATION=zh_CN.UTF-8</span><br><span class="line">sudo update-locale LC_ALL=</span><br></pre></td></tr></table></figure>
<p>这样操作后同样需要重新建立VNC会话。  </p>
<h3 id="VNC连过去后，命令行字体挤在一起，看不清楚"><a href="#VNC连过去后，命令行字体挤在一起，看不清楚" class="headerlink" title="VNC连过去后，命令行字体挤在一起，看不清楚"></a>VNC连过去后，命令行字体挤在一起，看不清楚</h3><p>这个原因也是因为locale设置的不对，设置了中文字体导致的问题，所以同样地，按照上面所说的更改locale的方法，更新locale即可。 </p>
<h3 id="VNC中，按Tab不自动补全，而是跳转到别的Terminal窗口"><a href="#VNC中，按Tab不自动补全，而是跳转到别的Terminal窗口" class="headerlink" title="VNC中，按Tab不自动补全，而是跳转到别的Terminal窗口"></a>VNC中，按Tab不自动补全，而是跳转到别的Terminal窗口</h3><p>这个问题的解决方法是实验室师兄提供的，打开<code>~/.config/xfce4/xfce-perchaannel-xml/xfce4-keyboard-shortcuts.xml</code>文件，将其中的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;<span class="symbol">&amp;lt;</span>Super<span class="symbol">&amp;gt;</span>Tab&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">value</span>=<span class="string">&quot;switch_window_key&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;<span class="symbol">&amp;lt;</span>Super<span class="symbol">&amp;gt;</span>Tab&quot;</span> <span class="attr">type</span>=<span class="string">&quot;empty&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后用<code>vncserver -kill :portid</code> kill掉连接，再用<code>vncserver -geometry 1920x1080 :portid</code>来新建连接。  </p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>总结</tag>
        <tag>Ubuntu</tag>
        <tag>Vnc</tag>
        <tag>Xfce</tag>
        <tag>Gnome</tag>
      </tags>
  </entry>
  <entry>
    <title>VitPose 论文阅读</title>
    <url>/2022/06/11/vitpose-intro/</url>
    <content><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>VitPose是最近出来的一篇用Transformer结构做人体2D关键点估计的论文，采用比较简单的Transformer结构就能在MS COCO 测试集上取得比较好的结果，挺吸引人的。论文不长，这周末读了一遍，感觉值得借鉴的地方挺多，这里我用自己的语言描述论文的细节，同时把自己的一些疑惑和思考写下来，欢迎讨论交流。</p>
<p>论文标题: ViTPose: Simple Vision Transformer Baselines for Human Pose Estimation<br>论文地址：<a href="https://arxiv.org/abs/2204.12484">https://arxiv.org/abs/2204.12484</a><br>代码地址：<a href="https://github.com/ViTAE-Transformer/ViTPose">https://github.com/ViTAE-Transformer/ViTPose</a></p>
<p>注：本文中框图和表格均来自原论文。</p>
<span id="more"></span>
<h2 id="2-摘要和引入"><a href="#2-摘要和引入" class="headerlink" title="2. 摘要和引入"></a>2. 摘要和引入</h2><p>Vison Transformer 在视觉识别任务中效果优秀，在识别但还没有人在姿态估计任务上验证这种结构的有效性。这篇论文提出了名为VitPose的用于姿态估计的Transformer网络，使用普通ViT结构作为Backbone，结合一个轻量级的Decoder，就能在MS COCO 关键点估计bechmark上达到SOTA。</p>
<h2 id="3-继续阅读前的几个疑问"><a href="#3-继续阅读前的几个疑问" class="headerlink" title="3. 继续阅读前的几个疑问"></a>3. 继续阅读前的几个疑问</h2><p>读完摘要和Introduction部分，我决定继续精读这篇论文，因此在进一步阅读前，为了提升对论文的理解程度，我想出了下面的问题，希望在读完剩余部分的时候，这些问题都能得到回答:</p>
<ol>
<li>如何确定SOTA结果中MAE和Transformer网络结构的贡献?</li>
<li>100M到1B参数的变化是通过哪个模块的变化调节的?</li>
<li>是基于Heatmap还是Regression的思路?</li>
<li>只针对单人场景还是多人场景也OK?</li>
<li>速度如何？</li>
</ol>
<p>带着这些疑问，咱们继续往下看。</p>
<h2 id="4-实现细节"><a href="#4-实现细节" class="headerlink" title="4. 实现细节"></a>4. 实现细节</h2><h3 id="4-1-整体结构"><a href="#4-1-整体结构" class="headerlink" title="4.1 整体结构"></a>4.1 整体结构</h3><p>网络结构设计比较简单，整体为采用ViT backbone + decoder的形式。</p>
<p><img src="/imgs/vitpose/vitpose_framework.jpg" alt="vitpose framework"><br>backbone分为patch embedding和多个transfomer模块。patch embedding将图像分为dxd的patch块。</p>
<p>而每个transfomer层包含 multi-head self-attention(MHSA) 与 feed-forward network (FFN) 模块。多个transfomer层堆叠，构成了backbone。</p>
<p>backbone根据计算量大小，选用了Vit-B, ViT-L，ViT-H[3]以及ViTAE-G[4]。</p>
<h4 id="4-1-1-decoder-选择"><a href="#4-1-1-decoder-选择" class="headerlink" title="4.1.1 decoder 选择"></a>4.1.1 decoder 选择</h4><p>由于backbone采用ViT现有的结构，因此在decoder的选取上，作者选择了两种结构进行了对比:</p>
<ol>
<li>经典Decoder结构，两个Deconv（+BN+ReLU) + 1个1x1 conv，每个deconv上采样2倍，最终输出feature map大小为输入的1/4倍<br><img src="/imgs/vitpose/vitpose_classic_decoder.jpg"></li>
<li>双线性差值上采样4倍，然后是ReLU+3x3conv，不过论文中公式与描述不符，ReLU在双线性上采样之前，需要看代码实现具体是哪一种。<br><img src="/imgs/vitpose/vitpose_simple_decoder.jpg"></li>
</ol>
<p>方案1非线性更高，因此在CNN的结构中使用比较多。而这篇论文也验证了由于Transformer强大的学习能力，即使像方案2这样的的简单decoder，也能达到很高的精度：</p>
<p><img src="/imgs/vitpose/vitpose_t1.png"><br>可以看到，ResNet系列在方案1上的结果远高于方案2，说明CNN结构的学习能力需要强有力的decoder来进一步加强，而VitPose结构则不需要，这需要归功于ViT结构的强大学习能力</p>
<p>如果光讲结构确实比较单一，所以论文也在好几个方面验证了ViTPose的优良特性。</p>
<h3 id="4-2-灵活性"><a href="#4-2-灵活性" class="headerlink" title="4.2 灵活性"></a>4.2 灵活性</h3><h4 id="4-2-1-预训练上的灵活性"><a href="#4-2-1-预训练上的灵活性" class="headerlink" title="4.2.1 预训练上的灵活性"></a>4.2.1 预训练上的灵活性</h4><p>一般情况下backbone都需要ImageNet上预训练。这篇论文提出了三种预训练方案：</p>
<ol>
<li>采用ImagNet预训练分类任务，比较经典的方法，数据集总共1M图片</li>
<li>采用MS COCO 预训练MAE任务，将75%的patch随机的mask掉，然后让网络学习恢复这些patch，数据集共150K图片</li>
<li>任务框架同方案2，不过数据集采用MS COCO + AI Challenger，共500K图片</li>
</ol>
<p>具体实现是将MS COCO和AI Challenger 中的单个人体crop出来，与ImageNet单个object的数据分布保持一致。然后在3个数据集上分别训练1600个epoch，再在MS COCO 上fine tune 210个epoch。</p>
<p>这个训练周期确实有点出乎意料地长……</p>
<p>采用VitPose-B结构，在MS COCO val set上，三种预训练方案的结果如下:<br><img src="/imgs/vitpose/vitpose_t2.jpg"><br>可以看到使用MS COCO + AI Challenger，在只有一半数据量的情况下，可以达到比ImageNet更好的效果。</p>
<h4 id="4-2-2-分辨率上的灵活性"><a href="#4-2-2-分辨率上的灵活性" class="headerlink" title="4.2.2 分辨率上的灵活性"></a>4.2.2 分辨率上的灵活性</h4><p>ViTPose可以通过使用更大的输出尺寸来训练，也可以通过减小backbone中的下采样来构造更大尺度的feature map，这两种操作都能提高精度，具体如下：<br>更大尺寸的输入：直接缩放原始图像，得到对应大小的输入<br>更大尺寸的特征：降低采样倍数，修改patch层的stride参数，</p>
<p>另外提一下，这个特性应该是CNN和ViT结构都通用的。</p>
<p>结果如下：<br><img src="/imgs/vitpose/vitpose_t3.jpg"><br>可以看到分辨率越大结果越高</p>
<h4 id="4-2-3-Attention种类上的灵活性"><a href="#4-2-3-Attention种类上的灵活性" class="headerlink" title="4.2.3 Attention种类上的灵活性"></a>4.2.3 Attention种类上的灵活性</h4><p>众所周知，Transformer中的Attention的计算量是Feature map 尺寸的平方，因此是很大的，而且显存占用也很大。因此作者用了Shift Window 和 Pooling Window 两种方案来缓解这个问题，结果如下：</p>
<p><img src="/imgs/vitpose/vitpose_t4.jpg"><br>单纯的网络显存占用太多，因此不得不采用fp16才能训起来……</p>
<h4 id="4-2-4-finetune的灵活性"><a href="#4-2-4-finetune的灵活性" class="headerlink" title="4.2.4 finetune的灵活性"></a>4.2.4 finetune的灵活性</h4><p>与NLP任务中一样，作者验证了只固定MHSA模块的参数，精度下降不多，而固定FFN的参数，则精度下降明显，因此作者认为MHSA更偏向<strong>与任务无关</strong>，而FFN则更具体任务关系更密切。</p>
<p><img src="/imgs/vitpose/vitpose_t5.jpg"></p>
<h4 id="4-2-5-多任务上的灵活性"><a href="#4-2-5-多任务上的灵活性" class="headerlink" title="4.2.5 多任务上的灵活性"></a>4.2.5 多任务上的灵活性</h4><p>作者还尝试了这样一个实验，采用同一个backbone，多个decoder，每个decoder对应一个数据集的任务，实验验证一次训练，多个数据集上的结果都能比较好，且比单个数据集精度有提升:</p>
<p><img src="/imgs/vitpose/vitpose_t6.jpg"></p>
<h3 id="4-3-蒸馏"><a href="#4-3-蒸馏" class="headerlink" title="4.3 蒸馏"></a>4.3 蒸馏</h3><p>这篇论文比较有意思的一个点是提出了一个基于Transformer的蒸馏方法，与常见的用loss来监督Teacher和Student网络的思路不太一样，具体如下:</p>
<ol>
<li>在大模型的patch embedding后的visual token后面增加一个知识token模块，并进行随机初始化</li>
<li>固定大模型的参数，只训练知识token模块</li>
<li>将训练好的知识token模块接到小模型的visual token后面，且固定知识token的参数，只训练小模型的其他参数</li>
</ol>
<p>通过这样的流程，将所有的知识都融合到了知识token模块的参数里面，并且从大模型传递到小模型，感觉理解起来也是很直观很有画面感。</p>
<p>结果如下：</p>
<p><img src="/imgs/vitpose/vitpose_t7.jpg"></p>
<h3 id="4-4-与SOTA对比"><a href="#4-4-与SOTA对比" class="headerlink" title="4.4 与SOTA对比"></a>4.4 与SOTA对比</h3><p> 实现细节中作者说明了，采用姿态估计中Top-Down的方案，即先用一个检测器检测出单个人体框，然后对人体框进行姿态估计。本文中方案其实是后面这一步。第一步的检测器在COCO的val集上用的是SimpleBaseline[1]，而在最后的COCO test-dev集上，与SOTA方案的比较实验中，采用了Bigdet[2]。</p>
<p>SOTA结果是在576x432输入，采用1B参数量的ViTAE-G作为backbone，使用MS COCO + AI Challenger训练的情况下获得的，具体如下：<br><img src="/imgs/vitpose/vitpose_t8.jpg"><br><img src="/imgs/vitpose/vitpose_t8.jpg"></p>
<h2 id="5-几个疑问的答案："><a href="#5-几个疑问的答案：" class="headerlink" title="5 几个疑问的答案："></a>5 几个疑问的答案：</h2><p>相信经过上面的细节描述，我们对开头的几个疑问中的一些问题已经有明确的答案了</p>
<ol>
<li>如何确定SOTA结果中MAE和Transformer网络结构的贡献? -&gt; </li>
<li>100M到1B参数的变化是通过哪个模块的变化调节的? -&gt; 通过修改backbone的结构来控制参数大小 </li>
<li>是基于Heatmap还是Regression的思路? -&gt; Heatmap</li>
<li>只针对单人场景还是多人场景也OK? -&gt; 只针对单人场景，且需要额外的前置detector</li>
<li>速度如何？ -&gt; 速度应该是比较慢的，训练周期比较长，网络比较大</li>
</ol>
<h2 id="6-思考"><a href="#6-思考" class="headerlink" title="6 思考"></a>6 思考</h2><ol>
<li>采用强大的Transformer结构，之前的很多trick都可以省略，包括skip-connection 等</li>
<li>Knowledge Token的思路很新颖挺有意思的，感觉可以用在所有的Transformer蒸馏里面</li>
<li>虽然论文强调只用了一个普通的ViT结构来做姿态估计，但是为了达到较高的精度，后面还是挺多提点的实验</li>
</ol>
<h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h2><p>[1] SimpleBaseline: <a href="https://arxiv.org/abs/1804.06208">https://arxiv.org/abs/1804.06208</a><br>[2] Bigdetection: A large-scale benchmark for improved object detector pre-training<br>[3] An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale<br>[4] Vitaev2: Vision transformer advanced by exploring inductive bias for image recognition and beyond</p>
]]></content>
      <tags>
        <tag>Computer Vision</tag>
        <tag>论文阅读</tag>
        <tag>Paper</tag>
        <tag>Pose Estimation</tag>
        <tag>ViT</tag>
        <tag>Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Subsystem for Linux 切换网络脚本</title>
    <url>/2020/03/04/wsl-dnc-sync/</url>
    <content><![CDATA[<p>在启用/关闭 VPN 的时候， WSL 里面，有时候网络会无法连接。根据<a href="https://github.com/microsoft/WSL/issues/416">这里</a>的讨论，这是由于 WSL 在网络变化的时候，未能正确解析 DNS 导致的。网友在这里也给出了一个解决办法，试了以后是可以的，因此记录下来。</p>
<span id="more"></span>
<p>在 WSL 的命令行执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">wget https://gist.github.com/matthiassb/9c8162d2564777a70e3ae3cbee7d2e95/raw/b204a9faa2b4c8d58df283ddc356086333e43408/dns-sync.sh </span><br><span class="line">sudo mv dns-sync.sh /etc/init.d/dns-sync.sh</span><br><span class="line">sudo chmod +x /etc/init.d/dns-sync.sh</span><br><span class="line">unlink /etc/resolv.conf</span><br></pre></td></tr></table></figure>
<p>如果 Gist 访问不了的话，可以从<a href="https://raw.githubusercontent.com/vra/wsl-dns-sync/master/dns-sync.sh">这里</a>下载我fork的一个版本。详细讨论可以参考<a href="https://gist.github.com/matthiassb/9c8162d2564777a70e3ae3cbee7d2e95">这里</a>的讨论。</p>
<p>注意：每次切换网络时需要手动执行最后的一句命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service dns-sync.sh start</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<ol>
<li><a href="https://gist.github.com/matthiassb/9c8162d2564777a70e3ae3cbee7d2e95">https://gist.github.com/matthiassb/9c8162d2564777a70e3ae3cbee7d2e95</a></li>
<li><a href="https://github.com/microsoft/WSL/issues/416">https://github.com/microsoft/WSL/issues/416</a></li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
        <tag>WSL</tag>
        <tag>Trick</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次赶论文记录</title>
    <url>/2017/03/19/write-paper-iccv-2017/</url>
    <content><![CDATA[<p>昨天早上八点，在通宵赶完ICCV 2017的论文后，我和孙可走下科技楼，和一起赶论文的张凯约好去食堂一楼吃早饭。<br>这次通宵赶论文的经历对我影响很大，触动最大的是周老师的勤奋，一丝不苟的精神和对科研的激情，反照出我自身的问题。我想趁着这个周末写下这段时间的经历，期望勉励自己，向周老师看齐，做一个能做好事情的人。  </p>
<span id="more"></span>

<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>在上学期期末总结的时候，周老师在听了我的汇报后，给了我一些改进的建议，并且让我明确目标：赶2017年的ICCV 会议。我当时挺担忧的，因为ICCV deadline是3月17日，而春节回来到学校已经是2月13日了，只有一个月的时间，而且实验结果还很差，论文也没有任何头绪。而且ICCV是Computer Vison领域的三大顶会之一，我担心我的实验结果做不到最好，投了会议命中率也太小了。不过在会上我还是答应周老师，努力赶ICCV。  </p>
<h3 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h3><p>春节在家的时候，我本来想连学校的服务器，再抓紧做一做实验。但是在家事情太多，自己也没法完全静下来做实验，刚写几行代码就又去干别的事情去了，所以也没有做出啥东西。这样很快春节假期就结束了。  </p>
<p>开学到了学校，已经是2月13号，周老师和李老师都很忙，有几次想去找他们让他们给一些思路，最后也没有去找。我们两周开一次组会，我们组新学期的第一次组会在2月23号，下一次组会是3月9日，然后再过一周论文就截止了！所以我必须在这两次组会上和老师讨论好实验的内容，细节以及论文的写法等等，时间还是比较紧张的。  </p>
<p>在2月23号的组会上，我跟老师提了下还在跑论文的实验，希望将ResNet加入到我们的结构里面来。老师也没有过多的提论文的事情，让我继续做实验。我又讲了另外一些方法，包括VGG 16年CVPR的论文的代码，还有Dynamic Image Network。  </p>
<p>组会结束后我有点迷茫，在想是不是老师不建议我赶这个会议了，毕竟时间已经不多了，只有3周时间就到deadline了，而且实验结果并不好。不过我还是继续做实验，将ResNet网络结构增加到RstarCNN的代码里面来。因为RstarCNN里面的caffe版本比较旧，而ResNet版本的caffe已经经过了较大幅度的改动，所以增加新的层进来的时候总是有问题。搞了好几天，最后还是没能成功地运行起来，没有办法只能放在VGG上面的实验结果了。  </p>
<p>在3月9号的组会之前，我大概跑完了实验，开始动笔写论文。在组会上，我给老师说论文已经开始写了，实验结果还没有大的提升。老师还是鼓励我先争取把论文写好，赶上每个deadline，对自己定一个目标，然后完成它。  </p>
<p>开完组会后，我就开始全力以赴地写论文了，每天只干一件事情，就是写论文。<br>3月11日是我24岁生日，彤彤怕打扰我写论文，本来不想来，但是我很想和她一起度过24岁这个很有纪念意义的生日。最后彤彤在周五晚上过来，周六我们去看了电影&lt;《金刚狼3》，去吃了花千骨，还吃了好吃的生日蛋糕。周日我们去拍了花，去打了羽毛球，然后下午四点多彤彤就坐车回北京了。我接着回实验室写论文。  </p>
<h3 id="写论文"><a href="#写论文" class="headerlink" title="写论文"></a>写论文</h3><p>3月13日， 周一，大概晚上9点多的时候，周老师问我论文写怎么样了。那会其实我只写了四页多，我不好再拖了，就给老师说写差不多了，争取今晚写完。于是那晚我硬着头皮写，最后写到了近7页，大概在14日凌晨2点的时候，我把这个初稿发到了老师邮箱，然后回宿舍。那天正好是农历正月十六，晚上天气很好，有点冷，回去的路上一个人也没有。我走着，感觉从高中以来，一直没有一天像今晚这么踏实。多少的日子里，我都是在混沌中度过的，渐渐地变得懒惰，不愿思考，不愿push自己，安于享乐。只有那晚，我感觉到没有虚度，所以唯有努力和奋斗才能给人内心的安稳吧。  </p>
<p>第二天白天，周老师把我的论文初稿交给他在美国的师弟张岐林修改，因为他实在是太忙了。下午的时候，我正趴在桌子上睡会，周老师来找我，让我把latex发给他的师弟，因为我的论文语法错误等太多了，直接在PDF文件上面修改都写不下了。于是我把latex发过去，自己看岐林师兄发过来的修改过的PDF，密密麻麻的修改和批注，我顿时觉得好惭愧，没有好好检查，麻烦别人了。于是我又在检查自己的初稿。  </p>
<p>3月15日下午16：35，周老师将岐林师兄修改过的论文发了过来，然后我在他的修改的基础上，把自己修改的部分合并了。我还在继续画表格和图片。  </p>
<p>3月16日上午9点，周老师拉了个微信群，把我和岐林师兄加了进去，师兄说一会和我打电话，沟通下论文中的问题，看他理解对不对。10点左右的时候师兄打了国际电话过来，我们讨论了一些论文中的问题，当师兄问我的时候，我发现有些细节的地方我也理解不是很到位，所以觉得很不好，感觉自己平时太偷懒了，没有完全理清论文的思路。师兄讨论完后，我就回去继续修改了。而且跑的实验有个问题搞错了，得重新跑，不知道时间还够不够。  </p>
<p>3月17日凌晨1点左右，我准备回去了。在一楼的时候，岐林师兄给我发了条微信消息，问我还醒着吗，打电话沟通下论文的细节。我于是坐电梯上去，到实验室门口和师兄通了电话。之后在1：50左右，我把自己修改和师兄修改好的版本合并后发给了周老师和岐林师兄。于是我就回去了。在路上，1：51的时候，周老师发QQ问我，论文里面的图分辨率怎么那么低，是不是使用了截屏的图片。我回想了下确实是用了截屏图片。周老师说不能使用截屏图片，否则在Latex中图片的分辨率会降很多。我记得老师之前也强调过这个事情，这次居然也犯了这个错误，觉得很惭愧。而且更让我感动的是，这么晚了周老师还看了我的论文，而且精益求精的精神，严谨的治学态度也让我暗暗钦佩。  </p>
<h3 id="一夜的工作"><a href="#一夜的工作" class="headerlink" title="一夜的工作"></a>一夜的工作</h3><p>3月17日早上起来，距离论文的deadline只有24个小时了。我又增加了一些对比实验，修改了框架图，增加了一个图，丰富了实验结果分析的部分，使得论文基本上到了8页。吃完晚饭后，我回了趟宿舍，稍微睡了会，准备晚上通宵。8点左右的时候回到实验室，买了好些吃的，准备晚上饿了吃。11点的时候，周老师发了微信消息过来，说是我们要坚持到明早八点，一遍一遍地改，改完后发给他和岐林师兄来改。本来我还有些犹豫要不要半夜两三点就回去，但老师的消息给了我一剂定心丸，让我静下心来，系统地对论文进行修改。当时实验室有我，孙可和孙韶言师兄在赶ICCV，蒲俊福和刘一丁也陪我们，给孙可的论文提意见。<br>2：50的时候，我把最新的修改的版本发给了周老师和岐林师兄。岐林师兄因为那天抽不出时间来，所以只有我和周老师在改。周老师看到我的论文后，先让我改了一些格式上的问题，包括下面这些：</p>
<ol>
<li>Reference 部分，会议写缩写，期刊写全名，而且论文标题和会议期刊名称除了虚词别的单词都必须首字母大写</li>
<li>Reference 部分， 需要冗余的信息，如年份只出现一次</li>
<li>论文中各级标题除了虚词都必须首字母大写</li>
<li>各级标题必须是名词或者名词短语，如“Combine” 就应该改成“Combination” 或者“Combining”</li>
<li>句号后面一定要有一个空格</li>
<li>括号前后都要加空格</li>
<li>图表的标题都不需要加粗</li>
</ol>
<p>这些内容我在修改完后，4：37的时候，周老师把他修改过的版本也发过来了。我看了下论文，好多语法错误，格式错误，周老师都一一标注出来了，我在他的批注的帮助下，把这些错误一一都修改了。因为当时他还在给黄杰师兄，孙师兄和张凯改论文，所以论文具体方法老师就没时间改了，我自己改了一些地方，最后由于实验跑的结果很差，我就把在一个数据集上的结果都删去了，后来想起来没给老师说，不知道老师知道后会不会责怪我。  </p>
<p>1点多的时候，蒲俊福就先回去了。大概6点多的时候，丁丁也回去了，孙师兄也休息了，我和孙可还在奋力地修改。我在微信上问了张凯，他也还在修改论文中。  </p>
<p>6：10的时候，我问周老师论文作者写谁，老师说写我，他和李老师即可。6：20周老师说改完到时候提交即可，让我提交完好好休息下。其实在2点多的时候我就在网站上提交了一个版本，6点多的时候又提交了一份，最后在7：40的时候，又修改了一些错误，把最后的版本交了上去。  </p>
<p>8点，我和孙可和张凯去食堂一楼吃了早饭，没想到3月的清晨居然这么冷。看朋友圈，才知道庆哥也在赶ICCV， 能和这些厉害的小伙伴为同一件事情奋斗，感觉真的很棒。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在整个准备这篇论文的时候，感触最深的是周老师对我们的认真负责，对科研的严谨和热情，身体力行，给我一个一直值得学习的榜样。虽然以前也知道周老师很有热情，但当老师说一起坚持到早上八点的时候，还是很诧异，很佩服老师。通过这次赶论文，知道了原来我一直都没有太努力，做事没有太大的热情，做事情没有内心的驱动力，这些坏习惯以后需要改掉。<br>此外还要感谢实验室的小伙伴对我论文思路的启发，他们会对我论文的思路都进行修正，给了我很多有用的建议。<br>还有感谢彤彤这段时间以来全力的支持，因为事情太多，总是没理她，她也毫无怨言，默默地支持我，督促我，鼓励我，让我能做完一个比较好的尝试，提交最后的论文。  </p>
]]></content>
      <tags>
        <tag>总结</tag>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Subsystem for Linux 下 SSH permission error 解决</title>
    <url>/2020/03/04/wsl-ssh-permission-error/</url>
    <content><![CDATA[<p>在 Windows SubSystem for Linux (WSL) 下，使用 <code>ssh</code> 命令的时候报下面的错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Bad owner or permissions on /home/yunfeng/.ssh/config</span><br></pre></td></tr></table></figure>
<p>搜索了一下，发现修改下 <code>config</code> 文件的权限就可以了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 600 ~/.ssh/config</span><br></pre></td></tr></table></figure>

<p>参考</p>
<ol>
<li><a href="https://github.com/Microsoft/WSL/issues/483">https://github.com/Microsoft/WSL/issues/483</a></li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
        <tag>SSH</tag>
        <tag>WSL</tag>
        <tag>Trick</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu上安装Python3.7</title>
    <url>/2019/05/03/ubuntu-install-python3-6-python3-7/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在有些情况下，如安装某个比较Cool的工具的时候，需要用到Python3.6+。这时候，可以选择从<a href="https://www.python.org/">Python官网</a>下载源代码，然后编译。不过编译可能会因为各种各样的问题而出错。对于只是想<strong>安装</strong>高版本的Python以便来使用Cool的工具的我来说，<br>从头一步步地解决这些编译问题，并不是我想要的，因此能不能有一种直接<code>apt install</code>来安装Python的途径呢？答案是Yes，下面详述（也就三条命令）。</p>
<span id="more"></span>

<p>为了使用<code>add-apt-repository</code>，需要先安装下面的包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br></pre></td></tr></table></figure>

<p>在Ubuntu的<a href="https://launchpad.net/">包管理网站</a>上，有一个专门的PPA，维护了从Python2.3到Python3.8的二进制包，可以直接增加PPA源后安装Python:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:deadsnakes/ppa</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y python3.7</span><br></pre></td></tr></table></figure>
<p>如果想要安装别的版本的Python，将上面的<code>3.7</code>改成对应的版本号即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install -y python3.6</span><br></pre></td></tr></table></figure>

<p>安装好对应的版本后，可以配合<a href="https://docs.pipenv.org/en/latest/">Pipenv</a>一起使用，实现多版本Python的管理和包安装。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://askubuntu.com/questions/865554/how-do-i-install-python-3-6-using-apt-get">https://askubuntu.com/questions/865554/how-do-i-install-python-3-6-using-apt-get</a></li>
<li><a href="https://launchpad.net/~deadsnakes/+archive/ubuntu/ppa">https://launchpad.net/~deadsnakes/+archive/ubuntu/ppa</a></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
        <tag>总结</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
</search>
