<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yunfeng&#39;s Simple Blog</title>
  
  <subtitle>Love, Life, Linux</subtitle>
  <link href="http://vra.github.io/atom.xml" rel="self"/>
  
  <link href="http://vra.github.io/"/>
  <updated>2022-06-24T15:51:04.865Z</updated>
  <id>http://vra.github.io/</id>
  
  <author>
    <name>Yunfeng Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>matplotlibt图像转OpenCV图像</title>
    <link href="http://vra.github.io/2022/06/24/matplotlib-convert-opencv/"/>
    <id>http://vra.github.io/2022/06/24/matplotlib-convert-opencv/</id>
    <published>2022-06-24T15:14:44.000Z</published>
    <updated>2022-06-24T15:51:04.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>有时候，我们需要使用Matplotlib库强大的绘图函数来在numpy.ndarray格式的图像上进行一些可视化，比如关键点绘制，投影点绘制。绘制完后，还需要把matplotlib的figure对象转换为numpy.ndarray 格式的对象，方便和原图进行比较。有时候为了可视化的美观，需要验证保证转换后的图像与原始图像大小一致。这里记录一下操作的流程，以及一些常遇到的问题。</p><span id="more"></span><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h2><p>核心原理是利用matplotlib.pyplot的<code>imshow</code>函数来显示np.ndarray格式的图像，然后进行可视化绘制，再通过matplotlib.pyplot.figure.canvas的<code>tostring_rgb</code>函数来将图像转换为string，在用numpy的<code>fromstring</code>函数将string转换为np.ndarray，即为我们所求。</p><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 numpy.ndarray格式的图像</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;/path/to/my.jpg&#x27;</span>)</span><br><span class="line">h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建figure对象</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">plt.imshow(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加函数绘制代码</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制画布</span></span><br><span class="line">fig.canvas.draw()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换plt canvas为string，再导入numpy</span></span><br><span class="line">vis_img = np.fromstring(fig.canvas.tostring_rgb(), dtype=np.uint8)</span><br><span class="line"><span class="comment"># 设置numpy数组大小为图像大小</span></span><br><span class="line">vis_img.shape = (h, w, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">plt.close()</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;/path/to/vis_img.jpg&#x27;</span>, vis_img)</span><br></pre></td></tr></table></figure><h2 id="3-几个关键点"><a href="#3-几个关键点" class="headerlink" title="3. 几个关键点"></a>3. 几个关键点</h2><p>上述代码是简单的原理，但要达到保存的<code>vis_img</code>对象与<code>img</code>对象完全等大小，还需要设置figure对象的size，具体实现是通过<code>set_size_inches</code>函数，传入原始图像的宽和高除以dpi的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">fig.set_size_inches(w/fig.dpi, h/fig.dpi)</span><br></pre></td></tr></table></figure><p>注意是宽在前面，高在后面。</p><p>还有一个很关键的点是需要去除matplotlib设置的padding白边，否则在相同尺寸的情况下，包含白边显得里面的内容变小了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.gca().set_position((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>为了不显示横纵坐标轴，需要添加<code>plt.axis(&#39;off&#39;)</code>语句。</p><p>为了能在无GUI的环境（比如SSH连到的Linux 服务器）这个脚本也能正常工作，需要采用<code>Agg</code> 这个backend：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;Agg&#x27;</span>)</span><br></pre></td></tr></table></figure><p>插句题外话，<code>Agg</code>这个backend原来是来自于<a href="http://agg.sourceforge.net/antigrain.com/">Anti-Grain Geometry</a> 2D渲染库，2002年开始开发，距今已有20年历史了，Respect。</p><p>此外由于matploltlib的<code>imshow</code>需要RGB格式的图像，而OpenCV图像格式为BGR，需要做转换。</p><h2 id="4-完整代码"><a href="#4-完整代码" class="headerlink" title="4. 完整代码"></a>4. 完整代码</h2><p>结合上一部分的几个关键点，最终的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;Agg&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;/path/to/my.jpg&#x27;</span>)</span><br><span class="line">img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line">h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">fig.set_size_inches(w/fig.dpi, h/fig.dpi)</span><br><span class="line"></span><br><span class="line">plt.imshow(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始 matplotlib的绘制</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关掉坐标轴的显示</span></span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加这一句，避免matplotlib的自动padding导致的空白</span></span><br><span class="line">plt.gca().set_position((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">fig.canvas.draw()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换plt canvas为string，再导入numpy</span></span><br><span class="line">vis_img = np.fromstring(fig.canvas.tostring_rgb(), dtype=np.uint8)</span><br><span class="line"><span class="comment"># 设置numpy数组大小为图像大小</span></span><br><span class="line">vis_img.shape = (h, w, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 将RGB格式转换为BGR格式</span></span><br><span class="line">vis_img = cv2.cvtColor(vis_img, cv2.COLOR_RGB2BGR)</span><br><span class="line"></span><br><span class="line">plt.close()</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;/path/to/vis_img.jpg&#x27;</span>, vis_img)</span><br></pre></td></tr></table></figure><p>需要注意的是，直接执行这段代码虽然可以得到你想要的结果，但本身是没有意义的，最核心的matplotlib调用需要你自己填写。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;有时候，我们需要使用Matplotlib库强大的绘图函数来在numpy.ndarray格式的图像上进行一些可视化，比如关键点绘制，投影点绘制。绘制完后，还需要把matplotlib的figure对象转换为numpy.ndarray 格式的对象，方便和原图进行比较。有时候为了可视化的美观，需要验证保证转换后的图像与原始图像大小一致。这里记录一下操作的流程，以及一些常遇到的问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="OpenCV" scheme="http://vra.github.io/tags/OpenCV/"/>
    
    <category term="Matplotlib" scheme="http://vra.github.io/tags/Matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>git 提交文件中的部分修改</title>
    <link href="http://vra.github.io/2022/06/17/git-add-part-of-a-file/"/>
    <id>http://vra.github.io/2022/06/17/git-add-part-of-a-file/</id>
    <published>2022-06-17T15:19:36.000Z</published>
    <updated>2022-06-17T23:56:04.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在 Git 提交一个文件的时候，有时候会在同一个文件中，包含两个不同功能的修改，或者一个功能完成了，而别的部分还没有完善不应该进入代码库，这时候如果使用<code>git add file-name</code>的话，会将这个文件中的所有更新都提交，达不到上述的需求。针对这种场景，git 提供了更细粒度的提交命令<code>git add -p</code>，可以分部分提交一个文件中的更新代码块，实测能满足常见的需求。这里简要记录一下如何使用这个命令。</p><span id="more"></span><h2 id="2-实现命令"><a href="#2-实现命令" class="headerlink" title="2. 实现命令"></a>2. 实现命令</h2><h3 id="2-1-原理解释"><a href="#2-1-原理解释" class="headerlink" title="2.1 原理解释"></a>2.1 原理解释</h3><p>git 中用”hunk”来表示一个文件中邻近区域中的代码修改块，比如用<code>git diff</code> 查看修改时，两个<code>@@</code>符号分割的一个区域就是一个hunk，其中行首是<code>-</code>，颜色为红色的为删去的行，而行首为<code>+</code>，颜色为绿色的为增加的行。<br><img src="/imgs/git_add_part/git_hunk_vis.jpg" alt="git_hunk_vis"></p><p>需要注意的是，git有一套默认的将文件中所有修改分成不同hunk的机制，但我们也可以将默认机制分的太大的hunk分割为多个小的hunk，这样能更精确地控制提交的粒度。</p><p>部分提交文件修改的原理简单来说是将所有的修改分成不同的hunk，通过对每个hunk来进行是否提交的判断，从而完成我们的需求。具体命令下面详细讲述。</p><h3 id="2-2-命令详解"><a href="#2-2-命令详解" class="headerlink" title="2.2 命令详解"></a>2.2 命令详解</h3><p><code>git add -p filename</code>就可以进入交互式的操作界面，所有的操作在该界面完成，其中<code>-p</code>是patch的缩写。界面如下:<br><img src="/imgs/git_add_part/git_part_add_2.jpg"><br>这里会自动载入第一个hunk，显示了修改的代码行，最底下一行显示了这是8个hunk里面的第一个，然后有一些选项让我们选择，这时候输入<code>?</code>，按会车会显示help信息:<br><img src="/imgs/git_add_part/git_part_add_2.jpg"></p><p>所有命令的含义如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">y - 将当前的hunk进行提交</span><br><span class="line">n - 不提交当前hunk</span><br><span class="line">q - 退出交互式界面，不提交当前hunk以及后面的所有hunk</span><br><span class="line">a - 提交当前hunk以及后面的所有hunk</span><br><span class="line">d - 不提交当前hunk以及后面的所有hunk，效果与q一样，也会退出交互式界面</span><br><span class="line">g - 选择一个hunk并跳转过去，输入后会列出所有hunk的编号，输入编号就跳转到对应的hunk</span><br><span class="line">/ - 输入一个正则表达式，选择一个包含搜索词的hunk进行跳转</span><br><span class="line">j - 暂时不确定是否保存当前hunk，跳转到下一个没确定的hunk</span><br><span class="line">J - 暂时不确定是否保存当前hunk，跳转到下一个hunk</span><br><span class="line">e - 手动修改hunk块的内容，将`-` 开头的行替换为 ` `则不会删去这行，删除`+`为首的行则不提交这个新增，以`<span class="comment">#`开始的行会被忽略</span></span><br><span class="line">? - 显示帮助信息 </span><br></pre></td></tr></table></figure><p>详细阅读上面的说明，结合实际的操作，就能掌握这个命令的所有用法。</p><p>简单来说，使用<code>y</code>来提交当前hunk，使用<code>n</code>来忽略当前hunk，如果hunk代码块太大，输入<code>s</code>会将其分割为小的hunk，在上面继续操作，hunk间上下跳转用vim的快捷键<code>k</code> 和<code>j</code>，要退出则输入<code>q</code>。</p><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><ol><li><a href="https://stackoverflow.com/questions/1085162/commit-only-part-of-a-file-in-git">https://stackoverflow.com/questions/1085162/commit-only-part-of-a-file-in-git</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;在 Git 提交一个文件的时候，有时候会在同一个文件中，包含两个不同功能的修改，或者一个功能完成了，而别的部分还没有完善不应该进入代码库，这时候如果使用&lt;code&gt;git add file-name&lt;/code&gt;的话，会将这个文件中的所有更新都提交，达不到上述的需求。针对这种场景，git 提供了更细粒度的提交命令&lt;code&gt;git add -p&lt;/code&gt;，可以分部分提交一个文件中的更新代码块，实测能满足常见的需求。这里简要记录一下如何使用这个命令。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>VitPose 论文阅读</title>
    <link href="http://vra.github.io/2022/06/11/vitpose-intro/"/>
    <id>http://vra.github.io/2022/06/11/vitpose-intro/</id>
    <published>2022-06-11T12:12:02.000Z</published>
    <updated>2022-06-12T14:23:06.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>VitPose是最近出来的一篇用Transformer结构做人体2D关键点估计的论文，采用比较简单的Transformer结构就能在MS COCO 测试集上取得比较好的结果，挺吸引人的。论文不长，这周末读了一遍，感觉值得借鉴的地方挺多，这里我用自己的语言描述论文的细节，同时把自己的一些疑惑和思考写下来，欢迎讨论交流。</p><p>论文标题: ViTPose: Simple Vision Transformer Baselines for Human Pose Estimation<br>论文地址：<a href="https://arxiv.org/abs/2204.12484">https://arxiv.org/abs/2204.12484</a><br>代码地址：<a href="https://github.com/ViTAE-Transformer/ViTPose">https://github.com/ViTAE-Transformer/ViTPose</a></p><p>注：本文中框图和表格均来自原论文。</p><span id="more"></span><h2 id="2-摘要和引入"><a href="#2-摘要和引入" class="headerlink" title="2. 摘要和引入"></a>2. 摘要和引入</h2><p>Vison Transformer 在视觉识别任务中效果优秀，在识别但还没有人在姿态估计任务上验证这种结构的有效性。这篇论文提出了名为VitPose的用于姿态估计的Transformer网络，使用普通ViT结构作为Backbone，结合一个轻量级的Decoder，就能在MS COCO 关键点估计bechmark上达到SOTA。</p><h2 id="3-继续阅读前的几个疑问"><a href="#3-继续阅读前的几个疑问" class="headerlink" title="3. 继续阅读前的几个疑问"></a>3. 继续阅读前的几个疑问</h2><p>读完摘要和Introduction部分，我决定继续精读这篇论文，因此在进一步阅读前，为了提升对论文的理解程度，我想出了下面的问题，希望在读完剩余部分的时候，这些问题都能得到回答:</p><ol><li>如何确定SOTA结果中MAE和Transformer网络结构的贡献?</li><li>100M到1B参数的变化是通过哪个模块的变化调节的?</li><li>是基于Heatmap还是Regression的思路?</li><li>只针对单人场景还是多人场景也OK?</li><li>速度如何？</li></ol><p>带着这些疑问，咱们继续往下看。</p><h2 id="4-实现细节"><a href="#4-实现细节" class="headerlink" title="4. 实现细节"></a>4. 实现细节</h2><h3 id="4-1-整体结构"><a href="#4-1-整体结构" class="headerlink" title="4.1 整体结构"></a>4.1 整体结构</h3><p>网络结构设计比较简单，整体为采用ViT backbone + decoder的形式。</p><p><img src="/imgs/vitpose/vitpose_framework.jpg" alt="vitpose framework"><br>backbone分为patch embedding和多个transfomer模块。patch embedding将图像分为dxd的patch块。</p><p>而每个transfomer层包含 multi-head self-attention(MHSA) 与 feed-forward network (FFN) 模块。多个transfomer层堆叠，构成了backbone。</p><p>backbone根据计算量大小，选用了Vit-B, ViT-L，ViT-H[3]以及ViTAE-G[4]。</p><h4 id="4-1-1-decoder-选择"><a href="#4-1-1-decoder-选择" class="headerlink" title="4.1.1 decoder 选择"></a>4.1.1 decoder 选择</h4><p>由于backbone采用ViT现有的结构，因此在decoder的选取上，作者选择了两种结构进行了对比:</p><ol><li>经典Decoder结构，两个Deconv（+BN+ReLU) + 1个1x1 conv，每个deconv上采样2倍，最终输出feature map大小为输入的1/4倍<br><img src="/imgs/vitpose/vitpose_classic_decoder.jpg"></li><li>双线性差值上采样4倍，然后是ReLU+3x3conv，不过论文中公式与描述不符，ReLU在双线性上采样之前，需要看代码实现具体是哪一种。<br><img src="/imgs/vitpose/vitpose_simple_decoder.jpg"></li></ol><p>方案1非线性更高，因此在CNN的结构中使用比较多。而这篇论文也验证了由于Transformer强大的学习能力，即使像方案2这样的的简单decoder，也能达到很高的精度：</p><p><img src="/imgs/vitpose/vitpose_t1.png"><br>可以看到，ResNet系列在方案1上的结果远高于方案2，说明CNN结构的学习能力需要强有力的decoder来进一步加强，而VitPose结构则不需要，这需要归功于ViT结构的强大学习能力</p><p>如果光讲结构确实比较单一，所以论文也在好几个方面验证了ViTPose的优良特性。</p><h3 id="4-2-灵活性"><a href="#4-2-灵活性" class="headerlink" title="4.2 灵活性"></a>4.2 灵活性</h3><h4 id="4-2-1-预训练上的灵活性"><a href="#4-2-1-预训练上的灵活性" class="headerlink" title="4.2.1 预训练上的灵活性"></a>4.2.1 预训练上的灵活性</h4><p>一般情况下backbone都需要ImageNet上预训练。这篇论文提出了三种预训练方案：</p><ol><li>采用ImagNet预训练分类任务，比较经典的方法，数据集总共1M图片</li><li>采用MS COCO 预训练MAE任务，将75%的patch随机的mask掉，然后让网络学习恢复这些patch，数据集共150K图片</li><li>任务框架同方案2，不过数据集采用MS COCO + AI Challenger，共500K图片</li></ol><p>具体实现是将MS COCO和AI Challenger 中的单个人体crop出来，与ImageNet单个object的数据分布保持一致。然后在3个数据集上分别训练1600个epoch，再在MS COCO 上fine tune 210个epoch。</p><p>这个训练周期确实有点出乎意料地长……</p><p>采用VitPose-B结构，在MS COCO val set上，三种预训练方案的结果如下:<br><img src="/imgs/vitpose/vitpose_t2.jpg"><br>可以看到使用MS COCO + AI Challenger，在只有一半数据量的情况下，可以达到比ImageNet更好的效果。</p><h4 id="4-2-2-分辨率上的灵活性"><a href="#4-2-2-分辨率上的灵活性" class="headerlink" title="4.2.2 分辨率上的灵活性"></a>4.2.2 分辨率上的灵活性</h4><p>ViTPose可以通过使用更大的输出尺寸来训练，也可以通过减小backbone中的下采样来构造更大尺度的feature map，这两种操作都能提高精度，具体如下：<br>更大尺寸的输入：直接缩放原始图像，得到对应大小的输入<br>更大尺寸的特征：降低采样倍数，修改patch层的stride参数，</p><p>另外提一下，这个特性应该是CNN和ViT结构都通用的。</p><p>结果如下：<br><img src="/imgs/vitpose/vitpose_t3.jpg"><br>可以看到分辨率越大结果越高</p><h4 id="4-2-3-Attention种类上的灵活性"><a href="#4-2-3-Attention种类上的灵活性" class="headerlink" title="4.2.3 Attention种类上的灵活性"></a>4.2.3 Attention种类上的灵活性</h4><p>众所周知，Transformer中的Attention的计算量是Feature map 尺寸的平方，因此是很大的，而且显存占用也很大。因此作者用了Shift Window 和 Pooling Window 两种方案来缓解这个问题，结果如下：</p><p><img src="/imgs/vitpose/vitpose_t4.jpg"><br>单纯的网络显存占用太多，因此不得不采用fp16才能训起来……</p><h4 id="4-2-4-finetune的灵活性"><a href="#4-2-4-finetune的灵活性" class="headerlink" title="4.2.4 finetune的灵活性"></a>4.2.4 finetune的灵活性</h4><p>与NLP任务中一样，作者验证了只固定MHSA模块的参数，精度下降不多，而固定FFN的参数，则精度下降明显，因此作者认为MHSA更偏向<strong>与任务无关</strong>，而FFN则更具体任务关系更密切。</p><p><img src="/imgs/vitpose/vitpose_t5.jpg"></p><h4 id="4-2-5-多任务上的灵活性"><a href="#4-2-5-多任务上的灵活性" class="headerlink" title="4.2.5 多任务上的灵活性"></a>4.2.5 多任务上的灵活性</h4><p>作者还尝试了这样一个实验，采用同一个backbone，多个decoder，每个decoder对应一个数据集的任务，实验验证一次训练，多个数据集上的结果都能比较好，且比单个数据集精度有提升:</p><p><img src="/imgs/vitpose/vitpose_t6.jpg"></p><h3 id="4-3-蒸馏"><a href="#4-3-蒸馏" class="headerlink" title="4.3 蒸馏"></a>4.3 蒸馏</h3><p>这篇论文比较有意思的一个点是提出了一个基于Transformer的蒸馏方法，与常见的用loss来监督Teacher和Student网络的思路不太一样，具体如下:</p><ol><li>在大模型的patch embedding后的visual token后面增加一个知识token模块，并进行随机初始化</li><li>固定大模型的参数，只训练知识token模块</li><li>将训练好的知识token模块接到小模型的visual token后面，且固定知识token的参数，只训练小模型的其他参数</li></ol><p>通过这样的流程，将所有的知识都融合到了知识token模块的参数里面，并且从大模型传递到小模型，感觉理解起来也是很直观很有画面感。</p><p>结果如下：</p><p><img src="/imgs/vitpose/vitpose_t7.jpg"></p><h3 id="4-4-与SOTA对比"><a href="#4-4-与SOTA对比" class="headerlink" title="4.4 与SOTA对比"></a>4.4 与SOTA对比</h3><p> 实现细节中作者说明了，采用姿态估计中Top-Down的方案，即先用一个检测器检测出单个人体框，然后对人体框进行姿态估计。本文中方案其实是后面这一步。第一步的检测器在COCO的val集上用的是SimpleBaseline[1]，而在最后的COCO test-dev集上，与SOTA方案的比较实验中，采用了Bigdet[2]。</p><p>SOTA结果是在576x432输入，采用1B参数量的ViTAE-G作为backbone，使用MS COCO + AI Challenger训练的情况下获得的，具体如下：<br><img src="/imgs/vitpose/vitpose_t8.jpg"><br><img src="/imgs/vitpose/vitpose_t8.jpg"></p><h2 id="5-几个疑问的答案："><a href="#5-几个疑问的答案：" class="headerlink" title="5 几个疑问的答案："></a>5 几个疑问的答案：</h2><p>相信经过上面的细节描述，我们对开头的几个疑问中的一些问题已经有明确的答案了</p><ol><li>如何确定SOTA结果中MAE和Transformer网络结构的贡献? -&gt; </li><li>100M到1B参数的变化是通过哪个模块的变化调节的? -&gt; 通过修改backbone的结构来控制参数大小 </li><li>是基于Heatmap还是Regression的思路? -&gt; Heatmap</li><li>只针对单人场景还是多人场景也OK? -&gt; 只针对单人场景，且需要额外的前置detector</li><li>速度如何？ -&gt; 速度应该是比较慢的，训练周期比较长，网络比较大</li></ol><h2 id="6-思考"><a href="#6-思考" class="headerlink" title="6 思考"></a>6 思考</h2><ol><li>采用强大的Transformer结构，之前的很多trick都可以省略，包括skip-connection 等</li><li>Knowledge Token的思路很新颖挺有意思的，感觉可以用在所有的Transformer蒸馏里面</li><li>虽然论文强调只用了一个普通的ViT结构来做姿态估计，但是为了达到较高的精度，后面还是挺多提点的实验</li></ol><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h2><p>[1] SimpleBaseline: <a href="https://arxiv.org/abs/1804.06208">https://arxiv.org/abs/1804.06208</a><br>[2] Bigdetection: A large-scale benchmark for improved object detector pre-training<br>[3] An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale<br>[4] Vitaev2: Vision transformer advanced by exploring inductive bias for image recognition and beyond</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;VitPose是最近出来的一篇用Transformer结构做人体2D关键点估计的论文，采用比较简单的Transformer结构就能在MS COCO 测试集上取得比较好的结果，挺吸引人的。论文不长，这周末读了一遍，感觉值得借鉴的地方挺多，这里我用自己的语言描述论文的细节，同时把自己的一些疑惑和思考写下来，欢迎讨论交流。&lt;/p&gt;
&lt;p&gt;论文标题: ViTPose: Simple Vision Transformer Baselines for Human Pose Estimation&lt;br&gt;论文地址：&lt;a href=&quot;https://arxiv.org/abs/2204.12484&quot;&gt;https://arxiv.org/abs/2204.12484&lt;/a&gt;&lt;br&gt;代码地址：&lt;a href=&quot;https://github.com/ViTAE-Transformer/ViTPose&quot;&gt;https://github.com/ViTAE-Transformer/ViTPose&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：本文中框图和表格均来自原论文。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Computer Vision" scheme="http://vra.github.io/tags/Computer-Vision/"/>
    
    <category term="论文阅读" scheme="http://vra.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    <category term="Paper" scheme="http://vra.github.io/tags/Paper/"/>
    
    <category term="Pose Estimation" scheme="http://vra.github.io/tags/Pose-Estimation/"/>
    
    <category term="ViT" scheme="http://vra.github.io/tags/ViT/"/>
    
    <category term="Transformer" scheme="http://vra.github.io/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>提高你的信息获取信噪比：RSS in 2022</title>
    <link href="http://vra.github.io/2022/05/29/rss-2022/"/>
    <id>http://vra.github.io/2022/05/29/rss-2022/</id>
    <published>2022-05-29T13:49:39.000Z</published>
    <updated>2022-05-29T14:29:26.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在上学的时候，有一次听boj师兄介绍博客，至今还记得讲座中的一句话，博客能提高获取信息的信噪比。</p><p>在今天网络和社交媒体信息严重过载的情况下，如何集中自己的精力，将时间花到有用的事情上，进而提高工作效率，对我们每个人来说，都很有挑战。</p><p>为了获取真正有用的信息，第一步是过滤信息来源。最近发现基于RSS的信息获取方式是比较高效的，这里大致描述一下我目前采用的信息获取方案。</p><span id="more"></span><h1 id="2-RSS-介绍"><a href="#2-RSS-介绍" class="headerlink" title="2. RSS 介绍"></a>2. RSS 介绍</h1><p>基于RSS的信息获取需要有两个东西，一个是RSS阅读器，另一个就是订阅源。通过订阅，每次订阅源有新内容发表的话，阅读器都可以爬取，因此打开阅读器就能阅读最新的订阅内容，避免了一个个/一次次检查网站的问题，也能最快地看到感兴趣的内容。如果一个订阅源的内容长期不喜欢的话，可以取消订阅，减少噪声。（但这个是不是也会加剧信息茧房现象？)</p><p>RSS阅读器我目前采用的是inoreader，之前也用过feedly，不过都需要科学上网。如果你有更好的方案，欢迎评论指出。</p><p>订阅源就是内容的生产方的RSS链接，一般博客网站都有会RSS标志，点击复制网页，添加到阅读器中即可。</p><p>这里是我的一些订阅源和平时会看的网站，欢迎寻找对你有用的内容.</p><h3 id="2-1-纯粹的技术网站"><a href="#2-1-纯粹的技术网站" class="headerlink" title="2.1 纯粹的技术网站"></a>2.1 纯粹的技术网站</h3><p>hacker news是大家提到比较多的网站，内容挺丰富的。而lobste.rs是一个没怎么被提到但社区和谐、内容优质的computing为主的社区，很喜欢这种纯粹地讨论技术的网站，很多大牛也在其中出没。不过由于采用邀请制，门槛很高，像我们这样的一般人很难参与他们的讨论。</p><h3 id="2-2-知乎上大佬总结的订阅源"><a href="#2-2-知乎上大佬总结的订阅源" class="headerlink" title="2.2 知乎上大佬总结的订阅源"></a>2.2 知乎上大佬总结的订阅源</h3><p><a href="https://zhuanlan.zhihu.com/p/472781319">这里</a>是知乎上大佬总结的优质RSS源，可以根据你的喜爱添加到自己的阅读器。</p><h3 id="2-3-独立博客汇总"><a href="#2-3-独立博客汇总" class="headerlink" title="2.3 独立博客汇总"></a>2.3 独立博客汇总</h3><p><a href="https://github.com/timqian/chinese-independent-blogs">这里</a>是GitHub上开发者总结的中文独立博客列表，很长，但应该是有很多优质内容的，值得一一阅读品味再订阅。阅读个人的独立博客，像是认识跟自己有同样爱好的一个好友，看ta看问题的角度，解决问题的思路，分享的创造，都会带来惊喜。</p><p>最后愿这篇博客对你高效获取信息有所帮助!</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;在上学的时候，有一次听boj师兄介绍博客，至今还记得讲座中的一句话，博客能提高获取信息的信噪比。&lt;/p&gt;
&lt;p&gt;在今天网络和社交媒体信息严重过载的情况下，如何集中自己的精力，将时间花到有用的事情上，进而提高工作效率，对我们每个人来说，都很有挑战。&lt;/p&gt;
&lt;p&gt;为了获取真正有用的信息，第一步是过滤信息来源。最近发现基于RSS的信息获取方式是比较高效的，这里大致描述一下我目前采用的信息获取方案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="RSS" scheme="http://vra.github.io/tags/RSS/"/>
    
    <category term="非技术" scheme="http://vra.github.io/tags/%E9%9D%9E%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Python 字符串的format用法</title>
    <link href="http://vra.github.io/2022/05/28/python-format/"/>
    <id>http://vra.github.io/2022/05/28/python-format/</id>
    <published>2022-05-28T02:57:49.000Z</published>
    <updated>2022-05-28T07:06:38.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h2><p>我有一个朋友，某天突然问我：你知道下面的Python语句什么含义，结果是多少吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#123;:😄^+#20_x&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">12345</span>)</span><br></pre></td></tr></table></figure><p>我一看，十脸懵逼，吓得赶紧学了学Python的Format字符串的用法，总算明白了这个语句的含义。你想了解这个语句到底是什么鬼吗，欢迎跟我一起学。</p><span id="more"></span><h2 id="2-整体说明"><a href="#2-整体说明" class="headerlink" title="2. 整体说明"></a>2. 整体说明</h2><p>Python的Format语法，可以用在两个场景：一个是<code>&#123;&#125;</code>.format中，另一个是f-string中，`f{xxx}’中，只不过后者支持外部定义的变量:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .format way 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello &#123;&#125;!&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;World&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># .format way 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello &#123;name&#125;!&#x27;</span>.<span class="built_in">format</span>(name=<span class="string">&#x27;World&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># f-string</span></span><br><span class="line">name = <span class="string">&#x27;World&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Hello <span class="subst">&#123;name&#125;</span>!&#x27;</span>)</span><br></pre></td></tr></table></figure><p>为了应对更复杂的使用场景，Python设计了一套全面的语法，来涵盖所有的使用情况。具体来说，这套语法将一个Format 语句分成五部分，分别是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&#123;&quot;</span> [字段名称部分] [<span class="string">&quot;!&quot;</span> 格式转换部分] [<span class="string">&quot;:&quot;</span> 格式规范部分] <span class="string">&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure><p> 也就是左大括号和右大括号以及中间的核心三个部分, 其中方括号中的内容是可选的，也就是说最简单的format语法就是<code>&#123;&#125;</code>.format(‘xxx’)，会打印format后的第一个内容。</p><p> 下面分开看看核心的三个部分。</p><h2 id="字段名称部分"><a href="#字段名称部分" class="headerlink" title="字段名称部分"></a>字段名称部分</h2><p> 这一部分是用来定位要进行操作的变量。大括号中的编号对应这实际传入的参数，例如:<br> 采用关键字形式：<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;My name is &#123;name&#125;, I am &#123;age&#125; years old&#x27;</span>.<span class="built_in">format</span>(name=<span class="string">&#x27;Root&#x27;</span>, age=<span class="number">100</span>)</span><br><span class="line"><span class="comment"># My name is Root, I am 100 years old</span></span><br></pre></td></tr></table></figure><br> 这里的<code>&#123;name&#125;</code>对应format后面的关键字形式的参数name。</p><p> 另一种是使用参数序号：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;My name is &#123;0&#125;, I am &#123;1&#125; years old&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Root&#x27;</span>, <span class="number">100</span>)</span><br><span class="line"><span class="comment"># My name is Root, I am 100 years old</span></span><br></pre></td></tr></table></figure><p> 这里的<code>&#123;0&#125;</code>对应<code>Root</code>, <code>&#123;1&#125;</code> 对应100，如果有更多的参数的话，编号按顺序往下继续。</p><p> 注意这里的<code>&#123;idx&#125;</code>在字符串中可以出现任意次，且出现的顺序是任意的：<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#123;5&#125; &#123;5&#125; &#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line"><span class="comment"># f f c</span></span><br></pre></td></tr></table></figure></p><p>如果下标越界的话，会报错:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#123;5&#125; &#123;5&#125; &#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">IndexError: Replacement index <span class="number">5</span> out of <span class="built_in">range</span> <span class="keyword">for</span> positional args <span class="built_in">tuple</span></span><br></pre></td></tr></table></figure><p>另外一个特性是，可以忽略括号中的编号，这时候就按照从0开始的顺序来读取输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的命令等效于 &#x27;My name is &#123;0&#125;, I am &#123;1&#125; years old&#x27;.format(&#x27;Root&#x27;, 100)</span></span><br><span class="line"><span class="string">&#x27;My name is &#123;&#125;, I am &#123;&#125; years old&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Root&#x27;</span>, <span class="number">100</span>)</span><br><span class="line"><span class="comment"># My name is Root, I am 100 years old</span></span><br></pre></td></tr></table></figure><p> 如果对复杂如列表或者字典，也可以使用下标或者属性来操作:<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 列表例子</span></span><br><span class="line">friends = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;&#123;0[0]&#125;&#x27;</span>.<span class="built_in">format</span>(friends)</span><br><span class="line"><span class="comment"># &#x27;foo`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典例子</span></span><br><span class="line">info = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Root&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">100</span>&#125;</span><br><span class="line"><span class="string">&#x27;&#123;0[name]&#125;&#x27;</span>.<span class="built_in">format</span>(info)</span><br><span class="line"><span class="comment"># &#x27;Root&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 属性对象例子</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">Person = namedtuple(<span class="string">&#x27;Person&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])</span><br><span class="line">p = Person(<span class="string">&#x27;Root&#x27;</span>, <span class="number">100</span>)</span><br><span class="line"><span class="string">&#x27;&#123;0.name&#125;&#x27;</span>.<span class="built_in">format</span>(p)</span><br><span class="line"><span class="comment"># &#x27;Root</span></span><br><span class="line">通过这些设置，能满足常见的需求。</span><br></pre></td></tr></table></figure></p><h2 id="3-格式转换部分"><a href="#3-格式转换部分" class="headerlink" title="3. 格式转换部分"></a>3. 格式转换部分</h2><p>这部分比较简单，在格式规范转换之前执行，通过感叹号加转换符号[r, s, a]之一，将原先的类型转换为字符串的类型，其中<code>!a</code> 表示对输入对象进行ascii()函数的调用，<code>!s</code>表示对输入对象进行str()函数的调用，而<code>!r</code>则调用repr()函数。</p><h2 id="4-格式规范部分"><a href="#4-格式规范部分" class="headerlink" title="4 格式规范部分"></a>4 格式规范部分</h2><p>这部分是format格式中的大头，包含很多项设置，但都是可选的，例如上面的例子中我们都没有设置这部分。关于这部分的规范下面我们一一道来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">format_spec     ::=  [[fill]align][sign][#][0][width][grouping_option][.precision][type]</span><br><span class="line">fill            ::=  &lt;any character&gt;</span><br><span class="line">align           ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;=&quot; | &quot;^&quot;</span><br><span class="line">sign            ::=  &quot;+&quot; | &quot;-&quot; | &quot; &quot;</span><br><span class="line">width           ::=  digit+</span><br><span class="line">grouping_option ::=  &quot;_&quot; | &quot;,&quot;</span><br><span class="line">precision       ::=  digit+</span><br><span class="line">type            ::=  &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot;</span><br></pre></td></tr></table></figure><h3 id="4-1-fill-和align-填充和对齐部分"><a href="#4-1-fill-和align-填充和对齐部分" class="headerlink" title="4.1 fill 和align: 填充和对齐部分"></a>4.1 fill 和align: 填充和对齐部分</h3><p>这部分包括填充和对齐，填充部分是任意的一个字符，如’+’, ‘*’, 或者😄。不设置的话，默认使用空格来填充。对齐方式包括下面四种:</p><ul><li>“&lt;”: 左对齐<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以空格左对齐，长度为10位</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:&lt;10&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.14</span>)</span><br><span class="line"><span class="string">&#x27;3.14      &#x27;</span></span><br><span class="line"><span class="comment"># 以星号左对齐，长度为10位</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:*&lt;10&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.14</span>)</span><br><span class="line"><span class="string">&#x27;3.14******&#x27;</span></span><br></pre></td></tr></table></figure></li><li>“&gt;”：右对齐<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以空格右对齐，长度为10位</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:&gt;10&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.14</span>)</span><br><span class="line"><span class="string">&#x27;      3.14&#x27;</span></span><br></pre></td></tr></table></figure></li><li>“=”：只对数值类型使用，表示对齐强制放到正负号和数值之间<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以星号数值对齐，长度为10位</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:*=10&#125;&#x27;</span>.<span class="built_in">format</span>(-<span class="number">3.14</span>)</span><br><span class="line"><span class="string">&#x27;-*****3.14&#x27;</span></span><br></pre></td></tr></table></figure></li><li>“^”: 居中对齐<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:*^10&#125;&#x27;</span>.<span class="built_in">format</span>(-<span class="number">3.14</span>)</span><br><span class="line"><span class="string">&#x27;**-3.14***&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-sign-符号部分"><a href="#4-2-sign-符号部分" class="headerlink" title="4.2 sign: 符号部分"></a>4.2 sign: 符号部分</h3>这部分有三个选项；<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="string">&quot;+&quot;</span>: 正负号都加符号</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:+&#125; &#123;1:+&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.14</span>, -<span class="number">3.14</span>)</span><br><span class="line"><span class="string">&#x27;+3.14 -3.14&#x27;</span></span><br></pre></td></tr></table></figure></li><li>“-“: 只有负数前面才加符号<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:-&#125; &#123;1:-&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.14</span>, -<span class="number">3.14</span>)</span><br><span class="line"><span class="string">&#x27;3.14 -3.14&#x27;</span></span><br></pre></td></tr></table></figure></li><li>“ “: 正数前面加空格，负数前面加负号<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0: &#125; &#123;1: &#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.14</span>, -<span class="number">3.14</span>)</span><br><span class="line"><span class="string">&#x27; 3.14 -3.14&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-进制表示位"><a href="#4-3-进制表示位" class="headerlink" title="4.3 #: 进制表示位"></a>4.3 #: 进制表示位</h3><p>使用<code>#</code>号结合不同的进制表示符号(下面详细展开)，会在进制前面增加对应的负号，如二进制前增加<code>0b</code>, 八进制前增加<code>0o</code>, 十六进制前增加<code>0x</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:#b&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">233</span>)</span><br><span class="line"><span class="string">&#x27;0b11101001&#x27;</span></span><br><span class="line"><span class="comment"># 八进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:#o&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">233</span>)</span><br><span class="line"><span class="string">&#x27;0o351&#x27;</span></span><br><span class="line"><span class="comment"># 十进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:#d&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">233</span>)</span><br><span class="line"><span class="string">&#x27;233&#x27;</span></span><br><span class="line"><span class="comment"># 十六进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:#x&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">233</span>)</span><br><span class="line"><span class="string">&#x27;0xe9</span></span><br></pre></td></tr></table></figure><h3 id="4-4-width-显示的字符长度"><a href="#4-4-width-显示的字符长度" class="headerlink" title="4.4 width: 显示的字符长度"></a>4.4 width: 显示的字符长度</h3><p>这一部分表示显示多少位字符，包括pad的字符位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 总长度为10位，不足的部分用默认的符号补齐</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:10&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">233</span>)</span><br><span class="line"><span class="string">&#x27;       233&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-5-grouping-option-千位的标识符号"><a href="#4-5-grouping-option-千位的标识符号" class="headerlink" title="4.5 grouping_option: 千位的标识符号"></a>4.5 grouping_option: 千位的标识符号</h3><p>这部分表示千位的标识符号，有<code>,</code>和<code>\_</code>两种选择:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:10,&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">23333333</span>)</span><br><span class="line"><span class="string">&#x27;23,333,333&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:10_&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">23333333</span>)</span><br><span class="line"><span class="string">&#x27;23_333_333&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-6-precision-数值精度"><a href="#4-6-precision-数值精度" class="headerlink" title="4.6 .precision: 数值精度"></a>4.6 .precision: 数值精度</h3><p>这个表示浮点数的精度位数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:.3&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.14159</span>)</span><br><span class="line"><span class="string">&#x27;3.14&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-7-type-格式类型"><a href="#4-7-type-格式类型" class="headerlink" title="4.7 type: 格式类型"></a>4.7 type: 格式类型</h3><p>这部分表示最终的展示类型，共有下面这些类:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot;</span><br></pre></td></tr></table></figure><p>每种的解释如下:</p><ul><li>“b”: 二进制表示<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:b&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;1000</span></span><br></pre></td></tr></table></figure></li><li>“c”: 只支持整数，将其转换为对应的unicode符号<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:c&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">23</span>)</span><br><span class="line"><span class="string">&#x27;\x17&#x27;</span></span><br></pre></td></tr></table></figure></li><li>“d”: 十进制表示 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:d&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;8&#x27;</span></span><br></pre></td></tr></table></figure></li><li>“e”: 科学计数法，采用小写的e<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:e&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;8.000000e+00&#x27;</span></span><br></pre></td></tr></table></figure></li><li>“E”: 科学计数法，采用大写的E<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:E&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;8.000000E+00</span></span><br></pre></td></tr></table></figure></li><li>“f”: 浮点数表示<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:f&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;8.000000&#x27;</span></span><br></pre></td></tr></table></figure></li><li>“F”: 与”f”基本相同，除了将nan显示为NAN, inf显示为INF<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:F&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;8.000000&#x27;</span></span><br></pre></td></tr></table></figure></li><li>“g”: 通用数据格式<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:g&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;8&#x27;</span></span><br></pre></td></tr></table></figure></li><li>“G”: 通用数据格式<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:G&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;8&#x27;</span></span><br></pre></td></tr></table></figure></li><li>“n”: 数值格式<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:n&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;8&#x27;</span></span><br></pre></td></tr></table></figure></li><li>“o”: 八进制格式<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:o&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;10</span></span><br></pre></td></tr></table></figure></li><li>“s”: 只能对字符串使用,字符串类型，默认输出类型，可以忽略<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:s&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&#x27;www&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;www&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&#x27;www&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;www&#x27;</span></span><br></pre></td></tr></table></figure></li><li>“x”: 十六进制<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:#x&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;0x8&#x27;</span></span><br></pre></td></tr></table></figure></li><li>“X”: 十六进制，符号标识采用大写的X <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:#X&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;0X8&#x27;</span></span><br></pre></td></tr></table></figure></li><li>“%”: 只对数值类型使用，以百分比的形式显示<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:%&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;800.000000%&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:%&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">0.001</span>)</span><br><span class="line"><span class="string">&#x27;0.100000%&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="5-解答开头的神秘符号串"><a href="#5-解答开头的神秘符号串" class="headerlink" title="5. 解答开头的神秘符号串"></a>5. 解答开头的神秘符号串</h2><p>有了上面的知识，我们就可以解开文章开头的的神秘符号串了:</p><ol><li>以笑脸符号作为pad的字符，且居中对齐，总长为20个符号</li><li>在正数前面增加加号</li><li>显示为16进制，并且显示前面的进制标注符号<br>结果如下:</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">&#x27;&#123;:😄^+#20_x&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">12345</span>)</span><br><span class="line"><span class="string">&#x27;😄😄😄😄😄😄+0x3039😄😄😄😄😄😄😄&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6. 参考"></a>6. 参考</h2><ol><li><a href="https://docs.python.org/3/library/string.html">https://docs.python.org/3/library/string.html</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-引入&quot;&gt;&lt;a href=&quot;#1-引入&quot; class=&quot;headerlink&quot; title=&quot;1. 引入&quot;&gt;&lt;/a&gt;1. 引入&lt;/h2&gt;&lt;p&gt;我有一个朋友，某天突然问我：你知道下面的Python语句什么含义，结果是多少吗？&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;#123;:😄^+#20_x&amp;#125;&amp;#x27;&lt;/span&gt;.&lt;span class=&quot;built_in&quot;&gt;format&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;12345&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我一看，十脸懵逼，吓得赶紧学了学Python的Format字符串的用法，总算明白了这个语句的含义。你想了解这个语句到底是什么鬼吗，欢迎跟我一起学。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>python importlib用法小结</title>
    <link href="http://vra.github.io/2022/05/28/python-importlib-usage/"/>
    <id>http://vra.github.io/2022/05/28/python-importlib-usage/</id>
    <published>2022-05-27T23:31:46.000Z</published>
    <updated>2022-05-28T01:50:56.052Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Python的时候，大部分时候引入包，都是通过<code>import</code> 语句，比如<code>import numpy as np</code>。有时候为了更复杂的需求，我们需要用<strong>程序化</strong>的方式来引入包 (Programmatic Importing), 比如根据输入不同，选择执行两个不同包里面的同名函数，这时候就需要用到<code>importlib</code>这个库了。这里先从一个简单例子开始，逐渐深入地讲一下这个库的用法。</p><span id="more"></span><h2 id="import-module用法"><a href="#import-module用法" class="headerlink" title="import_module用法"></a>import_module用法</h2><p><code>importlib</code>是Python3.1增加的系统库，其中最常用的函数是其中的<code>import_module</code>，功能是用程序语句的方式替代<code>import</code>语句，用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与 import time 效果一样</span></span><br><span class="line">time = importlib.import_module(<span class="string">&#x27;time&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(time.time())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与 import os.path as path 效果一样</span></span><br><span class="line">path = importlib.import_module(<span class="string">&#x27;os.path&#x27;</span>)</span><br><span class="line">path.join(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)  <span class="comment"># results: &#x27;a/b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相对引入, 一级目录，与 import os.path as path 效果一样</span></span><br><span class="line">path = importlib.import_module(<span class="string">&#x27;.path&#x27;</span>, package=<span class="string">&#x27;os&#x27;</span>)</span><br><span class="line">path.join(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)  <span class="comment"># results: &#x27;a/b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相对引入，二级目录，与 import os.path as path 效果一样</span></span><br><span class="line">path = importlib.import_module(<span class="string">&#x27;..path&#x27;</span>, package=<span class="string">&#x27;os.time&#x27;</span>)</span><br><span class="line">path.join(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)  <span class="comment"># results: &#x27;a/b&#x27;</span></span><br></pre></td></tr></table></figure><p>注意最后的例子中，相对引入时需要在前面增加<code>.</code>或者<code>..</code>来表示相对目录，如果直接使用<code>importlib.import_module(&#39;path&#39;, package=&#39;os&#39;)</code>会报错。</p><p>如果光看这几个例子的话，貌似跟<code>import</code> 没什么区别，而且语句变得更复杂了，有点多此一举的感觉。</p><p>其实不是的，<strong>个人认为，<code>importlib</code>的强大之处是将<code>import</code>语句中写死的字面值改成了<code>import_module</code>函数中的参数，因此可以通过修改参数在外部用变量来控制实际import的包或者模块，大大地增加了灵活性。</strong> 下面会举一个稍微实用一些的例子。</p><h2 id="一个实际例子"><a href="#一个实际例子" class="headerlink" title="一个实际例子"></a>一个实际例子</h2><p>假设我们在设计一个深度学习工具库，里面包含了N个网络模型（ResNet50, HRNet, MobileNet等等），每个模型的实现都有一个<code>load_model</code>的函数。由于计算设备的性能不同，需要调用的网络结构也会变化，我们需要根据外部传入的参数来判断实际load哪一个模型。</p><p>虽然采用<code>import</code>语句+<code>if-else</code>判断也能完成这个需求，举例实现如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">model_name, <span class="built_in">input</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> model_name == <span class="string">&#x27;resnet_50&#x27;</span>:</span><br><span class="line">        <span class="keyword">from</span> resnet_50.model <span class="keyword">import</span> load_model</span><br><span class="line">    <span class="keyword">elif</span> model_name == <span class="string">&#x27;hrnet&#x27;</span>:</span><br><span class="line">        <span class="keyword">from</span> hrnet.model <span class="keyword">import</span> load_model</span><br><span class="line">    <span class="keyword">elif</span> model_name == <span class="string">&#x27;moblienet&#x27;</span>:</span><br><span class="line">        <span class="keyword">from</span> mobilenet.model <span class="keyword">import</span> load_model</span><br><span class="line"></span><br><span class="line">    model = load_model()</span><br><span class="line">    output = model(<span class="built_in">input</span>)</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><p>这种写法存在下面的两个问题：</p><ol><li>写法很冗余, N个模型的话需要添加2N条语句</li><li>新增模型时需要修改调用处的代码，添加对应的import语句，不符合模块化的要求。</li></ol><p>这时候采用<code>importlib</code>就能比较简洁地解决这个问题:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">model_name, <span class="built_in">input</span></span>):</span></span><br><span class="line">    load_model = importlib.import_module(<span class="string">&#x27;load_model&#x27;</span>, package=<span class="string">&#x27;&#123;&#125;.model&#x27;</span>.<span class="built_in">format</span>(model_name))</span><br><span class="line"></span><br><span class="line">    model = load_model()</span><br><span class="line">    output = model(<span class="built_in">input</span>)</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><p>可以看到在这种场景下<code>importlib</code>确实能大大简化代码。</p><p>了解这些内容，日常使用这个库就没什么问题了（好像<code>importlib</code>针对普通用户场景的函数貌似就只有<code>import_module</code>这一个），别的一些进阶的概念<del>在下个部分展开说一下</del>(由于不太懂，暂时不展开了)。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://docs.python.org/3/library/importlib.html">https://docs.python.org/3/library/importlib.html</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用Python的时候，大部分时候引入包，都是通过&lt;code&gt;import&lt;/code&gt; 语句，比如&lt;code&gt;import numpy as np&lt;/code&gt;。有时候为了更复杂的需求，我们需要用&lt;strong&gt;程序化&lt;/strong&gt;的方式来引入包 (Programmatic Importing), 比如根据输入不同，选择执行两个不同包里面的同名函数，这时候就需要用到&lt;code&gt;importlib&lt;/code&gt;这个库了。这里先从一个简单例子开始，逐渐深入地讲一下这个库的用法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>python的列表推导式和生成器表达式对比</title>
    <link href="http://vra.github.io/2022/05/22/python-list-comprehension-vs-generator-expression/"/>
    <id>http://vra.github.io/2022/05/22/python-list-comprehension-vs-generator-expression/</id>
    <published>2022-05-22T05:16:58.000Z</published>
    <updated>2022-05-22T06:33:10.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Python中的列表推倒式(List Comprehension) 和 生成器表达式（Generator Expression）是两种很相似的表达式，但含义却不大不同，这里做一个对比。</p><span id="more"></span><h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>列表推导式是比较常用的技术，能将本来需要<code>for</code> loop和<code>if else</code>语句的情况简化成一条指令，最终得到一个列表对象:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">even = [e <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>具体细节不过多展开，相信很多使用Python的人都已经足够了解这种语法了。</p><p>需要注意的一点是，列表推导式不是惰性计算 ( Lazy Loading) 的，因此所有的列表成员都在声明完语句后立即计算 (Eager Loading)，因此在数组成员很多的情况下，速度会很慢，例如下面的在IPython环境里面的三个列表推导式的耗时统计:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: %timeit even = [e <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>) <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="number">5.5</span> ms ± <span class="number">24.8</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">100</span> loops each)</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: %timeit even = [e <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>) <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="number">58.9</span> ms ± <span class="number">440</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">10</span> loops each)</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: %timeit even = [e <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>) <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="number">5.65</span> s ± <span class="number">26.5</span> ms per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1</span> loop each)</span><br></pre></td></tr></table></figure><p>可以看到随着元素个数的增加，列表推导式执行的时间也相应变长，占用的内存也会变大。</p><p>有一种情况是，我们定义了很多很多的数组元素，但是最后并不是所有的元素都能用到，例如经过几条命令，最后可能只有列表里面的前10个元素会用到，或者只有符合某些条件的元素会用到，这样的话，Eager模式就白白花费了时间，白白花费了内存来创建很多用不到的元素，这显然有很大的改进空间。</p><h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>生成器能表达式解决上面的问题，它的元素迭代是惰性的，因此只有需要的时候才生产出来，避免了额外的内存开销和时间开销: 生成器表达式不管元素数目多大，创建时都是常数时间，因为它并没有立即创建元素。</p><p>那么生成器表达式的语法是怎么样的呢，很简单，只需要把列表推导式中的方括号改为圆括号:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">even_gen = (e <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>注意它的类型是生成器类型:</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span>(<span class="title">even_gen</span>)</span></span><br><span class="line"><span class="meta"># generator</span></span><br></pre></td></tr></table></figure><p>创建生成器表达式的耗时统计:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [1]: %timeit even_gen = (e <span class="keyword">for</span> e <span class="keyword">in</span> range(100000) <span class="keyword">if</span> e % 2 == 0)</span><br><span class="line">376 ns ± 2.61 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)</span><br><span class="line"></span><br><span class="line">In [2]: %timeit even_gen = (e <span class="keyword">for</span> e <span class="keyword">in</span> range(10000000) <span class="keyword">if</span> e % 2 == 0)</span><br><span class="line">382 ns ± 1.63 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)</span><br><span class="line"></span><br><span class="line">In [3]: %timeit even_gen = (e <span class="keyword">for</span> e <span class="keyword">in</span> range(1000000000) <span class="keyword">if</span> e % 2 == 0)</span><br><span class="line">384 ns ± 2.85 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)</span><br></pre></td></tr></table></figure><p>可以看到随着元素的增加，创建时间基本不变，而且比列表推导式的耗时要低不少。</p><h2 id="使用场景选择"><a href="#使用场景选择" class="headerlink" title="使用场景选择"></a>使用场景选择</h2><p>那么是不是就是说使用中可以用生成器表达式替代列表推导式了呢，也不尽然，因为列表推导式得到的是一个列表，很多便捷操作（如slice等）可以作用到上面，而生成器表达式则不行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: even = [e <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: even[:<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">18</span>]: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: even_gen = (e <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: even_gen[:<span class="number">3</span>]</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">Input In [<span class="number">20</span>], <span class="keyword">in</span> &lt;cell line: <span class="number">1</span>&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> even_gen[:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">TypeError: <span class="string">&#x27;generator&#x27;</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> subscriptable</span><br></pre></td></tr></table></figure><p>而且两者有一个致命的区别：生成器表达式只能迭代一次，而列表推导式可以使用很多次，举例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">22</span>]: even_gen = (e <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> e % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: <span class="keyword">for</span> e <span class="keyword">in</span> even_gen:</span><br><span class="line">    ...:     <span class="built_in">print</span>(e)</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: <span class="keyword">for</span> e <span class="keyword">in</span> even_gen:</span><br><span class="line">    ...:     <span class="built_in">print</span>(e)</span><br><span class="line">    ...:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到生成器表达式在第二次迭代的时候，里面已经没有元素了！即第一次迭代已经全部生成出来了，而列表推导式是每次迭代都是有相同的内容:</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">25</span>]: even = [<span class="built_in">e</span> <span class="keyword">for</span> <span class="built_in">e</span> <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> <span class="built_in">e</span> % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: <span class="keyword">for</span> <span class="built_in">e</span> <span class="keyword">in</span> even:</span><br><span class="line">    ...:     <span class="built_in">print</span>(<span class="built_in">e</span>)</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: <span class="keyword">for</span> <span class="built_in">e</span> <span class="keyword">in</span> even:</span><br><span class="line">    ...:     <span class="built_in">print</span>(<span class="built_in">e</span>)</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p>因此总结来说，</p><ul><li>如果要多次迭代时，建议使用列表推导式</li><li>如果数组很大或者有无穷个元素，建议使用生成器表达式</li><li>其他场景：两者均可，自己看情况使用一个，如果没有速度和方便度的问题即可，如果有问题换另一个再试试</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://stackoverflow.com/questions/47789/generator-expressions-vs-list-comprehensions">https://stackoverflow.com/questions/47789/generator-expressions-vs-list-comprehensions</a></li><li><a href="https://docs.python.org/3/howto/functional.html#generator-expressions-and-list-comprehensions">https://docs.python.org/3/howto/functional.html#generator-expressions-and-list-comprehensions</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Python中的列表推倒式(List Comprehension) 和 生成器表达式（Generator Expression）是两种很相似的表达式，但含义却不大不同，这里做一个对比。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>全世界最准确的翻译DeepL到底有多强? 一个有意思的例子</title>
    <link href="http://vra.github.io/2022/05/21/deepl-showoff/"/>
    <id>http://vra.github.io/2022/05/21/deepl-showoff/</id>
    <published>2022-05-21T09:44:43.000Z</published>
    <updated>2022-05-21T10:35:54.936Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Deep Learning</li><li>Translator</li></ul><p>在知乎上偶然看到了一个基于深度学习的翻译器DeepL，实际体验了一下，确实发现比Google Translate, 百度翻译等工具好用，因此最近抛弃了之前的翻译工具，开始往DeepL切换，毕竟在阅读英文内容的过程中还是有很多单词和词组的意思不了解。最近在阅读DeepMind的一篇文章的时候，看到一段有意思的话，对比了一下，发现DeepL真的比竞品厉害，更加加速了我抛弃之前工具的速度。具体什么例子呢，如下细说。</p><span id="more"></span><h2 id="一个有意思的例子"><a href="#一个有意思的例子" class="headerlink" title="一个有意思的例子"></a>一个有意思的例子</h2><p>在阅读DeepMind的<a href="https://www.deepmind.com/blog/from-lego-competitions-to-deepminds-robotics-lab">这篇文章</a>的时候，我发现了有一个段落里面的一句话有点看不懂，具体如下：</p><blockquote><p>My afternoons are a mix of meetings, coding and – now that most people are back in the office – an impromptu chat or two. That’s one of my favourite parts of being in the office – the random catch-ups and whiteboard sessions that help me learn and move quickly. From there I’ll take a quick snack break, and if the weather is nice, head to the balcony to catch up on some of my favourite US sports podcasts (<strong>I still haven’t made the switch from football to <em>football</em></strong>). Then I’ll code a little while longer.</p></blockquote><p>截图如下：<br><img src="/imgs/quote.png" alt="段落"></p><p>这里前情提要是这样的：这个科学家是个英国人，在美国读了大学，在谷歌工作了一些时间后transfer到DeepMind了。这里提到一些每日活动安排，前面说到他会看一会最喜欢的美国体育播客，然后就是红色框里面的那句<code>I still haven’t made the switch from football to football</code>，这里我没看懂，两个football是什么意思呢？依稀记得英语课上说够football有不同的含义，但不知道具体是什么。</p><p>因此我动用了翻译工具，结果如下。</p><p>谷歌翻译的结果:<br><img src="/imgs/google_translate.jpg" alt="google_translate"></p><p>百度翻译的结果：<br><img src="/imgs/baidu_translate.jpg" alt="baidu_translate"></p><p>看来那句话这几个翻译器都没看懂，让我也看得一头雾水。</p><p>然后尝试了一下DeepL，结果出乎意料:<br><img src="/imgs/deepl_translate.jpg" alt="deepl_translate"><br>谜题解开了，这里前面的<code>football</code>是美式英语，意思是橄榄球，而后面的<code>football</code>是英式英语表达，意思是足球，这也契合了前面说的看美国体育的播客的说法，DeepL估计是从上下文推断出来的，别的翻译器看来还是在理解文本上差一些。</p><p>至此我对DeepL的敬畏又增加了几分。</p><h2 id="一个疑问"><a href="#一个疑问" class="headerlink" title="一个疑问"></a>一个疑问</h2><p>看了下DeepL网站的介绍，确实做了很多创新。但我在想，像谷歌怎么厉害的公司，也有财力和物力来做相同的事情，为什么他们没有做或者说做不到跟DeepL那么好呢？</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Deep Learning&lt;/li&gt;
&lt;li&gt;Translator&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在知乎上偶然看到了一个基于深度学习的翻译器DeepL，实际体验了一下，确实发现比Google Translate, 百度翻译等工具好用，因此最近抛弃了之前的翻译工具，开始往DeepL切换，毕竟在阅读英文内容的过程中还是有很多单词和词组的意思不了解。最近在阅读DeepMind的一篇文章的时候，看到一段有意思的话，对比了一下，发现DeepL真的比竞品厉害，更加加速了我抛弃之前工具的速度。具体什么例子呢，如下细说。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Pytorch Apple Silicon GPU 训练与测评</title>
    <link href="http://vra.github.io/2022/05/19/pytorch-mps-benchmark/"/>
    <id>http://vra.github.io/2022/05/19/pytorch-mps-benchmark/</id>
    <published>2022-05-19T08:46:24.000Z</published>
    <updated>2022-05-21T13:47:51.969Z</updated>
    
    <content type="html"><![CDATA[<p>今天中午看到Pytorch的官方博客发了Apple M1 芯片 GPU加速的文章，这是我期待了很久的功能，因此很兴奋，立马进行测试，结论是在MNIST上，速度与P100差不多，相比CPU提速1.7倍。当然这只是一个最简单的例子，不能反映大部分情况。这里详细记录操作的一步步流程，如果你也感兴趣，不妨自己上手一试。</p><span id="more"></span><h2 id="加速原理"><a href="#加速原理" class="headerlink" title="加速原理"></a>加速原理</h2><p>苹果有自己的一套GPU实现API Metal，而Pytorch此次的加速就是基于Metal，具体来说，使用苹果的Metal Performance Shaders（MPS）作为PyTorch的后端，可以实现加速GPU训练。MPS后端扩展了PyTorch框架，提供了在Mac上设置和运行操作的脚本和功能。MPS通过针对每个Metal GPU系列的独特特性进行微调的内核来优化计算性能。新设备在MPS图形框架和MPS提供的调整内核上映射机器学习计算图形和基元。</p><p>因此此次新增的的device名字是<code>mps</code>，使用方式与<code>cuda</code>类似，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">foo = torch.rand(<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>).to(<span class="string">&#x27;mps&#x27;</span>)</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&#x27;mps&#x27;</span>)</span><br><span class="line">foo = foo.to(device)</span><br></pre></td></tr></table></figure><p>是不是熟悉的配方，熟悉的味道？可以说是无门槛即可上手。</p><p>此外发现，Pytorch已经支持下面这些device了，确实出乎意料:</p><ul><li>cpu, cuda, ipu, xpu, mkldnn, opengl, opencl, ideep, hip, ve, ort, mps, xla, lazy, vulkan, meta, hpu</li></ul><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>为了使用这个实验特性，你需要满足下面三个条件：</p><ol><li>有一台配有Apple Silicon 系列芯片（M1, M1 Pro, M1 Pro Max, M1 Ultra)的Mac笔记本</li><li>安装了<strong>arm64</strong>位的Python</li><li>安装了最新的<code>nightly</code>版本的Pytorch </li></ol><p>第一个条件需要你自己来设法满足，这篇文章对它的达到没有什么帮助。</p><p>假设机器已经准备好。我们可以从<a href="https://docs.conda.io/en/latest/miniconda.html">这里</a>下载arm64版本的miniconda(文件名是<code>Miniconda3 macOS Apple M1 64-bit bash</code>)，基于它安装的Python环境就是arm64位的。下载和安装Minicoda的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-arm64.sh </span><br><span class="line">chmod +x Miniconda3-latest-MacOSX-arm64.sh </span><br><span class="line">./Miniconda3-latest-MacOSX-arm64.sh </span><br></pre></td></tr></table></figure><p>按照说明来操作即可，安装完成后，创建一个虚拟环境，通过检查<code>platform.uname()[4]</code>是不是为<code>arm64</code>来检查Python的架构:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda config --env --<span class="built_in">set</span> always_yes <span class="literal">true</span></span><br><span class="line">conda create -n try-mps python=3.8</span><br><span class="line">conda activate try-mps</span><br><span class="line">python -c <span class="string">&quot;import platform; print(platform.uname()[4])&quot;</span></span><br></pre></td></tr></table></figure><p>如果最后一句命令的输出为<code>arm64</code>，说明Python版本OK，可以继续往下走了。  </p><p>第三步，安装nightly版本的Pytorch，在开启的虚拟环境中进行下面的操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip  install --pre torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/nightly/cpu</span><br></pre></td></tr></table></figure><p>执行完成后通过下面的命令检查MPS后端是否可用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&quot;import torch;print(torch.backends.mps.is_built())&quot;</span></span><br></pre></td></tr></table></figure><p>如果输出为<code>True</code>，说明MPS后端可用，可以继续往下走了。</p><h2 id="跑一个MNIST"><a href="#跑一个MNIST" class="headerlink" title="跑一个MNIST"></a>跑一个MNIST</h2><p>基于Pytorch官方的example中的MNIST例子，修改了来测试cpu和mps模式，代码如下:</p><figure class="highlight python"><figcaption><span>mark:85</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"><span class="keyword">from</span> torch.optim.lr_scheduler <span class="keyword">import</span> StepLR</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">32</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">        self.dropout1 = nn.Dropout(<span class="number">0.25</span>)</span><br><span class="line">        self.dropout2 = nn.Dropout(<span class="number">0.5</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">9216</span>, <span class="number">128</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">128</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = F.max_pool2d(x, <span class="number">2</span>)</span><br><span class="line">        x = self.dropout1(x)</span><br><span class="line">        x = torch.flatten(x, <span class="number">1</span>)</span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = self.dropout2(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        output = F.log_softmax(x, dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">args, model, device, train_loader, optimizer, epoch</span>):</span></span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        data, target = data.to(device), target.to(device)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(data)</span><br><span class="line">        loss = F.nll_loss(output, target)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span> batch_idx % args.log_interval == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch, batch_idx * <span class="built_in">len</span>(data), <span class="built_in">len</span>(train_loader.dataset),</span><br><span class="line">                <span class="number">100.</span> * batch_idx / <span class="built_in">len</span>(train_loader), loss.item()))</span><br><span class="line">            <span class="keyword">if</span> args.dry_run:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># Training settings</span></span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&#x27;PyTorch MNIST Example&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--batch-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">64</span>, metavar=<span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;input batch size for training (default: 64)&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--test-batch-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1000</span>, metavar=<span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;input batch size for testing (default: 1000)&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--epochs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">4</span>, metavar=<span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;number of epochs to train (default: 14)&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--lr&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">1.0</span>, metavar=<span class="string">&#x27;LR&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;learning rate (default: 1.0)&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--gamma&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.7</span>, metavar=<span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Learning rate step gamma (default: 0.7)&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--no-cuda&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;disables CUDA training&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--use_gpu&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;enable MPS&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--dry-run&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;quickly check a single pass&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--seed&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1</span>, metavar=<span class="string">&#x27;S&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;random seed (default: 1)&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--log-interval&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">10</span>, metavar=<span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;how many batches to wait before logging training status&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--save-model&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;For Saving the current Model&#x27;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    use_gpu = args.use_gpu</span><br><span class="line"></span><br><span class="line">    torch.manual_seed(args.seed)</span><br><span class="line"></span><br><span class="line">    device = torch.device(<span class="string">&quot;mps&quot;</span> <span class="keyword">if</span> args.use_gpu <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line">    train_kwargs = &#123;<span class="string">&#x27;batch_size&#x27;</span>: args.batch_size&#125;</span><br><span class="line">    test_kwargs = &#123;<span class="string">&#x27;batch_size&#x27;</span>: args.test_batch_size&#125;</span><br><span class="line">    <span class="keyword">if</span> use_gpu:</span><br><span class="line">        cuda_kwargs = &#123;<span class="string">&#x27;num_workers&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                       <span class="string">&#x27;pin_memory&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">                       <span class="string">&#x27;shuffle&#x27;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">        train_kwargs.update(cuda_kwargs)</span><br><span class="line">        test_kwargs.update(cuda_kwargs)</span><br><span class="line"></span><br><span class="line">    transform=transforms.Compose([</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">        ])</span><br><span class="line">    dataset1 = datasets.MNIST(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>,</span><br><span class="line">                       transform=transform)</span><br><span class="line">    dataset2 = datasets.MNIST(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">False</span>,</span><br><span class="line">                       transform=transform)</span><br><span class="line">    train_loader = torch.utils.data.DataLoader(dataset1,**train_kwargs)</span><br><span class="line">    test_loader = torch.utils.data.DataLoader(dataset2, **test_kwargs)</span><br><span class="line"></span><br><span class="line">    model = Net().to(device)</span><br><span class="line">    optimizer = optim.Adadelta(model.parameters(), lr=args.lr)</span><br><span class="line"></span><br><span class="line">    scheduler = StepLR(optimizer, step_size=<span class="number">1</span>, gamma=args.gamma)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, args.epochs + <span class="number">1</span>):</span><br><span class="line">        train(args, model, device, train_loader, optimizer, epoch)</span><br><span class="line">        test(model, device, test_loader)</span><br><span class="line">        scheduler.step()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t0 = time.time()</span><br><span class="line">    main()</span><br><span class="line">    t1 = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;time_cost:&#x27;</span>, t1 - t0)</span><br></pre></td></tr></table></figure><p>测试CPU：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure><p>测试MPS:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python main --use_gpu</span><br></pre></td></tr></table></figure><p>在M1机器上测试发现，训一个Epoch的MNIST，CPU耗时33.4s，而使用MPS的话耗时19.6s，加速1.7倍，好像没官方博客中说的那么多，估计是跟模型太小有关。</p><p>我又在Nvidia P100 GPU服务器上进行了测试，CPU耗时34.2s，使用CUDA 耗时20.4s，加速比1.67倍，跟M1差不多，整体速度略低于M1。<br>下面是一个总结表格：</p><table><thead><tr><th>机器</th><th>内存</th><th>CPU耗时</th><th>GPU耗时</th><th>加速比</th></tr></thead><tbody><tr><td>M1</td><td>16G</td><td>33.4s</td><td>19.6s</td><td>1.70</td></tr><tr><td>P100</td><td>256G</td><td>34.2s</td><td>20.4s</td><td>1.67</td></tr></tbody></table><h2 id="跑一下VAE模型"><a href="#跑一下VAE模型" class="headerlink" title="跑一下VAE模型"></a>跑一下VAE模型</h2><p>类似地，跑一下这个仓库里面地VAE模型，发现CPU模式正常，换成MPS后loss不断增大，最后到nan，看来还是有bug的 (毕竟是实验特性)，可以在Pytorch GitHub 仓库里面提issue，期待更好的Pytorch。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[W ParallelNative.cpp:229] Warning: Cannot <span class="built_in">set</span> number of intraop threads after parallel work has started or after set_num_threads call when using native parallel backend (<span class="keyword">function</span> set_num_threads)</span><br><span class="line">Train Epoch: 1 [0/60000 (0%)]   Loss: 550.842529</span><br><span class="line">Train Epoch: 1 [1280/60000 (2%)]        Loss: 330.613251</span><br><span class="line">Train Epoch: 1 [2560/60000 (4%)]        Loss: 4705.016602</span><br><span class="line">Train Epoch: 1 [3840/60000 (6%)]        Loss: 183532752.000000</span><br><span class="line">...</span><br><span class="line">Train Epoch: 6 [40960/60000 (68%)]      Loss: nan</span><br><span class="line">Train Epoch: 6 [42240/60000 (70%)]      Loss: nan</span><br></pre></td></tr></table></figure><h2 id="一个愿景"><a href="#一个愿景" class="headerlink" title="一个愿景"></a>一个愿景</h2><p>开头提到，关注这个特性挺久了，其实我最初的想法，是希望一台普通计算设备（不带GPU的笔记本，智能手机）都能训非常快的模型。因为GPU卡很昂贵，只有科研机构和大公司才有，普通人购买成本比较高，而云服务商提供的GPU按时收费，价格不菲。另一方面，所有普通笔记本和智能手机都有不错的CPU，算力不错，如果能将这部分性能合理地利用起来，就像深度学习前的时代一样，有一台笔记本就能用MatLab快速地进行科学实验，这样才能将AI推广到更多人，将AI平民化，也避免了大公司在硬件资源上的垄断和显卡巨大的能耗。</p><p>今天的Mac GPU训练至少是在降低深度学习能耗和深度学习模型训练的”轻量化”上面有了一个大的进步，你可以抱着笔记本在床上训练改变AI模型了 😊 。但以Mac笔记的价格，很难说在平民化方向上有任何的进展。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天中午看到Pytorch的官方博客发了Apple M1 芯片 GPU加速的文章，这是我期待了很久的功能，因此很兴奋，立马进行测试，结论是在MNIST上，速度与P100差不多，相比CPU提速1.7倍。当然这只是一个最简单的例子，不能反映大部分情况。这里详细记录操作的一步步流程，如果你也感兴趣，不妨自己上手一试。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="Pytorch" scheme="http://vra.github.io/tags/Pytorch/"/>
    
    <category term="GPU" scheme="http://vra.github.io/tags/GPU/"/>
    
    <category term="Mac" scheme="http://vra.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>C++的RAII到底指的是什么</title>
    <link href="http://vra.github.io/2022/05/19/cpp-raii/"/>
    <id>http://vra.github.io/2022/05/19/cpp-raii/</id>
    <published>2022-05-19T08:43:00.000Z</published>
    <updated>2022-05-19T15:19:46.603Z</updated>
    
    <content type="html"><![CDATA[<p>RAII，全称 Resource Acquisition Is Initialization，中文翻译为资源获取即初始化。这是C++中一个比较不直观的术语，而RAII的缩写也时不时遇到，总给人一种很高深但不易掌握的感觉。实际上查了资料后发现，RAII这个技术的含义其实比较明确，这里简单汇总一下从资料中的得到的知识点。</p><span id="more"></span><h2 id="什么是资源"><a href="#什么是资源" class="headerlink" title="什么是资源"></a>什么是资源</h2><p>这里的资源 (Resource) 是C++编程中的一个概念，表示哪些不能无限申请的变量（常有明确的含义），比如一段内存，数据库句柄，Socket，打开的文件，线程等。<br>个人理解，一般的内置类型变量如<code>int</code> 变量不算是资源。</p><h2 id="为什么要设计-RAII-这项技术？"><a href="#为什么要设计-RAII-这项技术？" class="headerlink" title="为什么要设计 RAII 这项技术？"></a>为什么要设计 RAII 这项技术？</h2><p>简单来说，RAII 这项技术的目的是将资源的生命周期绑定到某个对象（Object）上。对象，一般情况是某个类的示例。这么做有下面几个好处：</p><ol><li>保证资源在使用的时候已经进行了初始化，避免访问未初始化的内存地址而crash</li><li>保证资源在程序正常退出的时候进行了释放，避免未释放导致的内存泄漏</li><li>保证资源在运行出错的时候也能被正常释放</li></ol><h2 id="具体如何实现RAII？"><a href="#具体如何实现RAII？" class="headerlink" title="具体如何实现RAII？"></a>具体如何实现RAII？</h2><p>RAII 的实现可以总结为：</p><ul><li>将每个资源封装到一个类中，类的构造函数获取资源，如果获取资源失败，则抛出一个异常。</li><li>类的解构函数释放资源，并且保证不抛出异常，因此保证资源的释放是没问题的</li></ul><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>从<a href="https://docs.microsoft.com/en-us/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?redirectedfrom=MSDN&view=msvc-170">这里</a>拿过来的一个例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">widget</span>(<span class="keyword">const</span> <span class="keyword">int</span> size) &#123; data = <span class="keyword">new</span> <span class="keyword">int</span>[size]; &#125; <span class="comment">// 资源获取</span></span><br><span class="line">    ~<span class="built_in">widget</span>() &#123; <span class="keyword">delete</span>[] data; &#125; <span class="comment">// 资源释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionUsingWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">widget <span class="title">w</span><span class="params">(<span class="number">1000000</span>)</span></span>;   <span class="comment">// lifetime automatically tied to enclosing scope</span></span><br><span class="line">                        <span class="comment">// constructs w, including the w.data member</span></span><br><span class="line">    w.<span class="built_in">do_something</span>();</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// automatic destruction and deallocation for w and w.data</span></span><br></pre></td></tr></table></figure><p>这里<code>widget</code>就是一个RAII类，它将<code>data</code>这个资源绑定到类上面，在构造和析构函数里面进行资源获取和释放。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://en.cppreference.com/w/cpp/language/raii">https://en.cppreference.com/w/cpp/language/raii</a></li><li><a href="https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii?answertab=scoredesc#tab-top">https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii?answertab=scoredesc#tab-top</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?redirectedfrom=MSDN&amp;view=msvc-170">https://docs.microsoft.com/en-us/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?redirectedfrom=MSDN&amp;view=msvc-170</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;RAII，全称 Resource Acquisition Is Initialization，中文翻译为资源获取即初始化。这是C++中一个比较不直观的术语，而RAII的缩写也时不时遇到，总给人一种很高深但不易掌握的感觉。实际上查了资料后发现，RAII这个技术的含义其实比较明确，这里简单汇总一下从资料中的得到的知识点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://vra.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Python Multiprocessing使用Queue的例子</title>
    <link href="http://vra.github.io/2022/05/16/python-multiprocessing-queue-example/"/>
    <id>http://vra.github.io/2022/05/16/python-multiprocessing-queue-example/</id>
    <published>2022-05-16T14:10:55.000Z</published>
    <updated>2022-05-16T14:26:19.510Z</updated>
    
    <content type="html"><![CDATA[<p>对于一些计算密集性的任务，使用Python的多进程能显著缩短运行的时间。例如对10个元素进行相同的操作，通过Python的<code>multiprocessing</code> 包可以进行并行化，实测能有数倍的速度提升。这里写一个简单的例子，将所有的结果写入队列，等队列拿到10个结果后，将结果写入文件。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue, Process, Pool</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_queue</span>(<span class="params">q, i</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Begin process (<span class="subst">&#123;os.getpid()&#125;</span>)&#x27;</span>)</span><br><span class="line">    cur_value = i * i</span><br><span class="line"></span><br><span class="line">    q.put(cur_value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_queue</span>(<span class="params">q, num_sample</span>):</span></span><br><span class="line">    val_list = []</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        v = q.get(<span class="literal">True</span>)</span><br><span class="line">        val_list.append(v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(val_list) &gt;= num_sample:</span><br><span class="line">            np.save(<span class="string">&#x27;data.npy&#x27;</span>, np.array(val_list))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    NUM_PROCESS = <span class="number">10</span></span><br><span class="line">    q = Queue(NUM_PROCESS)</span><br><span class="line">    pws = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(NUM_PROCESS):</span><br><span class="line">        pw = Process(target=write_queue, args=(q, i))</span><br><span class="line">        pws.append(pw)</span><br><span class="line"></span><br><span class="line">    pr = Process(target=read_queue, args=(q, NUM_PROCESS))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> pw <span class="keyword">in</span> pws:</span><br><span class="line">        pw.start()</span><br><span class="line"></span><br><span class="line">    pr.start()</span><br><span class="line">    <span class="keyword">for</span> pw <span class="keyword">in</span> pws:</span><br><span class="line">        pw.join()</span><br><span class="line"></span><br><span class="line">    pr.terminate()</span><br><span class="line"></span><br><span class="line">    data = np.load(<span class="string">&#x27;data.npy&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于一些计算密集性的任务，使用Python的多进程能显著缩短运行的时间。例如对10个元素进行相同的操作，通过Python的&lt;code&gt;multiprocessing&lt;/code&gt; 包可以进行并行化，实测能有数倍的速度提升。这里写一个简单的例子，将所有的结果写入队列，等队列拿到10个结果后，将结果写入文件。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="多进程" scheme="http://vra.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>kinematics和dynamics含义辨析</title>
    <link href="http://vra.github.io/2022/04/13/kinematics-vs-dynamics/"/>
    <id>http://vra.github.io/2022/04/13/kinematics-vs-dynamics/</id>
    <published>2022-04-13T03:10:14.000Z</published>
    <updated>2022-04-14T05:19:40.511Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kinematics is the study of how things move, while dynamics is the study of forces and motion. Kinematics is the study of motion. It is concerned with what happens to a body when it is at rest and in uniform motion. Dynamics is the study of forces and their effect on moving bodies.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Kinematics is the study of how things move, while dynamics is the study of forces and motion. Kinematics is the study of mot</summary>
      
    
    
    
    
    <category term="misc" scheme="http://vra.github.io/tags/misc/"/>
    
  </entry>
  
  <entry>
    <title>git 删除远程分支</title>
    <link href="http://vra.github.io/2022/04/10/git-delete-branch/"/>
    <id>http://vra.github.io/2022/04/10/git-delete-branch/</id>
    <published>2022-04-10T09:55:35.000Z</published>
    <updated>2022-04-14T05:18:46.308Z</updated>
    
    <content type="html"><![CDATA[<p>Git可以方便地删除本地的某个分支。具体操作是：</p><ol><li>切换到别的分支</li><li>执行<code>git branch -d &lt;name-of-branch-to-delete&gt;</code></li></ol><p>比如我想删除当前的<code>dev-tmp</code>分支:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git branch -d dev-tmp</span><br></pre></td></tr></table></figure><p>上面的命令只删除了本地的分支，如果要删除远端的分支，该怎么操作呢？答案是用带有<code>--delete</code>选项的<code>git push</code>命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete dev-tmp</span><br></pre></td></tr></table></figure><p>可以删除远端的<code>dev-tmp</code>分支。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Git可以方便地删除本地的某个分支。具体操作是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;切换到别的分支&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;git branch -d &amp;lt;name-of-branch-to-delete&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如我想删除</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Xcode无法安装ios程序的一种情况记录</title>
    <link href="http://vra.github.io/2022/04/06/ios-cannot-install/"/>
    <id>http://vra.github.io/2022/04/06/ios-cannot-install/</id>
    <published>2022-04-06T06:06:46.000Z</published>
    <updated>2022-04-10T09:55:05.439Z</updated>
    
    <content type="html"><![CDATA[<p>在用Xcode调试ios代码的时候，发现代码可以正常编译，但是安装到手机的时候，提示”App installation failed: Could not write to the device”。在网上找了很多回答，都没能解决。后来发现原因是在要复制到ios的目录中添加了一个软链接，导致出错。删除软链接后，安装正常。这应该是一个比较少见的原因，记录一下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在用Xcode调试ios代码的时候，发现代码可以正常编译，但是安装到手机的时候，提示”App installation failed: Could not write to the device”。在网上找了很多回答，都没能解决。后来发现原因是在要复制到ios的目录中添加了</summary>
      
    
    
    
    
    <category term="iOS" scheme="http://vra.github.io/tags/iOS/"/>
    
    <category term="Mac" scheme="http://vra.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>数字永存的一些想法</title>
    <link href="http://vra.github.io/2022/03/27/eternal-life/"/>
    <id>http://vra.github.io/2022/03/27/eternal-life/</id>
    <published>2022-03-27T14:15:43.000Z</published>
    <updated>2022-03-27T15:26:00.883Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>自古以来，人类就在思考自己与自然的关系，思考短暂人生与永恒时空的对比。从《论语》中的”子在川上曰，逝者如斯夫，不舍昼夜“，再到苏轼在《赤壁赋》中的“哀吾生之须臾，羡长江之无穷“，都体现了古代智者对人生的生老病死的思考。在漫长的历史中，只有少部分知识精英的思考和言论被记录下来，而大部分人们身上发生的故事，则在历史长河中湮灭了。一个例子是，我连我曾祖父之前的祖先的叫什么名字都不知道。</p><p>另一方面，随着互联网的出现，人类在数字世界里面记录着生活中的一切，朋友圈里面的自拍，与家人朋友的合影，快手上的短视频等等，在记录生活的同时，有意或无意地构建着自己的数字人生。当一个人在现实生活中去世后，他在数字世界里面的资产，包括图片，视频，音频都还存在（但这种存在不是永久的，可能因为保存这些资产的公司的经营而消失），某种程度上是永生在数字世界里。但目前的形式还没有明确的数字空间与真实空间的界限，拍摄的内容也都是2D的，除了观看，没法进行更多的交互。而随着苹果等大公司积极地推动AR技术，虚拟Avatar等技术也越来越成熟，大家也更能接受虚拟的主播，虚拟的歌手，虚拟的朋友。</p><p>随着渲染技术、AI技术以及硬件技术的不断发展，元宇宙的概念被越来越多的人所了解。不管是应用于何种场景，在元宇宙的概念里，现实生活中的人有对应的数字化身。这个数字化身是数字永存的一个核心。</p><p>设想这样一个场景，当一个人在世时构建好完美的3D数字化身，包括穿着的衣服重建，长相，发音，步态识别，以及最重要的，对于问题的思考方式和回应方式，那么在他去世后，当有亲友来到他的纪念室时，通过计算机技术，可以渲染出跟真实长相一样的ta，也能智能地回答问题，甚至声音都一样，那ta可以就算永生了。</p><p>为什么要设想这样一个场景呢？一个想法时想让人类的存在都能被记录，被看见，因为每个人身上都有值得后人纪念记录都闪光点和独有的故事。另一个想法是给后来人一个认清自己从哪里来的机会，避免出现三代以上，一字未知的现象。最后还是希望每个人有重新回忆亲人的机会。</p><h2 id="设想的场景"><a href="#设想的场景" class="headerlink" title="设想的场景"></a>设想的场景</h2><p>设想的场景如下。每个人有一个包含自己数字资产的U盘，由家人保存。同时有专门的数字形象进行展示的场所（比如叫数字永存展览馆），可以进行数字资产的重建和展示。当家人想要了解ta的生活的时候，可以拿着U盘去数字永存展览馆，对ta进行重建，观看他在生活中某天画的画，和家人在一起的画面，劳动的场景，以及对生活的思考。同时结合3D地球重建，可以看ta开车去玩时的路两边的风景，去乐山大佛时的大佛在他身旁展示出来。另外可以告诉他最近的新闻，他也会以他的方式来进行回复，和你一起讨论。</p><h2 id="涉及的技术"><a href="#涉及的技术" class="headerlink" title="涉及的技术"></a>涉及的技术</h2><p>这个场景涉及到的技术其实现在都有一些技术实现了一部分，但距离满足上述的场景还估计有至少有数十年的路要走。具体来说，有下面的子任务：</p><ul><li>听力和发音重建，听力包括能否听得懂方言，普通话，英语等，发音包括口音</li><li>人体重建：包括不同年龄段的头发重建，人脸重建，身体重建，微表情重建</li><li>衣物重建：每个时代有不同的服饰风格，每个人有自己喜欢的衣服，穿过的衣服，也需要重建，才足够真实</li><li>步态识别与重建：每个人走路也是不同的，只有步态重建好了，与数字形象沟通时才足够有真实感</li><li>知识体系重建：了解哪些知识，擅长哪些方面</li><li>思维习惯重建：面对一个问题，ta会怎么回复，这些需要通过日常的对话来重建</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之这是一个有点难，有点意义，但可能也会面临很多问题的事情。结合元宇宙，以及最近看的Upload电视剧，和今早一篇微信文章想到的一些点，这里把它记录下来，作为人生的一点思考，一个小的脚注。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;自古以来，人类就在思考自己与自然的关系，思考短暂人生与永恒时空的对比。从《论语》中的”子在川上曰，逝者如斯夫，不舍昼夜“，再到苏轼在《赤壁赋</summary>
      
    
    
    
    
    <category term="数字空间" scheme="http://vra.github.io/tags/%E6%95%B0%E5%AD%97%E7%A9%BA%E9%97%B4/"/>
    
    <category term="技术畅想" scheme="http://vra.github.io/tags/%E6%8A%80%E6%9C%AF%E7%95%85%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>git log 修改提交日期显示格式</title>
    <link href="http://vra.github.io/2022/03/26/git-change-log-date-format/"/>
    <id>http://vra.github.io/2022/03/26/git-change-log-date-format/</id>
    <published>2022-03-26T13:34:49.000Z</published>
    <updated>2022-03-26T13:54:44.559Z</updated>
    
    <content type="html"><![CDATA[<p>git log 默认显示的日期格式是欧美形式的，使用起来不太习惯，还得在大脑中进行一次转换，有点费脑。后来发现有办法可以修改日期显示格式，在git仓库下执行下面的命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config log.date iso</span><br></pre></td></tr></table></figure><p>如果要对所有的git仓库都起作用，添加<code>--global</code>选项即可。</p><p>另外输入<code>git config</code> 按tab键，可以显示所有的配置选项。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;git log 默认显示的日期格式是欧美形式的，使用起来不太习惯，还得在大脑中进行一次转换，有点费脑。后来发现有办法可以修改日期显示格式，在git仓库下执行下面的命令即可：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td </summary>
      
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git显示文件首次被跟踪的日期</title>
    <link href="http://vra.github.io/2022/03/26/git-show-first-added-time/"/>
    <id>http://vra.github.io/2022/03/26/git-show-first-added-time/</id>
    <published>2022-03-26T13:15:45.000Z</published>
    <updated>2022-03-26T13:34:22.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在使用Git的时候，想要显示某个文件首次被跟踪的时间，可以用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --format=%ad /path/to/file |tail -1</span><br></pre></td></tr></table></figure><p>管道操作前的命令是以默认日期格式显示所有包含这个文件的所有提交记录，从上往下依次为最新的最早的提交。管道操作后面的命令是提取前面的输出中最后一条记录，即最早的提交，这正是我们需要的。</p><p>各种关于git log的用法，参考上一篇博文。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在使用Git的时候，想要显示某个文件首次被跟踪的时间，可以用下面的命令：&lt;/p&gt;
&lt;figure class=&quot;highlight bash</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git log 常见参数总结</title>
    <link href="http://vra.github.io/2022/03/26/git-log/"/>
    <id>http://vra.github.io/2022/03/26/git-log/</id>
    <published>2022-03-26T12:59:55.000Z</published>
    <updated>2022-03-27T14:05:51.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-概述"><a href="#0-概述" class="headerlink" title="0. 概述"></a>0. 概述</h2><p>git log 是查看git提交记录的一个命令，它有非常多的控制参数和选项，合理使用的话，可以达到任何的精准控制目的。这里列一些日常使用可能会用到的用法，全部的用法，请在命令行<code>git help log</code>查看。</p><span id="more"></span><h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h2><h3 id="1-1-无参数"><a href="#1-1-无参数" class="headerlink" title="1.1. 无参数"></a>1.1. 无参数</h3><p>使用<code>git log</code>，会从新到旧显示所有的提交记录，按<code>j</code>往下翻页，按<code>k</code>往上翻页, 按<code>q</code>退出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">commit 869cc0a22aea80d34f0728e184842bdea42fe43b (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Merge: 78aaac39 2e872840</span><br><span class="line">Author: Johan Mabille &lt;johan.mabille@gmail.com&gt;</span><br><span class="line">Date:   2021-04-10 02:29:06 +0200</span><br><span class="line"></span><br><span class="line">    Merge pull request <span class="comment">#2353 from JohanMabille/chunk</span></span><br><span class="line"></span><br><span class="line">    Refactoring of xchunked_view</span><br><span class="line"></span><br><span class="line">commit 2e872840a7ebc3e4e8b0f84cbae39360503243b1</span><br><span class="line">Author: Johan Mabille &lt;johan.mabille@gmail.com&gt;</span><br><span class="line">Date:   2021-04-09 16:59:16 +0200</span><br><span class="line"></span><br><span class="line">    One xchunk_iterator to rule them all</span><br><span class="line"></span><br><span class="line">commit 42fc49080522c94ea784541b53ef302ccb0344c0</span><br><span class="line">Author: Johan Mabille &lt;johan.mabille@gmail.com&gt;</span><br><span class="line">Date:   2021-04-08 22:40:14 +0200</span><br><span class="line"></span><br><span class="line">    Refactoring of xchunked_view</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>通过增加<code>-&lt;n&gt;</code>选项来显示最近n次的提交记录，如<code>git log -2</code>仅显示最近的2次提交；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">commit 869cc0a22aea80d34f0728e184842bdea42fe43b (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Merge: 78aaac39 2e872840</span><br><span class="line">Author: Johan Mabille &lt;johan.mabille@gmail.com&gt;</span><br><span class="line">Date:   2021-04-10 02:29:06 +0200</span><br><span class="line"></span><br><span class="line">    Merge pull request <span class="comment">#2353 from JohanMabille/chunk</span></span><br><span class="line"></span><br><span class="line">    Refactoring of xchunked_view</span><br><span class="line"></span><br><span class="line">commit 2e872840a7ebc3e4e8b0f84cbae39360503243b1</span><br><span class="line">Author: Johan Mabille &lt;johan.mabille@gmail.com&gt;</span><br><span class="line">Date:   2021-04-09 16:59:16 +0200</span><br><span class="line"></span><br><span class="line">    One xchunk_iterator to rule them all</span><br></pre></td></tr></table></figure><p>此外如果想显示每次提交代码修改的地方，可以增加<code>-p</code>参数:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">commit 869cc0a22aea80d34f0728e184842bdea42fe43b (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Merge: 78aaac39 2e872840</span><br><span class="line">Author: Johan Mabille &lt;johan.mabille@gmail.com&gt;</span><br><span class="line">Date:   2021-04-10 02:29:06 +0200</span><br><span class="line"></span><br><span class="line">    Merge pull request #2353 from JohanMabille/chunk</span><br><span class="line"></span><br><span class="line">    Refactoring of xchunked_view</span><br><span class="line"></span><br><span class="line">commit 2e872840a7ebc3e4e8b0f84cbae39360503243b1</span><br><span class="line">Author: Johan Mabille &lt;johan.mabille@gmail.com&gt;</span><br><span class="line">Date:   2021-04-09 16:59:16 +0200</span><br><span class="line"></span><br><span class="line">    One xchunk_iterator to rule them all</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/include/xtensor/xchunked_array.hpp b/include/xtensor/xchunked_array.hpp</span></span><br><span class="line"><span class="comment">index ed4003d0..23a843ec 100644</span></span><br><span class="line"><span class="comment">--- a/include/xtensor/xchunked_array.hpp</span></span><br><span class="line"><span class="comment">+++ b/include/xtensor/xchunked_array.hpp</span></span><br><span class="line"><span class="meta">@@ -126,10 +128,16 @@</span> namespace xt</span><br><span class="line">         template &lt;class S&gt;</span><br><span class="line">         const_stepper stepper_end(const S&amp; shape, layout_type) const noexcept;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-        const shape_type&amp; chunk_shape() const;</span></span><br><span class="line"><span class="addition">+        const shape_type&amp; chunk_shape() const noexcept;</span></span><br><span class="line"><span class="addition">+        size_type grid_size() const noexcept;</span></span><br><span class="line"><span class="addition">+        const shape_type&amp; grid_shape() const noexcept;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">         chunk_storage_type&amp; chunks();</span><br><span class="line">         const chunk_storage_type&amp; chunks() const;</span><br><span class="line"></span><br><span class="line"><span class="addition">+        chunk_iterator_type chunk_begin();</span></span><br><span class="line"><span class="addition">+        chunk_iterator_type chunk_end();</span></span><br></pre></td></tr></table></figure><h3 id="1-2-显示统计信息"><a href="#1-2-显示统计信息" class="headerlink" title="1.2. 显示统计信息"></a>1.2. 显示统计信息</h3><p>增加<code>--stat</code>选项可以显示某次提交文件的修改信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">commit 869cc0a22aea80d34f0728e184842bdea42fe43b (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Merge: 78aaac39 2e872840</span><br><span class="line">Author: Johan Mabille &lt;johan.mabille@gmail.com&gt;</span><br><span class="line">Date:   2021-04-10 02:29:06 +0200</span><br><span class="line"></span><br><span class="line">    Merge pull request <span class="comment">#2353 from JohanMabille/chunk</span></span><br><span class="line"></span><br><span class="line">    Refactoring of xchunked_view</span><br><span class="line"></span><br><span class="line">commit 2e872840a7ebc3e4e8b0f84cbae39360503243b1</span><br><span class="line">Author: Johan Mabille &lt;johan.mabille@gmail.com&gt;</span><br><span class="line">Date:   2021-04-09 16:59:16 +0200</span><br><span class="line"></span><br><span class="line">    One xchunk_iterator to rule them all</span><br><span class="line"></span><br><span class="line"> include/xtensor/xchunked_array.hpp  |  45 ++++++++++-</span><br><span class="line"> include/xtensor/xchunked_assign.hpp | 246 +++++++++++++++++++++++++++++++++++++++++++++-------------</span><br><span class="line"> include/xtensor/xchunked_view.hpp   | 164 +++++++++++----------------------------</span><br><span class="line"> 3 files changed, 280 insertions(+), 175 deletions(-)</span><br></pre></td></tr></table></figure><h3 id="1-3-过滤选项"><a href="#1-3-过滤选项" class="headerlink" title="1.3. 过滤选项"></a>1.3. 过滤选项</h3><p>默认所有的提交都显示，如果我们想搜索某段时间或某个人的提交记录，该怎么办呢？git提供了详细的命令来进行过滤，下面详细举例说明。</p><h4 id="1-3-1-过滤作者"><a href="#1-3-1-过滤作者" class="headerlink" title="1.3.1. 过滤作者"></a>1.3.1. 过滤作者</h4><p>通过<code>--author</code>选项可以只显示某个人的提交记录，以这个仓库为例，下面的写法（FirstName，LastName, Email, FirstName + LastName, FirstName + LastName + Email）都可以:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --author=Johan</span><br><span class="line">git <span class="built_in">log</span> --author=Mabille</span><br><span class="line">git <span class="built_in">log</span> --author=johan.mabille@gmail.com</span><br><span class="line">git <span class="built_in">log</span> --author=<span class="string">&quot;Johan Mabille&quot;</span></span><br><span class="line">git <span class="built_in">log</span> --author=<span class="string">&quot;Johan Mabille &lt;johan.mabille@gmail.com&gt;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-2-过滤代码关键字"><a href="#1-3-2-过滤代码关键字" class="headerlink" title="1.3.2. 过滤代码关键字"></a>1.3.2. 过滤代码关键字</h4><p>通过<code>-S&lt;keyword&gt;</code>的形式可以搜索代码中增加或删除<code>keyword</code>的提交记录，比如<code>git log -Sxchunked_array</code>就会显示所有关于<code>xchunked_array</code>关键字的提交。结合前面的<code>-p</code>和<code>-&lt;n&gt;</code>参数，我们能很好的达到我们的搜索目的，比如只显示最近两次提交中关键词的修改内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -Sxchunked_array -p -2</span><br></pre></td></tr></table></figure><h4 id="1-3-3-过滤提交信息中的关键字"><a href="#1-3-3-过滤提交信息中的关键字" class="headerlink" title="1.3.3. 过滤提交信息中的关键字"></a>1.3.3. 过滤提交信息中的关键字</h4><p>此外还可以利用<code>--grep</code>选项来对commit内容进行过滤，比如我们想搜索所有包含<code>fix</code>的提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --grep fix</span><br></pre></td></tr></table></figure><h4 id="1-3-4-过滤日期"><a href="#1-3-4-过滤日期" class="headerlink" title="1.3.4. 过滤日期"></a>1.3.4. 过滤日期</h4><p>另一个很有用的选项是根据日期来过滤提交。日期过滤有好多形式，比如今年以来的提交，最近一周的提交，git提供了详细的控制命令，具体如下表:</p><table><thead><tr><th>关键词</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>after=<xxx></td><td>从xxx到现在的所有提交</td><td>after=”2020-01-01”</td></tr><tr><td>since=<xxx></td><td>从xxx到现在的所有提交，与after同义</td><td>since=”2020-01-01”</td></tr><tr><td>before=<xxx></td><td>xxx之前的所有提交</td><td>before=”2020-01-01”</td></tr><tr><td>until=<xxx></td><td>xxx之前的所有提交，与before同义</td><td>until=”2020-01-01”</td></tr></tbody></table><p>日期格式如下：</p><table><thead><tr><th>时间格式</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>YYYY-MM-DD</td><td>到某个具体日期的提交</td><td>since=2020-01-01</td></tr><tr><td>n.minute</td><td>n分钟内的提交</td><td>since=3.minute</td></tr><tr><td>n.hour</td><td>n小时内的提交</td><td>since=3.hour</td></tr><tr><td>n.day</td><td>n天内的提交</td><td>since=3.day</td></tr><tr><td>n.week</td><td>n周内的提交</td><td>since=3.week</td></tr><tr><td>n.month</td><td>n个月内的提交</td><td>since=3.month</td></tr><tr><td>n.year</td><td>n年内的提交</td><td>since=1.year</td></tr><tr><td>组合</td><td>上述形式的组合</td><td>since=1.year,10.month</td></tr></tbody></table><p>比如要显示2天内的所有提交，可以用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=2.day</span><br></pre></td></tr></table></figure><h2 id="2-显示格式调整"><a href="#2-显示格式调整" class="headerlink" title="2. 显示格式调整"></a>2. 显示格式调整</h2><p>默认的显示格式比较松散，一次提交占的空间太大，有没有办法显示地更紧凑呢？是有的，可以通过<code>--format=oneline</code>来设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">869cc0a22aea80d34f0728e184842bdea42fe43b (HEAD -&gt; master, origin/master, origin/HEAD) Merge pull request <span class="comment">#2353 from JohanMabille/chunk</span></span><br><span class="line">2e872840a7ebc3e4e8b0f84cbae39360503243b1 One xchunk_iterator to rule them all</span><br><span class="line">42fc49080522c94ea784541b53ef302ccb0344c0 Refactoring of xchunked_view</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>这下每条记录在一行显示，包括提交hash串，commit信息。</p><p>那么 git 支持哪些format参数呢，总结下来如下表：</p><table><tr><th>格式名称</th><th>格式说明</th></tr><tr><td><pre>oneline</pre></td><td><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">hash</span>&gt; &lt;title-line&gt;</span><br></pre></td></tr></table></figure></td></tr><tr><td><pre>short</pre></td><td><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">commit &lt;<span class="built_in">hash</span>&gt;</span><br><span class="line">Author: &lt;author&gt;</span><br><span class="line"></span><br><span class="line">&lt;title-line&gt;</span><br></pre></td></tr></table></figure></td></tr><tr><td><pre>medium</pre></td><td><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">commit &lt;<span class="built_in">hash</span>&gt;</span><br><span class="line">Author: &lt;author&gt;</span><br><span class="line">Date:   &lt;author-date&gt;</span><br><span class="line"></span><br><span class="line">&lt;title-line&gt;</span><br><span class="line"></span><br><span class="line">&lt;full-commit-message&gt;</span><br></pre></td></tr></table></figure></td></tr><tr><td><pre>full</pre></td><td><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">commit &lt;<span class="built_in">hash</span>&gt;</span><br><span class="line">Author: &lt;author&gt;</span><br><span class="line">Commit: &lt;committer&gt;</span><br><span class="line"></span><br><span class="line">&lt;title-line&gt;</span><br><span class="line"></span><br><span class="line">&lt;full-commit-message&gt;</span><br></pre></td></tr></table></figure></td></tr><tr><td><pre>fuller</pre></td><td><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">commit &lt;<span class="built_in">hash</span>&gt;</span><br><span class="line">Author:     &lt;author&gt;</span><br><span class="line">AuthorDate: &lt;author-date&gt;</span><br><span class="line">Commit:     &lt;committer&gt;</span><br><span class="line">CommitDate: &lt;committer-date&gt;</span><br><span class="line"></span><br><span class="line">&lt;title-line&gt;</span><br><span class="line"></span><br><span class="line">&lt;full-commit-message&gt;</span><br></pre></td></tr></table></figure></td></tr><tr><td><pre>reference</pre></td><td><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;abbrev-hash&gt; (&lt;title-line&gt;, &lt;short-author-date&gt;)</span><br></pre></td></tr></table></figure></td></tr><tr><td><pre>email</pre></td><td><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">From &lt;<span class="built_in">hash</span>&gt; &lt;date&gt;</span><br><span class="line">From: &lt;author&gt;</span><br><span class="line">Date: &lt;author-date&gt;</span><br><span class="line">Subject: [PATCH] &lt;title-line&gt;</span><br><span class="line"></span><br><span class="line">&lt;full-commit-message&gt;</span><br></pre></td></tr></table></figure></td></tr></table><p>还有一些别的选项，可以访问<a href="https://git-scm.com/docs/git-log#_pretty_formats">这里</a>详细了解。</p><h2 id="3-自定义显示"><a href="#3-自定义显示" class="headerlink" title="3. 自定义显示"></a>3. 自定义显示</h2><p>上述命令在某些情况下可能并不能满足我们的需求，比如<code>--format=oneline</code>选项没有显示提交时间。因此我们需要自定义log显示的方式。git提供了对commit信息中各部分的描述符号，可以让我们方便地自定义log显示。</p><p>下面列出了常见的选项：</p><table><thead><tr><th>选项</th><th>全称</th><th>含义</th></tr></thead><tbody><tr><td>%cd</td><td>commit date</td><td>提交日期</td></tr><tr><td>%H</td><td>Hash</td><td>commit 的完整哈希串</td></tr><tr><td>%h</td><td>hash</td><td>commit 的简短哈希串</td></tr><tr><td>%an</td><td>author name</td><td>提交者名字</td></tr><tr><td>%ae</td><td>author email</td><td>提交者邮箱</td></tr><tr><td>%s</td><td>message</td><td>提交信息</td></tr></tbody></table><p>利用这些描述符，我们可以定制log显示格式，比如<code>git log --format=&quot;%cd|%h|%an|%ae|%s&quot;</code> 就是显示提交日期，commit简短hash，提交者的名字和邮箱，以及提交内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2022-03-23 09:52:22 +0100|b2e23d05|Johan Mabille|johan.mabille@gmail.com|Merge pull request <span class="comment">#2497 from spectre-ns/master</span></span><br><span class="line">2022-03-18 20:59:53 -0300|a5a70449|spectre-ns|dahubley@hotmail.ca|Updated C++20 option <span class="keyword">for</span> visual studio builds C++2a no longer a valid std option.</span><br><span class="line">2022-03-18 10:59:57 +0100|f603205a|Johan Mabille|johan.mabille@gmail.com|Merge pull request <span class="comment">#2496 from JohanMabille/adapt_doc</span></span><br></pre></td></tr></table></figure><h2 id="4-命令组合"><a href="#4-命令组合" class="headerlink" title="4. 命令组合"></a>4. 命令组合</h2><p>git log最强大的地方在于可以组合上述所有的选项，大大缩小搜索范围，能更方便地定位到想要的提交。例如我通过下面的命令，可以将搜索范围从3711条缩小到6条：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有提交记录，共3177条</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline |wc</span><br><span class="line">3177   19594  159959</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加搜索过滤，只剩6条</span></span><br><span class="line">$ git <span class="built_in">log</span> --since=<span class="string">&quot;2020-01-01&quot;</span> --until=<span class="string">&quot;2020-02-01&quot;</span> --grep fix --oneline</span><br><span class="line">af5cc6c4 Merge pull request <span class="comment">#1904 from BioDataAnalysis/emmenlau_tiny_variable_name_fix</span></span><br><span class="line">0f3caa37 benchmark/CMakeLists.txt: fixed a tiny spelling mistake</span><br><span class="line">218dcbe7 Merge pull request <span class="comment">#1902 from kolibri91/fix_warning</span></span><br><span class="line">38cb9617 Merge pull request <span class="comment">#1886 from wolfv/fix_reshape_return</span></span><br><span class="line">31cbd6d2 Merge pull request <span class="comment">#1880 from wolfv/fix_older_cmake</span></span><br><span class="line">f363e9d1 fix older cmak</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;0-概述&quot;&gt;&lt;a href=&quot;#0-概述&quot; class=&quot;headerlink&quot; title=&quot;0. 概述&quot;&gt;&lt;/a&gt;0. 概述&lt;/h2&gt;&lt;p&gt;git log 是查看git提交记录的一个命令，它有非常多的控制参数和选项，合理使用的话，可以达到任何的精准控制目的。这里列一些日常使用可能会用到的用法，全部的用法，请在命令行&lt;code&gt;git help log&lt;/code&gt;查看。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>从Python传递参数到C++</title>
    <link href="http://vra.github.io/2022/03/20/cpp-read-binary-file-from-python/"/>
    <id>http://vra.github.io/2022/03/20/cpp-read-binary-file-from-python/</id>
    <published>2022-03-20T13:05:30.000Z</published>
    <updated>2022-03-20T14:02:56.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>有些场景下，需要将Python里面计算得到的参数或者结果传入到C++来进行工程部署。一个常见问题是，Python该以什么格式 (二进制还是文本) 保存这些参数，然后从C++代码里面来读取呢，各有什么优劣？这里我们简单实验一下，并写一些趁手的代码，供查阅。</p><span id="more"></span><h2 id="二进制格式和文本格式对比"><a href="#二进制格式和文本格式对比" class="headerlink" title="二进制格式和文本格式对比"></a>二进制格式和文本格式对比</h2><p>假设我们有一组参数是存储在Numpy的<code>ndarray</code>格式中的，为了在C++中使用，我们需要保存它们到硬盘的文件中。一般有两种保存方法：二进制文件保存和文本文件保存。</p><p>假设我们有一个1024x1024的浮点型参数待保存：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">params = np.random.rand(<span class="number">1024</span>, <span class="number">1024</span>).astype(<span class="string">&#x27;float32&#x27;</span>)</span><br></pre></td></tr></table></figure><p>二进制保存很简单，直接调用Numpy的<code>tofile</code>文件即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">params.tofile(<span class="string">&quot;params.bin&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果用文本文件保存，有两种保存方式，分别为调用<code>savetxt</code>函数和将每个值转换为<code>str</code>并用分隔符分开依次存入文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本文件保存方式1</span></span><br><span class="line">np.savetxt(<span class="string">&quot;params_1.txt&quot;</span>, params)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文本文件保存方式2</span></span><br><span class="line">delimiter = <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;params_2.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> params:</span><br><span class="line">        f.write(<span class="built_in">str</span>(p) + delimiter)</span><br></pre></td></tr></table></figure><p>猜猜看这三种情况分别大小是多少？</p><p>结论如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4.0M params.bin</span><br><span class="line">25M params_1.txt</span><br><span class="line">11M params_2.txt</span><br></pre></td></tr></table></figure><p>可以看到，二进制格式存储空间是最小的，分别是两种文本形式存储空间的16%和36%，存储压缩比例还是比较明显的。</p><p>因此推荐以二进制形式存储, 存储脚本简单总结如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># rand默认格式是float64，我们使用float32就可以</span></span><br><span class="line">params = np.random.rand(<span class="number">1024</span>, <span class="number">1024</span>).astype(<span class="string">&quot;float32&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉平成一维，为了在C++里面方便处理</span></span><br><span class="line">params = params.flatten()</span><br><span class="line"></span><br><span class="line">params.tofile(<span class="string">&quot;params.bin&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="C-读取二进制文件"><a href="#C-读取二进制文件" class="headerlink" title="C++ 读取二进制文件"></a>C++ 读取二进制文件</h2><p>C++ 去读二进制的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_binary</span><span class="params">(<span class="keyword">const</span> std::string &amp;file_path, <span class="keyword">float</span> *data, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  std::ifstream in_file;</span><br><span class="line">  in_file.<span class="built_in">open</span>(file_path, std::ios::binary | std::ios::in);</span><br><span class="line">  in_file.<span class="built_in">read</span>((<span class="keyword">char</span> *)data, size * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>));</span><br><span class="line">  in_file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string file_path = <span class="string">&quot;params.bin&quot;</span>;</span><br><span class="line">  <span class="keyword">int</span> size = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用stack上空间来创建数组，有大小限制，不推荐</span></span><br><span class="line">  <span class="comment">// float params[size];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用new来构建heap上空间, 无大小限制，但需要自己释放内存</span></span><br><span class="line">  <span class="keyword">float</span> *params = <span class="keyword">new</span> <span class="keyword">float</span>[size];</span><br><span class="line">  <span class="built_in">read_binary</span>(file_path, params, size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印前10个参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    std::cout &lt;&lt; params[i] &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>[] params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意新建数组的时候，有在栈上或者堆上构建两种方式，栈上构建有大小限制，如果数组维度太大就会报错，如下面的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行会报错:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ stack_over.cpp &amp;&amp; ./a.out</span><br><span class="line">[1]    89415 segmentation fault  ./a.out</span><br></pre></td></tr></table></figure><p>因此推荐用堆上创建数组，详见上述代码的注释。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;有些场景下，需要将Python里面计算得到的参数或者结果传入到C++来进行工程部署。一个常见问题是，Python该以什么格式 (二进制还是文本) 保存这些参数，然后从C++代码里面来读取呢，各有什么优劣？这里我们简单实验一下，并写一些趁手的代码，供查阅。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="C++" scheme="http://vra.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch模型转ONNX时cross操作不支持的解决方法</title>
    <link href="http://vra.github.io/2022/03/20/pytorch-cross-to-onnx/"/>
    <id>http://vra.github.io/2022/03/20/pytorch-cross-to-onnx/</id>
    <published>2022-03-20T10:34:46.000Z</published>
    <updated>2022-03-20T11:50:08.922Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Pytorch很灵活，支持各种OP和Python的动态语法。但是转换到onnx的时候，有些OP（目前）并不支持，比如<code>torch.cross</code>。这里以一个最小化的例子来演示这个过程，以及对应的解决办法。</p><span id="more"></span><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>考虑下面这个简单的Pytorch转ONNX的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file name: pytorch_cross_to_onnx.py</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModel</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MyModel, self).__init__()</span><br><span class="line">        self.conv = nn.Conv2d(<span class="number">3</span>, <span class="number">10</span>, <span class="number">3</span>, stride=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = torch.cross(x, x)</span><br><span class="line">        y = self.conv(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = MyModel()</span><br><span class="line"></span><br><span class="line">dummy_input = torch.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>, device=<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">input_names = [<span class="string">&quot;x&quot;</span>]</span><br><span class="line">output_names = [<span class="string">&quot;y&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># opset_version 选择范围：[7,15]</span></span><br><span class="line">torch.onnx.export(</span><br><span class="line">    model,</span><br><span class="line">    dummy_input,</span><br><span class="line">    <span class="string">&quot;my_model.onnx&quot;</span>,</span><br><span class="line">    input_names=input_names,</span><br><span class="line">    output_names=output_names,</span><br><span class="line">    opset_version=<span class="number">14</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>运行这个脚本，会报下面的错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ python3 pytorch_cross_to_onnx.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;pytorch_cross.py&quot;</span>, line 25, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    torch.onnx.export(model, dummy_input, <span class="string">&quot;my_model.onnx&quot;</span>, input_names=input_names, output_names=output_names, opset_version=14)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/__init__.py&quot;</span>, line 320, <span class="keyword">in</span> <span class="built_in">export</span></span><br><span class="line">    custom_opsets, enable_onnx_checker, use_external_data_format)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/utils.py&quot;</span>, line 111, <span class="keyword">in</span> <span class="built_in">export</span></span><br><span class="line">    custom_opsets=custom_opsets, use_external_data_format=use_external_data_format)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/utils.py&quot;</span>, line 729, <span class="keyword">in</span> _export</span><br><span class="line">    dynamic_axes=dynamic_axes)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/utils.py&quot;</span>, line 501, <span class="keyword">in</span> _model_to_graph</span><br><span class="line">    module=module)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/utils.py&quot;</span>, line 216, <span class="keyword">in</span> _optimize_graph</span><br><span class="line">    graph = torch._C._jit_pass_onnx(graph, operator_export_type)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/__init__.py&quot;</span>, line 373, <span class="keyword">in</span> _run_symbolic_function</span><br><span class="line">    <span class="built_in">return</span> utils._run_symbolic_function(*args, **kwargs)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/utils.py&quot;</span>, line 1028, <span class="keyword">in</span> _run_symbolic_function</span><br><span class="line">    symbolic_fn = _find_symbolic_in_registry(domain, op_name, opset_version, operator_export_type)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/utils.py&quot;</span>, line 982, <span class="keyword">in</span> _find_symbolic_in_registry</span><br><span class="line">    <span class="built_in">return</span> sym_registry.get_registered_op(op_name, domain, opset_version)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/symbolic_registry.py&quot;</span>, line 125, <span class="keyword">in</span> get_registered_op</span><br><span class="line">    raise RuntimeError(msg)</span><br><span class="line">RuntimeError: Exporting the operator cross to ONNX opset version 14 is not supported. Please feel free to request support or submit a pull request on PyTorch GitHub.</span><br></pre></td></tr></table></figure><p>注意最后一句的报错:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError: Exporting the operator cross to ONNX opset version 14 is not supported. Please feel free to request support or submit a pull request on PyTorch GitHub.</span><br></pre></td></tr></table></figure><p>也就是说目前版本是不支持<code>torch.cross</code>转onnx的，同时提示你”feel free” 去Pytorch 的 GitHub 上提交/贡献一个转换操作。不过2020年03月就有人提了<a href="https://github.com/onnx/onnx/issues/2683">issue</a>，至今仍没有g官方的解决方案。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>上面的issue里有人给出了解决思路，就是用元素相乘替代<code>cross</code>操作。具体来说，实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_cross</span>(<span class="params">x, y, dim=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">assert</span> x.dim() == y.dim() <span class="keyword">and</span> dim &lt; x.dim()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> torch.stack(</span><br><span class="line">        (</span><br><span class="line">            x[:, <span class="number">1</span>, ...] * y[:, <span class="number">2</span>, ...] - x[:, <span class="number">2</span>, ...] * y[:, <span class="number">1</span>, ...],</span><br><span class="line">            x[:, <span class="number">2</span>, ...] * y[:, <span class="number">0</span>, ...] - x[:, <span class="number">0</span>, ...] * y[:, <span class="number">2</span>, ...],</span><br><span class="line">            x[:, <span class="number">0</span>, ...] * y[:, <span class="number">1</span>, ...] - x[:, <span class="number">1</span>, ...] * y[:, <span class="number">0</span>, ...],</span><br><span class="line">        ),</span><br><span class="line">        dim=dim,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p><strong>注意：这里是以dim=1为例写的实现，如果是在别的维度进行cross操作，需要修改dim参数，同时修改对应stack的维度。</strong></p><p>同时在Pytorch doc网站上看到，如果<code>torch.cross</code>不指定<code>dim</code>参数的话，默认是从前往后找第一个维度为3的维度，因此这个可能是你所不期望的，建议显式指定这个参数。</p><p>因此总结下来，下面是修改后的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_cross</span>(<span class="params">x, y, dim=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">assert</span> x.dim() == y.dim() <span class="keyword">and</span> dim &lt; x.dim()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> torch.stack(</span><br><span class="line">        (</span><br><span class="line">            x[:, <span class="number">1</span>, ...] * y[:, <span class="number">2</span>, ...] - x[:, <span class="number">2</span>, ...] * y[:, <span class="number">1</span>, ...],</span><br><span class="line">            x[:, <span class="number">2</span>, ...] * y[:, <span class="number">0</span>, ...] - x[:, <span class="number">0</span>, ...] * y[:, <span class="number">2</span>, ...],</span><br><span class="line">            x[:, <span class="number">0</span>, ...] * y[:, <span class="number">1</span>, ...] - x[:, <span class="number">1</span>, ...] * y[:, <span class="number">0</span>, ...],</span><br><span class="line">        ),</span><br><span class="line">        dim=dim,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModel</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MyModel, self).__init__()</span><br><span class="line">        self.conv = nn.Conv2d(<span class="number">3</span>, <span class="number">10</span>, <span class="number">3</span>, stride=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># x = torch.cross(x, x)</span></span><br><span class="line">        x = my_cross(x, x)</span><br><span class="line">        y = self.conv(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = MyModel()</span><br><span class="line"></span><br><span class="line">dummy_input = torch.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>, device=<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">output = model(dummy_input)</span><br><span class="line">input_names = [<span class="string">&quot;x&quot;</span>]</span><br><span class="line">output_names = [<span class="string">&quot;y&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># opset_version 选择范围：[7,15]</span></span><br><span class="line">torch.onnx.export(</span><br><span class="line">    model,</span><br><span class="line">    dummy_input,</span><br><span class="line">    <span class="string">&quot;my_model.onnx&quot;</span>,</span><br><span class="line">    input_names=input_names,</span><br><span class="line">    output_names=output_names,</span><br><span class="line">    opset_version=<span class="number">14</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>为了验证我们的实现与Pytorch的实现是否一致，可以用下面的函数验证:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_torch_cross_and_my_cross</span>():</span></span><br><span class="line">    x = torch.randn(<span class="number">10</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">    y = torch.randn(<span class="number">10</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;my_cross == torch.cross:&quot;</span>, torch.allclose(torch.cross(x, y), my_cross(x, y)))</span><br></pre></td></tr></table></figure><p>执行后输出如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_cross == torch.cross: True</span><br></pre></td></tr></table></figure><p>说明这个实现是正确的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://github.com/onnx/onnx/issues/2683">https://github.com/onnx/onnx/issues/2683</a></li><li><a href="https://pytorch.org/docs/stable/generated/torch.cross.html">https://pytorch.org/docs/stable/generated/torch.cross.html</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Pytorch很灵活，支持各种OP和Python的动态语法。但是转换到onnx的时候，有些OP（目前）并不支持，比如&lt;code&gt;torch.cross&lt;/code&gt;。这里以一个最小化的例子来演示这个过程，以及对应的解决办法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="Deep Learning" scheme="http://vra.github.io/tags/Deep-Learning/"/>
    
    <category term="Pytorch" scheme="http://vra.github.io/tags/Pytorch/"/>
    
    <category term="ONNX" scheme="http://vra.github.io/tags/ONNX/"/>
    
    <category term="Torchscript" scheme="http://vra.github.io/tags/Torchscript/"/>
    
  </entry>
  
</feed>
