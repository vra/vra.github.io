<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yunfeng&#39;s Simple Blog</title>
  
  <subtitle>Love, Life, Linux</subtitle>
  <link href="http://vra.github.io/atom.xml" rel="self"/>
  
  <link href="http://vra.github.io/"/>
  <updated>2022-12-19T15:46:55.254Z</updated>
  <id>http://vra.github.io/</id>
  
  <author>
    <name>Yunfeng Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git 更新历史提交</title>
    <link href="http://vra.github.io/2022/12/16/git-update-a-history-commit/"/>
    <id>http://vra.github.io/2022/12/16/git-update-a-history-commit/</id>
    <published>2022-12-16T01:01:45.000Z</published>
    <updated>2022-12-19T15:46:55.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>有时候我们在git commit后才发现，之前的一些提交有些问题，比如有些代码忘提交了或者有一些typo需要修改。如果要修改的地方是需要添加到最后一次提交上的，那么可以参考我的<a href="https://vra.github.io/2022/11/12/git-add-file-to-last-commit/">这篇博文</a>修改，如果是在非最后一次提交上的，那么就需要用<code>git rebase</code>来操作。这里简单记录一下操作的过程。</p><p><strong>TL;DR</strong><br>操作命令简要来说是这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用git log 查看历史提交，得到需要修改的那次提交的commit id</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 执行rebase命令，注意&lt;commit-id&gt;后面有一个^，表示修改在此次提交前</span></span><br><span class="line">git rebase -i <span class="string">&#x27;&lt;commmit-hash&gt;^&#x27;</span> <span class="comment"># 如果是修改第一次提交，使用 git rebase -i --root</span></span><br><span class="line"><span class="comment"># 修改代码</span></span><br><span class="line">vim changed-file</span><br><span class="line"><span class="comment"># git add 添加更新后的文件</span></span><br><span class="line">git add changed-file</span><br><span class="line"><span class="comment"># git commit 提交，注意需要使用后面三个选项，并且不需要加commit信息，因为会采用之前的commit信息</span></span><br><span class="line">git commit --all --amend --no-edit</span><br><span class="line"><span class="comment"># 使用--continue来完成 git rebase</span></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>后面会使用一个具体的（假）例子来演示这个过程。</p><span id="more"></span><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>假设我们创建了一个代码仓库<code>my_project</code>，先后创建并提交了<code>README.md</code>和<code>main.py</code>文件，但发现第一次的提交里面有一个typo，例如比<code>math</code>打成了<code>meth</code>，现在想要修改第一次提交。</p><p>首先构造”案发现场”:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir my_project &amp;&amp; <span class="built_in">cd</span> my_project</span><br><span class="line">git init</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is my meth library&quot;</span> &gt;&gt; README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;doc: add readme&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;import numpy as np&quot;</span> &gt;&gt; main.py</span><br><span class="line">git add main.py</span><br><span class="line">git commit -m <span class="string">&quot;feat: create main.py&quot;</span></span><br></pre></td></tr></table></figure><p>注意上面的typo <code>meth</code>。</p><p>我们发现了上述问题，但不想新建一个提交来修复，因为确实不算是新功能，那么就用<code>git rebase</code>来完成吧。</p><p>git rebase 是用来修改git commit的命令，提供了非常多的功能。这里我们用<code>git rebase -i</code>来交互式地修改某次commit。</p><p>首先用 <code>git log</code>查看commit ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">* 9bec788 - (HEAD -&gt; main) add sigmoid (31 minutes ago) &lt;xyz&gt;</span><br><span class="line">* ea833e9 - doc: add doc (31 minutes ago) &lt;xyz&gt;</span><br></pre></td></tr></table></figure><p>假如要修改第二次提交，那我们可以用<code>git rebase -i &#39;9bec788^</code>，但我们要修改的是第一次提交，没有之前的状态，所以要用下面的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i --root</span><br><span class="line">Successfully rebased and updated refs/heads/main.</span><br></pre></td></tr></table></figure><p>出来的交互式界面:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pick ea833e9 doc: add doc</span><br><span class="line">pick 9bec788 add sigmoid</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase 9bec788 onto 927493a (2 commands)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment"># p, pick &lt;commit&gt; = use commit</span></span><br><span class="line"><span class="comment"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment"># e, edit &lt;commit&gt; = use commit, but stop for amending</span></span><br><span class="line"><span class="comment"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment"># f, fixup [-C | -c] &lt;commit&gt; = like &quot;squash&quot; but keep only the previous</span></span><br><span class="line"><span class="comment">#                    commit&#x27;s log message, unless -C is used, in which case</span></span><br><span class="line"><span class="comment">#                    keep only this commit&#x27;s message; -c is same as -C but</span></span><br><span class="line"><span class="comment">#                    opens the editor</span></span><br><span class="line"><span class="comment"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span></span><br><span class="line"><span class="comment"># d, drop &lt;commit&gt; = remove commit</span></span><br><span class="line"><span class="comment"># l, label &lt;label&gt; = label current HEAD with a name</span></span><br><span class="line"><span class="comment"># t, reset &lt;label&gt; = reset HEAD to a label</span></span><br><span class="line"><span class="comment"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span><br><span class="line"><span class="comment">#         create a merge commit using the original merge commit&#x27;s</span></span><br><span class="line"><span class="comment">#         message (or the oneline, if no original merge commit was</span></span><br><span class="line"><span class="comment">#         specified); use -c &lt;commit&gt; to reword the commit message</span></span><br><span class="line"><span class="comment"># u, update-ref &lt;ref&gt; = track a placeholder for the &lt;ref&gt; to be updated</span></span><br><span class="line"><span class="comment">#                       to this position in the new commits. The &lt;ref&gt; is</span></span><br><span class="line"><span class="comment">#                       updated at the end of the rebase</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br></pre></td></tr></table></figure><p>底下注释中给出了rebase支持的一些命令和对应的缩写，我们将需要修改的提交前面的命令修改为<code>edit</code>，然后保存退出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">edit ea833e9 doc: add doc</span><br><span class="line">pick 9bec788 add sigmoid</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase 9bec788 onto e3f4cea (2 commands)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment"># p, pick &lt;commit&gt; = use commit</span></span><br><span class="line"><span class="comment"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment"># e, edit &lt;commit&gt; = use commit, but stop for amending</span></span><br><span class="line"><span class="comment"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment"># f, fixup [-C | -c] &lt;commit&gt; = like &quot;squash&quot; but keep only the previous</span></span><br><span class="line"><span class="comment">#                    commit&#x27;s log message, unless -C is used, in which case</span></span><br><span class="line"><span class="comment">#                    keep only this commit&#x27;s message; -c is same as -C but</span></span><br><span class="line"><span class="comment">#                    opens the editor</span></span><br><span class="line"><span class="comment"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span></span><br><span class="line"><span class="comment"># d, drop &lt;commit&gt; = remove commit</span></span><br><span class="line"><span class="comment"># l, label &lt;label&gt; = label current HEAD with a name</span></span><br><span class="line"><span class="comment"># t, reset &lt;label&gt; = reset HEAD to a label</span></span><br><span class="line"><span class="comment"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span><br><span class="line"><span class="comment">#         create a merge commit using the original merge commit&#x27;s</span></span><br><span class="line"><span class="comment">#         message (or the oneline, if no original merge commit was</span></span><br><span class="line"><span class="comment">#         specified); use -c &lt;commit&gt; to reword the commit message</span></span><br><span class="line"><span class="comment"># u, update-ref &lt;ref&gt; = track a placeholder for the &lt;ref&gt; to be updated</span></span><br><span class="line"><span class="comment">#                       to this position in the new commits. The &lt;ref&gt; is</span></span><br><span class="line"><span class="comment">#                       updated at the end of the rebase</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span><br></pre></td></tr></table></figure><p>保存后输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stopped at ea833e9...  doc: add doc</span><br><span class="line">You can amend the commit now, with</span><br><span class="line"></span><br><span class="line">  git commit --amend</span><br><span class="line"></span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line"></span><br><span class="line">  git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>用<code>git status</code> 查看代码状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interactive rebase <span class="keyword">in</span> progress; onto e3f4cea</span><br><span class="line">Last <span class="built_in">command</span> <span class="keyword">done</span> (1 <span class="built_in">command</span> <span class="keyword">done</span>):</span><br><span class="line">   edit ea833e9 doc: add doc</span><br><span class="line">Next <span class="built_in">command</span> to <span class="keyword">do</span> (1 remaining <span class="built_in">command</span>):</span><br><span class="line">   pick 9bec788 add sigmoid</span><br><span class="line">  (use <span class="string">&quot;git rebase --edit-todo&quot;</span> to view and edit)</span><br><span class="line">You are currently editing a commit <span class="keyword">while</span> rebasing branch <span class="string">&#x27;main&#x27;</span> on <span class="string">&#x27;e3f4cea&#x27;</span>.</span><br><span class="line">  (use <span class="string">&quot;git commit --amend&quot;</span> to amend the current commit)</span><br><span class="line">  (use <span class="string">&quot;git rebase --continue&quot;</span> once you are satisfied with your changes)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>git 的提示信息还是很丰富的，按照提示来操作代码，将<code>meth</code> 修改为<code>math</code>，再<code>git add</code>, <code>git commit --all --amend --no-edit</code>和 <code>git rebase --continue</code> 来结束rebase:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git add README.md</span><br><span class="line"></span><br><span class="line">$ git commit --all --amend --no-edit</span><br><span class="line">[detached HEAD 3b83a85] doc: add doc</span><br><span class="line"> Date: Sat Dec 17 18:00:12 2022 +0800</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br><span class="line"> create mode 100644 README.md</span><br><span class="line"></span><br><span class="line">$ git rebase --<span class="built_in">continue</span></span><br><span class="line">Successfully rebased and updated refs/heads/main.</span><br></pre></td></tr></table></figure><p>然后用<code>git log</code>查看命令，可以看到修改的那次提交和后续提交的编号都已经更新了，意味着这是全新的提交，跟之前的提交没有关系了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;有时候我们在git commit后才发现，之前的一些提交有些问题，比如有些代码忘提交了或者有一些typo需要修改。如果要修改的地方是需要添加到最后一次提交上的，那么可以参考我的&lt;a href=&quot;https://vra.github.io/2022/11/12/git-add-file-to-last-commit/&quot;&gt;这篇博文&lt;/a&gt;修改，如果是在非最后一次提交上的，那么就需要用&lt;code&gt;git rebase&lt;/code&gt;来操作。这里简单记录一下操作的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;&lt;br&gt;操作命令简要来说是这样:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 使用git log 查看历史提交，得到需要修改的那次提交的commit id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 执行rebase命令，注意&amp;lt;commit-id&amp;gt;后面有一个^，表示修改在此次提交前&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git rebase -i &lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;lt;commmit-hash&amp;gt;^&amp;#x27;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# 如果是修改第一次提交，使用 git rebase -i --root&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 修改代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vim changed-file&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# git add 添加更新后的文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git add changed-file&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# git commit 提交，注意需要使用后面三个选项，并且不需要加commit信息，因为会采用之前的commit信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit --all --amend --no-edit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 使用--continue来完成 git rebase&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git rebase --&lt;span class=&quot;built_in&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;后面会使用一个具体的（假）例子来演示这个过程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>使用 defaultdict 来简化 dict 的初始化</title>
    <link href="http://vra.github.io/2022/12/10/python-defaultdict-usage/"/>
    <id>http://vra.github.io/2022/12/10/python-defaultdict-usage/</id>
    <published>2022-12-10T07:17:17.000Z</published>
    <updated>2022-12-10T07:57:10.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在我们使用Python中的dict时，常常需要判断某个关键字是否已经在dict中，如果不存在则创建，非空则进行另外的操作。例如统计一篇文章中所有单词出现次数的代码，大致写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">words_num = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> words_num.keys():</span><br><span class="line">        words_num[word] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        words_num[word] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样写总是需要判断key是否在dict中，不是很优雅。</p><p>Python标准库collections中<a href="https://docs.python.org/3/library/collections.html#defaultdict-objects">defaultdict</a>类可以很好的解决这个问题。这个类使用与dict几乎一样，除了可以在初始化时设置key的默认类型和数值。类的声明格式为<code>defaultdict(default_factory=None, /[, ...])</code>，<code>default_factory</code>是一个<code>callable</code>的变量。</p><p>别的使用与dict无异，正常使用即可。</p><span id="more"></span><p>例如，<code>foo = defaultdict(int)</code>表示foo中的key的默认类型是int，且默认值为int的默认值0，我们可以获取<strong>任意</strong>的key，不需要手动初始化key:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;whatever&#x27;</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>所以最开始的例子可以简化为如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">words_num = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    words_num[word] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看到使用defaultdict后，代码中只需要关注上层逻辑（统计单词的出现次数），而不需要关注具体的语法的代码实现（dict是否存在某个key，没有的话xxx，有的话xxx），因此世界变得更美好了一些。</p><p>除了int外，用list，tuple，dict，set等作为变量也比较常见。除了内置类型外，还可以自定义函数，比如设置key的默认值为<code>&#39;China&#39;</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_default_contry</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">&quot;China&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from = defaultdict(set_default_contry)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from[<span class="string">&#x27;张三&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;China&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from[<span class="string">&#x27;李四&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;China&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from[<span class="string">&#x27;Tim&#x27;</span>] = <span class="string">&#x27;USA&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from</span><br><span class="line">defaultdict(&lt;function set_default_contry at <span class="number">0x10896eca0</span>&gt;, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;China&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>: <span class="string">&#x27;China&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>: <span class="string">&#x27;China&#x27;</span>, <span class="string">&#x27;Tim&#x27;</span>: <span class="string">&#x27;USA&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p><code>defauldict</code>是一个简单但很好用的功能，在日常的使用中还是能减少一些代码复杂度的。希望这篇小文能给让你写代码更容易，更开心。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;在我们使用Python中的dict时，常常需要判断某个关键字是否已经在dict中，如果不存在则创建，非空则进行另外的操作。例如统计一篇文章中所有单词出现次数的代码，大致写法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;words_num = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; word &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; words:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; word &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; words_num.keys():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        words_num[word] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        words_num[word] += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样写总是需要判断key是否在dict中，不是很优雅。&lt;/p&gt;
&lt;p&gt;Python标准库collections中&lt;a href=&quot;https://docs.python.org/3/library/collections.html#defaultdict-objects&quot;&gt;defaultdict&lt;/a&gt;类可以很好的解决这个问题。这个类使用与dict几乎一样，除了可以在初始化时设置key的默认类型和数值。类的声明格式为&lt;code&gt;defaultdict(default_factory=None, /[, ...])&lt;/code&gt;，&lt;code&gt;default_factory&lt;/code&gt;是一个&lt;code&gt;callable&lt;/code&gt;的变量。&lt;/p&gt;
&lt;p&gt;别的使用与dict无异，正常使用即可。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>git如何添加文件到最新的提交</title>
    <link href="http://vra.github.io/2022/11/12/git-add-file-to-last-commit/"/>
    <id>http://vra.github.io/2022/11/12/git-add-file-to-last-commit/</id>
    <published>2022-11-12T09:54:22.000Z</published>
    <updated>2022-12-16T00:54:01.016Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，在git commit后，我们会发现一些文件忘了提交了，或者需要修改，而且这些提交和修改是与上一次commit的主题一致的，这时候再执行一遍相同的git commit就会让提交记录显得比较冗余，有没有办法将修改后的文件加到最后一次的提交记录里面呢？搜索后发现<a href="https://stackoverflow.com/a/40503483">这里</a>给了一个解决办法，git add文件后调用<code>git commit --amend -no-edit</code>即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file_path&gt;</span><br><span class="line">git commit --amend --no-edit</span><br></pre></td></tr></table></figure><p><strong>注意：如果之前的代码已经提交的话，需要执行<code>git push --force</code>来推送代码以替代之前的提交记录。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有时候，在git commit后，我们会发现一些文件忘了提交了，或者需要修改，而且这些提交和修改是与上一次commit的主题一致的，这时候再执行一遍相同的git commit就会让提交记录显得比较冗余，有没有办法将修改后的文件加到最后一次的提交记录里面呢？搜索后发现&lt;a h</summary>
      
    
    
    
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
    <category term="TIL" scheme="http://vra.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>执行du命令时统计隐藏文件和目录</title>
    <link href="http://vra.github.io/2022/11/07/du-show-hidden-folders/"/>
    <id>http://vra.github.io/2022/11/07/du-show-hidden-folders/</id>
    <published>2022-11-07T15:32:23.000Z</published>
    <updated>2022-11-07T15:38:24.784Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux和Mac下，执行<code>du -sh</code> 来统计目录大小时，默认不统计以点开头的文件或者目录，比如<code>.local</code>，因此得到不准确的统计结果。从<a href="https://superuser.com/a/633808">这里</a>知道，要统计隐藏文件和目录，可以这么用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只统计隐藏文件或者目录</span></span><br><span class="line">du -sh .[^.]*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计隐藏文件或者目录和常规文件</span></span><br><span class="line">du -sh .[^.]* *</span><br></pre></td></tr></table></figure><p>结合 <code>sort -h</code>，可以快速得到比较大的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh .[^.]* * |sort -h</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Linux和Mac下，执行&lt;code&gt;du -sh&lt;/code&gt; 来统计目录大小时，默认不统计以点开头的文件或者目录，比如&lt;code&gt;.local&lt;/code&gt;，因此得到不准确的统计结果。从&lt;a href=&quot;https://superuser.com/a/633808&quot;&gt;</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="TIL" scheme="http://vra.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>如何举办一个顶会学术比赛</title>
    <link href="http://vra.github.io/2022/10/30/how-to-host-a-challenge/"/>
    <id>http://vra.github.io/2022/10/30/how-to-host-a-challenge/</id>
    <published>2022-10-30T12:34:41.000Z</published>
    <updated>2022-10-30T16:13:55.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>今年我和团队成员一起组织了了ECCV上的一个<a href="https://sites.google.com/view/wcpa2022/home">学术比赛</a>。从1.31日开始准备材料开始，到前两天(10.28日) 把奖金和奖状发给选手，活动结束，整个周期持续了近9个月，真的是出乎意料。整体流程包括Workshop Proposal编写和申请、Workshop合并（多个申请团队合并成一个Workshop），网站搭建，比赛数据和baseline准备，比赛平台搭建，比赛奖金申请，比赛宣传和选手招募、比赛论文评审、参加线上Workshop介绍比赛，奖金和证书颁发等等，第一次参与组织这种比赛，学到了挺多东西，这里记录备忘，下次参考。需要说明的是，这里的分享的都是个人观点，与我所在公司无关。</p><span id="more"></span><h2 id="2-时间流水线记录"><a href="#2-时间流水线记录" class="headerlink" title="2. 时间流水线记录"></a>2. 时间流水线记录</h2><p>这里记录整个过程中的一些关键行动和一些注意事项。</p><h3 id="2-1-前期准备"><a href="#2-1-前期准备" class="headerlink" title="2.1. 前期准备"></a>2.1. 前期准备</h3><p>首先要注意，要申办Workshop或者比赛的话，涉及事务多，需要一个团队来共同来负责，而且周期长，占用时间比较多，办比赛的话还需要奖金的申请，这些都需要团队Leader的理解和支持。同时需要一些学术界有声望的教授来一起参与，这样申请通过的概率会大一些。我们组内有跟学术界的长期合作，这次也是一起申办的。另一个是比赛一般需要新的数据集，有内部的数据团队或者合作的数据公司也会更好一些，分担一些数据收集和准备的任务。<br>有这些条件后，还是得思考Workshop或者比赛的主题，也就是为了解决学术界还是工业界的什么核心问题，来举办这样一个比赛。这样比赛意义会更重大，参赛选手的方案也许能推进某个方向的SOTA。</p><p>确定要举办Workshop或者比赛后，就需要盘点参与人员，提前联系学术界和数据公司的合作方，通通气，确认参与意向。</p><h3 id="2-2-撰写-Workshop-Proposal"><a href="#2-2-撰写-Workshop-Proposal" class="headerlink" title="2.2 撰写 Workshop Proposal"></a>2.2 撰写 Workshop Proposal</h3><p>接下来就需要写 Workshop Proposal给大会，大会收到后通过申请，才可以正式举办 Workshop。</p><p>Workshop Proposal 的撰写参考大会给的要求，填写workshop主体，比赛任务描述和对应的指标描述，主办者的资料等。</p><h3 id="2-3-嘉宾邀请"><a href="#2-3-嘉宾邀请" class="headerlink" title="2.3 嘉宾邀请"></a>2.3 嘉宾邀请</h3><p>为了让Workshop Proprasl更容易通过，需要邀请一些学术界有声望的教授，作为Workshop的主席。同时还需要邀请一些人来做邀请嘉宾作报告。</p><h3 id="2-4-合并-Workshop"><a href="#2-4-合并-Workshop" class="headerlink" title="2.4. 合并 Workshop"></a>2.4. 合并 Workshop</h3><p>Proposal 提交上去后，主办方可能会反馈workshop申请太多，需要合并某几个workshop团队，一起举办一个workshop。这时候就需要团队一起讨论来决定了。最后我们和意大利的一个大学合办workshop，他们负责regular paper的接收和评审，我们负责challenge比赛部分。除了邮件沟通外，IM采用slack，整体使用还比较方便，双方用英文沟通。</p><h3 id="2-5-比赛网站构建"><a href="#2-5-比赛网站构建" class="headerlink" title="2.5. 比赛网站构建"></a>2.5. 比赛网站构建</h3><p>确定负责比赛后，我们制定了比赛的流程，包括什么时候开放队伍注册，测评服务开启，第一阶段和第二阶段，技术报告什么时候提交，workshop举办日期等。还有最重要的，奖金是多少。具体金额需要和宣传和财务部分确定。同时还有参赛者的条件，比如是否允许企业参加，是否允许公司内部人士参加等。所有这些信息都发布到比赛网站上，保证在宣传开始的时候，参赛者看到的是一个日期完整、奖金和名额分布清晰的比赛。</p><h3 id="2-6-比赛数据准备"><a href="#2-6-比赛数据准备" class="headerlink" title="2.6. 比赛数据准备"></a>2.6. 比赛数据准备</h3><p>数据需要按照train, validation, test 集合准备好，分validation和test是为了避免参赛者过拟合，可以在第一阶段用validation集，第二阶段用test集，筛选出啊泛化性更好的方案。</p><p>如有必要，参赛选手需要签署一份数据协议才能使用数据，协议内容可以包括选手只有数据的使用权，没有分发权等等，视你们的数据要求而定。</p><p>数据准备好后上传到网盘平台，为了保证国内外选手都可以访问，可以上传国内国外的多个平台。同时如有必要，对数据进行加密，只有签署了数据协议的人才可以解压数据，避免数据的泄漏。</p><h3 id="2-7-参赛选手审核"><a href="#2-7-参赛选手审核" class="headerlink" title="2.7 参赛选手审核"></a>2.7 参赛选手审核</h3><p>参赛选手需要是研究机构的，所以我们要求报名时填写学校邮箱，注明单位信息，提交数据声明。这些信息审核通过后，回复邮件确认。</p><h3 id="2-8-测评服务搭建与baseline准备"><a href="#2-8-测评服务搭建与baseline准备" class="headerlink" title="2.8. 测评服务搭建与baseline准备"></a>2.8. 测评服务搭建与baseline准备</h3><p>比赛平台可以选择公开的平台，Kaggle，CoLab，也可以选公司的平台。因为CV顶会的比赛面向的是全球的CVer，因此尽量选择中英文都支持的平台。</p><p>平台选择后，需要部署Evaluation Server，也就是参赛者上传代码或者输出，拿到分数的服务。首先需要确定输入和输出，以及最终榜单排名的评价指标，这部分需要在比赛开始的时候就在Workshop Propoal里面写出来，这里需要用具体的代码来实现出来。具体代码测评可以用平台已有的接口，因为大平台任务很多，接口都比较成熟。</p><p>然后在比赛网站写详细的教程，指导参赛者怎么下载数据、理解数据、跑baseline、提交结果、查看榜单。最好是给出一个quick start或者可以直接跑的代码，让参赛者能完整地走完流程，提交一个baseline的结果。</p><h3 id="2-9-比赛宣传和选手招募"><a href="#2-9-比赛宣传和选手招募" class="headerlink" title="2.9. 比赛宣传和选手招募"></a>2.9. 比赛宣传和选手招募</h3><p>比赛建立起来后，需要对比赛进行宣传，让更多的人来加入。这时候可以发表公司或部门的公众号文章来进行宣传，同时也可以针对专门的打比赛群和网站来找专门的人来宣传，比如在xxx公众号发表一篇相关的文章，不过大号价格都毕竟贵。</p><p>另外可以让实习生或者同学、学弟学妹在学校的论坛、BBS、系里面的群、实验室的群里面进行宣传。</p><h3 id="2-10-选手答疑"><a href="#2-10-选手答疑" class="headerlink" title="2.10. 选手答疑"></a>2.10. 选手答疑</h3><p>针对选手的问题，需要及时回复，如果是有共性的问题，要在论坛上或者网站上进行通知，让所有人都知道，也避免每个人都来问一遍。</p><h3 id="2-11-论文评审与代码查重"><a href="#2-11-论文评审与代码查重" class="headerlink" title="2.11. 论文评审与代码查重"></a>2.11. 论文评审与代码查重</h3><p>比赛结束后，参赛队伍需要提交一份比赛方案介绍的Report，来描述他们的方法，同时为了避免作弊，可能还需要参赛者上传一份代码，这里就涉及到对Report的评审和代码的查重。代码查重好做，利用查重软件或者类似工具就可以，Report的评审还需要花比较多时间来做。</p><p>我认为比赛Report评审的核心是比赛方案的介绍是否清楚，包括输入输出是否符合规范，网络细节、训练测试过程、超参是否描述清楚，数值对比和ablation study是否充分等等。与常规论文不同，比赛Report的创新性的占比其实不是太高的。</p><p>评审完后需要写反馈意见，确定论文是否被接收。是否接收需要综合考虑论文的质量和比赛的排名。尽可能写一些有用的comments给作者，然后参赛者写Camera Ready版本。</p><p>如果比赛论文走大会的proceeding的话，需要提醒作者注册大会，尽早购买早鸟票，因为作者不注册的话论文不能正常发表。一般一篇论文有一个作者注册大会就可以，所以在Camera Ready版本中可以添加中了正会论文的作者进来。</p><h3 id="2-12-比赛名次确定"><a href="#2-12-比赛名次确定" class="headerlink" title="2.12. 比赛名次确定"></a>2.12. 比赛名次确定</h3><p>在论文评审完后，需要根据是否存在违规和论文来确定最终的名次，不符合规定的团队不参与最终的排名，由后面的队伍补上。名次确定后需要在比赛网站上公示，让所有参赛者周知。</p><h3 id="2-13-Workshop比赛介绍与Winner-Talk-Host"><a href="#2-13-Workshop比赛介绍与Winner-Talk-Host" class="headerlink" title="2.13. Workshop比赛介绍与Winner Talk Host"></a>2.13. Workshop比赛介绍与Winner Talk Host</h3><p>在Workshop召开的时候，需要有一个人来做演讲介绍整个比赛，可以包括Organizers介绍，比赛背景，数据集情况，任务介绍，参与情况，以及获奖团队的介绍。这个部分的Slides组织可以参考历年CV顶会上的比赛介绍视频，学习他们做的比较好的地方。</p><p>比赛介绍完后，会议的主持人可能还会让你主持Winner Talk，所以提前准备下，介绍一下演讲团队，提一些问题，Move to next speaker等，讲完后对比赛做一个总结。</p><p>这里有一个细节，就是不需要比赛主办的所有成员都需要注册大会（注册大会费用很高），只要一个人注册，在大会网站上拿到zoom会议的链接后，可以发送给别的主办者，让他们加入zoom会议来演讲或者观看。</p><h3 id="2-14-奖金与证书颁发"><a href="#2-14-奖金与证书颁发" class="headerlink" title="2.14. 奖金与证书颁发"></a>2.14. 奖金与证书颁发</h3><p>奖金发放需要获奖者填写一张银行卡信息来收钱。这里需要保证团队的所有人都知情，避免一个队员填写自己的银行卡信息而未经别的组员同意，产生的纠纷。一些解决办法是大家签署奖金发放同意书，或者邮件抄送所有队员。</p><p>证书颁发涉及到证书制作，证书制作需要一个证书模板，可以采用Office网站上的<a href="https://templates.office.com/zh-cn/%e8%af%81%e4%b9%a6">证书模板</a>，选择喜欢的来修改。具体内容可以搜索一下CVPR，ICCV和ECCV这些大会往年的证书图片，自己参考下，或者让公司的设计团队来制作一个。制作好后可以发送电子版，如果可以线下举办的话，制作一份纸质版颁发给参赛者。</p><h2 id="3-感想"><a href="#3-感想" class="headerlink" title="3. 感想"></a>3. 感想</h2><h3 id="3-1-举办-Workshop的意义"><a href="#3-1-举办-Workshop的意义" class="headerlink" title="3.1 举办 Workshop的意义"></a>3.1 举办 Workshop的意义</h3><p>对于公司来说，如果能举办一个受欢迎的Workshop或者比赛，既可以宣传公司，也可以招揽一些参赛选手，同时如果比赛的方案如果能对业务中的难题有一些启发，那就更好了。<br>对于个人来说，参与举办Workshop绝对是一次受益颇多的经历。首先是锻炼沟通能力。此次过程中，沟通的团队包括自己团队、国内国外高校老师、合作公司、公司内部宣传部门、比赛平台部门、网盘部门、参赛选手，如何有效沟通，在规定的时间里高效地完成既定目标，如何避免突发事故，都很考验我们的沟通能力。同时是锻炼组织能力，比赛消息怎么传递给参赛者，面对参赛者的延期请求怎么处理，都是之前做research写代码没有遇到过的问题。最后还是英文的文档撰写和交流能力的提升，以及参与Workshop时对自身学术能力的提升。我觉得通过这样一次活动，对以后怎么组织类似的活动有信心了，也相信以后能组织好同样的活动。</p><h3 id="3-2-一些经验总结"><a href="#3-2-一些经验总结" class="headerlink" title="3.2 一些经验总结"></a>3.2 一些经验总结</h3><ul><li>决定尽早做，涉及到某些流程和方案修改的，需要尽早决定，不拖延，因为拖延意味着某些人还在按之前的方案进行，浪费了时间和精力，做了无用功</li><li>信息公布尽量做到公开透明，让需要了解的各方都了解变更，因为各方的意见可能不同，或者有更好的解决办法</li><li>每支队伍要设置一个固定的联络人，从始至终保持不变（特殊情况除外），并保证联络人能联系上，也就是有联络人的钉钉微信邮箱和电话，保证紧急情况下能联系上ta，由ta来进一步联络队员</li><li>对于参赛者的一些请求，如延长比赛时间，需要站在大多人参赛者的角度考虑，同时避免修改后影响后续流程。实际上每个修改在某些方面都是有积极意义的，这里需要做一些符合大家利益的取舍</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;今年我和团队成员一起组织了了ECCV上的一个&lt;a href=&quot;https://sites.google.com/view/wcpa2022/home&quot;&gt;学术比赛&lt;/a&gt;。从1.31日开始准备材料开始，到前两天(10.28日) 把奖金和奖状发给选手，活动结束，整个周期持续了近9个月，真的是出乎意料。整体流程包括Workshop Proposal编写和申请、Workshop合并（多个申请团队合并成一个Workshop），网站搭建，比赛数据和baseline准备，比赛平台搭建，比赛奖金申请，比赛宣传和选手招募、比赛论文评审、参加线上Workshop介绍比赛，奖金和证书颁发等等，第一次参与组织这种比赛，学到了挺多东西，这里记录备忘，下次参考。需要说明的是，这里的分享的都是个人观点，与我所在公司无关。&lt;/p&gt;</summary>
    
    
    
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Computer Vision" scheme="http://vra.github.io/tags/Computer-Vision/"/>
    
    <category term="Workshop" scheme="http://vra.github.io/tags/Workshop/"/>
    
    <category term="Challenge" scheme="http://vra.github.io/tags/Challenge/"/>
    
  </entry>
  
  <entry>
    <title>Python中将图像切分为小的patch</title>
    <link href="http://vra.github.io/2022/10/15/python-split-image-to-grid-patch/"/>
    <id>http://vra.github.io/2022/10/15/python-split-image-to-grid-patch/</id>
    <published>2022-10-14T23:51:36.000Z</published>
    <updated>2022-10-15T03:37:09.291Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h3><p>假如有张1000x1000的图像，我们要将它切成20x20的小patch，该怎么处理呢？<br>最简单的方法就是采用两重for循环，每次计算小patch对应的下标，在原图上进行crop:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">size = <span class="number">1000</span></span><br><span class="line">ncols = <span class="number">20</span></span><br><span class="line">nrows = <span class="number">20</span></span><br><span class="line">img = np.random.rand(size, size)</span><br><span class="line"></span><br><span class="line">patches = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size//ncols):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(size//nrows):</span><br><span class="line">patch = img[ncols*i:ncols*(i+<span class="number">1</span>), nrows*j:nrows*(j+<span class="number">1</span>)]</span><br><span class="line">patches.append(patch)</span><br><span class="line"></span><br><span class="line">patches = np.array(patches)</span><br></pre></td></tr></table></figure><p>但这样总共需要循环50*x50=2500次，而我们知道 Python 的 for 循环比较慢，因此整体开销还是比较大的，有没有更快的方式呢？</p><span id="more"></span><h3 id="reshape-swapaxes"><a href="#reshape-swapaxes" class="headerlink" title="reshape + swapaxes"></a>reshape + swapaxes</h3><p>搜索发现可以使用 reshape + swapaxes函数的组合来完成这个功能:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">size = <span class="number">1000</span></span><br><span class="line">ncols = <span class="number">20</span></span><br><span class="line">nrows = <span class="number">20</span></span><br><span class="line">img = np.random.rand(size, size)</span><br><span class="line"></span><br><span class="line">patches = img.reshape(size // ncols, ncols, -<span class="number">1</span>, nrows).swapaxes(<span class="number">1</span>, <span class="number">2</span>).reshape(-<span class="number">1</span>, ncols, nrows)</span><br></pre></td></tr></table></figure><p>完整对比代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">size = <span class="number">1000</span></span><br><span class="line">ncols = <span class="number">20</span></span><br><span class="line">nrows = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计100次耗时</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    img = np.random.rand(size, size)</span><br><span class="line">    t0 = time.time()</span><br><span class="line">    patches0 = img.reshape(size // ncols, ncols, -<span class="number">1</span>, nrows).swapaxes(<span class="number">1</span>, <span class="number">2</span>).reshape(-<span class="number">1</span>, ncols, nrows)</span><br><span class="line"></span><br><span class="line">    t1 = time.time()</span><br><span class="line">    d1 = t1 - t0</span><br><span class="line"></span><br><span class="line">    patches = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size//ncols):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(size//nrows):</span><br><span class="line">            patch = img[ncols*i:ncols*(i+<span class="number">1</span>), nrows*j:nrows*(j+<span class="number">1</span>)]</span><br><span class="line">            patches.append(patch)</span><br><span class="line"></span><br><span class="line">    patches1 = np.array(patches)</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    d2 = t2 - t1</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;time ratio:&#x27;</span>, d2/d1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;diff:&#x27;</span>, (patches0-patches1).<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure><p>实际测试对于1000x1000的图像，采用reshape + swapaxes 要比循环快大约4倍。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">time ratio: 4.684571428571428</span><br><span class="line">diff: 0.0</span><br><span class="line">time ratio: 4.806614785992218</span><br><span class="line">diff: 0.0</span><br><span class="line">time ratio: 4.696482035928144</span><br><span class="line">diff: 0.0</span><br><span class="line">time ratio: 3.00382226469183</span><br><span class="line">diff: 0.0</span><br><span class="line">time ratio: 3.710854363028276</span><br><span class="line">diff: 0.0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="Pytorch中的实现？"><a href="#Pytorch中的实现？" class="headerlink" title="Pytorch中的实现？"></a>Pytorch中的实现？</h3><p>Pytorch相比numpy，又增加了许多操作tensor的函数，因此实现方式会更多，这里大概列一下几种实现，具体函数可以查询 Pytorch 的文档:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">patches1 = img.unfold(<span class="number">0</span>, ncols, nrows).unfold(<span class="number">1</span>, ncols, nrows).reshape(-<span class="number">1</span>, ncols, nrows)</span><br><span class="line">patches2 = img.reshape(size//ncols, ncols, -<span class="number">1</span>, nrows).swapaxes(<span class="number">1</span>, <span class="number">2</span>).reshape(-<span class="number">1</span>, ncols, nrows)</span><br><span class="line">patches3 = img.reshape(size//ncols, ncols, -<span class="number">1</span>, nrows).permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>).reshape(-<span class="number">1</span>, ncols, nrows)</span><br></pre></td></tr></table></figure><h3 id="其他相关操作"><a href="#其他相关操作" class="headerlink" title="其他相关操作"></a>其他相关操作</h3><p>ShuffleNet中的ShuffleBlock中的channel shuffle也是通过reshape+维度变换来完成的，可以参考<a href="https://github.com/MegEngine/Models/blob/master/official/vision/classification/shufflenet/model.py#L98">这里</a> 和<a href="https://iq.opengenus.org/shufflenet-implementation-using-pytorch/">这里</a>的实现。</p><p>另外之前一篇做分割的论文<a href="https://arxiv.org/abs/1702.08502">DUC</a>里面也用到了类似的把图像特征重排列来Upsample的操作，<a href="https://github.com/ycszen/pytorch-segmentation/blob/master/duc.py#L18">搜索了下</a>对应的实现，是用Pytorch的PixelShuffle来做的，具体用法参考<a href="https://pytorch.org/docs/stable/generated/torch.nn.PixelShuffle.html">文档</a>，还有个匹配的PixelUnShuffle来进行逆向操作。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://stackoverflow.com/questions/16856788/slice-2d-array-into-smaller-2d-arrays/16858283#16858283">https://stackoverflow.com/questions/16856788/slice-2d-array-into-smaller-2d-arrays/16858283#16858283</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;问题定义&quot;&gt;&lt;a href=&quot;#问题定义&quot; class=&quot;headerlink&quot; title=&quot;问题定义&quot;&gt;&lt;/a&gt;问题定义&lt;/h3&gt;&lt;p&gt;假如有张1000x1000的图像，我们要将它切成20x20的小patch，该怎么处理呢？&lt;br&gt;最简单的方法就是采用两重for循环，每次计算小patch对应的下标，在原图上进行crop:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;size = &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ncols = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nrows = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;img = np.random.rand(size, size)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;patches = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;range&lt;/span&gt;(size//ncols):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;range&lt;/span&gt;(size//nrows):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		patch = img[ncols*i:ncols*(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), nrows*j:nrows*(j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		patches.append(patch)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;patches = np.array(patches)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;但这样总共需要循环50*x50=2500次，而我们知道 Python 的 for 循环比较慢，因此整体开销还是比较大的，有没有更快的方式呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="Numpy" scheme="http://vra.github.io/tags/Numpy/"/>
    
    <category term="Pytorch" scheme="http://vra.github.io/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>用Python将图片转换为base64字符串</title>
    <link href="http://vra.github.io/2022/10/07/convert-image-to-base64/"/>
    <id>http://vra.github.io/2022/10/07/convert-image-to-base64/</id>
    <published>2022-10-07T14:19:37.000Z</published>
    <updated>2022-10-07T14:26:06.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>无他，这篇博文记录一下利用Python将OpenCV图片转换为base64字符串并在网页上进行展示的过程，权当备忘。可在<a href="https://github.com/vra/image-to-base64">这里</a>查看源码。</p><span id="more"></span><h3 id="2-Show-the-code"><a href="#2-Show-the-code" class="headerlink" title="2. Show the code"></a>2. Show the code</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_to_base64</span>(<span class="params">img_path</span>):</span></span><br><span class="line">    img = cv2.imread(img_path)</span><br><span class="line"></span><br><span class="line">    _, buffer = cv2.imencode(<span class="string">&#x27;.jpg&#x27;</span>, img)</span><br><span class="line">    text = base64.b64encode(buffer).decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_html_file</span>(<span class="params">text, file_name</span>):</span></span><br><span class="line">    html_pattern = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;img src=&quot;data:image/png;base64,&#123;&#125;&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;/html&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    html = html_pattern.<span class="built_in">format</span>(text)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img_path = <span class="string">&#x27;data/cat.jpg&#x27;</span></span><br><span class="line">    html_file_name = <span class="string">&#x27;data/show_img.html&#x27;</span></span><br><span class="line"></span><br><span class="line">    text = img_to_base64(img_path)</span><br><span class="line">    create_html_file(text, html_file_name)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;无他，这篇博文记录一下利用Python将OpenCV图片转换为base64字符串并在网页上进行展示的过程，权当备忘。可在&lt;a href=&quot;https://github.com/vra/image-to-base64&quot;&gt;这里&lt;/a&gt;查看源码。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="HTML" scheme="http://vra.github.io/tags/HTML/"/>
    
    <category term="OpenCV" scheme="http://vra.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>fly.io 使用指南</title>
    <link href="http://vra.github.io/2022/10/06/fly-io-tutorial/"/>
    <id>http://vra.github.io/2022/10/06/fly-io-tutorial/</id>
    <published>2022-10-06T00:18:04.000Z</published>
    <updated>2022-12-19T16:16:09.680Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>最近看技术论坛，发现提到 <a href="https://fly.io/">fly.io</a> 的次数越来越多了。 fly.io 是一个容器化的部署平台，只需要一个<code>Dockerfile</code>文件就能部署代码到fly.io 的服务器上，同时还自动生成域名。其他的好处多多，我根据自己体验，我总结成了下面的这些条：</p><ul><li><p><del>有免费使用的额度。不填写信用卡信息可以创建一个App，完全不收费；填写信用卡信息后每月有一定额度的免费流量，超过额度会额外收费。所以想做个小demo完全可以不填信用卡试用。</del> 目前已经不支持无信用卡使用了，参见<a href="https://community.fly.io/t/is-it-free-getting-error-we-need-your-payment-information-to-continue/8871">这里</a>的讨论</p></li><li><p>自动生成域名。比如你创建一个名字叫<code>my_demo</code>的App，那么部署完成后，就会生成<code>my_demo.fly.dev</code>的域名，可以全球访问，不用自己单独买域名了。</p></li><li><p>可以 SSH 连接进入服务器。部署完成后，可以通过<code>flyctl ssh console</code> 命令登录部署的服务器，所以相当于你有了一台免费的VPS，可以做你想做的任何事情。</p></li><li><p>部署简单，采用<code>flyctl</code> 命令集合统一部署;支持各种语言的各种框架来搭建部署环境，能自动识别当前目录下代码所采用的是哪个框架，自动部署。</p></li></ul><p>下面简单记录一下使用的流程和一些教程里面没提及的使用命令。</p><span id="more"></span><h3 id="2-部署一个应用"><a href="#2-部署一个应用" class="headerlink" title="2. 部署一个应用"></a>2. 部署一个应用</h3><p>这里以Python 的 Flask 框架为例，进行部署的步骤总结，其实fly.io支持很多框架，可以在<a href="https://fly.io/docs/speedrun/">这里</a>查看。</p><h4 id="2-1-安装-flyctl"><a href="#2-1-安装-flyctl" class="headerlink" title="2.1 安装 flyctl"></a>2.1 安装 flyctl</h4><p>首先需要安装 flyctl 这个工具：<br>Mac:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install flyctl</span><br></pre></td></tr></table></figure><p>Linux:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://fly.io/install.sh | sh</span><br></pre></td></tr></table></figure><p>Windows:<br>在Powershell中运行下面的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iwr https://fly.io/install.ps1 -useb | iex</span><br></pre></td></tr></table></figure><p>如果执行<code>flyctl version</code> 不报错，就说明安装成功了。</p><p><strong>一个小技巧，flyctl还有个alias fly，敲起来更简短些。</strong></p><p>安装这个工具是一次性的，后面不需要再操作</p><h4 id="2-2-创建并登录账号"><a href="#2-2-创建并登录账号" class="headerlink" title="2.2 创建并登录账号"></a>2.2 创建并登录账号</h4><p>创建账号:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fly auth signup</span><br></pre></td></tr></table></figure><p>会打开网页，选择自己要创建账号的方式，GitHub账号或者邮箱等。</p><p>创建完成后登录账号:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fly auth login</span><br></pre></td></tr></table></figure><h4 id="2-3-先在本地将Flask-demo跑起来"><a href="#2-3-先在本地将Flask-demo跑起来" class="headerlink" title="2.3 先在本地将Flask demo跑起来"></a>2.3 先在本地将Flask demo跑起来</h4><p>这里采用 fly.io 提供的Flask demo 代码，先在本地跑起来:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/fly-apps/python-hellofly-flask</span><br><span class="line"><span class="built_in">cd</span> python-hellofly-flask</span><br><span class="line">python -m venv flask-env</span><br><span class="line"><span class="built_in">source</span> flask-env/bin/activate</span><br><span class="line">python -m pip install -r requirements.txt</span><br><span class="line">FLASK_APP=hellofly flask run</span><br></pre></td></tr></table></figure><p>然后访问<code>http://127.0.0.1:5000</code> 就能看到网站，说明本地搭建成功了。</p><h3 id="2-4-部署到-fly-io"><a href="#2-4-部署到-fly-io" class="headerlink" title="2.4 部署到 fly.io"></a>2.4 部署到 fly.io</h3><p>在当前目录下，执行<code>fly launch</code>，进入交互式界面创建App:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">flyctl launch</span><br><span class="line">Creating app <span class="keyword">in</span> /Users/username/project/demo/flyio_demo/python-hellofly-flask</span><br><span class="line">Scanning <span class="built_in">source</span> code</span><br><span class="line">Detected a Python app</span><br><span class="line">Using the following build configuration:</span><br><span class="line">        Builder: paketobuildpacks/builder:base</span><br><span class="line">? Overwrite <span class="string">&quot;/Users/username/project/demo/flyio_demo/python-hellofly-flask/Procfile&quot;</span>? No</span><br><span class="line">? App Name (leave blank to use an auto-generated name): treehole</span><br><span class="line">Automatically selected personal organization: username</span><br><span class="line">? Select region: hkg (Hong Kong, Hong Kong)</span><br><span class="line">Created app treehole <span class="keyword">in</span> organization personal</span><br><span class="line">Wrote config file fly.toml</span><br><span class="line">? Would you like to <span class="built_in">set</span> up a Postgresql database now? No</span><br><span class="line">We have generated a simple Procfile <span class="keyword">for</span> you. Modify it to fit your needs and run <span class="string">&quot;fly deploy&quot;</span> to deploy your application.</span><br></pre></td></tr></table></figure><p>然后执行<code>flyctl deploy</code> 来将Appb部署到 fly.io 的服务器上:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flyctl deploy</span><br></pre></td></tr></table></figure><p>执行成功后，可以用<code>flyctl open</code>来打开浏览器，访问自己部署的App，网址是<code>appname.fly.dev</code>。</p><p>如果后面有源码或者配置的修改，可以多次执行<code>flyctl deploy</code>，会生成新的版本v0，v1, v2依次往下，往fly.io上部署。</p><p>接下来就是修改你的Flask源代码，完成更复杂有真正意义的功能了。</p><h4 id="2-5-别的有用的flyctl-命令"><a href="#2-5-别的有用的flyctl-命令" class="headerlink" title="2.5 别的有用的flyctl 命令"></a>2.5 别的有用的flyctl 命令</h4><ul><li>查看App状态: <code>flyctl status</code></li><li>查看App信息: <code>flyctl info</code></li><li>查看App列表: <code>flyctl apps list</code></li><li>查看App的IP: <code>flyctl ips list</code></li><li>销毁某个App: <code>flyctl apps destroy &lt;appname&gt;</code></li></ul><h3 id="3-登录部署机器"><a href="#3-登录部署机器" class="headerlink" title="3. 登录部署机器"></a>3. 登录部署机器</h3><p>机器部署完成后，可以通过<code>flyctl ssh console</code>来登录机器，登录后就跟普通Linux机器的使用是一样的了，可以随意探索。</p><h3 id="4-复制部署机器上的文件到本地"><a href="#4-复制部署机器上的文件到本地" class="headerlink" title="4. 复制部署机器上的文件到本地"></a>4. 复制部署机器上的文件到本地</h3><p>在一个终端输入下面的命令来代理端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fly proxy 10022:22</span><br></pre></td></tr></table></figure><p>然后保持上面的终端打开，在另一个终端输入下面的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 10022 root@localhost:/path/of/file/on/vm  /path/on/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>修改文件的路径就能将文件复制过来</p><h3 id="5-一点感想"><a href="#5-一点感想" class="headerlink" title="5.一点感想"></a>5.一点感想</h3><p>当demo部署服务成功后，却不知道能做什么真正有意义的事情，或许缺少的不是工具，而是真正产生价值的点子。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;最近看技术论坛，发现提到 &lt;a href=&quot;https://fly.io/&quot;&gt;fly.io&lt;/a&gt; 的次数越来越多了。 fly.io 是一个容器化的部署平台，只需要一个&lt;code&gt;Dockerfile&lt;/code&gt;文件就能部署代码到fly.io 的服务器上，同时还自动生成域名。其他的好处多多，我根据自己体验，我总结成了下面的这些条：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;del&gt;有免费使用的额度。不填写信用卡信息可以创建一个App，完全不收费；填写信用卡信息后每月有一定额度的免费流量，超过额度会额外收费。所以想做个小demo完全可以不填信用卡试用。&lt;/del&gt; 目前已经不支持无信用卡使用了，参见&lt;a href=&quot;https://community.fly.io/t/is-it-free-getting-error-we-need-your-payment-information-to-continue/8871&quot;&gt;这里&lt;/a&gt;的讨论&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自动生成域名。比如你创建一个名字叫&lt;code&gt;my_demo&lt;/code&gt;的App，那么部署完成后，就会生成&lt;code&gt;my_demo.fly.dev&lt;/code&gt;的域名，可以全球访问，不用自己单独买域名了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以 SSH 连接进入服务器。部署完成后，可以通过&lt;code&gt;flyctl ssh console&lt;/code&gt; 命令登录部署的服务器，所以相当于你有了一台免费的VPS，可以做你想做的任何事情。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;部署简单，采用&lt;code&gt;flyctl&lt;/code&gt; 命令集合统一部署;支持各种语言的各种框架来搭建部署环境，能自动识别当前目录下代码所采用的是哪个框架，自动部署。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面简单记录一下使用的流程和一些教程里面没提及的使用命令。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="fly.io" scheme="http://vra.github.io/tags/fly-io/"/>
    
    <category term="Docker" scheme="http://vra.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>在ctypes的C共享库中调用Python函数</title>
    <link href="http://vra.github.io/2022/10/04/callback-in-ctypes/"/>
    <id>http://vra.github.io/2022/10/04/callback-in-ctypes/</id>
    <published>2022-10-04T03:42:22.000Z</published>
    <updated>2022-10-04T04:35:42.172Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p><a href="https://docs.python.org/3/library/ctypes.html">ctypes</a> 是Python标准库中提供的外部函数库，可以用来在Python中调用动态链接库或者共享库中的函数，比如将使用大量循环的代码写在C语言中来进行提速，因为Python代码循环实在是太慢了。大致流程是通过 ctypes 来调用C函数，先将Python类型的对象转换为C的类型，在C函数中做完计算，返回结果到Python中。这个过程相对是比较容易的。</p><p>现在有个更复杂的情况，我想要在C代码中调用Python中的某些函数来完成C代码的计算，比如在C代码的sort函数中，采用Python中定义的函数来进行大小判断。这个在Python中定义的函数在 ctypes 中称为回调函数 (callback function)。也就是说需要把Python函数当作变量传给C语言，想想还是有些难度。 但调查以后发现 ctypes 提供了 <code>CFUNCTYPE</code>来方便地进行回调函数定义，而C语言本身也是支持函数指针的，因此这个功能实现还算简单，具体展开如下。</p><span id="more"></span><h3 id="2-一个最简单例子"><a href="#2-一个最简单例子" class="headerlink" title="2. 一个最简单例子"></a>2. 一个最简单例子</h3><p>先从最简单例子开始，跑通整体流程。假设我们有个回调函数，判断int类型的输入是不是大于0，那么可以在C语言这么写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_lib.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> (*function_ptr)(<span class="keyword">int</span>) , <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> function_ptr(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个文件内容很简单，我们定义了一个C函数<code>foo</code>，它调用Python传过来的回调函数，直接返回结果。</p><p>这里使用了C语言的函数指针类型，<code>int (function_ptr)(int)</code>中函数指针变量名是<code>function_ptr</code>, 返回值类型是前面的int，参数类型是后面的int。</p><p>我们在C语言里面只是简单地调用了Python传过来的函数指针，并直接将结果返回，实际使用时其实是需要在Python函数算完后，利用输出进行更多操作，否则直接在Python里面计算函数就可以了，没必要传函数到C，算法结果再返回给Python。</p><p>使用下面的命令来将上述C文件编程成共享库<code>my_lib.so</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o my_lib.so my_lib.c</span><br></pre></td></tr></table></figure><p>这个命令会在当前目录下会生成<code>my_lib.so</code>。</p><p>然后在Python文件中定义这个回调函数的具体实现，以及调用共享库<code>my_lib.so</code>中定义的<code>foo</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file name: ctype_callback_demo.py</span></span><br><span class="line"><span class="keyword">import</span> ctypes <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> cdll</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义回调函数</span></span><br><span class="line"><span class="meta">@c.CFUNCTYPE(<span class="params">c.c_int, c.c_int</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback_func</span>(<span class="params">a</span>):</span></span><br><span class="line">    res = <span class="built_in">int</span>(a &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入共享库</span></span><br><span class="line">    lib = cdll.LoadLibrary(<span class="string">&#x27;./my_lib.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用共享库中的foo函数</span></span><br><span class="line">    res = lib.foo(callback_func, a)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; &gt; 0 = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(a, res))</span><br></pre></td></tr></table></figure><p>所有 magic 的事情都被 ctypes 这个库给做了，留给我们的都是比较简单的接口。</p><p><code>@c.CFUNCTYPE</code> 这个装饰器就是用来声明回调函数的，装饰器的第一个参数是函数的返回类型，第二个参数开始，就是回调函数自己的参数的类型。如果回调函数没有返回值，那<code>@c.CFUNCTYPE</code>后面的第一个参数设置为<code>None</code>。</p><p>然后执行这个Python脚本，可以得到下面的输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python ctype_callback_demo.py</span><br><span class="line">2 &gt; 0 = 1</span><br></pre></td></tr></table></figure><h3 id="3-Numpy-ndarray-类型的参数如何使用"><a href="#3-Numpy-ndarray-类型的参数如何使用" class="headerlink" title="3. Numpy.ndarray 类型的参数如何使用"></a>3. Numpy.ndarray 类型的参数如何使用</h3><p>ctypes 对 Python原生类型支持是没问题的，但我们还会经常用到Numpy的ndarray对象，它们该如何转换为C语言可以识别的类型呢？因为跨语言的类型转换不对的话，结果就会有问题。</p><p>Numpy 提供了 numpy.ndarray.ctypes 属性，可以来完成这个操作。</p><p>比如C文件中，需要一个float 指针类型的输入:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_lib.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> (*function_ptr)(<span class="keyword">float</span>*) , <span class="keyword">float</span>* a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">function_ptr</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要将Numpy.ndarray对象进行转换，传给C函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取C的float指针类型</span></span><br><span class="line">c_float_p = ctypes.POINTER(ctypes.c_float)</span><br><span class="line"></span><br><span class="line">data = np.random.rand(<span class="number">3</span>, <span class="number">3</span>).astype(np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将np.ndarray 对象的类型转换为C的float指针类型</span></span><br><span class="line">data_p = data.ctypes.data_as(c_float_p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用共享库中的foo函数</span></span><br><span class="line">my_lib.foo(data_p)</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://docs.python.org/3/library/ctypes.html#callback-functions">https://docs.python.org/3/library/ctypes.html#callback-functions</a></li><li><a href="https://stackoverflow.com/questions/3195660/how-to-use-numpy-array-with-ctypes">https://stackoverflow.com/questions/3195660/how-to-use-numpy-array-with-ctypes</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/library/ctypes.html&quot;&gt;ctypes&lt;/a&gt; 是Python标准库中提供的外部函数库，可以用来在Python中调用动态链接库或者共享库中的函数，比如将使用大量循环的代码写在C语言中来进行提速，因为Python代码循环实在是太慢了。大致流程是通过 ctypes 来调用C函数，先将Python类型的对象转换为C的类型，在C函数中做完计算，返回结果到Python中。这个过程相对是比较容易的。&lt;/p&gt;
&lt;p&gt;现在有个更复杂的情况，我想要在C代码中调用Python中的某些函数来完成C代码的计算，比如在C代码的sort函数中，采用Python中定义的函数来进行大小判断。这个在Python中定义的函数在 ctypes 中称为回调函数 (callback function)。也就是说需要把Python函数当作变量传给C语言，想想还是有些难度。 但调查以后发现 ctypes 提供了 &lt;code&gt;CFUNCTYPE&lt;/code&gt;来方便地进行回调函数定义，而C语言本身也是支持函数指针的，因此这个功能实现还算简单，具体展开如下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="C++" scheme="http://vra.github.io/tags/C/"/>
    
    <category term="Numpy" scheme="http://vra.github.io/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>简单好用的英文拼写检查工具codespell</title>
    <link href="http://vra.github.io/2022/09/22/python-spell-checking-codespell/"/>
    <id>http://vra.github.io/2022/09/22/python-spell-checking-codespell/</id>
    <published>2022-09-22T15:14:39.000Z</published>
    <updated>2022-09-22T15:31:31.134Z</updated>
    
    <content type="html"><![CDATA[<p>网上冲浪看到了一个简单好用的英语单词拼写检查工具 <a href="https://github.com/codespell-project/codespell">codespell</a>，测试发现真的好用，一键安装&amp;一键开箱使用，没有比这更美好的体验了，下面展开说下流程。</p><span id="more"></span><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>codespell 是用 Python 写的工具，因此直接使用pip安装即可:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install codespell</span><br></pre></td></tr></table></figure><p>输出应该类似如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collecting codespell</span><br><span class="line">  Downloading codespell-2.2.1-py3-none-any.whl (202 kB)</span><br><span class="line">     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 202.1/202.1 kB 165.1 kB/s eta 0:00:00</span><br><span class="line">Installing collected packages: codespell</span><br><span class="line">Successfully installed codespell-2.2.1</span><br></pre></td></tr></table></figure><p>很简单。</p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><p>进一个包含英文文本的目录，比如你的源码根目录，或者文档目录，然后执行<code>codespell</code>, 就会检查当前目录下所有的文本，给出可能的拼写错误。</p><p>例如我clone一个我的GitHub 仓库，进去执行<code>codespell</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/vra/easybox</span><br><span class="line"><span class="built_in">cd</span> easybox</span><br><span class="line">codespell</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./README.md:10: termial ==&gt; terminal</span><br><span class="line">./README.md:53: termial ==&gt; terminal</span><br><span class="line">./easybox/main.py:41: Mimimal ==&gt; Minimal</span><br></pre></td></tr></table></figure><p>可以看到，markdown文件和Python文件中的一些拼写错误都被找出来了。</p><p>除了这么直接使用外，还可以在命令后面增加一些目录和路径的限定，比如<code>*.md</code> 只检查当前目录下的<code>.md</code>文件，<code>folder</code> 只检查文件夹<code>folder</code>下的所有文件，等等，都是Linux下的基本操作。</p><h3 id="3-原理"><a href="#3-原理" class="headerlink" title="3. 原理"></a>3. 原理</h3><p>这个工具的大致原理是将英文单词容易出错的情况写到代码库的数据中，然后在代码中进行匹配，所以不会出现别的工具那样，对变量命名的误判断，这是一个很好的特性。具体实现细节就需要查看<a href="https://github.com/codespell-project/codespell">源码</a>了，有空或许可以分析一下，写一个源码解读哈哈。</p><p>上面这些内容，对于普通人日常使用基本是够用了，关于codespell更多高级的配置选项，请参考GitHub上的<a href="https://github.com/codespell-project/codespell">README</a>文件中的说明。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;网上冲浪看到了一个简单好用的英语单词拼写检查工具 &lt;a href=&quot;https://github.com/codespell-project/codespell&quot;&gt;codespell&lt;/a&gt;，测试发现真的好用，一键安装&amp;amp;一键开箱使用，没有比这更美好的体验了，下面展开说下流程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="工具" scheme="http://vra.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="TIL" scheme="http://vra.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>git合并另一个分支的某个文件到当前分支</title>
    <link href="http://vra.github.io/2022/08/14/git-merge-file-from-another-branch/"/>
    <id>http://vra.github.io/2022/08/14/git-merge-file-from-another-branch/</id>
    <published>2022-08-14T03:14:26.000Z</published>
    <updated>2022-08-14T04:23:44.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>使用Git时，有时候不同分支的文件是不同步的，因此如果想要把别的分支的文件改动应用到当前分支，应该怎么操作呢？如果两边都有更新，该如何选择合并呢？这篇小文会对不同情形下的合并进行一个简单的介绍。</p><span id="more"></span><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>假设我们当前在分支<code>branch1</code>, 需要将分支<code>branch2</code>上的<code>a.py</code>合并到当前分支。<br>根据<a href="https://vra.github.io/2021/09/25/git-copy-from-another-branch">之前写的这篇文章</a>，我们可以这么操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout branch2 -- a.py</span><br></pre></td></tr></table></figure><h2 id="两边都存在文件"><a href="#两边都存在文件" class="headerlink" title="两边都存在文件"></a>两边都存在文件</h2><p>现在换一个情况，假设分支<code>branch1</code>和<code>branch2</code>都有文件<code>a.py</code>，且分支<code>branch1</code>上的文件包含在<code>branch2</code>的内容里，那么采用上面的命令也还是可以的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout branch2 -- a.py</span><br></pre></td></tr></table></figure><p>另外如果只想合并<code>branch2</code>上的文件的一部分更新到<code>branch1</code>，可以在<code>chekcout</code>后面增加<code>-p</code>或者<code>--patch</code>选项，交互式地选择要合并过来的代码块:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -p branch2 -- a.py</span><br></pre></td></tr></table></figure><p>交互式地操作命令同<code>git add -p</code>，可以参考<a href="https://vra.github.io/2022/06/17/git-add-part-of-a-file/">这里的文章</a>。</p><p>更复杂的情况是，分支<code>branch1</code>也有同名文件，且也有更新，如果直接使用<code>git checkout</code>的话，分支<code>branch2</code>上的文件会替代本地的文件，且没有任何提示（毕竟cheeckout的含义就是切换到某个分支）。因此为了保持本地的更新，需要增加<code>-p</code>选项。</p><p>这时候，会出现一种情况，本地的更新和远程的更新被放到一个块(hunk)里面，只能保留其中一个，此时就需要更精细的操作，在交互式环境中采用<code>e</code>命令来手动对hunk进行更新，去掉或增加代码的<code>+</code>或者<code>-</code>，具体可以参考<a href="https://stackoverflow.com/a/6290646">这个回答</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;使用Git时，有时候不同分支的文件是不同步的，因此如果想要把别的分支的文件改动应用到当前分支，应该怎么操作呢？如果两边都有更新，该如何选择合并呢？这篇小文会对不同情形下的合并进行一个简单的介绍。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的包名&quot;xxx&quot;和&quot;xxx-dev&quot;有什么区别?</title>
    <link href="http://vra.github.io/2022/07/23/linux-package-vs-package-dev/"/>
    <id>http://vra.github.io/2022/07/23/linux-package-vs-package-dev/</id>
    <published>2022-07-23T09:40:03.000Z</published>
    <updated>2022-08-14T03:13:41.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h2><p>在安装包的时候，有时候需要安装<code>xxx</code>的包，有时候又需要安装<code>xxx-dev</code>的包 (在CentOS系列发行版上则是<code>xxx-devel</code>)。这两类包之间又什么区别呢？</p><span id="more"></span><h2 id="2-结论"><a href="#2-结论" class="headerlink" title="2. 结论"></a>2. 结论</h2><p>不包含<code>-dev</code>的包里面包含的是运行所需要的二进制文件或者连接库文件（如<code>xxx.so</code>），而包含<code>-dev</code>的包则包含包的源码文件（如<code>.h</code>文件），为的是在编译使用了这些库的程序的时候，能找到对应的头文件，否则只有二进制文件或者<code>.so</code>文件，编译时会报代码找不到头文件的错误。</p><p>下面举个例子进行说明。</p><p>我们只使用Python的话，用<code>sudo apt install python</code>即可，安装后就可以正常使用Python。</p><p>如果想要编译一个叫<a href="https://github.com/lxml/lxml">lxml</a>的库，它依赖Python的源码，例如<a href="https://github.com/lxml/lxml/blob/06631bb0677250cb632638a2c89f4d336360965b/src/lxml/includes/etree_defs.h#L5">这里</a>的代码依赖<code>Python.h</code>这个文件，因此我们需要安装<code>python-dev</code>包，把<code>Python.h</code>安装到本地上，这样lxml包才能正常安装。</p><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><ol><li><a href="https://stackoverflow.com/questions/2358801/what-are-devel-packages">https://stackoverflow.com/questions/2358801/what-are-devel-packages</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-引入&quot;&gt;&lt;a href=&quot;#1-引入&quot; class=&quot;headerlink&quot; title=&quot;1. 引入&quot;&gt;&lt;/a&gt;1. 引入&lt;/h2&gt;&lt;p&gt;在安装包的时候，有时候需要安装&lt;code&gt;xxx&lt;/code&gt;的包，有时候又需要安装&lt;code&gt;xxx-dev&lt;/code&gt;的包 (在CentOS系列发行版上则是&lt;code&gt;xxx-devel&lt;/code&gt;)。这两类包之间又什么区别呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="Ubuntu" scheme="http://vra.github.io/tags/Ubuntu/"/>
    
    <category term="Debian" scheme="http://vra.github.io/tags/Debian/"/>
    
    <category term="CentOS" scheme="http://vra.github.io/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>Linux小知识:apt install什么时候会出现 Do you want to continue?的提示</title>
    <link href="http://vra.github.io/2022/07/23/ubuntu-when-to-ask-do-you-want-to-continue/"/>
    <id>http://vra.github.io/2022/07/23/ubuntu-when-to-ask-do-you-want-to-continue/</id>
    <published>2022-07-23T03:17:27.000Z</published>
    <updated>2022-07-23T09:38:32.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-一个故事"><a href="#1-一个故事" class="headerlink" title="1. 一个故事"></a>1. 一个故事</h2><p>在大约十年以前，大二或大三的夏天，<a href="https://wzhd.org/">子浩</a> 在科大西区活动中心的自习室内，给我帮忙安装Linux系统。当时他问了一个问题，用<code>apt-get install</code> 安装包时，什么时候会弹出<code>Do you want to continue?Y/[n]</code>的提示呢？我当时说应该是包大小超过限制时会有这个提示吧，但我们随即验证了这个假设并不成立，安装一个很小的包也会有这个提示。当时没有得到明确的结论。</p><p>这个问题时不时在脑海中想起，每次想查一下弄个清楚，但始终是没做。这样十年过去了，近日终于又想起来，通过谷歌搜索，终于发现了StackOverflow上已经又同样疑问的人提问了，而且得到了解答。至此这个小疑问算是解决了，我也不用每次念念不忘了。</p><p>具体原因是什么，请见下节。</p><span id="more"></span><h2 id="2-谜底揭晓"><a href="#2-谜底揭晓" class="headerlink" title="2. 谜底揭晓"></a>2. 谜底揭晓</h2><p>根据<a href="https://superuser.com/questions/287348/why-does-apt-get-sometimes-asks-for-confirmation/287357#287357">这里</a>的回答，<code>Do you want to continue</code> 的提示会在下面几种情况下出现:</p><ol><li>当除了你要安装包外，有额外的依赖包需要被安装的时候，比如你执行的是<code>sudo apt install aaa</code>, 包 <code>aaa</code> 依赖 <code>bbb</code>，因此<code>bbb</code> 也需要被安装，这时候就会有提示</li><li>当现有包的版本要改变，比如机器上已经安装了<code>bbb-1.0.0</code>，而安装<code>aaa</code>需要安装<code>bbb-2.0.0</code>，这时候就会有提示</li><li>当基础包要被移除的时候，基础包大体意思是系统运行所需的最小软件包集，删除了就会导致系统运行出问题，详细的概念可以参考<a href="https://www.debian.org/doc/debian-policy/ch-binary.html#essential-packages">这里</a></li></ol><p>常见的情况应该是第一种和第二种，第三种情况应该是只有<code>apt remove</code>才会出现。</p><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><ol><li><a href="https://superuser.com/questions/287348/why-does-apt-get-sometimes-asks-for-confirmation/287357#287357">https://superuser.com/questions/287348/why-does-apt-get-sometimes-asks-for-confirmation/287357#287357</a></li><li><a href="https://unix.stackexchange.com/questions/70651/when-does-apt-get-install-ask-me-to-confirm-whether-i-want-to-continue-or-not">https://unix.stackexchange.com/questions/70651/when-does-apt-get-install-ask-me-to-confirm-whether-i-want-to-continue-or-not</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-一个故事&quot;&gt;&lt;a href=&quot;#1-一个故事&quot; class=&quot;headerlink&quot; title=&quot;1. 一个故事&quot;&gt;&lt;/a&gt;1. 一个故事&lt;/h2&gt;&lt;p&gt;在大约十年以前，大二或大三的夏天，&lt;a href=&quot;https://wzhd.org/&quot;&gt;子浩&lt;/a&gt; 在科大西区活动中心的自习室内，给我帮忙安装Linux系统。当时他问了一个问题，用&lt;code&gt;apt-get install&lt;/code&gt; 安装包时，什么时候会弹出&lt;code&gt;Do you want to continue?Y/[n]&lt;/code&gt;的提示呢？我当时说应该是包大小超过限制时会有这个提示吧，但我们随即验证了这个假设并不成立，安装一个很小的包也会有这个提示。当时没有得到明确的结论。&lt;/p&gt;
&lt;p&gt;这个问题时不时在脑海中想起，每次想查一下弄个清楚，但始终是没做。这样十年过去了，近日终于又想起来，通过谷歌搜索，终于发现了StackOverflow上已经又同样疑问的人提问了，而且得到了解答。至此这个小疑问算是解决了，我也不用每次念念不忘了。&lt;/p&gt;
&lt;p&gt;具体原因是什么，请见下节。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="Ubuntu" scheme="http://vra.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>surface-simplification-using-quadric-error-metrics</title>
    <link href="http://vra.github.io/2022/06/29/surface-simplification-using-quadric-error-metrics/"/>
    <id>http://vra.github.io/2022/06/29/surface-simplification-using-quadric-error-metrics/</id>
    <published>2022-06-29T07:25:53.000Z</published>
    <updated>2022-06-29T07:29:10.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>顶点可以看作是三角面片所在的平面的交集</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;顶点可以看作是三角面片所在的平面的交集&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Graphic" scheme="http://vra.github.io/tags/Graphic/"/>
    
  </entry>
  
  <entry>
    <title>Python转换elif语句为列表推导式</title>
    <link href="http://vra.github.io/2022/06/28/python-list-comprehension-with-elif/"/>
    <id>http://vra.github.io/2022/06/28/python-list-comprehension-with-elif/</id>
    <published>2022-06-28T14:32:11.000Z</published>
    <updated>2022-06-28T14:42:50.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>今天才发现，在Python的列表推导式里面，也可以使用多个else，也就是elif的情况，具体来说，可以将下面的一长串的elif 语句转换成一句列表推导式，大大简化代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cond1:</span><br><span class="line">do1</span><br><span class="line"><span class="keyword">elif</span> cond2:</span><br><span class="line">do2</span><br><span class="line"><span class="keyword">elif</span> cond3:</span><br><span class="line">do3</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">do4</span><br></pre></td></tr></table></figure><p>转换成列表推导式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = [do1 <span class="keyword">if</span> cond1 <span class="keyword">else</span> do2 <span class="keyword">if</span> cond2 <span class="keyword">else</span> do3 <span class="keyword">if</span> cond3 <span class="keyword">else</span> do4][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>Python喜爱值+1，代码行数-N。</p><span id="more"></span><h2 id="2-几个例子"><a href="#2-几个例子" class="headerlink" title="2. 几个例子"></a>2. 几个例子</h2><p>原先代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &gt; <span class="number">10</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;large&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> a &gt; <span class="number">5</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;middle&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;small&#x27;</span></span><br></pre></td></tr></table></figure><p>可以转换为下面的形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = [<span class="string">&#x27;large&#x27;</span> <span class="keyword">if</span> a &gt; <span class="number">10</span> <span class="keyword">else</span> <span class="string">&#x27;middle&#x27;</span> <span class="keyword">if</span> a &gt; <span class="number">5</span> <span class="keyword">else</span> <span class="string">&#x27;small&#x27;</span>]</span><br></pre></td></tr></table></figure><p>任意多个elif都是可以的，下面的代码验证了两种写法结果是一致的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">if</span> a &gt; <span class="number">0.9</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> a &gt; <span class="number">0.7</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;b&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> a &gt; <span class="number">0.5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;c&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> a &gt; <span class="number">0.3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;d&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> a &gt;= <span class="number">0.1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;e&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span> <span class="keyword">if</span> a &gt; <span class="number">0.9</span> <span class="keyword">else</span> <span class="string">&#x27;b&#x27;</span> <span class="keyword">if</span> a &gt; <span class="number">0.7</span> <span class="keyword">else</span> <span class="string">&#x27;c&#x27;</span> <span class="keyword">if</span> a &gt; <span class="number">0.5</span> <span class="keyword">else</span> <span class="string">&#x27;d&#x27;</span> <span class="keyword">if</span> a &gt; <span class="number">0.3</span> <span class="keyword">else</span> <span class="string">&#x27;e&#x27;</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr = np.random.rand(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="built_in">print</span>(func1(a) == func2(a))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;今天才发现，在Python的列表推导式里面，也可以使用多个else，也就是elif的情况，具体来说，可以将下面的一长串的elif 语句转换成一句列表推导式，大大简化代码:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; cond1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	do1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; cond2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	do2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; cond3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	do3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	do4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;转换成列表推导式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;res = [do1 &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; cond1 &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; do2 &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; cond2 &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; do3 &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; cond3 &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; do4][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Python喜爱值+1，代码行数-N。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch 拟合多项式的例子</title>
    <link href="http://vra.github.io/2022/06/26/pytorch-fit-polynomial/"/>
    <id>http://vra.github.io/2022/06/26/pytorch-fit-polynomial/</id>
    <published>2022-06-26T03:20:15.000Z</published>
    <updated>2022-06-26T09:00:34.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Pytorch包含了Linear层，可以用来拟合<code>y = w * x + b</code> 形式的函数，其中<code>w</code>和<code>bias</code>就是Linear层的weights和bias。这里写个拟合一次多项式的简单demo，作为一个小实验。</p><span id="more"></span><h2 id="2-拟合一次多项式"><a href="#2-拟合一次多项式" class="headerlink" title="2. 拟合一次多项式"></a>2. 拟合一次多项式</h2><p>采用下面的代码，我们设计了一个包含一个线性层的网络，通过给它feed随机构造的数据(y = 1.233 * x + 0.988)，结合梯度下降算法和MSE loss惩罚函数，让它学习数据的构造参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    torch.manual_seed(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    model = Model()</span><br><span class="line">    model.train()</span><br><span class="line">    optimizer = optim.SGD(model.parameters(), lr=<span class="number">1e-2</span>)</span><br><span class="line"></span><br><span class="line">    w = <span class="number">1.233</span></span><br><span class="line">    b = <span class="number">0.988</span></span><br><span class="line">num_iteration = <span class="number">5000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_iteration):</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        x = torch.rand(<span class="number">1</span>)</span><br><span class="line">        y = w * x + b</span><br><span class="line">        pred = model(x)</span><br><span class="line"></span><br><span class="line">        loss = F.mse_loss(y, pred)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name, param <span class="keyword">in</span> model.named_parameters():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>=<span class="subst">&#123;param.data.numpy().squeeze():<span class="number">.3</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><p>运行这个脚本的输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linear.weight=1.233</span><br><span class="line">linear.bias=0.988</span><br></pre></td></tr></table></figure><p>可以看到，经过5000次的迭代，网络能成功地学习到数据构造过程中的w和b参数, 这个小网络现在可以用来替代线性回归机器学习算法了!</p><p>如果迭代周期太小则可能收敛不到我们预设的参数，可以手动修改迭代次数<code>num_iteration</code>为2000查看结果。</p><h2 id="3-如果重复Linear层会发生什么？"><a href="#3-如果重复Linear层会发生什么？" class="headerlink" title="3. 如果重复Linear层会发生什么？"></a>3. 如果重复Linear层会发生什么？</h2><p>如果我们把同一个linear层重复执行两次，会有什么结果呢？也就是网络定义修改如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>这里调用了两次同一个linear层，因此相当于 <code>y = w * ( w * x + b) + b</code>，也就是一次forward更新两次参数，也可以理解成两个共享参数的线性层。<br>完整的示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    torch.manual_seed(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    model = Model()</span><br><span class="line">    model.train()</span><br><span class="line">    optimizer = optim.SGD(model.parameters(), lr=<span class="number">1e-2</span>)</span><br><span class="line"></span><br><span class="line">    w = <span class="number">1.233</span></span><br><span class="line">    b = <span class="number">0.988</span></span><br><span class="line">    num_iteration = <span class="number">5000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_iteration):</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        x = torch.rand(<span class="number">1</span>)</span><br><span class="line">        y = w * x + b</span><br><span class="line">        pred = model(x)</span><br><span class="line"></span><br><span class="line">        loss = F.mse_loss(y, pred)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name, param <span class="keyword">in</span> model.named_parameters():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>=<span class="subst">&#123;param.data.numpy().squeeze():<span class="number">.3</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><p>同样的，通过我们构造 y = 1.233 * x + 0.998的数据，带入 y = w * ( w * x + b) + b，可以得到一组解 <code>w=1.110, b=0.468</code>,这与我们网络运行得到的结果是一致的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linear.weight=1.110</span><br><span class="line">linear.bias=0.468</span><br></pre></td></tr></table></figure><p>同时也有一个问题：为什么没得到w为负数的另一组解呢？这是因为我这里为了保证复现性，手动设置了随机数种子为1024，设置为别的值应该可以得到另一组参数，欢迎尝试。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;Pytorch包含了Linear层，可以用来拟合&lt;code&gt;y = w * x + b&lt;/code&gt; 形式的函数，其中&lt;code&gt;w&lt;/code&gt;和&lt;code&gt;bias&lt;/code&gt;就是Linear层的weights和bias。这里写个拟合一次多项式的简单demo，作为一个小实验。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Deep Learning" scheme="http://vra.github.io/tags/Deep-Learning/"/>
    
    <category term="Pytorch" scheme="http://vra.github.io/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>matplotlibt图像转OpenCV图像</title>
    <link href="http://vra.github.io/2022/06/24/matplotlib-convert-opencv/"/>
    <id>http://vra.github.io/2022/06/24/matplotlib-convert-opencv/</id>
    <published>2022-06-24T15:14:44.000Z</published>
    <updated>2022-06-24T15:51:04.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>有时候，我们需要使用Matplotlib库强大的绘图函数来在numpy.ndarray格式的图像上进行一些可视化，比如关键点绘制，投影点绘制。绘制完后，还需要把matplotlib的figure对象转换为numpy.ndarray 格式的对象，方便和原图进行比较。有时候为了可视化的美观，需要验证保证转换后的图像与原始图像大小一致。这里记录一下操作的流程，以及一些常遇到的问题。</p><span id="more"></span><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h2><p>核心原理是利用matplotlib.pyplot的<code>imshow</code>函数来显示np.ndarray格式的图像，然后进行可视化绘制，再通过matplotlib.pyplot.figure.canvas的<code>tostring_rgb</code>函数来将图像转换为string，在用numpy的<code>fromstring</code>函数将string转换为np.ndarray，即为我们所求。</p><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 numpy.ndarray格式的图像</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;/path/to/my.jpg&#x27;</span>)</span><br><span class="line">h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建figure对象</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">plt.imshow(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加函数绘制代码</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制画布</span></span><br><span class="line">fig.canvas.draw()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换plt canvas为string，再导入numpy</span></span><br><span class="line">vis_img = np.fromstring(fig.canvas.tostring_rgb(), dtype=np.uint8)</span><br><span class="line"><span class="comment"># 设置numpy数组大小为图像大小</span></span><br><span class="line">vis_img.shape = (h, w, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">plt.close()</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;/path/to/vis_img.jpg&#x27;</span>, vis_img)</span><br></pre></td></tr></table></figure><h2 id="3-几个关键点"><a href="#3-几个关键点" class="headerlink" title="3. 几个关键点"></a>3. 几个关键点</h2><p>上述代码是简单的原理，但要达到保存的<code>vis_img</code>对象与<code>img</code>对象完全等大小，还需要设置figure对象的size，具体实现是通过<code>set_size_inches</code>函数，传入原始图像的宽和高除以dpi的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">fig.set_size_inches(w/fig.dpi, h/fig.dpi)</span><br></pre></td></tr></table></figure><p>注意是宽在前面，高在后面。</p><p>还有一个很关键的点是需要去除matplotlib设置的padding白边，否则在相同尺寸的情况下，包含白边显得里面的内容变小了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.gca().set_position((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>为了不显示横纵坐标轴，需要添加<code>plt.axis(&#39;off&#39;)</code>语句。</p><p>为了能在无GUI的环境（比如SSH连到的Linux 服务器）这个脚本也能正常工作，需要采用<code>Agg</code> 这个backend：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;Agg&#x27;</span>)</span><br></pre></td></tr></table></figure><p>插句题外话，<code>Agg</code>这个backend原来是来自于<a href="http://agg.sourceforge.net/antigrain.com/">Anti-Grain Geometry</a> 2D渲染库，2002年开始开发，距今已有20年历史了，Respect。</p><p>此外由于matploltlib的<code>imshow</code>需要RGB格式的图像，而OpenCV图像格式为BGR，需要做转换。</p><h2 id="4-完整代码"><a href="#4-完整代码" class="headerlink" title="4. 完整代码"></a>4. 完整代码</h2><p>结合上一部分的几个关键点，最终的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;Agg&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;/path/to/my.jpg&#x27;</span>)</span><br><span class="line">img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line">h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">fig.set_size_inches(w/fig.dpi, h/fig.dpi)</span><br><span class="line"></span><br><span class="line">plt.imshow(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始 matplotlib的绘制</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关掉坐标轴的显示</span></span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加这一句，避免matplotlib的自动padding导致的空白</span></span><br><span class="line">plt.gca().set_position((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">fig.canvas.draw()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换plt canvas为string，再导入numpy</span></span><br><span class="line">vis_img = np.fromstring(fig.canvas.tostring_rgb(), dtype=np.uint8)</span><br><span class="line"><span class="comment"># 设置numpy数组大小为图像大小</span></span><br><span class="line">vis_img.shape = (h, w, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 将RGB格式转换为BGR格式</span></span><br><span class="line">vis_img = cv2.cvtColor(vis_img, cv2.COLOR_RGB2BGR)</span><br><span class="line"></span><br><span class="line">plt.close()</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;/path/to/vis_img.jpg&#x27;</span>, vis_img)</span><br></pre></td></tr></table></figure><p>需要注意的是，直接执行这段代码虽然可以得到你想要的结果，但本身是没有意义的，最核心的matplotlib调用需要你自己填写。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;有时候，我们需要使用Matplotlib库强大的绘图函数来在numpy.ndarray格式的图像上进行一些可视化，比如关键点绘制，投影点绘制。绘制完后，还需要把matplotlib的figure对象转换为numpy.ndarray 格式的对象，方便和原图进行比较。有时候为了可视化的美观，需要验证保证转换后的图像与原始图像大小一致。这里记录一下操作的流程，以及一些常遇到的问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="OpenCV" scheme="http://vra.github.io/tags/OpenCV/"/>
    
    <category term="Matplotlib" scheme="http://vra.github.io/tags/Matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>git 提交文件中的部分修改</title>
    <link href="http://vra.github.io/2022/06/17/git-add-part-of-a-file/"/>
    <id>http://vra.github.io/2022/06/17/git-add-part-of-a-file/</id>
    <published>2022-06-17T15:19:36.000Z</published>
    <updated>2022-06-17T23:56:04.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在 Git 提交一个文件的时候，有时候会在同一个文件中，包含两个不同功能的修改，或者一个功能完成了，而别的部分还没有完善不应该进入代码库，这时候如果使用<code>git add file-name</code>的话，会将这个文件中的所有更新都提交，达不到上述的需求。针对这种场景，git 提供了更细粒度的提交命令<code>git add -p</code>，可以分部分提交一个文件中的更新代码块，实测能满足常见的需求。这里简要记录一下如何使用这个命令。</p><span id="more"></span><h2 id="2-实现命令"><a href="#2-实现命令" class="headerlink" title="2. 实现命令"></a>2. 实现命令</h2><h3 id="2-1-原理解释"><a href="#2-1-原理解释" class="headerlink" title="2.1 原理解释"></a>2.1 原理解释</h3><p>git 中用”hunk”来表示一个文件中邻近区域中的代码修改块，比如用<code>git diff</code> 查看修改时，两个<code>@@</code>符号分割的一个区域就是一个hunk，其中行首是<code>-</code>，颜色为红色的为删去的行，而行首为<code>+</code>，颜色为绿色的为增加的行。<br><img src="/imgs/git_add_part/git_hunk_vis.jpg" alt="git_hunk_vis"></p><p>需要注意的是，git有一套默认的将文件中所有修改分成不同hunk的机制，但我们也可以将默认机制分的太大的hunk分割为多个小的hunk，这样能更精确地控制提交的粒度。</p><p>部分提交文件修改的原理简单来说是将所有的修改分成不同的hunk，通过对每个hunk来进行是否提交的判断，从而完成我们的需求。具体命令下面详细讲述。</p><h3 id="2-2-命令详解"><a href="#2-2-命令详解" class="headerlink" title="2.2 命令详解"></a>2.2 命令详解</h3><p><code>git add -p filename</code>就可以进入交互式的操作界面，所有的操作在该界面完成，其中<code>-p</code>是patch的缩写。界面如下:<br><img src="/imgs/git_add_part/git_part_add_2.jpg"><br>这里会自动载入第一个hunk，显示了修改的代码行，最底下一行显示了这是8个hunk里面的第一个，然后有一些选项让我们选择，这时候输入<code>?</code>，按会车会显示help信息:<br><img src="/imgs/git_add_part/git_part_add_2.jpg"></p><p>所有命令的含义如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">y - 将当前的hunk进行提交</span><br><span class="line">n - 不提交当前hunk</span><br><span class="line">q - 退出交互式界面，不提交当前hunk以及后面的所有hunk</span><br><span class="line">a - 提交当前hunk以及后面的所有hunk</span><br><span class="line">d - 不提交当前hunk以及后面的所有hunk，效果与q一样，也会退出交互式界面</span><br><span class="line">g - 选择一个hunk并跳转过去，输入后会列出所有hunk的编号，输入编号就跳转到对应的hunk</span><br><span class="line">/ - 输入一个正则表达式，选择一个包含搜索词的hunk进行跳转</span><br><span class="line">j - 暂时不确定是否保存当前hunk，跳转到下一个没确定的hunk</span><br><span class="line">J - 暂时不确定是否保存当前hunk，跳转到下一个hunk</span><br><span class="line">e - 手动修改hunk块的内容，将`-` 开头的行替换为 ` `则不会删去这行，删除`+`为首的行则不提交这个新增，以`<span class="comment">#`开始的行会被忽略</span></span><br><span class="line">? - 显示帮助信息 </span><br></pre></td></tr></table></figure><p>详细阅读上面的说明，结合实际的操作，就能掌握这个命令的所有用法。</p><p>简单来说，使用<code>y</code>来提交当前hunk，使用<code>n</code>来忽略当前hunk，如果hunk代码块太大，输入<code>s</code>会将其分割为小的hunk，在上面继续操作，hunk间上下跳转用vim的快捷键<code>k</code> 和<code>j</code>，要退出则输入<code>q</code>。</p><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><ol><li><a href="https://stackoverflow.com/questions/1085162/commit-only-part-of-a-file-in-git">https://stackoverflow.com/questions/1085162/commit-only-part-of-a-file-in-git</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;在 Git 提交一个文件的时候，有时候会在同一个文件中，包含两个不同功能的修改，或者一个功能完成了，而别的部分还没有完善不应该进入代码库，这时候如果使用&lt;code&gt;git add file-name&lt;/code&gt;的话，会将这个文件中的所有更新都提交，达不到上述的需求。针对这种场景，git 提供了更细粒度的提交命令&lt;code&gt;git add -p&lt;/code&gt;，可以分部分提交一个文件中的更新代码块，实测能满足常见的需求。这里简要记录一下如何使用这个命令。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>VitPose 论文阅读</title>
    <link href="http://vra.github.io/2022/06/11/vitpose-intro/"/>
    <id>http://vra.github.io/2022/06/11/vitpose-intro/</id>
    <published>2022-06-11T12:12:02.000Z</published>
    <updated>2022-06-12T14:23:06.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>VitPose是最近出来的一篇用Transformer结构做人体2D关键点估计的论文，采用比较简单的Transformer结构就能在MS COCO 测试集上取得比较好的结果，挺吸引人的。论文不长，这周末读了一遍，感觉值得借鉴的地方挺多，这里我用自己的语言描述论文的细节，同时把自己的一些疑惑和思考写下来，欢迎讨论交流。</p><p>论文标题: ViTPose: Simple Vision Transformer Baselines for Human Pose Estimation<br>论文地址：<a href="https://arxiv.org/abs/2204.12484">https://arxiv.org/abs/2204.12484</a><br>代码地址：<a href="https://github.com/ViTAE-Transformer/ViTPose">https://github.com/ViTAE-Transformer/ViTPose</a></p><p>注：本文中框图和表格均来自原论文。</p><span id="more"></span><h2 id="2-摘要和引入"><a href="#2-摘要和引入" class="headerlink" title="2. 摘要和引入"></a>2. 摘要和引入</h2><p>Vison Transformer 在视觉识别任务中效果优秀，在识别但还没有人在姿态估计任务上验证这种结构的有效性。这篇论文提出了名为VitPose的用于姿态估计的Transformer网络，使用普通ViT结构作为Backbone，结合一个轻量级的Decoder，就能在MS COCO 关键点估计bechmark上达到SOTA。</p><h2 id="3-继续阅读前的几个疑问"><a href="#3-继续阅读前的几个疑问" class="headerlink" title="3. 继续阅读前的几个疑问"></a>3. 继续阅读前的几个疑问</h2><p>读完摘要和Introduction部分，我决定继续精读这篇论文，因此在进一步阅读前，为了提升对论文的理解程度，我想出了下面的问题，希望在读完剩余部分的时候，这些问题都能得到回答:</p><ol><li>如何确定SOTA结果中MAE和Transformer网络结构的贡献?</li><li>100M到1B参数的变化是通过哪个模块的变化调节的?</li><li>是基于Heatmap还是Regression的思路?</li><li>只针对单人场景还是多人场景也OK?</li><li>速度如何？</li></ol><p>带着这些疑问，咱们继续往下看。</p><h2 id="4-实现细节"><a href="#4-实现细节" class="headerlink" title="4. 实现细节"></a>4. 实现细节</h2><h3 id="4-1-整体结构"><a href="#4-1-整体结构" class="headerlink" title="4.1 整体结构"></a>4.1 整体结构</h3><p>网络结构设计比较简单，整体为采用ViT backbone + decoder的形式。</p><p><img src="/imgs/vitpose/vitpose_framework.jpg" alt="vitpose framework"><br>backbone分为patch embedding和多个transfomer模块。patch embedding将图像分为dxd的patch块。</p><p>而每个transfomer层包含 multi-head self-attention(MHSA) 与 feed-forward network (FFN) 模块。多个transfomer层堆叠，构成了backbone。</p><p>backbone根据计算量大小，选用了Vit-B, ViT-L，ViT-H[3]以及ViTAE-G[4]。</p><h4 id="4-1-1-decoder-选择"><a href="#4-1-1-decoder-选择" class="headerlink" title="4.1.1 decoder 选择"></a>4.1.1 decoder 选择</h4><p>由于backbone采用ViT现有的结构，因此在decoder的选取上，作者选择了两种结构进行了对比:</p><ol><li>经典Decoder结构，两个Deconv（+BN+ReLU) + 1个1x1 conv，每个deconv上采样2倍，最终输出feature map大小为输入的1/4倍<br><img src="/imgs/vitpose/vitpose_classic_decoder.jpg"></li><li>双线性差值上采样4倍，然后是ReLU+3x3conv，不过论文中公式与描述不符，ReLU在双线性上采样之前，需要看代码实现具体是哪一种。<br><img src="/imgs/vitpose/vitpose_simple_decoder.jpg"></li></ol><p>方案1非线性更高，因此在CNN的结构中使用比较多。而这篇论文也验证了由于Transformer强大的学习能力，即使像方案2这样的的简单decoder，也能达到很高的精度：</p><p><img src="/imgs/vitpose/vitpose_t1.png"><br>可以看到，ResNet系列在方案1上的结果远高于方案2，说明CNN结构的学习能力需要强有力的decoder来进一步加强，而VitPose结构则不需要，这需要归功于ViT结构的强大学习能力</p><p>如果光讲结构确实比较单一，所以论文也在好几个方面验证了ViTPose的优良特性。</p><h3 id="4-2-灵活性"><a href="#4-2-灵活性" class="headerlink" title="4.2 灵活性"></a>4.2 灵活性</h3><h4 id="4-2-1-预训练上的灵活性"><a href="#4-2-1-预训练上的灵活性" class="headerlink" title="4.2.1 预训练上的灵活性"></a>4.2.1 预训练上的灵活性</h4><p>一般情况下backbone都需要ImageNet上预训练。这篇论文提出了三种预训练方案：</p><ol><li>采用ImagNet预训练分类任务，比较经典的方法，数据集总共1M图片</li><li>采用MS COCO 预训练MAE任务，将75%的patch随机的mask掉，然后让网络学习恢复这些patch，数据集共150K图片</li><li>任务框架同方案2，不过数据集采用MS COCO + AI Challenger，共500K图片</li></ol><p>具体实现是将MS COCO和AI Challenger 中的单个人体crop出来，与ImageNet单个object的数据分布保持一致。然后在3个数据集上分别训练1600个epoch，再在MS COCO 上fine tune 210个epoch。</p><p>这个训练周期确实有点出乎意料地长……</p><p>采用VitPose-B结构，在MS COCO val set上，三种预训练方案的结果如下:<br><img src="/imgs/vitpose/vitpose_t2.jpg"><br>可以看到使用MS COCO + AI Challenger，在只有一半数据量的情况下，可以达到比ImageNet更好的效果。</p><h4 id="4-2-2-分辨率上的灵活性"><a href="#4-2-2-分辨率上的灵活性" class="headerlink" title="4.2.2 分辨率上的灵活性"></a>4.2.2 分辨率上的灵活性</h4><p>ViTPose可以通过使用更大的输出尺寸来训练，也可以通过减小backbone中的下采样来构造更大尺度的feature map，这两种操作都能提高精度，具体如下：<br>更大尺寸的输入：直接缩放原始图像，得到对应大小的输入<br>更大尺寸的特征：降低采样倍数，修改patch层的stride参数，</p><p>另外提一下，这个特性应该是CNN和ViT结构都通用的。</p><p>结果如下：<br><img src="/imgs/vitpose/vitpose_t3.jpg"><br>可以看到分辨率越大结果越高</p><h4 id="4-2-3-Attention种类上的灵活性"><a href="#4-2-3-Attention种类上的灵活性" class="headerlink" title="4.2.3 Attention种类上的灵活性"></a>4.2.3 Attention种类上的灵活性</h4><p>众所周知，Transformer中的Attention的计算量是Feature map 尺寸的平方，因此是很大的，而且显存占用也很大。因此作者用了Shift Window 和 Pooling Window 两种方案来缓解这个问题，结果如下：</p><p><img src="/imgs/vitpose/vitpose_t4.jpg"><br>单纯的网络显存占用太多，因此不得不采用fp16才能训起来……</p><h4 id="4-2-4-finetune的灵活性"><a href="#4-2-4-finetune的灵活性" class="headerlink" title="4.2.4 finetune的灵活性"></a>4.2.4 finetune的灵活性</h4><p>与NLP任务中一样，作者验证了只固定MHSA模块的参数，精度下降不多，而固定FFN的参数，则精度下降明显，因此作者认为MHSA更偏向<strong>与任务无关</strong>，而FFN则更具体任务关系更密切。</p><p><img src="/imgs/vitpose/vitpose_t5.jpg"></p><h4 id="4-2-5-多任务上的灵活性"><a href="#4-2-5-多任务上的灵活性" class="headerlink" title="4.2.5 多任务上的灵活性"></a>4.2.5 多任务上的灵活性</h4><p>作者还尝试了这样一个实验，采用同一个backbone，多个decoder，每个decoder对应一个数据集的任务，实验验证一次训练，多个数据集上的结果都能比较好，且比单个数据集精度有提升:</p><p><img src="/imgs/vitpose/vitpose_t6.jpg"></p><h3 id="4-3-蒸馏"><a href="#4-3-蒸馏" class="headerlink" title="4.3 蒸馏"></a>4.3 蒸馏</h3><p>这篇论文比较有意思的一个点是提出了一个基于Transformer的蒸馏方法，与常见的用loss来监督Teacher和Student网络的思路不太一样，具体如下:</p><ol><li>在大模型的patch embedding后的visual token后面增加一个知识token模块，并进行随机初始化</li><li>固定大模型的参数，只训练知识token模块</li><li>将训练好的知识token模块接到小模型的visual token后面，且固定知识token的参数，只训练小模型的其他参数</li></ol><p>通过这样的流程，将所有的知识都融合到了知识token模块的参数里面，并且从大模型传递到小模型，感觉理解起来也是很直观很有画面感。</p><p>结果如下：</p><p><img src="/imgs/vitpose/vitpose_t7.jpg"></p><h3 id="4-4-与SOTA对比"><a href="#4-4-与SOTA对比" class="headerlink" title="4.4 与SOTA对比"></a>4.4 与SOTA对比</h3><p> 实现细节中作者说明了，采用姿态估计中Top-Down的方案，即先用一个检测器检测出单个人体框，然后对人体框进行姿态估计。本文中方案其实是后面这一步。第一步的检测器在COCO的val集上用的是SimpleBaseline[1]，而在最后的COCO test-dev集上，与SOTA方案的比较实验中，采用了Bigdet[2]。</p><p>SOTA结果是在576x432输入，采用1B参数量的ViTAE-G作为backbone，使用MS COCO + AI Challenger训练的情况下获得的，具体如下：<br><img src="/imgs/vitpose/vitpose_t8.jpg"><br><img src="/imgs/vitpose/vitpose_t8.jpg"></p><h2 id="5-几个疑问的答案："><a href="#5-几个疑问的答案：" class="headerlink" title="5 几个疑问的答案："></a>5 几个疑问的答案：</h2><p>相信经过上面的细节描述，我们对开头的几个疑问中的一些问题已经有明确的答案了</p><ol><li>如何确定SOTA结果中MAE和Transformer网络结构的贡献? -&gt; </li><li>100M到1B参数的变化是通过哪个模块的变化调节的? -&gt; 通过修改backbone的结构来控制参数大小 </li><li>是基于Heatmap还是Regression的思路? -&gt; Heatmap</li><li>只针对单人场景还是多人场景也OK? -&gt; 只针对单人场景，且需要额外的前置detector</li><li>速度如何？ -&gt; 速度应该是比较慢的，训练周期比较长，网络比较大</li></ol><h2 id="6-思考"><a href="#6-思考" class="headerlink" title="6 思考"></a>6 思考</h2><ol><li>采用强大的Transformer结构，之前的很多trick都可以省略，包括skip-connection 等</li><li>Knowledge Token的思路很新颖挺有意思的，感觉可以用在所有的Transformer蒸馏里面</li><li>虽然论文强调只用了一个普通的ViT结构来做姿态估计，但是为了达到较高的精度，后面还是挺多提点的实验</li></ol><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h2><p>[1] SimpleBaseline: <a href="https://arxiv.org/abs/1804.06208">https://arxiv.org/abs/1804.06208</a><br>[2] Bigdetection: A large-scale benchmark for improved object detector pre-training<br>[3] An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale<br>[4] Vitaev2: Vision transformer advanced by exploring inductive bias for image recognition and beyond</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;VitPose是最近出来的一篇用Transformer结构做人体2D关键点估计的论文，采用比较简单的Transformer结构就能在MS COCO 测试集上取得比较好的结果，挺吸引人的。论文不长，这周末读了一遍，感觉值得借鉴的地方挺多，这里我用自己的语言描述论文的细节，同时把自己的一些疑惑和思考写下来，欢迎讨论交流。&lt;/p&gt;
&lt;p&gt;论文标题: ViTPose: Simple Vision Transformer Baselines for Human Pose Estimation&lt;br&gt;论文地址：&lt;a href=&quot;https://arxiv.org/abs/2204.12484&quot;&gt;https://arxiv.org/abs/2204.12484&lt;/a&gt;&lt;br&gt;代码地址：&lt;a href=&quot;https://github.com/ViTAE-Transformer/ViTPose&quot;&gt;https://github.com/ViTAE-Transformer/ViTPose&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：本文中框图和表格均来自原论文。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Computer Vision" scheme="http://vra.github.io/tags/Computer-Vision/"/>
    
    <category term="论文阅读" scheme="http://vra.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    <category term="Paper" scheme="http://vra.github.io/tags/Paper/"/>
    
    <category term="Pose Estimation" scheme="http://vra.github.io/tags/Pose-Estimation/"/>
    
    <category term="ViT" scheme="http://vra.github.io/tags/ViT/"/>
    
    <category term="Transformer" scheme="http://vra.github.io/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>提高你的信息获取信噪比：RSS in 2022</title>
    <link href="http://vra.github.io/2022/05/29/rss-2022/"/>
    <id>http://vra.github.io/2022/05/29/rss-2022/</id>
    <published>2022-05-29T13:49:39.000Z</published>
    <updated>2022-05-29T14:29:26.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在上学的时候，有一次听boj师兄介绍博客，至今还记得讲座中的一句话，博客能提高获取信息的信噪比。</p><p>在今天网络和社交媒体信息严重过载的情况下，如何集中自己的精力，将时间花到有用的事情上，进而提高工作效率，对我们每个人来说，都很有挑战。</p><p>为了获取真正有用的信息，第一步是过滤信息来源。最近发现基于RSS的信息获取方式是比较高效的，这里大致描述一下我目前采用的信息获取方案。</p><span id="more"></span><h1 id="2-RSS-介绍"><a href="#2-RSS-介绍" class="headerlink" title="2. RSS 介绍"></a>2. RSS 介绍</h1><p>基于RSS的信息获取需要有两个东西，一个是RSS阅读器，另一个就是订阅源。通过订阅，每次订阅源有新内容发表的话，阅读器都可以爬取，因此打开阅读器就能阅读最新的订阅内容，避免了一个个/一次次检查网站的问题，也能最快地看到感兴趣的内容。如果一个订阅源的内容长期不喜欢的话，可以取消订阅，减少噪声。（但这个是不是也会加剧信息茧房现象？)</p><p>RSS阅读器我目前采用的是inoreader，之前也用过feedly，不过都需要科学上网。如果你有更好的方案，欢迎评论指出。</p><p>订阅源就是内容的生产方的RSS链接，一般博客网站都有会RSS标志，点击复制网页，添加到阅读器中即可。</p><p>这里是我的一些订阅源和平时会看的网站，欢迎寻找对你有用的内容.</p><h3 id="2-1-纯粹的技术网站"><a href="#2-1-纯粹的技术网站" class="headerlink" title="2.1 纯粹的技术网站"></a>2.1 纯粹的技术网站</h3><p>hacker news是大家提到比较多的网站，内容挺丰富的。而lobste.rs是一个没怎么被提到但社区和谐、内容优质的computing为主的社区，很喜欢这种纯粹地讨论技术的网站，很多大牛也在其中出没。不过由于采用邀请制，门槛很高，像我们这样的一般人很难参与他们的讨论。</p><h3 id="2-2-知乎上大佬总结的订阅源"><a href="#2-2-知乎上大佬总结的订阅源" class="headerlink" title="2.2 知乎上大佬总结的订阅源"></a>2.2 知乎上大佬总结的订阅源</h3><p><a href="https://zhuanlan.zhihu.com/p/472781319">这里</a>是知乎上大佬总结的优质RSS源，可以根据你的喜爱添加到自己的阅读器。</p><h3 id="2-3-独立博客汇总"><a href="#2-3-独立博客汇总" class="headerlink" title="2.3 独立博客汇总"></a>2.3 独立博客汇总</h3><p><a href="https://github.com/timqian/chinese-independent-blogs">这里</a>是GitHub上开发者总结的中文独立博客列表，很长，但应该是有很多优质内容的，值得一一阅读品味再订阅。阅读个人的独立博客，像是认识跟自己有同样爱好的一个好友，看ta看问题的角度，解决问题的思路，分享的创造，都会带来惊喜。</p><p>最后愿这篇博客对你高效获取信息有所帮助!</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;在上学的时候，有一次听boj师兄介绍博客，至今还记得讲座中的一句话，博客能提高获取信息的信噪比。&lt;/p&gt;
&lt;p&gt;在今天网络和社交媒体信息严重过载的情况下，如何集中自己的精力，将时间花到有用的事情上，进而提高工作效率，对我们每个人来说，都很有挑战。&lt;/p&gt;
&lt;p&gt;为了获取真正有用的信息，第一步是过滤信息来源。最近发现基于RSS的信息获取方式是比较高效的，这里大致描述一下我目前采用的信息获取方案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="RSS" scheme="http://vra.github.io/tags/RSS/"/>
    
    <category term="非技术" scheme="http://vra.github.io/tags/%E9%9D%9E%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
