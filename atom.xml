<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yunfeng&#39;s Simple Blog</title>
  
  <subtitle>Love, Life, Linux</subtitle>
  <link href="http://vra.github.io/atom.xml" rel="self"/>
  
  <link href="http://vra.github.io/"/>
  <updated>2023-01-15T07:58:36.358Z</updated>
  <id>http://vra.github.io/</id>
  
  <author>
    <name>Yunfeng Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>原来 git stash 应该这么用</title>
    <link href="http://vra.github.io/2023/01/15/git-stash/"/>
    <id>http://vra.github.io/2023/01/15/git-stash/</id>
    <published>2023-01-15T05:19:57.000Z</published>
    <updated>2023-01-15T07:58:36.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前段时间突然发现，我之前对<code>git stash</code>的使用都是错误的。</p><p>具体说来，我是这么使用的：在远端有新的提交，需要<code>git pull</code>来拉取合并时，发现本地有一些未提交的修改，功能也没实现，不适合做一次commit。这时候我执行<code>git stash</code>隐藏本地的修改，然后执行<code>git pull</code>来拉取远端的更新，在最新代码基础上<strong>重新实现</strong>stash的那些代码中的功能。</p><p>这里的问题是，重新实现stash代码中的那一步，其实完全可以用<code>git stash pop</code>来替代，执行这个命令会在最新代码基础上作用stash的代码，不用再重新实现一遍了（不过这时可能会有代码冲突需要解决）。所以我之前是把<code>git stash</code>当<code>git checkout -- .</code>来用了，也就是抛弃了本地的代码更新，显然是有问题的。</p><p>正确流程基本上是这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="comment"># 或者 git stash push，效果一样</span></span><br><span class="line">git pull <span class="comment"># 可能有冲突需要手动合并</span></span><br><span class="line">git stash pop <span class="comment"># 可能有冲突需要手动合并</span></span><br></pre></td></tr></table></figure><p>下面详细讲 git stash 的提供的功能和一些参数。</p><span id="more"></span><h2 id="git-stash-具体用法"><a href="#git-stash-具体用法" class="headerlink" title="git stash 具体用法"></a>git stash 具体用法</h2><p><code>git stash</code>创建一个新的stash，效果与<code>git stash push</code> 一样，效果如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on master: c6771a5 doc: fix error during pre-commiting</span><br></pre></td></tr></table></figure><p>增加<code>-u</code>选项可以将未track的文件也隐藏起来。</p><p>你可以创建多个stash，最早的stash表示为<code>stash@&#123;0&#125;</code>，然后是<code>stash@&#123;1&#125;</code>，依次递加。</p><p><code>git stash list</code> 会列出所有的stash：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: c6771a5 doc: fix error during pre-commiting</span><br><span class="line">stash@&#123;1&#125;: WIP on master: c6771a5 doc: fix error during pre-commiting</span><br></pre></td></tr></table></figure><p><code>git stash show</code>可以查看最新stash中的修改，加上编号可以查看之前版本的修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash show stash@&#123;0&#125;</span><br><span class="line">version.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p><code>git stash apply</code> 可以应用最新的stash到当前的代码中，同样的，如果加上编号则可以应用之前版本的修改到当前代码。apply执行后记得调用<code>git stash drop</code> 来去除以及应用的stash。<br><code>git stash pop</code>效果等于<code>git stash apply</code> + <code>git stash drop</code>。</p><p><code>git stash branch</code>会基于老的提交代码创建一个分支，同时把最新的修改也作用过去，这样对于新的提交和老提交代码变化很大的场景比较好，避免在新的提交上apply stash时由于冲突太多造成的合并问题。</p><p><code>git stash clean</code> 会清空所有的stash，<strong>且没有任何提示</strong>，这意味着你所有隐藏的代码都会被删除，执行此命令前请三思！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;前段时间突然发现，我之前对&lt;code&gt;git stash&lt;/code&gt;的使用都是错误的。&lt;/p&gt;
&lt;p&gt;具体说来，我是这么使用的：在远端有新的提交，需要&lt;code&gt;git pull&lt;/code&gt;来拉取合并时，发现本地有一些未提交的修改，功能也没实现，不适合做一次commit。这时候我执行&lt;code&gt;git stash&lt;/code&gt;隐藏本地的修改，然后执行&lt;code&gt;git pull&lt;/code&gt;来拉取远端的更新，在最新代码基础上&lt;strong&gt;重新实现&lt;/strong&gt;stash的那些代码中的功能。&lt;/p&gt;
&lt;p&gt;这里的问题是，重新实现stash代码中的那一步，其实完全可以用&lt;code&gt;git stash pop&lt;/code&gt;来替代，执行这个命令会在最新代码基础上作用stash的代码，不用再重新实现一遍了（不过这时可能会有代码冲突需要解决）。所以我之前是把&lt;code&gt;git stash&lt;/code&gt;当&lt;code&gt;git checkout -- .&lt;/code&gt;来用了，也就是抛弃了本地的代码更新，显然是有问题的。&lt;/p&gt;
&lt;p&gt;正确流程基本上是这样：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git stash &lt;span class=&quot;comment&quot;&gt;# 或者 git stash push，效果一样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git pull &lt;span class=&quot;comment&quot;&gt;# 可能有冲突需要手动合并&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git stash pop &lt;span class=&quot;comment&quot;&gt;# 可能有冲突需要手动合并&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面详细讲 git stash 的提供的功能和一些参数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>2022年终总结</title>
    <link href="http://vra.github.io/2022/12/31/summary-2022/"/>
    <id>http://vra.github.io/2022/12/31/summary-2022/</id>
    <published>2022-12-31T03:09:39.000Z</published>
    <updated>2023-01-02T16:59:23.374Z</updated>
    
    <content type="html"><![CDATA[<p>多年以后，想起2022，我会回忆起哪个画面？为了解答这个问题，我回想过去的这些年份，2021，2020，……2005，看能想到什么。除了有些年份里，我结婚，毕业，所以有记忆深刻的事件，大部分年份我甚至想不起任何事情。对于一个模糊的数字，在多年以后，我们确实难以将它和自己一天天度过的日常事情关联起来。虽然2022年发生了很多事情，但大部分还是会被遗忘，但我还是尽量想用详细的文字记录下来，这样当以后想会看那年我身上发生了什么的时候，我知道只要在浏览器里面输入<code>vra.github.io/2022/12/31/summary-2022</code>，这些时刻都会清晰地浮现在我眼前。</p><span id="more"></span><h2 id="今年做了什么"><a href="#今年做了什么" class="headerlink" title="今年做了什么"></a>今年做了什么</h2><p>今年在比赛和论文上，和亭枫参加了一个DLGC学术比赛，拿到了第一名，也发表了一篇对应的Workshop论文。去年合作投稿的论文今年辗转投稿了几次，最后投了期刊。今年组内还举办了一场ECCV学术比赛，我作为一个赛道的负责人，在合作方的支持下，构建了训练和测试数据，提供了Baseline，搭建了测评服务，写介绍文章，招募选手，在Slack上和合作的老师英文沟通，成长了挺多的。</p><p>到新团队后，在天猫App上线了一些创新算法驱动的的功能，也算是在亿级用户的App上开发过产品了。</p><p>在技术总结上，今年总共更新了共36篇技术博客，相比之前几年进步巨大。虽然没有太多有亮点的文章，但总算是开始形成比较好的更新习惯了。在大概10月的生活，发现了程序员大神 Simon Willison的<a href="https://simonwillison.net/">博客</a>，收获很多。让我收益的是他的TIL (Tody I Learned) 板块，就是记录每天学习到的技术，开始记录，然后慢慢地提高。基于这个思路，今年写了许多学习到的简单但有用的命令和操作，希望以后坚持下去。</p><h2 id="今年的遗憾"><a href="#今年的遗憾" class="headerlink" title="今年的遗憾"></a>今年的遗憾</h2><p>2022年也是一个充满遗憾的一年。春天晋升失败，虽然身处其中，但面对失败的那种难受感觉，相信你能懂。然后就是组织调整，猝不及防间，很多小伙伴离开了团队，人心惶惶。在公司的一道通知前，我们打工者只有默默接受。然后换到新的组，做新的事情，所幸做的东西差别不大，能够比较快的适应。</p><p>在回望工作这五年，发现工作中，虽然事情勉强能做好，但还远没做到让自己满意。没有发表什么好的论文，模型效果差强人意，做的项目也平平庸庸。</p><p>虽然不想承认，但在即将到来的2023年，我要满30周岁了。在能看到自身的各种问题，却没有好的解决方法的时候，我知道我遇到职业生涯的危机了。那么我自己的核心问题出在哪里？核心矛盾是：长期的目标与短期的行动之间没有匹配。长期的目标是明确的，但当目标被分解到日常的工作中时，很多核心问题没有被解决，而是其他紧急且必须但长远来看不核心的任务占用了绝大部分的时间，导致在不占用家庭和个人生活时间的情况下，没有足够的时间来做核心的工作。</p><p>正如大老板讲过的，通过换环境、换赛道来解决自己遇到问题的想法，是不切实际的。根本问题不解决，在新的赛道，新的环境，就算刚开始做的很顺利，在后面还是会遇到同样的问题，会踩同样的坑。</p><p>2023年，希望多一些清醒的思考，少一些每天只忙着做手头事情的混沌时刻。</p><h2 id="关于技术社区"><a href="#关于技术社区" class="headerlink" title="关于技术社区"></a>关于技术社区</h2><p>今年接触了Lobste.rs社区，发现里面很多编程大佬和很多高质量文章，高质量讨论。而且更为难得的是，社区氛围很好，每个讨论都是非常理性，就事论事，让人不禁想，国内能否有这样的纯粹的技术社区，学习，讨论，研发最新的技术。作为尝试的一小步，我用一个git仓库记录了每周我阅读的技术文章，至于怎么进一步增加讨论，还没有比较好的思路。</p><p>2023-01-03更新：在v2ex上看到了国内的Lobste.rs社区<a href="https://dto.pipecraft.net/">DTO</a>，欢迎在<a href="https://www.v2ex.com/t/905509">这里</a>或<a href="https://github.com/dev-topics-only/lobsters/issues/1">这里</a>发帖申请加入，为提高国内的技术氛围做一份贡献!</p><h2 id="关于AI和chatGPT"><a href="#关于AI和chatGPT" class="headerlink" title="关于AI和chatGPT"></a>关于AI和chatGPT</h2><p>去年体验了一下Copilot，当时的震撼现在还有印象，体验完后，我不禁想：相比Copilot，我们真人的优势在哪里，该如何与它共存？我没答案。<br>今年的chatGPT的爆火，进一步地让我看到AI工具对我们开发者的巨大影响。经过思考，我认为这些AI工具可能会替代我们程序员的某些工作，但不会替代程序员这个行业，只是会明显地改变程序员的编程行为，而且利用好这些工具，会是程序员的必修课。</p><p>从研究者的角度，chatGPT已经可以很好地理解大部分人类语言，所以我认为NLP研究已经到了一个里程碑的阶段，真正智能的AI语音助手不远了，未来几年也会有更多真正的语音助手进入普通人的生活中。</p><p>有点感慨，有时候技术的发展很慢，让人看不到希望，但有时候，技术又发展的太快，让人跟不上脚步。作为一个普通人技术人，还是要感谢那些顶尖的研究者，让我们在有生之年能看到如此激动人心的技术进步。</p><h2 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h2><p>说完技术，谈谈生活吧。今年6月份搬了一次家，从公司附近搬到了老婆上班的幼儿园附近，开始坐地铁上下班。<br>在地铁上，要么刷技术网站，要么刷gif和搞笑网站。在地铁19号线开通后，单程时间缩短到一个小时内，旅程没那么漫长，站着也没那么累了。</p><p>因为疫情封控，平时没怎么出去，周末基本躺家里，偶尔周末一个人去爬山，逛博物馆。有时候和老婆一起出去走走，有时候有同学来杭州来聚聚，大部分时候，坐地铁，上班，坐地铁，从热的蒸发的六月到有些寒冷的腊月。</p><p>印象最深刻的是夏天从地铁站到公司的那段路。那时候19号线还没开通，只能从5号线永福地铁站出来，然后骑共享单车去公司。有时候没有车了，就只能步行近20分钟去公司。2022年的夏天特别的热，一出地铁，刚到扶梯上，一股热浪就袭来，然后出去找单车，坐上去屁股都快烫熟了。在过十字路口前，找一片小树荫躲避烈日，一到绿灯，上班的人都骑着车过马路，在下一个路口继续寻找小树荫，到公司大部分时候后背都已经湿透了。</p><p>好在9月22日，杭州地铁19号线开通，开通当天的晚上，我就去体验了，从此回家快了不少，而且再也不用走那么远的路了。</p><p>平常的日子里，也有惊喜的时刻。9月1日，听到老婆怀孕的消息，我激动坏了。离当爸爸越来越近了，也有对于自己能否做个好爸爸的隐忧。</p><p>今年和小伙伴每天吃饭时讨论最多的话题就是疫情。没想到结局竟然是这样。这里也说说我开放之后变🐑的经历。12月22日是周四，冬至，嗓子开始有点涩的感觉，等到周五下午，浑身酸疼，差点撑不到下班。六点下班，到家后九点就开始睡觉，周六醒来浑身不疼了，到下午🈶又开始疼，头后面一抽一抽地疼。周日测了一下，果然是阳性。过了几天，浑身不疼了，但嗓子还有些难受。</p><h2 id="阅读的书籍"><a href="#阅读的书籍" class="headerlink" title="阅读的书籍"></a>阅读的书籍</h2><p>今年读了比较多的历史方面的书，让我一直思考”我们从哪来”的问题得到了更完整的理解。最难忘的是王鼎钧的回忆录系列，“插柳学诗”章节是我看过的对清末民初乡村士绅最好的介绍。《李宗仁回忆录》和《胡适口述自传》也让我对唐德刚老教授敬佩不已。下面列出一些基本看完且比较推荐的书，供以后查阅。</p><ul><li>《王鼎钧回忆录四部曲》</li><li>《李宗仁回忆录》</li><li>《五更盘道》</li><li>《依稀识得故乡痕：漆家山50年村史》</li><li>《人间杭州》</li><li>《红星照耀中国》</li><li>《晚清最后十八年》</li><li>《寻觅意义》</li><li>《尼安德特人》</li><li>《周恩来传》</li><li>《胡适口述自传》</li><li>《我的个天》</li><li>《左宗棠在甘肃》</li></ul><h2 id="观影"><a href="#观影" class="headerlink" title="观影"></a>观影</h2><p>今年还是在周末看了很多影视作品，难得的是有很多比较感兴趣的科幻和赛博朋克的影视作品出现，大饱眼福。这里按照我的喜好大致排序列出来一些推荐的影视作品。</p><ul><li>《万神殿》</li><li>《赛博朋克：边缘行者》</li><li>《隐入尘烟》</li><li>《史前星球》</li><li>《边缘世界》</li><li>《指环王力量之戒》</li><li>《白莲花度假村》</li><li>《狙击手》</li><li>《爱，死亡和机器人第三季》</li><li>《瞬息全宇宙》</li><li>《人生切割术》</li><li>《黑袍纠察队》</li><li>《1883》  </li><li>《利刃出鞘2》</li><li>《流人第一季》</li><li>《和平使者》</li><li>《塔尔萨之王》</li><li>《上载》</li><li>《法兰西特派》</li><li>《亚当计划》</li><li>《柏青哥》</li><li>《初创玩家》</li><li>《阶梯之间》</li><li>《替身演员》</li><li>《光环》</li><li>《欧比旺》</li><li>《三体动画》</li><li>《月光骑士》</li><li>《荒野迷案》</li><li>《雷神4》</li><li>《奇异博士2》</li><li>《我是格鲁特》</li></ul><h2 id="相聚与出游"><a href="#相聚与出游" class="headerlink" title="相聚与出游"></a>相聚与出游</h2><p>今年疫情反复，几乎没有出杭州，也没有和朋友太多相聚，努力的回忆这些难得的出行和相聚时刻，想起来还是很温暖。</p><ul><li>1月28日，先从杭州坐飞机到西安，由于西安到天水的航班取消了，我到西安后坐高铁到天水，然后在在天水去庄浪，待了两天后和彤彤一起回我家过年。在正月大雪初霁的初六坐车去杭州，先联系出租到县城，和二姐云亮吃了火锅，然后在二姐家住了一晚，第二天一大早出发，坐武山去天水的火车，然后去天水南站坐去杭州的高铁。</li><li>在武山去了前程的鱿鱼摊位，和他匆匆聊了几句，晚上去康智雄家，也是数年没见了。</li><li>2月份，去张凯家里坐了会，聊了聊各自工作的情况。</li><li>3月5日，植物园春游，灵峰山下梅花盛开，花团锦簇，游人如织。</li><li>4月9日，和彤彤去青山湖，从地铁站出来的湖边开阔处，一直走到杉树林，找到一个地方野餐。</li><li>4月17日，从五云山牌坊入口爬山，重游真迹寺，再走万林背山，到三分叉，从龙井村下山，走反了方向，朝九溪十八涧去了，没大路了才重新走回来打车。</li><li>5月3日，去凯旋家做客，他们俩热情地招待我们，吃完饭后玩了一会Switch</li><li>6月3日，7年后重游绍兴，坐地铁两个小时到鲁迅故居站，游鲁迅故居，王阳明故居，上次来吃的好吃饭店已经关门了。</li><li>6月4日，骑行杭州古城门，从西湖文化广场出发，先后去艮山门，庆春门，清泰门，望江门，候潮门至凤山水潮门，至此西湖的古城门算是都走过一圈了，虽然基本上出了一个写着名字的标志，没有别的什么留存了。</li><li>6月19日，高中同学东升换工作来杭州了，和他在青山湖科技城附近吃了饭，还吃到了他从家里带来的好吃的杏子。</li><li>7月1日，小团队去了西湖文体中心打羽毛球，攀岩，之后去西溪湿地里面聚餐。</li><li>7月9日，和彤彤夜游断桥。</li><li>7月14-7月17日，团队去成都outing，见了小爱，夜游锦江；团队去了杜甫草堂，武侯祠，乐山大佛，都江堰，大熊猫基地</li><li>7月24日，夜游钱塘江，骑自行车从近九堡大桥到新彭埠大桥</li><li>8月5日，和本科室友刘旸和他女朋友杨珈蒙聚餐</li><li>8月16日，和彤彤去杭州国家版本馆，里面的科技含量、文化含量远超预期，值得再去。</li><li>8月28日，和高中同学东升、聂小鹏在火车东站万象汇聚餐，和小鹏毕业后就没见过，已经11年了。</li><li>8月29日，独游钱王祠和万松书院，钱王祠的丹书铁券让人印象深刻，万松书院幽深高远，见湖亭上可远眺西湖雷峰塔。</li><li>8月30日，游杭州博物馆，杭州孔庙和西湖博物馆。</li><li>9月18日，独自去丰收湖，空无一人的公交和空荡荡的过街天桥，和充满孩子欢声笑语的公园形成鲜明的对比。</li><li>9月27日，和小伙伴们给实习生乃源饯行，他要去深圳实习了。 </li><li>10月4日，和彤彤去了春天去过的南苕溪，春去秋来，野草疯长，旧路难辨。</li><li>10月15日，与彤彤去植物园露营，待了大半天，桂花虽旺季已过，仍留有余香。</li><li>10月29日，独自去了飞来峰、灵隐寺，韬光寺，北高峰。灵隐寺建筑高大雄伟，里面香客稠密，代表的是寺庙鲜活的一面，而韬光寺需要走不少的山路才到，里面人不多，难得清净，但也难以寻觅白居易与韬光大师论道的踪迹.</li><li>11月5日，韶言师兄来杭参加云栖大会，实验室部分小伙伴在滨江浦江聚餐。</li><li>11月9日，下午小团队去爬老和山，日落后下山，穿过植物园，没人收门票。再次路过梅树区空无一人，之后去青芝坞旁的民宿体验客家菜，难忘的时刻.</li><li>11月27日，与彤彤从市民中心漫游到钱塘江边的城市阳台，路过杭州标志之一的大金球，在城市阳台看对面奥体中心附近的3D霓虹广告。</li></ul><h2 id="2023年的展望"><a href="#2023年的展望" class="headerlink" title="2023年的展望"></a>2023年的展望</h2><p>虽然断断续续写了一整天，在出租屋里，生活杂事和刷手机的冲动下，还是静不下心，感觉还有很多思考很多方面没写到，留待以后再补充吧。</p><p>2023年，给自己定一些小的要求，激励自己：</p><ul><li>遇到问题彻底搞懂再停止，不要提前选择简单的路径或似懂非懂，走hard但长久来看更根本的路径</li><li>做真正有影响力的工作，反思：如果别人来做，会做成怎么样，我比别人做的好在哪里？</li><li>提高工作效率，聚焦长期目标，突破工作上的瓶颈</li><li>不看微博热搜，不刷短视频，卸载快手和抖音，空闲时间多看书</li><li>保证每周写一篇技术博客，将遇到的技术问题和技术思考记录下来，锻炼思考总结能力</li><li>每周校准一次目标，确认是不是在短期任务上偏离了长期目标，如果出现偏差及时纠正</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在2022年，感谢身边的所有人，不管是陪在身边的老婆和肚子里的孩子，还是每天一起工作，一起吃食堂的干饭小伙伴，还是每周视频里远方的家人，还是偶尔在钉钉上问候一下的同学同事，还是躺在微信通讯录里面几年没联系的老友，你们构成了我这一年的思念和牵绊，也构成了我难忘的2022。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;多年以后，想起2022，我会回忆起哪个画面？为了解答这个问题，我回想过去的这些年份，2021，2020，……2005，看能想到什么。除了有些年份里，我结婚，毕业，所以有记忆深刻的事件，大部分年份我甚至想不起任何事情。对于一个模糊的数字，在多年以后，我们确实难以将它和自己一天天度过的日常事情关联起来。虽然2022年发生了很多事情，但大部分还是会被遗忘，但我还是尽量想用详细的文字记录下来，这样当以后想会看那年我身上发生了什么的时候，我知道只要在浏览器里面输入&lt;code&gt;vra.github.io/2022/12/31/summary-2022&lt;/code&gt;，这些时刻都会清晰地浮现在我眼前。&lt;/p&gt;</summary>
    
    
    
    
    <category term="年终总结" scheme="http://vra.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>git 更新历史提交</title>
    <link href="http://vra.github.io/2022/12/16/git-update-a-history-commit/"/>
    <id>http://vra.github.io/2022/12/16/git-update-a-history-commit/</id>
    <published>2022-12-16T01:01:45.000Z</published>
    <updated>2022-12-19T15:46:55.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>有时候我们在git commit后才发现，之前的一些提交有些问题，比如有些代码忘提交了或者有一些typo需要修改。如果要修改的地方是需要添加到最后一次提交上的，那么可以参考我的<a href="https://vra.github.io/2022/11/12/git-add-file-to-last-commit/">这篇博文</a>修改，如果是在非最后一次提交上的，那么就需要用<code>git rebase</code>来操作。这里简单记录一下操作的过程。</p><p><strong>TL;DR</strong><br>操作命令简要来说是这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用git log 查看历史提交，得到需要修改的那次提交的commit id</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 执行rebase命令，注意&lt;commit-id&gt;后面有一个^，表示修改在此次提交前</span></span><br><span class="line">git rebase -i <span class="string">&#x27;&lt;commmit-hash&gt;^&#x27;</span> <span class="comment"># 如果是修改第一次提交，使用 git rebase -i --root</span></span><br><span class="line"><span class="comment"># 修改代码</span></span><br><span class="line">vim changed-file</span><br><span class="line"><span class="comment"># git add 添加更新后的文件</span></span><br><span class="line">git add changed-file</span><br><span class="line"><span class="comment"># git commit 提交，注意需要使用后面三个选项，并且不需要加commit信息，因为会采用之前的commit信息</span></span><br><span class="line">git commit --all --amend --no-edit</span><br><span class="line"><span class="comment"># 使用--continue来完成 git rebase</span></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>后面会使用一个具体的（假）例子来演示这个过程。</p><span id="more"></span><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>假设我们创建了一个代码仓库<code>my_project</code>，先后创建并提交了<code>README.md</code>和<code>main.py</code>文件，但发现第一次的提交里面有一个typo，例如比<code>math</code>打成了<code>meth</code>，现在想要修改第一次提交。</p><p>首先构造”案发现场”:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir my_project &amp;&amp; <span class="built_in">cd</span> my_project</span><br><span class="line">git init</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is my meth library&quot;</span> &gt;&gt; README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;doc: add readme&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;import numpy as np&quot;</span> &gt;&gt; main.py</span><br><span class="line">git add main.py</span><br><span class="line">git commit -m <span class="string">&quot;feat: create main.py&quot;</span></span><br></pre></td></tr></table></figure><p>注意上面的typo <code>meth</code>。</p><p>我们发现了上述问题，但不想新建一个提交来修复，因为确实不算是新功能，那么就用<code>git rebase</code>来完成吧。</p><p>git rebase 是用来修改git commit的命令，提供了非常多的功能。这里我们用<code>git rebase -i</code>来交互式地修改某次commit。</p><p>首先用 <code>git log</code>查看commit ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">* 9bec788 - (HEAD -&gt; main) add sigmoid (31 minutes ago) &lt;xyz&gt;</span><br><span class="line">* ea833e9 - doc: add doc (31 minutes ago) &lt;xyz&gt;</span><br></pre></td></tr></table></figure><p>假如要修改第二次提交，那我们可以用<code>git rebase -i &#39;9bec788^</code>，但我们要修改的是第一次提交，没有之前的状态，所以要用下面的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i --root</span><br><span class="line">Successfully rebased and updated refs/heads/main.</span><br></pre></td></tr></table></figure><p>出来的交互式界面:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pick ea833e9 doc: add doc</span><br><span class="line">pick 9bec788 add sigmoid</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase 9bec788 onto 927493a (2 commands)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment"># p, pick &lt;commit&gt; = use commit</span></span><br><span class="line"><span class="comment"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment"># e, edit &lt;commit&gt; = use commit, but stop for amending</span></span><br><span class="line"><span class="comment"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment"># f, fixup [-C | -c] &lt;commit&gt; = like &quot;squash&quot; but keep only the previous</span></span><br><span class="line"><span class="comment">#                    commit&#x27;s log message, unless -C is used, in which case</span></span><br><span class="line"><span class="comment">#                    keep only this commit&#x27;s message; -c is same as -C but</span></span><br><span class="line"><span class="comment">#                    opens the editor</span></span><br><span class="line"><span class="comment"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span></span><br><span class="line"><span class="comment"># d, drop &lt;commit&gt; = remove commit</span></span><br><span class="line"><span class="comment"># l, label &lt;label&gt; = label current HEAD with a name</span></span><br><span class="line"><span class="comment"># t, reset &lt;label&gt; = reset HEAD to a label</span></span><br><span class="line"><span class="comment"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span><br><span class="line"><span class="comment">#         create a merge commit using the original merge commit&#x27;s</span></span><br><span class="line"><span class="comment">#         message (or the oneline, if no original merge commit was</span></span><br><span class="line"><span class="comment">#         specified); use -c &lt;commit&gt; to reword the commit message</span></span><br><span class="line"><span class="comment"># u, update-ref &lt;ref&gt; = track a placeholder for the &lt;ref&gt; to be updated</span></span><br><span class="line"><span class="comment">#                       to this position in the new commits. The &lt;ref&gt; is</span></span><br><span class="line"><span class="comment">#                       updated at the end of the rebase</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br></pre></td></tr></table></figure><p>底下注释中给出了rebase支持的一些命令和对应的缩写，我们将需要修改的提交前面的命令修改为<code>edit</code>，然后保存退出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">edit ea833e9 doc: add doc</span><br><span class="line">pick 9bec788 add sigmoid</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase 9bec788 onto e3f4cea (2 commands)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment"># p, pick &lt;commit&gt; = use commit</span></span><br><span class="line"><span class="comment"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment"># e, edit &lt;commit&gt; = use commit, but stop for amending</span></span><br><span class="line"><span class="comment"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment"># f, fixup [-C | -c] &lt;commit&gt; = like &quot;squash&quot; but keep only the previous</span></span><br><span class="line"><span class="comment">#                    commit&#x27;s log message, unless -C is used, in which case</span></span><br><span class="line"><span class="comment">#                    keep only this commit&#x27;s message; -c is same as -C but</span></span><br><span class="line"><span class="comment">#                    opens the editor</span></span><br><span class="line"><span class="comment"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span></span><br><span class="line"><span class="comment"># d, drop &lt;commit&gt; = remove commit</span></span><br><span class="line"><span class="comment"># l, label &lt;label&gt; = label current HEAD with a name</span></span><br><span class="line"><span class="comment"># t, reset &lt;label&gt; = reset HEAD to a label</span></span><br><span class="line"><span class="comment"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span><br><span class="line"><span class="comment">#         create a merge commit using the original merge commit&#x27;s</span></span><br><span class="line"><span class="comment">#         message (or the oneline, if no original merge commit was</span></span><br><span class="line"><span class="comment">#         specified); use -c &lt;commit&gt; to reword the commit message</span></span><br><span class="line"><span class="comment"># u, update-ref &lt;ref&gt; = track a placeholder for the &lt;ref&gt; to be updated</span></span><br><span class="line"><span class="comment">#                       to this position in the new commits. The &lt;ref&gt; is</span></span><br><span class="line"><span class="comment">#                       updated at the end of the rebase</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span><br></pre></td></tr></table></figure><p>保存后输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stopped at ea833e9...  doc: add doc</span><br><span class="line">You can amend the commit now, with</span><br><span class="line"></span><br><span class="line">  git commit --amend</span><br><span class="line"></span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line"></span><br><span class="line">  git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>用<code>git status</code> 查看代码状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interactive rebase <span class="keyword">in</span> progress; onto e3f4cea</span><br><span class="line">Last <span class="built_in">command</span> <span class="keyword">done</span> (1 <span class="built_in">command</span> <span class="keyword">done</span>):</span><br><span class="line">   edit ea833e9 doc: add doc</span><br><span class="line">Next <span class="built_in">command</span> to <span class="keyword">do</span> (1 remaining <span class="built_in">command</span>):</span><br><span class="line">   pick 9bec788 add sigmoid</span><br><span class="line">  (use <span class="string">&quot;git rebase --edit-todo&quot;</span> to view and edit)</span><br><span class="line">You are currently editing a commit <span class="keyword">while</span> rebasing branch <span class="string">&#x27;main&#x27;</span> on <span class="string">&#x27;e3f4cea&#x27;</span>.</span><br><span class="line">  (use <span class="string">&quot;git commit --amend&quot;</span> to amend the current commit)</span><br><span class="line">  (use <span class="string">&quot;git rebase --continue&quot;</span> once you are satisfied with your changes)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>git 的提示信息还是很丰富的，按照提示来操作代码，将<code>meth</code> 修改为<code>math</code>，再<code>git add</code>, <code>git commit --all --amend --no-edit</code>和 <code>git rebase --continue</code> 来结束rebase:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git add README.md</span><br><span class="line"></span><br><span class="line">$ git commit --all --amend --no-edit</span><br><span class="line">[detached HEAD 3b83a85] doc: add doc</span><br><span class="line"> Date: Sat Dec 17 18:00:12 2022 +0800</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br><span class="line"> create mode 100644 README.md</span><br><span class="line"></span><br><span class="line">$ git rebase --<span class="built_in">continue</span></span><br><span class="line">Successfully rebased and updated refs/heads/main.</span><br></pre></td></tr></table></figure><p>然后用<code>git log</code>查看命令，可以看到修改的那次提交和后续提交的编号都已经更新了，意味着这是全新的提交，跟之前的提交没有关系了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;有时候我们在git commit后才发现，之前的一些提交有些问题，比如有些代码忘提交了或者有一些typo需要修改。如果要修改的地方是需要添加到最后一次提交上的，那么可以参考我的&lt;a href=&quot;https://vra.github.io/2022/11/12/git-add-file-to-last-commit/&quot;&gt;这篇博文&lt;/a&gt;修改，如果是在非最后一次提交上的，那么就需要用&lt;code&gt;git rebase&lt;/code&gt;来操作。这里简单记录一下操作的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;&lt;br&gt;操作命令简要来说是这样:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 使用git log 查看历史提交，得到需要修改的那次提交的commit id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 执行rebase命令，注意&amp;lt;commit-id&amp;gt;后面有一个^，表示修改在此次提交前&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git rebase -i &lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;lt;commmit-hash&amp;gt;^&amp;#x27;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# 如果是修改第一次提交，使用 git rebase -i --root&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 修改代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vim changed-file&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# git add 添加更新后的文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git add changed-file&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# git commit 提交，注意需要使用后面三个选项，并且不需要加commit信息，因为会采用之前的commit信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit --all --amend --no-edit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 使用--continue来完成 git rebase&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git rebase --&lt;span class=&quot;built_in&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;后面会使用一个具体的（假）例子来演示这个过程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>使用 defaultdict 来简化 dict 的初始化</title>
    <link href="http://vra.github.io/2022/12/10/python-defaultdict-usage/"/>
    <id>http://vra.github.io/2022/12/10/python-defaultdict-usage/</id>
    <published>2022-12-10T07:17:17.000Z</published>
    <updated>2022-12-10T07:57:10.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在我们使用Python中的dict时，常常需要判断某个关键字是否已经在dict中，如果不存在则创建，非空则进行另外的操作。例如统计一篇文章中所有单词出现次数的代码，大致写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">words_num = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> words_num.keys():</span><br><span class="line">        words_num[word] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        words_num[word] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样写总是需要判断key是否在dict中，不是很优雅。</p><p>Python标准库collections中<a href="https://docs.python.org/3/library/collections.html#defaultdict-objects">defaultdict</a>类可以很好的解决这个问题。这个类使用与dict几乎一样，除了可以在初始化时设置key的默认类型和数值。类的声明格式为<code>defaultdict(default_factory=None, /[, ...])</code>，<code>default_factory</code>是一个<code>callable</code>的变量。</p><p>别的使用与dict无异，正常使用即可。</p><span id="more"></span><p>例如，<code>foo = defaultdict(int)</code>表示foo中的key的默认类型是int，且默认值为int的默认值0，我们可以获取<strong>任意</strong>的key，不需要手动初始化key:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;whatever&#x27;</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>所以最开始的例子可以简化为如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">words_num = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    words_num[word] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看到使用defaultdict后，代码中只需要关注上层逻辑（统计单词的出现次数），而不需要关注具体的语法的代码实现（dict是否存在某个key，没有的话xxx，有的话xxx），因此世界变得更美好了一些。</p><p>除了int外，用list，tuple，dict，set等作为变量也比较常见。除了内置类型外，还可以自定义函数，比如设置key的默认值为<code>&#39;China&#39;</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_default_contry</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">&quot;China&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from = defaultdict(set_default_contry)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from[<span class="string">&#x27;张三&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;China&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from[<span class="string">&#x27;李四&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;China&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from[<span class="string">&#x27;Tim&#x27;</span>] = <span class="string">&#x27;USA&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from</span><br><span class="line">defaultdict(&lt;function set_default_contry at <span class="number">0x10896eca0</span>&gt;, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;China&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>: <span class="string">&#x27;China&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>: <span class="string">&#x27;China&#x27;</span>, <span class="string">&#x27;Tim&#x27;</span>: <span class="string">&#x27;USA&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p><code>defauldict</code>是一个简单但很好用的功能，在日常的使用中还是能减少一些代码复杂度的。希望这篇小文能给让你写代码更容易，更开心。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;在我们使用Python中的dict时，常常需要判断某个关键字是否已经在dict中，如果不存在则创建，非空则进行另外的操作。例如统计一篇文章中所有单词出现次数的代码，大致写法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;words_num = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; word &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; words:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; word &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; words_num.keys():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        words_num[word] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        words_num[word] += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样写总是需要判断key是否在dict中，不是很优雅。&lt;/p&gt;
&lt;p&gt;Python标准库collections中&lt;a href=&quot;https://docs.python.org/3/library/collections.html#defaultdict-objects&quot;&gt;defaultdict&lt;/a&gt;类可以很好的解决这个问题。这个类使用与dict几乎一样，除了可以在初始化时设置key的默认类型和数值。类的声明格式为&lt;code&gt;defaultdict(default_factory=None, /[, ...])&lt;/code&gt;，&lt;code&gt;default_factory&lt;/code&gt;是一个&lt;code&gt;callable&lt;/code&gt;的变量。&lt;/p&gt;
&lt;p&gt;别的使用与dict无异，正常使用即可。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>git如何添加文件到最新的提交</title>
    <link href="http://vra.github.io/2022/11/12/git-add-file-to-last-commit/"/>
    <id>http://vra.github.io/2022/11/12/git-add-file-to-last-commit/</id>
    <published>2022-11-12T09:54:22.000Z</published>
    <updated>2022-12-16T00:54:01.016Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，在git commit后，我们会发现一些文件忘了提交了，或者需要修改，而且这些提交和修改是与上一次commit的主题一致的，这时候再执行一遍相同的git commit就会让提交记录显得比较冗余，有没有办法将修改后的文件加到最后一次的提交记录里面呢？搜索后发现<a href="https://stackoverflow.com/a/40503483">这里</a>给了一个解决办法，git add文件后调用<code>git commit --amend -no-edit</code>即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file_path&gt;</span><br><span class="line">git commit --amend --no-edit</span><br></pre></td></tr></table></figure><p><strong>注意：如果之前的代码已经提交的话，需要执行<code>git push --force</code>来推送代码以替代之前的提交记录。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有时候，在git commit后，我们会发现一些文件忘了提交了，或者需要修改，而且这些提交和修改是与上一次commit的主题一致的，这时候再执行一遍相同的git commit就会让提交记录显得比较冗余，有没有办法将修改后的文件加到最后一次的提交记录里面呢？搜索后发现&lt;a h</summary>
      
    
    
    
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
    <category term="TIL" scheme="http://vra.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>执行du命令时统计隐藏文件和目录</title>
    <link href="http://vra.github.io/2022/11/07/du-show-hidden-folders/"/>
    <id>http://vra.github.io/2022/11/07/du-show-hidden-folders/</id>
    <published>2022-11-07T15:32:23.000Z</published>
    <updated>2022-11-07T15:38:24.784Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux和Mac下，执行<code>du -sh</code> 来统计目录大小时，默认不统计以点开头的文件或者目录，比如<code>.local</code>，因此得到不准确的统计结果。从<a href="https://superuser.com/a/633808">这里</a>知道，要统计隐藏文件和目录，可以这么用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只统计隐藏文件或者目录</span></span><br><span class="line">du -sh .[^.]*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计隐藏文件或者目录和常规文件</span></span><br><span class="line">du -sh .[^.]* *</span><br></pre></td></tr></table></figure><p>结合 <code>sort -h</code>，可以快速得到比较大的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh .[^.]* * |sort -h</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Linux和Mac下，执行&lt;code&gt;du -sh&lt;/code&gt; 来统计目录大小时，默认不统计以点开头的文件或者目录，比如&lt;code&gt;.local&lt;/code&gt;，因此得到不准确的统计结果。从&lt;a href=&quot;https://superuser.com/a/633808&quot;&gt;</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="TIL" scheme="http://vra.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>如何举办一个顶会学术比赛</title>
    <link href="http://vra.github.io/2022/10/30/how-to-host-a-challenge/"/>
    <id>http://vra.github.io/2022/10/30/how-to-host-a-challenge/</id>
    <published>2022-10-30T12:34:41.000Z</published>
    <updated>2022-10-30T16:13:55.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>今年我和团队成员一起组织了了ECCV上的一个<a href="https://sites.google.com/view/wcpa2022/home">学术比赛</a>。从1.31日开始准备材料开始，到前两天(10.28日) 把奖金和奖状发给选手，活动结束，整个周期持续了近9个月，真的是出乎意料。整体流程包括Workshop Proposal编写和申请、Workshop合并（多个申请团队合并成一个Workshop），网站搭建，比赛数据和baseline准备，比赛平台搭建，比赛奖金申请，比赛宣传和选手招募、比赛论文评审、参加线上Workshop介绍比赛，奖金和证书颁发等等，第一次参与组织这种比赛，学到了挺多东西，这里记录备忘，下次参考。需要说明的是，这里的分享的都是个人观点，与我所在公司无关。</p><span id="more"></span><h2 id="2-时间流水线记录"><a href="#2-时间流水线记录" class="headerlink" title="2. 时间流水线记录"></a>2. 时间流水线记录</h2><p>这里记录整个过程中的一些关键行动和一些注意事项。</p><h3 id="2-1-前期准备"><a href="#2-1-前期准备" class="headerlink" title="2.1. 前期准备"></a>2.1. 前期准备</h3><p>首先要注意，要申办Workshop或者比赛的话，涉及事务多，需要一个团队来共同来负责，而且周期长，占用时间比较多，办比赛的话还需要奖金的申请，这些都需要团队Leader的理解和支持。同时需要一些学术界有声望的教授来一起参与，这样申请通过的概率会大一些。我们组内有跟学术界的长期合作，这次也是一起申办的。另一个是比赛一般需要新的数据集，有内部的数据团队或者合作的数据公司也会更好一些，分担一些数据收集和准备的任务。<br>有这些条件后，还是得思考Workshop或者比赛的主题，也就是为了解决学术界还是工业界的什么核心问题，来举办这样一个比赛。这样比赛意义会更重大，参赛选手的方案也许能推进某个方向的SOTA。</p><p>确定要举办Workshop或者比赛后，就需要盘点参与人员，提前联系学术界和数据公司的合作方，通通气，确认参与意向。</p><h3 id="2-2-撰写-Workshop-Proposal"><a href="#2-2-撰写-Workshop-Proposal" class="headerlink" title="2.2 撰写 Workshop Proposal"></a>2.2 撰写 Workshop Proposal</h3><p>接下来就需要写 Workshop Proposal给大会，大会收到后通过申请，才可以正式举办 Workshop。</p><p>Workshop Proposal 的撰写参考大会给的要求，填写workshop主体，比赛任务描述和对应的指标描述，主办者的资料等。</p><h3 id="2-3-嘉宾邀请"><a href="#2-3-嘉宾邀请" class="headerlink" title="2.3 嘉宾邀请"></a>2.3 嘉宾邀请</h3><p>为了让Workshop Proprasl更容易通过，需要邀请一些学术界有声望的教授，作为Workshop的主席。同时还需要邀请一些人来做邀请嘉宾作报告。</p><h3 id="2-4-合并-Workshop"><a href="#2-4-合并-Workshop" class="headerlink" title="2.4. 合并 Workshop"></a>2.4. 合并 Workshop</h3><p>Proposal 提交上去后，主办方可能会反馈workshop申请太多，需要合并某几个workshop团队，一起举办一个workshop。这时候就需要团队一起讨论来决定了。最后我们和意大利的一个大学合办workshop，他们负责regular paper的接收和评审，我们负责challenge比赛部分。除了邮件沟通外，IM采用slack，整体使用还比较方便，双方用英文沟通。</p><h3 id="2-5-比赛网站构建"><a href="#2-5-比赛网站构建" class="headerlink" title="2.5. 比赛网站构建"></a>2.5. 比赛网站构建</h3><p>确定负责比赛后，我们制定了比赛的流程，包括什么时候开放队伍注册，测评服务开启，第一阶段和第二阶段，技术报告什么时候提交，workshop举办日期等。还有最重要的，奖金是多少。具体金额需要和宣传和财务部分确定。同时还有参赛者的条件，比如是否允许企业参加，是否允许公司内部人士参加等。所有这些信息都发布到比赛网站上，保证在宣传开始的时候，参赛者看到的是一个日期完整、奖金和名额分布清晰的比赛。</p><h3 id="2-6-比赛数据准备"><a href="#2-6-比赛数据准备" class="headerlink" title="2.6. 比赛数据准备"></a>2.6. 比赛数据准备</h3><p>数据需要按照train, validation, test 集合准备好，分validation和test是为了避免参赛者过拟合，可以在第一阶段用validation集，第二阶段用test集，筛选出啊泛化性更好的方案。</p><p>如有必要，参赛选手需要签署一份数据协议才能使用数据，协议内容可以包括选手只有数据的使用权，没有分发权等等，视你们的数据要求而定。</p><p>数据准备好后上传到网盘平台，为了保证国内外选手都可以访问，可以上传国内国外的多个平台。同时如有必要，对数据进行加密，只有签署了数据协议的人才可以解压数据，避免数据的泄漏。</p><h3 id="2-7-参赛选手审核"><a href="#2-7-参赛选手审核" class="headerlink" title="2.7 参赛选手审核"></a>2.7 参赛选手审核</h3><p>参赛选手需要是研究机构的，所以我们要求报名时填写学校邮箱，注明单位信息，提交数据声明。这些信息审核通过后，回复邮件确认。</p><h3 id="2-8-测评服务搭建与baseline准备"><a href="#2-8-测评服务搭建与baseline准备" class="headerlink" title="2.8. 测评服务搭建与baseline准备"></a>2.8. 测评服务搭建与baseline准备</h3><p>比赛平台可以选择公开的平台，Kaggle，CoLab，也可以选公司的平台。因为CV顶会的比赛面向的是全球的CVer，因此尽量选择中英文都支持的平台。</p><p>平台选择后，需要部署Evaluation Server，也就是参赛者上传代码或者输出，拿到分数的服务。首先需要确定输入和输出，以及最终榜单排名的评价指标，这部分需要在比赛开始的时候就在Workshop Propoal里面写出来，这里需要用具体的代码来实现出来。具体代码测评可以用平台已有的接口，因为大平台任务很多，接口都比较成熟。</p><p>然后在比赛网站写详细的教程，指导参赛者怎么下载数据、理解数据、跑baseline、提交结果、查看榜单。最好是给出一个quick start或者可以直接跑的代码，让参赛者能完整地走完流程，提交一个baseline的结果。</p><h3 id="2-9-比赛宣传和选手招募"><a href="#2-9-比赛宣传和选手招募" class="headerlink" title="2.9. 比赛宣传和选手招募"></a>2.9. 比赛宣传和选手招募</h3><p>比赛建立起来后，需要对比赛进行宣传，让更多的人来加入。这时候可以发表公司或部门的公众号文章来进行宣传，同时也可以针对专门的打比赛群和网站来找专门的人来宣传，比如在xxx公众号发表一篇相关的文章，不过大号价格都毕竟贵。</p><p>另外可以让实习生或者同学、学弟学妹在学校的论坛、BBS、系里面的群、实验室的群里面进行宣传。</p><h3 id="2-10-选手答疑"><a href="#2-10-选手答疑" class="headerlink" title="2.10. 选手答疑"></a>2.10. 选手答疑</h3><p>针对选手的问题，需要及时回复，如果是有共性的问题，要在论坛上或者网站上进行通知，让所有人都知道，也避免每个人都来问一遍。</p><h3 id="2-11-论文评审与代码查重"><a href="#2-11-论文评审与代码查重" class="headerlink" title="2.11. 论文评审与代码查重"></a>2.11. 论文评审与代码查重</h3><p>比赛结束后，参赛队伍需要提交一份比赛方案介绍的Report，来描述他们的方法，同时为了避免作弊，可能还需要参赛者上传一份代码，这里就涉及到对Report的评审和代码的查重。代码查重好做，利用查重软件或者类似工具就可以，Report的评审还需要花比较多时间来做。</p><p>我认为比赛Report评审的核心是比赛方案的介绍是否清楚，包括输入输出是否符合规范，网络细节、训练测试过程、超参是否描述清楚，数值对比和ablation study是否充分等等。与常规论文不同，比赛Report的创新性的占比其实不是太高的。</p><p>评审完后需要写反馈意见，确定论文是否被接收。是否接收需要综合考虑论文的质量和比赛的排名。尽可能写一些有用的comments给作者，然后参赛者写Camera Ready版本。</p><p>如果比赛论文走大会的proceeding的话，需要提醒作者注册大会，尽早购买早鸟票，因为作者不注册的话论文不能正常发表。一般一篇论文有一个作者注册大会就可以，所以在Camera Ready版本中可以添加中了正会论文的作者进来。</p><h3 id="2-12-比赛名次确定"><a href="#2-12-比赛名次确定" class="headerlink" title="2.12. 比赛名次确定"></a>2.12. 比赛名次确定</h3><p>在论文评审完后，需要根据是否存在违规和论文来确定最终的名次，不符合规定的团队不参与最终的排名，由后面的队伍补上。名次确定后需要在比赛网站上公示，让所有参赛者周知。</p><h3 id="2-13-Workshop比赛介绍与Winner-Talk-Host"><a href="#2-13-Workshop比赛介绍与Winner-Talk-Host" class="headerlink" title="2.13. Workshop比赛介绍与Winner Talk Host"></a>2.13. Workshop比赛介绍与Winner Talk Host</h3><p>在Workshop召开的时候，需要有一个人来做演讲介绍整个比赛，可以包括Organizers介绍，比赛背景，数据集情况，任务介绍，参与情况，以及获奖团队的介绍。这个部分的Slides组织可以参考历年CV顶会上的比赛介绍视频，学习他们做的比较好的地方。</p><p>比赛介绍完后，会议的主持人可能还会让你主持Winner Talk，所以提前准备下，介绍一下演讲团队，提一些问题，Move to next speaker等，讲完后对比赛做一个总结。</p><p>这里有一个细节，就是不需要比赛主办的所有成员都需要注册大会（注册大会费用很高），只要一个人注册，在大会网站上拿到zoom会议的链接后，可以发送给别的主办者，让他们加入zoom会议来演讲或者观看。</p><h3 id="2-14-奖金与证书颁发"><a href="#2-14-奖金与证书颁发" class="headerlink" title="2.14. 奖金与证书颁发"></a>2.14. 奖金与证书颁发</h3><p>奖金发放需要获奖者填写一张银行卡信息来收钱。这里需要保证团队的所有人都知情，避免一个队员填写自己的银行卡信息而未经别的组员同意，产生的纠纷。一些解决办法是大家签署奖金发放同意书，或者邮件抄送所有队员。</p><p>证书颁发涉及到证书制作，证书制作需要一个证书模板，可以采用Office网站上的<a href="https://templates.office.com/zh-cn/%e8%af%81%e4%b9%a6">证书模板</a>，选择喜欢的来修改。具体内容可以搜索一下CVPR，ICCV和ECCV这些大会往年的证书图片，自己参考下，或者让公司的设计团队来制作一个。制作好后可以发送电子版，如果可以线下举办的话，制作一份纸质版颁发给参赛者。</p><h2 id="3-感想"><a href="#3-感想" class="headerlink" title="3. 感想"></a>3. 感想</h2><h3 id="3-1-举办-Workshop的意义"><a href="#3-1-举办-Workshop的意义" class="headerlink" title="3.1 举办 Workshop的意义"></a>3.1 举办 Workshop的意义</h3><p>对于公司来说，如果能举办一个受欢迎的Workshop或者比赛，既可以宣传公司，也可以招揽一些参赛选手，同时如果比赛的方案如果能对业务中的难题有一些启发，那就更好了。<br>对于个人来说，参与举办Workshop绝对是一次受益颇多的经历。首先是锻炼沟通能力。此次过程中，沟通的团队包括自己团队、国内国外高校老师、合作公司、公司内部宣传部门、比赛平台部门、网盘部门、参赛选手，如何有效沟通，在规定的时间里高效地完成既定目标，如何避免突发事故，都很考验我们的沟通能力。同时是锻炼组织能力，比赛消息怎么传递给参赛者，面对参赛者的延期请求怎么处理，都是之前做research写代码没有遇到过的问题。最后还是英文的文档撰写和交流能力的提升，以及参与Workshop时对自身学术能力的提升。我觉得通过这样一次活动，对以后怎么组织类似的活动有信心了，也相信以后能组织好同样的活动。</p><h3 id="3-2-一些经验总结"><a href="#3-2-一些经验总结" class="headerlink" title="3.2 一些经验总结"></a>3.2 一些经验总结</h3><ul><li>决定尽早做，涉及到某些流程和方案修改的，需要尽早决定，不拖延，因为拖延意味着某些人还在按之前的方案进行，浪费了时间和精力，做了无用功</li><li>信息公布尽量做到公开透明，让需要了解的各方都了解变更，因为各方的意见可能不同，或者有更好的解决办法</li><li>每支队伍要设置一个固定的联络人，从始至终保持不变（特殊情况除外），并保证联络人能联系上，也就是有联络人的钉钉微信邮箱和电话，保证紧急情况下能联系上ta，由ta来进一步联络队员</li><li>对于参赛者的一些请求，如延长比赛时间，需要站在大多人参赛者的角度考虑，同时避免修改后影响后续流程。实际上每个修改在某些方面都是有积极意义的，这里需要做一些符合大家利益的取舍</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;今年我和团队成员一起组织了了ECCV上的一个&lt;a href=&quot;https://sites.google.com/view/wcpa2022/home&quot;&gt;学术比赛&lt;/a&gt;。从1.31日开始准备材料开始，到前两天(10.28日) 把奖金和奖状发给选手，活动结束，整个周期持续了近9个月，真的是出乎意料。整体流程包括Workshop Proposal编写和申请、Workshop合并（多个申请团队合并成一个Workshop），网站搭建，比赛数据和baseline准备，比赛平台搭建，比赛奖金申请，比赛宣传和选手招募、比赛论文评审、参加线上Workshop介绍比赛，奖金和证书颁发等等，第一次参与组织这种比赛，学到了挺多东西，这里记录备忘，下次参考。需要说明的是，这里的分享的都是个人观点，与我所在公司无关。&lt;/p&gt;</summary>
    
    
    
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Computer Vision" scheme="http://vra.github.io/tags/Computer-Vision/"/>
    
    <category term="Workshop" scheme="http://vra.github.io/tags/Workshop/"/>
    
    <category term="Challenge" scheme="http://vra.github.io/tags/Challenge/"/>
    
  </entry>
  
  <entry>
    <title>Python中将图像切分为小的patch</title>
    <link href="http://vra.github.io/2022/10/15/python-split-image-to-grid-patch/"/>
    <id>http://vra.github.io/2022/10/15/python-split-image-to-grid-patch/</id>
    <published>2022-10-14T23:51:36.000Z</published>
    <updated>2022-10-15T03:37:09.291Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h3><p>假如有张1000x1000的图像，我们要将它切成20x20的小patch，该怎么处理呢？<br>最简单的方法就是采用两重for循环，每次计算小patch对应的下标，在原图上进行crop:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">size = <span class="number">1000</span></span><br><span class="line">ncols = <span class="number">20</span></span><br><span class="line">nrows = <span class="number">20</span></span><br><span class="line">img = np.random.rand(size, size)</span><br><span class="line"></span><br><span class="line">patches = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size//ncols):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(size//nrows):</span><br><span class="line">patch = img[ncols*i:ncols*(i+<span class="number">1</span>), nrows*j:nrows*(j+<span class="number">1</span>)]</span><br><span class="line">patches.append(patch)</span><br><span class="line"></span><br><span class="line">patches = np.array(patches)</span><br></pre></td></tr></table></figure><p>但这样总共需要循环50*x50=2500次，而我们知道 Python 的 for 循环比较慢，因此整体开销还是比较大的，有没有更快的方式呢？</p><span id="more"></span><h3 id="reshape-swapaxes"><a href="#reshape-swapaxes" class="headerlink" title="reshape + swapaxes"></a>reshape + swapaxes</h3><p>搜索发现可以使用 reshape + swapaxes函数的组合来完成这个功能:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">size = <span class="number">1000</span></span><br><span class="line">ncols = <span class="number">20</span></span><br><span class="line">nrows = <span class="number">20</span></span><br><span class="line">img = np.random.rand(size, size)</span><br><span class="line"></span><br><span class="line">patches = img.reshape(size // ncols, ncols, -<span class="number">1</span>, nrows).swapaxes(<span class="number">1</span>, <span class="number">2</span>).reshape(-<span class="number">1</span>, ncols, nrows)</span><br></pre></td></tr></table></figure><p>完整对比代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">size = <span class="number">1000</span></span><br><span class="line">ncols = <span class="number">20</span></span><br><span class="line">nrows = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计100次耗时</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    img = np.random.rand(size, size)</span><br><span class="line">    t0 = time.time()</span><br><span class="line">    patches0 = img.reshape(size // ncols, ncols, -<span class="number">1</span>, nrows).swapaxes(<span class="number">1</span>, <span class="number">2</span>).reshape(-<span class="number">1</span>, ncols, nrows)</span><br><span class="line"></span><br><span class="line">    t1 = time.time()</span><br><span class="line">    d1 = t1 - t0</span><br><span class="line"></span><br><span class="line">    patches = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size//ncols):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(size//nrows):</span><br><span class="line">            patch = img[ncols*i:ncols*(i+<span class="number">1</span>), nrows*j:nrows*(j+<span class="number">1</span>)]</span><br><span class="line">            patches.append(patch)</span><br><span class="line"></span><br><span class="line">    patches1 = np.array(patches)</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    d2 = t2 - t1</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;time ratio:&#x27;</span>, d2/d1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;diff:&#x27;</span>, (patches0-patches1).<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure><p>实际测试对于1000x1000的图像，采用reshape + swapaxes 要比循环快大约4倍。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">time ratio: 4.684571428571428</span><br><span class="line">diff: 0.0</span><br><span class="line">time ratio: 4.806614785992218</span><br><span class="line">diff: 0.0</span><br><span class="line">time ratio: 4.696482035928144</span><br><span class="line">diff: 0.0</span><br><span class="line">time ratio: 3.00382226469183</span><br><span class="line">diff: 0.0</span><br><span class="line">time ratio: 3.710854363028276</span><br><span class="line">diff: 0.0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="Pytorch中的实现？"><a href="#Pytorch中的实现？" class="headerlink" title="Pytorch中的实现？"></a>Pytorch中的实现？</h3><p>Pytorch相比numpy，又增加了许多操作tensor的函数，因此实现方式会更多，这里大概列一下几种实现，具体函数可以查询 Pytorch 的文档:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">patches1 = img.unfold(<span class="number">0</span>, ncols, nrows).unfold(<span class="number">1</span>, ncols, nrows).reshape(-<span class="number">1</span>, ncols, nrows)</span><br><span class="line">patches2 = img.reshape(size//ncols, ncols, -<span class="number">1</span>, nrows).swapaxes(<span class="number">1</span>, <span class="number">2</span>).reshape(-<span class="number">1</span>, ncols, nrows)</span><br><span class="line">patches3 = img.reshape(size//ncols, ncols, -<span class="number">1</span>, nrows).permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>).reshape(-<span class="number">1</span>, ncols, nrows)</span><br></pre></td></tr></table></figure><h3 id="其他相关操作"><a href="#其他相关操作" class="headerlink" title="其他相关操作"></a>其他相关操作</h3><p>ShuffleNet中的ShuffleBlock中的channel shuffle也是通过reshape+维度变换来完成的，可以参考<a href="https://github.com/MegEngine/Models/blob/master/official/vision/classification/shufflenet/model.py#L98">这里</a> 和<a href="https://iq.opengenus.org/shufflenet-implementation-using-pytorch/">这里</a>的实现。</p><p>另外之前一篇做分割的论文<a href="https://arxiv.org/abs/1702.08502">DUC</a>里面也用到了类似的把图像特征重排列来Upsample的操作，<a href="https://github.com/ycszen/pytorch-segmentation/blob/master/duc.py#L18">搜索了下</a>对应的实现，是用Pytorch的PixelShuffle来做的，具体用法参考<a href="https://pytorch.org/docs/stable/generated/torch.nn.PixelShuffle.html">文档</a>，还有个匹配的PixelUnShuffle来进行逆向操作。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://stackoverflow.com/questions/16856788/slice-2d-array-into-smaller-2d-arrays/16858283#16858283">https://stackoverflow.com/questions/16856788/slice-2d-array-into-smaller-2d-arrays/16858283#16858283</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;问题定义&quot;&gt;&lt;a href=&quot;#问题定义&quot; class=&quot;headerlink&quot; title=&quot;问题定义&quot;&gt;&lt;/a&gt;问题定义&lt;/h3&gt;&lt;p&gt;假如有张1000x1000的图像，我们要将它切成20x20的小patch，该怎么处理呢？&lt;br&gt;最简单的方法就是采用两重for循环，每次计算小patch对应的下标，在原图上进行crop:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;size = &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ncols = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nrows = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;img = np.random.rand(size, size)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;patches = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;range&lt;/span&gt;(size//ncols):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;range&lt;/span&gt;(size//nrows):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		patch = img[ncols*i:ncols*(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), nrows*j:nrows*(j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		patches.append(patch)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;patches = np.array(patches)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;但这样总共需要循环50*x50=2500次，而我们知道 Python 的 for 循环比较慢，因此整体开销还是比较大的，有没有更快的方式呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="Numpy" scheme="http://vra.github.io/tags/Numpy/"/>
    
    <category term="Pytorch" scheme="http://vra.github.io/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>用Python将图片转换为base64字符串</title>
    <link href="http://vra.github.io/2022/10/07/convert-image-to-base64/"/>
    <id>http://vra.github.io/2022/10/07/convert-image-to-base64/</id>
    <published>2022-10-07T14:19:37.000Z</published>
    <updated>2022-10-07T14:26:06.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>无他，这篇博文记录一下利用Python将OpenCV图片转换为base64字符串并在网页上进行展示的过程，权当备忘。可在<a href="https://github.com/vra/image-to-base64">这里</a>查看源码。</p><span id="more"></span><h3 id="2-Show-the-code"><a href="#2-Show-the-code" class="headerlink" title="2. Show the code"></a>2. Show the code</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_to_base64</span>(<span class="params">img_path</span>):</span></span><br><span class="line">    img = cv2.imread(img_path)</span><br><span class="line"></span><br><span class="line">    _, buffer = cv2.imencode(<span class="string">&#x27;.jpg&#x27;</span>, img)</span><br><span class="line">    text = base64.b64encode(buffer).decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_html_file</span>(<span class="params">text, file_name</span>):</span></span><br><span class="line">    html_pattern = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;img src=&quot;data:image/png;base64,&#123;&#125;&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;/html&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    html = html_pattern.<span class="built_in">format</span>(text)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img_path = <span class="string">&#x27;data/cat.jpg&#x27;</span></span><br><span class="line">    html_file_name = <span class="string">&#x27;data/show_img.html&#x27;</span></span><br><span class="line"></span><br><span class="line">    text = img_to_base64(img_path)</span><br><span class="line">    create_html_file(text, html_file_name)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;无他，这篇博文记录一下利用Python将OpenCV图片转换为base64字符串并在网页上进行展示的过程，权当备忘。可在&lt;a href=&quot;https://github.com/vra/image-to-base64&quot;&gt;这里&lt;/a&gt;查看源码。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="HTML" scheme="http://vra.github.io/tags/HTML/"/>
    
    <category term="OpenCV" scheme="http://vra.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>fly.io 使用指南</title>
    <link href="http://vra.github.io/2022/10/06/fly-io-tutorial/"/>
    <id>http://vra.github.io/2022/10/06/fly-io-tutorial/</id>
    <published>2022-10-06T00:18:04.000Z</published>
    <updated>2022-12-19T16:16:09.680Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>最近看技术论坛，发现提到 <a href="https://fly.io/">fly.io</a> 的次数越来越多了。 fly.io 是一个容器化的部署平台，只需要一个<code>Dockerfile</code>文件就能部署代码到fly.io 的服务器上，同时还自动生成域名。其他的好处多多，我根据自己体验，我总结成了下面的这些条：</p><ul><li><p><del>有免费使用的额度。不填写信用卡信息可以创建一个App，完全不收费；填写信用卡信息后每月有一定额度的免费流量，超过额度会额外收费。所以想做个小demo完全可以不填信用卡试用。</del> 目前已经不支持无信用卡使用了，参见<a href="https://community.fly.io/t/is-it-free-getting-error-we-need-your-payment-information-to-continue/8871">这里</a>的讨论</p></li><li><p>自动生成域名。比如你创建一个名字叫<code>my_demo</code>的App，那么部署完成后，就会生成<code>my_demo.fly.dev</code>的域名，可以全球访问，不用自己单独买域名了。</p></li><li><p>可以 SSH 连接进入服务器。部署完成后，可以通过<code>flyctl ssh console</code> 命令登录部署的服务器，所以相当于你有了一台免费的VPS，可以做你想做的任何事情。</p></li><li><p>部署简单，采用<code>flyctl</code> 命令集合统一部署;支持各种语言的各种框架来搭建部署环境，能自动识别当前目录下代码所采用的是哪个框架，自动部署。</p></li></ul><p>下面简单记录一下使用的流程和一些教程里面没提及的使用命令。</p><span id="more"></span><h3 id="2-部署一个应用"><a href="#2-部署一个应用" class="headerlink" title="2. 部署一个应用"></a>2. 部署一个应用</h3><p>这里以Python 的 Flask 框架为例，进行部署的步骤总结，其实fly.io支持很多框架，可以在<a href="https://fly.io/docs/speedrun/">这里</a>查看。</p><h4 id="2-1-安装-flyctl"><a href="#2-1-安装-flyctl" class="headerlink" title="2.1 安装 flyctl"></a>2.1 安装 flyctl</h4><p>首先需要安装 flyctl 这个工具：<br>Mac:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install flyctl</span><br></pre></td></tr></table></figure><p>Linux:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://fly.io/install.sh | sh</span><br></pre></td></tr></table></figure><p>Windows:<br>在Powershell中运行下面的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iwr https://fly.io/install.ps1 -useb | iex</span><br></pre></td></tr></table></figure><p>如果执行<code>flyctl version</code> 不报错，就说明安装成功了。</p><p><strong>一个小技巧，flyctl还有个alias fly，敲起来更简短些。</strong></p><p>安装这个工具是一次性的，后面不需要再操作</p><h4 id="2-2-创建并登录账号"><a href="#2-2-创建并登录账号" class="headerlink" title="2.2 创建并登录账号"></a>2.2 创建并登录账号</h4><p>创建账号:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fly auth signup</span><br></pre></td></tr></table></figure><p>会打开网页，选择自己要创建账号的方式，GitHub账号或者邮箱等。</p><p>创建完成后登录账号:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fly auth login</span><br></pre></td></tr></table></figure><h4 id="2-3-先在本地将Flask-demo跑起来"><a href="#2-3-先在本地将Flask-demo跑起来" class="headerlink" title="2.3 先在本地将Flask demo跑起来"></a>2.3 先在本地将Flask demo跑起来</h4><p>这里采用 fly.io 提供的Flask demo 代码，先在本地跑起来:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/fly-apps/python-hellofly-flask</span><br><span class="line"><span class="built_in">cd</span> python-hellofly-flask</span><br><span class="line">python -m venv flask-env</span><br><span class="line"><span class="built_in">source</span> flask-env/bin/activate</span><br><span class="line">python -m pip install -r requirements.txt</span><br><span class="line">FLASK_APP=hellofly flask run</span><br></pre></td></tr></table></figure><p>然后访问<code>http://127.0.0.1:5000</code> 就能看到网站，说明本地搭建成功了。</p><h3 id="2-4-部署到-fly-io"><a href="#2-4-部署到-fly-io" class="headerlink" title="2.4 部署到 fly.io"></a>2.4 部署到 fly.io</h3><p>在当前目录下，执行<code>fly launch</code>，进入交互式界面创建App:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">flyctl launch</span><br><span class="line">Creating app <span class="keyword">in</span> /Users/username/project/demo/flyio_demo/python-hellofly-flask</span><br><span class="line">Scanning <span class="built_in">source</span> code</span><br><span class="line">Detected a Python app</span><br><span class="line">Using the following build configuration:</span><br><span class="line">        Builder: paketobuildpacks/builder:base</span><br><span class="line">? Overwrite <span class="string">&quot;/Users/username/project/demo/flyio_demo/python-hellofly-flask/Procfile&quot;</span>? No</span><br><span class="line">? App Name (leave blank to use an auto-generated name): treehole</span><br><span class="line">Automatically selected personal organization: username</span><br><span class="line">? Select region: hkg (Hong Kong, Hong Kong)</span><br><span class="line">Created app treehole <span class="keyword">in</span> organization personal</span><br><span class="line">Wrote config file fly.toml</span><br><span class="line">? Would you like to <span class="built_in">set</span> up a Postgresql database now? No</span><br><span class="line">We have generated a simple Procfile <span class="keyword">for</span> you. Modify it to fit your needs and run <span class="string">&quot;fly deploy&quot;</span> to deploy your application.</span><br></pre></td></tr></table></figure><p>然后执行<code>flyctl deploy</code> 来将Appb部署到 fly.io 的服务器上:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flyctl deploy</span><br></pre></td></tr></table></figure><p>执行成功后，可以用<code>flyctl open</code>来打开浏览器，访问自己部署的App，网址是<code>appname.fly.dev</code>。</p><p>如果后面有源码或者配置的修改，可以多次执行<code>flyctl deploy</code>，会生成新的版本v0，v1, v2依次往下，往fly.io上部署。</p><p>接下来就是修改你的Flask源代码，完成更复杂有真正意义的功能了。</p><h4 id="2-5-别的有用的flyctl-命令"><a href="#2-5-别的有用的flyctl-命令" class="headerlink" title="2.5 别的有用的flyctl 命令"></a>2.5 别的有用的flyctl 命令</h4><ul><li>查看App状态: <code>flyctl status</code></li><li>查看App信息: <code>flyctl info</code></li><li>查看App列表: <code>flyctl apps list</code></li><li>查看App的IP: <code>flyctl ips list</code></li><li>销毁某个App: <code>flyctl apps destroy &lt;appname&gt;</code></li></ul><h3 id="3-登录部署机器"><a href="#3-登录部署机器" class="headerlink" title="3. 登录部署机器"></a>3. 登录部署机器</h3><p>机器部署完成后，可以通过<code>flyctl ssh console</code>来登录机器，登录后就跟普通Linux机器的使用是一样的了，可以随意探索。</p><h3 id="4-复制部署机器上的文件到本地"><a href="#4-复制部署机器上的文件到本地" class="headerlink" title="4. 复制部署机器上的文件到本地"></a>4. 复制部署机器上的文件到本地</h3><p>在一个终端输入下面的命令来代理端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fly proxy 10022:22</span><br></pre></td></tr></table></figure><p>然后保持上面的终端打开，在另一个终端输入下面的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 10022 root@localhost:/path/of/file/on/vm  /path/on/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>修改文件的路径就能将文件复制过来</p><h3 id="5-一点感想"><a href="#5-一点感想" class="headerlink" title="5.一点感想"></a>5.一点感想</h3><p>当demo部署服务成功后，却不知道能做什么真正有意义的事情，或许缺少的不是工具，而是真正产生价值的点子。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;最近看技术论坛，发现提到 &lt;a href=&quot;https://fly.io/&quot;&gt;fly.io&lt;/a&gt; 的次数越来越多了。 fly.io 是一个容器化的部署平台，只需要一个&lt;code&gt;Dockerfile&lt;/code&gt;文件就能部署代码到fly.io 的服务器上，同时还自动生成域名。其他的好处多多，我根据自己体验，我总结成了下面的这些条：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;del&gt;有免费使用的额度。不填写信用卡信息可以创建一个App，完全不收费；填写信用卡信息后每月有一定额度的免费流量，超过额度会额外收费。所以想做个小demo完全可以不填信用卡试用。&lt;/del&gt; 目前已经不支持无信用卡使用了，参见&lt;a href=&quot;https://community.fly.io/t/is-it-free-getting-error-we-need-your-payment-information-to-continue/8871&quot;&gt;这里&lt;/a&gt;的讨论&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自动生成域名。比如你创建一个名字叫&lt;code&gt;my_demo&lt;/code&gt;的App，那么部署完成后，就会生成&lt;code&gt;my_demo.fly.dev&lt;/code&gt;的域名，可以全球访问，不用自己单独买域名了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以 SSH 连接进入服务器。部署完成后，可以通过&lt;code&gt;flyctl ssh console&lt;/code&gt; 命令登录部署的服务器，所以相当于你有了一台免费的VPS，可以做你想做的任何事情。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;部署简单，采用&lt;code&gt;flyctl&lt;/code&gt; 命令集合统一部署;支持各种语言的各种框架来搭建部署环境，能自动识别当前目录下代码所采用的是哪个框架，自动部署。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面简单记录一下使用的流程和一些教程里面没提及的使用命令。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="fly.io" scheme="http://vra.github.io/tags/fly-io/"/>
    
    <category term="Docker" scheme="http://vra.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>在ctypes的C共享库中调用Python函数</title>
    <link href="http://vra.github.io/2022/10/04/callback-in-ctypes/"/>
    <id>http://vra.github.io/2022/10/04/callback-in-ctypes/</id>
    <published>2022-10-04T03:42:22.000Z</published>
    <updated>2022-10-04T04:35:42.172Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p><a href="https://docs.python.org/3/library/ctypes.html">ctypes</a> 是Python标准库中提供的外部函数库，可以用来在Python中调用动态链接库或者共享库中的函数，比如将使用大量循环的代码写在C语言中来进行提速，因为Python代码循环实在是太慢了。大致流程是通过 ctypes 来调用C函数，先将Python类型的对象转换为C的类型，在C函数中做完计算，返回结果到Python中。这个过程相对是比较容易的。</p><p>现在有个更复杂的情况，我想要在C代码中调用Python中的某些函数来完成C代码的计算，比如在C代码的sort函数中，采用Python中定义的函数来进行大小判断。这个在Python中定义的函数在 ctypes 中称为回调函数 (callback function)。也就是说需要把Python函数当作变量传给C语言，想想还是有些难度。 但调查以后发现 ctypes 提供了 <code>CFUNCTYPE</code>来方便地进行回调函数定义，而C语言本身也是支持函数指针的，因此这个功能实现还算简单，具体展开如下。</p><span id="more"></span><h3 id="2-一个最简单例子"><a href="#2-一个最简单例子" class="headerlink" title="2. 一个最简单例子"></a>2. 一个最简单例子</h3><p>先从最简单例子开始，跑通整体流程。假设我们有个回调函数，判断int类型的输入是不是大于0，那么可以在C语言这么写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_lib.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> (*function_ptr)(<span class="keyword">int</span>) , <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> function_ptr(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个文件内容很简单，我们定义了一个C函数<code>foo</code>，它调用Python传过来的回调函数，直接返回结果。</p><p>这里使用了C语言的函数指针类型，<code>int (function_ptr)(int)</code>中函数指针变量名是<code>function_ptr</code>, 返回值类型是前面的int，参数类型是后面的int。</p><p>我们在C语言里面只是简单地调用了Python传过来的函数指针，并直接将结果返回，实际使用时其实是需要在Python函数算完后，利用输出进行更多操作，否则直接在Python里面计算函数就可以了，没必要传函数到C，算法结果再返回给Python。</p><p>使用下面的命令来将上述C文件编程成共享库<code>my_lib.so</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o my_lib.so my_lib.c</span><br></pre></td></tr></table></figure><p>这个命令会在当前目录下会生成<code>my_lib.so</code>。</p><p>然后在Python文件中定义这个回调函数的具体实现，以及调用共享库<code>my_lib.so</code>中定义的<code>foo</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file name: ctype_callback_demo.py</span></span><br><span class="line"><span class="keyword">import</span> ctypes <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> cdll</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义回调函数</span></span><br><span class="line"><span class="meta">@c.CFUNCTYPE(<span class="params">c.c_int, c.c_int</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback_func</span>(<span class="params">a</span>):</span></span><br><span class="line">    res = <span class="built_in">int</span>(a &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入共享库</span></span><br><span class="line">    lib = cdll.LoadLibrary(<span class="string">&#x27;./my_lib.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用共享库中的foo函数</span></span><br><span class="line">    res = lib.foo(callback_func, a)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; &gt; 0 = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(a, res))</span><br></pre></td></tr></table></figure><p>所有 magic 的事情都被 ctypes 这个库给做了，留给我们的都是比较简单的接口。</p><p><code>@c.CFUNCTYPE</code> 这个装饰器就是用来声明回调函数的，装饰器的第一个参数是函数的返回类型，第二个参数开始，就是回调函数自己的参数的类型。如果回调函数没有返回值，那<code>@c.CFUNCTYPE</code>后面的第一个参数设置为<code>None</code>。</p><p>然后执行这个Python脚本，可以得到下面的输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python ctype_callback_demo.py</span><br><span class="line">2 &gt; 0 = 1</span><br></pre></td></tr></table></figure><h3 id="3-Numpy-ndarray-类型的参数如何使用"><a href="#3-Numpy-ndarray-类型的参数如何使用" class="headerlink" title="3. Numpy.ndarray 类型的参数如何使用"></a>3. Numpy.ndarray 类型的参数如何使用</h3><p>ctypes 对 Python原生类型支持是没问题的，但我们还会经常用到Numpy的ndarray对象，它们该如何转换为C语言可以识别的类型呢？因为跨语言的类型转换不对的话，结果就会有问题。</p><p>Numpy 提供了 numpy.ndarray.ctypes 属性，可以来完成这个操作。</p><p>比如C文件中，需要一个float 指针类型的输入:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_lib.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> (*function_ptr)(<span class="keyword">float</span>*) , <span class="keyword">float</span>* a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">function_ptr</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要将Numpy.ndarray对象进行转换，传给C函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取C的float指针类型</span></span><br><span class="line">c_float_p = ctypes.POINTER(ctypes.c_float)</span><br><span class="line"></span><br><span class="line">data = np.random.rand(<span class="number">3</span>, <span class="number">3</span>).astype(np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将np.ndarray 对象的类型转换为C的float指针类型</span></span><br><span class="line">data_p = data.ctypes.data_as(c_float_p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用共享库中的foo函数</span></span><br><span class="line">my_lib.foo(data_p)</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://docs.python.org/3/library/ctypes.html#callback-functions">https://docs.python.org/3/library/ctypes.html#callback-functions</a></li><li><a href="https://stackoverflow.com/questions/3195660/how-to-use-numpy-array-with-ctypes">https://stackoverflow.com/questions/3195660/how-to-use-numpy-array-with-ctypes</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/library/ctypes.html&quot;&gt;ctypes&lt;/a&gt; 是Python标准库中提供的外部函数库，可以用来在Python中调用动态链接库或者共享库中的函数，比如将使用大量循环的代码写在C语言中来进行提速，因为Python代码循环实在是太慢了。大致流程是通过 ctypes 来调用C函数，先将Python类型的对象转换为C的类型，在C函数中做完计算，返回结果到Python中。这个过程相对是比较容易的。&lt;/p&gt;
&lt;p&gt;现在有个更复杂的情况，我想要在C代码中调用Python中的某些函数来完成C代码的计算，比如在C代码的sort函数中，采用Python中定义的函数来进行大小判断。这个在Python中定义的函数在 ctypes 中称为回调函数 (callback function)。也就是说需要把Python函数当作变量传给C语言，想想还是有些难度。 但调查以后发现 ctypes 提供了 &lt;code&gt;CFUNCTYPE&lt;/code&gt;来方便地进行回调函数定义，而C语言本身也是支持函数指针的，因此这个功能实现还算简单，具体展开如下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="C++" scheme="http://vra.github.io/tags/C/"/>
    
    <category term="Numpy" scheme="http://vra.github.io/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>简单好用的英文拼写检查工具codespell</title>
    <link href="http://vra.github.io/2022/09/22/python-spell-checking-codespell/"/>
    <id>http://vra.github.io/2022/09/22/python-spell-checking-codespell/</id>
    <published>2022-09-22T15:14:39.000Z</published>
    <updated>2022-09-22T15:31:31.134Z</updated>
    
    <content type="html"><![CDATA[<p>网上冲浪看到了一个简单好用的英语单词拼写检查工具 <a href="https://github.com/codespell-project/codespell">codespell</a>，测试发现真的好用，一键安装&amp;一键开箱使用，没有比这更美好的体验了，下面展开说下流程。</p><span id="more"></span><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>codespell 是用 Python 写的工具，因此直接使用pip安装即可:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install codespell</span><br></pre></td></tr></table></figure><p>输出应该类似如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collecting codespell</span><br><span class="line">  Downloading codespell-2.2.1-py3-none-any.whl (202 kB)</span><br><span class="line">     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 202.1/202.1 kB 165.1 kB/s eta 0:00:00</span><br><span class="line">Installing collected packages: codespell</span><br><span class="line">Successfully installed codespell-2.2.1</span><br></pre></td></tr></table></figure><p>很简单。</p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><p>进一个包含英文文本的目录，比如你的源码根目录，或者文档目录，然后执行<code>codespell</code>, 就会检查当前目录下所有的文本，给出可能的拼写错误。</p><p>例如我clone一个我的GitHub 仓库，进去执行<code>codespell</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/vra/easybox</span><br><span class="line"><span class="built_in">cd</span> easybox</span><br><span class="line">codespell</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./README.md:10: termial ==&gt; terminal</span><br><span class="line">./README.md:53: termial ==&gt; terminal</span><br><span class="line">./easybox/main.py:41: Mimimal ==&gt; Minimal</span><br></pre></td></tr></table></figure><p>可以看到，markdown文件和Python文件中的一些拼写错误都被找出来了。</p><p>除了这么直接使用外，还可以在命令后面增加一些目录和路径的限定，比如<code>*.md</code> 只检查当前目录下的<code>.md</code>文件，<code>folder</code> 只检查文件夹<code>folder</code>下的所有文件，等等，都是Linux下的基本操作。</p><h3 id="3-原理"><a href="#3-原理" class="headerlink" title="3. 原理"></a>3. 原理</h3><p>这个工具的大致原理是将英文单词容易出错的情况写到代码库的数据中，然后在代码中进行匹配，所以不会出现别的工具那样，对变量命名的误判断，这是一个很好的特性。具体实现细节就需要查看<a href="https://github.com/codespell-project/codespell">源码</a>了，有空或许可以分析一下，写一个源码解读哈哈。</p><p>上面这些内容，对于普通人日常使用基本是够用了，关于codespell更多高级的配置选项，请参考GitHub上的<a href="https://github.com/codespell-project/codespell">README</a>文件中的说明。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;网上冲浪看到了一个简单好用的英语单词拼写检查工具 &lt;a href=&quot;https://github.com/codespell-project/codespell&quot;&gt;codespell&lt;/a&gt;，测试发现真的好用，一键安装&amp;amp;一键开箱使用，没有比这更美好的体验了，下面展开说下流程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="工具" scheme="http://vra.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="TIL" scheme="http://vra.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>git合并另一个分支的某个文件到当前分支</title>
    <link href="http://vra.github.io/2022/08/14/git-merge-file-from-another-branch/"/>
    <id>http://vra.github.io/2022/08/14/git-merge-file-from-another-branch/</id>
    <published>2022-08-14T03:14:26.000Z</published>
    <updated>2022-08-14T04:23:44.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>使用Git时，有时候不同分支的文件是不同步的，因此如果想要把别的分支的文件改动应用到当前分支，应该怎么操作呢？如果两边都有更新，该如何选择合并呢？这篇小文会对不同情形下的合并进行一个简单的介绍。</p><span id="more"></span><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>假设我们当前在分支<code>branch1</code>, 需要将分支<code>branch2</code>上的<code>a.py</code>合并到当前分支。<br>根据<a href="https://vra.github.io/2021/09/25/git-copy-from-another-branch">之前写的这篇文章</a>，我们可以这么操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout branch2 -- a.py</span><br></pre></td></tr></table></figure><h2 id="两边都存在文件"><a href="#两边都存在文件" class="headerlink" title="两边都存在文件"></a>两边都存在文件</h2><p>现在换一个情况，假设分支<code>branch1</code>和<code>branch2</code>都有文件<code>a.py</code>，且分支<code>branch1</code>上的文件包含在<code>branch2</code>的内容里，那么采用上面的命令也还是可以的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout branch2 -- a.py</span><br></pre></td></tr></table></figure><p>另外如果只想合并<code>branch2</code>上的文件的一部分更新到<code>branch1</code>，可以在<code>chekcout</code>后面增加<code>-p</code>或者<code>--patch</code>选项，交互式地选择要合并过来的代码块:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -p branch2 -- a.py</span><br></pre></td></tr></table></figure><p>交互式地操作命令同<code>git add -p</code>，可以参考<a href="https://vra.github.io/2022/06/17/git-add-part-of-a-file/">这里的文章</a>。</p><p>更复杂的情况是，分支<code>branch1</code>也有同名文件，且也有更新，如果直接使用<code>git checkout</code>的话，分支<code>branch2</code>上的文件会替代本地的文件，且没有任何提示（毕竟cheeckout的含义就是切换到某个分支）。因此为了保持本地的更新，需要增加<code>-p</code>选项。</p><p>这时候，会出现一种情况，本地的更新和远程的更新被放到一个块(hunk)里面，只能保留其中一个，此时就需要更精细的操作，在交互式环境中采用<code>e</code>命令来手动对hunk进行更新，去掉或增加代码的<code>+</code>或者<code>-</code>，具体可以参考<a href="https://stackoverflow.com/a/6290646">这个回答</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;使用Git时，有时候不同分支的文件是不同步的，因此如果想要把别的分支的文件改动应用到当前分支，应该怎么操作呢？如果两边都有更新，该如何选择合并呢？这篇小文会对不同情形下的合并进行一个简单的介绍。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的包名&quot;xxx&quot;和&quot;xxx-dev&quot;有什么区别?</title>
    <link href="http://vra.github.io/2022/07/23/linux-package-vs-package-dev/"/>
    <id>http://vra.github.io/2022/07/23/linux-package-vs-package-dev/</id>
    <published>2022-07-23T09:40:03.000Z</published>
    <updated>2022-08-14T03:13:41.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h2><p>在安装包的时候，有时候需要安装<code>xxx</code>的包，有时候又需要安装<code>xxx-dev</code>的包 (在CentOS系列发行版上则是<code>xxx-devel</code>)。这两类包之间又什么区别呢？</p><span id="more"></span><h2 id="2-结论"><a href="#2-结论" class="headerlink" title="2. 结论"></a>2. 结论</h2><p>不包含<code>-dev</code>的包里面包含的是运行所需要的二进制文件或者连接库文件（如<code>xxx.so</code>），而包含<code>-dev</code>的包则包含包的源码文件（如<code>.h</code>文件），为的是在编译使用了这些库的程序的时候，能找到对应的头文件，否则只有二进制文件或者<code>.so</code>文件，编译时会报代码找不到头文件的错误。</p><p>下面举个例子进行说明。</p><p>我们只使用Python的话，用<code>sudo apt install python</code>即可，安装后就可以正常使用Python。</p><p>如果想要编译一个叫<a href="https://github.com/lxml/lxml">lxml</a>的库，它依赖Python的源码，例如<a href="https://github.com/lxml/lxml/blob/06631bb0677250cb632638a2c89f4d336360965b/src/lxml/includes/etree_defs.h#L5">这里</a>的代码依赖<code>Python.h</code>这个文件，因此我们需要安装<code>python-dev</code>包，把<code>Python.h</code>安装到本地上，这样lxml包才能正常安装。</p><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><ol><li><a href="https://stackoverflow.com/questions/2358801/what-are-devel-packages">https://stackoverflow.com/questions/2358801/what-are-devel-packages</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-引入&quot;&gt;&lt;a href=&quot;#1-引入&quot; class=&quot;headerlink&quot; title=&quot;1. 引入&quot;&gt;&lt;/a&gt;1. 引入&lt;/h2&gt;&lt;p&gt;在安装包的时候，有时候需要安装&lt;code&gt;xxx&lt;/code&gt;的包，有时候又需要安装&lt;code&gt;xxx-dev&lt;/code&gt;的包 (在CentOS系列发行版上则是&lt;code&gt;xxx-devel&lt;/code&gt;)。这两类包之间又什么区别呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="Ubuntu" scheme="http://vra.github.io/tags/Ubuntu/"/>
    
    <category term="Debian" scheme="http://vra.github.io/tags/Debian/"/>
    
    <category term="CentOS" scheme="http://vra.github.io/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>Linux小知识:apt install什么时候会出现 Do you want to continue?的提示</title>
    <link href="http://vra.github.io/2022/07/23/ubuntu-when-to-ask-do-you-want-to-continue/"/>
    <id>http://vra.github.io/2022/07/23/ubuntu-when-to-ask-do-you-want-to-continue/</id>
    <published>2022-07-23T03:17:27.000Z</published>
    <updated>2022-07-23T09:38:32.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-一个故事"><a href="#1-一个故事" class="headerlink" title="1. 一个故事"></a>1. 一个故事</h2><p>在大约十年以前，大二或大三的夏天，<a href="https://wzhd.org/">子浩</a> 在科大西区活动中心的自习室内，给我帮忙安装Linux系统。当时他问了一个问题，用<code>apt-get install</code> 安装包时，什么时候会弹出<code>Do you want to continue?Y/[n]</code>的提示呢？我当时说应该是包大小超过限制时会有这个提示吧，但我们随即验证了这个假设并不成立，安装一个很小的包也会有这个提示。当时没有得到明确的结论。</p><p>这个问题时不时在脑海中想起，每次想查一下弄个清楚，但始终是没做。这样十年过去了，近日终于又想起来，通过谷歌搜索，终于发现了StackOverflow上已经又同样疑问的人提问了，而且得到了解答。至此这个小疑问算是解决了，我也不用每次念念不忘了。</p><p>具体原因是什么，请见下节。</p><span id="more"></span><h2 id="2-谜底揭晓"><a href="#2-谜底揭晓" class="headerlink" title="2. 谜底揭晓"></a>2. 谜底揭晓</h2><p>根据<a href="https://superuser.com/questions/287348/why-does-apt-get-sometimes-asks-for-confirmation/287357#287357">这里</a>的回答，<code>Do you want to continue</code> 的提示会在下面几种情况下出现:</p><ol><li>当除了你要安装包外，有额外的依赖包需要被安装的时候，比如你执行的是<code>sudo apt install aaa</code>, 包 <code>aaa</code> 依赖 <code>bbb</code>，因此<code>bbb</code> 也需要被安装，这时候就会有提示</li><li>当现有包的版本要改变，比如机器上已经安装了<code>bbb-1.0.0</code>，而安装<code>aaa</code>需要安装<code>bbb-2.0.0</code>，这时候就会有提示</li><li>当基础包要被移除的时候，基础包大体意思是系统运行所需的最小软件包集，删除了就会导致系统运行出问题，详细的概念可以参考<a href="https://www.debian.org/doc/debian-policy/ch-binary.html#essential-packages">这里</a></li></ol><p>常见的情况应该是第一种和第二种，第三种情况应该是只有<code>apt remove</code>才会出现。</p><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><ol><li><a href="https://superuser.com/questions/287348/why-does-apt-get-sometimes-asks-for-confirmation/287357#287357">https://superuser.com/questions/287348/why-does-apt-get-sometimes-asks-for-confirmation/287357#287357</a></li><li><a href="https://unix.stackexchange.com/questions/70651/when-does-apt-get-install-ask-me-to-confirm-whether-i-want-to-continue-or-not">https://unix.stackexchange.com/questions/70651/when-does-apt-get-install-ask-me-to-confirm-whether-i-want-to-continue-or-not</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-一个故事&quot;&gt;&lt;a href=&quot;#1-一个故事&quot; class=&quot;headerlink&quot; title=&quot;1. 一个故事&quot;&gt;&lt;/a&gt;1. 一个故事&lt;/h2&gt;&lt;p&gt;在大约十年以前，大二或大三的夏天，&lt;a href=&quot;https://wzhd.org/&quot;&gt;子浩&lt;/a&gt; 在科大西区活动中心的自习室内，给我帮忙安装Linux系统。当时他问了一个问题，用&lt;code&gt;apt-get install&lt;/code&gt; 安装包时，什么时候会弹出&lt;code&gt;Do you want to continue?Y/[n]&lt;/code&gt;的提示呢？我当时说应该是包大小超过限制时会有这个提示吧，但我们随即验证了这个假设并不成立，安装一个很小的包也会有这个提示。当时没有得到明确的结论。&lt;/p&gt;
&lt;p&gt;这个问题时不时在脑海中想起，每次想查一下弄个清楚，但始终是没做。这样十年过去了，近日终于又想起来，通过谷歌搜索，终于发现了StackOverflow上已经又同样疑问的人提问了，而且得到了解答。至此这个小疑问算是解决了，我也不用每次念念不忘了。&lt;/p&gt;
&lt;p&gt;具体原因是什么，请见下节。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="Ubuntu" scheme="http://vra.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>surface-simplification-using-quadric-error-metrics</title>
    <link href="http://vra.github.io/2022/06/29/surface-simplification-using-quadric-error-metrics/"/>
    <id>http://vra.github.io/2022/06/29/surface-simplification-using-quadric-error-metrics/</id>
    <published>2022-06-29T07:25:53.000Z</published>
    <updated>2022-06-29T07:29:10.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>顶点可以看作是三角面片所在的平面的交集</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;顶点可以看作是三角面片所在的平面的交集&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Graphic" scheme="http://vra.github.io/tags/Graphic/"/>
    
  </entry>
  
  <entry>
    <title>Python转换elif语句为列表推导式</title>
    <link href="http://vra.github.io/2022/06/28/python-list-comprehension-with-elif/"/>
    <id>http://vra.github.io/2022/06/28/python-list-comprehension-with-elif/</id>
    <published>2022-06-28T14:32:11.000Z</published>
    <updated>2022-06-28T14:42:50.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>今天才发现，在Python的列表推导式里面，也可以使用多个else，也就是elif的情况，具体来说，可以将下面的一长串的elif 语句转换成一句列表推导式，大大简化代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cond1:</span><br><span class="line">do1</span><br><span class="line"><span class="keyword">elif</span> cond2:</span><br><span class="line">do2</span><br><span class="line"><span class="keyword">elif</span> cond3:</span><br><span class="line">do3</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">do4</span><br></pre></td></tr></table></figure><p>转换成列表推导式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = [do1 <span class="keyword">if</span> cond1 <span class="keyword">else</span> do2 <span class="keyword">if</span> cond2 <span class="keyword">else</span> do3 <span class="keyword">if</span> cond3 <span class="keyword">else</span> do4][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>Python喜爱值+1，代码行数-N。</p><span id="more"></span><h2 id="2-几个例子"><a href="#2-几个例子" class="headerlink" title="2. 几个例子"></a>2. 几个例子</h2><p>原先代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &gt; <span class="number">10</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;large&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> a &gt; <span class="number">5</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;middle&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;small&#x27;</span></span><br></pre></td></tr></table></figure><p>可以转换为下面的形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = [<span class="string">&#x27;large&#x27;</span> <span class="keyword">if</span> a &gt; <span class="number">10</span> <span class="keyword">else</span> <span class="string">&#x27;middle&#x27;</span> <span class="keyword">if</span> a &gt; <span class="number">5</span> <span class="keyword">else</span> <span class="string">&#x27;small&#x27;</span>]</span><br></pre></td></tr></table></figure><p>任意多个elif都是可以的，下面的代码验证了两种写法结果是一致的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">if</span> a &gt; <span class="number">0.9</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> a &gt; <span class="number">0.7</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;b&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> a &gt; <span class="number">0.5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;c&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> a &gt; <span class="number">0.3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;d&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> a &gt;= <span class="number">0.1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;e&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span> <span class="keyword">if</span> a &gt; <span class="number">0.9</span> <span class="keyword">else</span> <span class="string">&#x27;b&#x27;</span> <span class="keyword">if</span> a &gt; <span class="number">0.7</span> <span class="keyword">else</span> <span class="string">&#x27;c&#x27;</span> <span class="keyword">if</span> a &gt; <span class="number">0.5</span> <span class="keyword">else</span> <span class="string">&#x27;d&#x27;</span> <span class="keyword">if</span> a &gt; <span class="number">0.3</span> <span class="keyword">else</span> <span class="string">&#x27;e&#x27;</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr = np.random.rand(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="built_in">print</span>(func1(a) == func2(a))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;今天才发现，在Python的列表推导式里面，也可以使用多个else，也就是elif的情况，具体来说，可以将下面的一长串的elif 语句转换成一句列表推导式，大大简化代码:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; cond1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	do1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; cond2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	do2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; cond3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	do3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	do4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;转换成列表推导式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;res = [do1 &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; cond1 &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; do2 &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; cond2 &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; do3 &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; cond3 &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; do4][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Python喜爱值+1，代码行数-N。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch 拟合多项式的例子</title>
    <link href="http://vra.github.io/2022/06/26/pytorch-fit-polynomial/"/>
    <id>http://vra.github.io/2022/06/26/pytorch-fit-polynomial/</id>
    <published>2022-06-26T03:20:15.000Z</published>
    <updated>2022-06-26T09:00:34.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Pytorch包含了Linear层，可以用来拟合<code>y = w * x + b</code> 形式的函数，其中<code>w</code>和<code>bias</code>就是Linear层的weights和bias。这里写个拟合一次多项式的简单demo，作为一个小实验。</p><span id="more"></span><h2 id="2-拟合一次多项式"><a href="#2-拟合一次多项式" class="headerlink" title="2. 拟合一次多项式"></a>2. 拟合一次多项式</h2><p>采用下面的代码，我们设计了一个包含一个线性层的网络，通过给它feed随机构造的数据(y = 1.233 * x + 0.988)，结合梯度下降算法和MSE loss惩罚函数，让它学习数据的构造参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    torch.manual_seed(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    model = Model()</span><br><span class="line">    model.train()</span><br><span class="line">    optimizer = optim.SGD(model.parameters(), lr=<span class="number">1e-2</span>)</span><br><span class="line"></span><br><span class="line">    w = <span class="number">1.233</span></span><br><span class="line">    b = <span class="number">0.988</span></span><br><span class="line">num_iteration = <span class="number">5000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_iteration):</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        x = torch.rand(<span class="number">1</span>)</span><br><span class="line">        y = w * x + b</span><br><span class="line">        pred = model(x)</span><br><span class="line"></span><br><span class="line">        loss = F.mse_loss(y, pred)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name, param <span class="keyword">in</span> model.named_parameters():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>=<span class="subst">&#123;param.data.numpy().squeeze():<span class="number">.3</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><p>运行这个脚本的输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linear.weight=1.233</span><br><span class="line">linear.bias=0.988</span><br></pre></td></tr></table></figure><p>可以看到，经过5000次的迭代，网络能成功地学习到数据构造过程中的w和b参数, 这个小网络现在可以用来替代线性回归机器学习算法了!</p><p>如果迭代周期太小则可能收敛不到我们预设的参数，可以手动修改迭代次数<code>num_iteration</code>为2000查看结果。</p><h2 id="3-如果重复Linear层会发生什么？"><a href="#3-如果重复Linear层会发生什么？" class="headerlink" title="3. 如果重复Linear层会发生什么？"></a>3. 如果重复Linear层会发生什么？</h2><p>如果我们把同一个linear层重复执行两次，会有什么结果呢？也就是网络定义修改如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>这里调用了两次同一个linear层，因此相当于 <code>y = w * ( w * x + b) + b</code>，也就是一次forward更新两次参数，也可以理解成两个共享参数的线性层。<br>完整的示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    torch.manual_seed(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    model = Model()</span><br><span class="line">    model.train()</span><br><span class="line">    optimizer = optim.SGD(model.parameters(), lr=<span class="number">1e-2</span>)</span><br><span class="line"></span><br><span class="line">    w = <span class="number">1.233</span></span><br><span class="line">    b = <span class="number">0.988</span></span><br><span class="line">    num_iteration = <span class="number">5000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_iteration):</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        x = torch.rand(<span class="number">1</span>)</span><br><span class="line">        y = w * x + b</span><br><span class="line">        pred = model(x)</span><br><span class="line"></span><br><span class="line">        loss = F.mse_loss(y, pred)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name, param <span class="keyword">in</span> model.named_parameters():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>=<span class="subst">&#123;param.data.numpy().squeeze():<span class="number">.3</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><p>同样的，通过我们构造 y = 1.233 * x + 0.998的数据，带入 y = w * ( w * x + b) + b，可以得到一组解 <code>w=1.110, b=0.468</code>,这与我们网络运行得到的结果是一致的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linear.weight=1.110</span><br><span class="line">linear.bias=0.468</span><br></pre></td></tr></table></figure><p>同时也有一个问题：为什么没得到w为负数的另一组解呢？这是因为我这里为了保证复现性，手动设置了随机数种子为1024，设置为别的值应该可以得到另一组参数，欢迎尝试。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;Pytorch包含了Linear层，可以用来拟合&lt;code&gt;y = w * x + b&lt;/code&gt; 形式的函数，其中&lt;code&gt;w&lt;/code&gt;和&lt;code&gt;bias&lt;/code&gt;就是Linear层的weights和bias。这里写个拟合一次多项式的简单demo，作为一个小实验。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Deep Learning" scheme="http://vra.github.io/tags/Deep-Learning/"/>
    
    <category term="Pytorch" scheme="http://vra.github.io/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>matplotlibt图像转OpenCV图像</title>
    <link href="http://vra.github.io/2022/06/24/matplotlib-convert-opencv/"/>
    <id>http://vra.github.io/2022/06/24/matplotlib-convert-opencv/</id>
    <published>2022-06-24T15:14:44.000Z</published>
    <updated>2022-06-24T15:51:04.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>有时候，我们需要使用Matplotlib库强大的绘图函数来在numpy.ndarray格式的图像上进行一些可视化，比如关键点绘制，投影点绘制。绘制完后，还需要把matplotlib的figure对象转换为numpy.ndarray 格式的对象，方便和原图进行比较。有时候为了可视化的美观，需要验证保证转换后的图像与原始图像大小一致。这里记录一下操作的流程，以及一些常遇到的问题。</p><span id="more"></span><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h2><p>核心原理是利用matplotlib.pyplot的<code>imshow</code>函数来显示np.ndarray格式的图像，然后进行可视化绘制，再通过matplotlib.pyplot.figure.canvas的<code>tostring_rgb</code>函数来将图像转换为string，在用numpy的<code>fromstring</code>函数将string转换为np.ndarray，即为我们所求。</p><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 numpy.ndarray格式的图像</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;/path/to/my.jpg&#x27;</span>)</span><br><span class="line">h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建figure对象</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">plt.imshow(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加函数绘制代码</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制画布</span></span><br><span class="line">fig.canvas.draw()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换plt canvas为string，再导入numpy</span></span><br><span class="line">vis_img = np.fromstring(fig.canvas.tostring_rgb(), dtype=np.uint8)</span><br><span class="line"><span class="comment"># 设置numpy数组大小为图像大小</span></span><br><span class="line">vis_img.shape = (h, w, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">plt.close()</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;/path/to/vis_img.jpg&#x27;</span>, vis_img)</span><br></pre></td></tr></table></figure><h2 id="3-几个关键点"><a href="#3-几个关键点" class="headerlink" title="3. 几个关键点"></a>3. 几个关键点</h2><p>上述代码是简单的原理，但要达到保存的<code>vis_img</code>对象与<code>img</code>对象完全等大小，还需要设置figure对象的size，具体实现是通过<code>set_size_inches</code>函数，传入原始图像的宽和高除以dpi的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">fig.set_size_inches(w/fig.dpi, h/fig.dpi)</span><br></pre></td></tr></table></figure><p>注意是宽在前面，高在后面。</p><p>还有一个很关键的点是需要去除matplotlib设置的padding白边，否则在相同尺寸的情况下，包含白边显得里面的内容变小了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.gca().set_position((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>为了不显示横纵坐标轴，需要添加<code>plt.axis(&#39;off&#39;)</code>语句。</p><p>为了能在无GUI的环境（比如SSH连到的Linux 服务器）这个脚本也能正常工作，需要采用<code>Agg</code> 这个backend：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;Agg&#x27;</span>)</span><br></pre></td></tr></table></figure><p>插句题外话，<code>Agg</code>这个backend原来是来自于<a href="http://agg.sourceforge.net/antigrain.com/">Anti-Grain Geometry</a> 2D渲染库，2002年开始开发，距今已有20年历史了，Respect。</p><p>此外由于matploltlib的<code>imshow</code>需要RGB格式的图像，而OpenCV图像格式为BGR，需要做转换。</p><h2 id="4-完整代码"><a href="#4-完整代码" class="headerlink" title="4. 完整代码"></a>4. 完整代码</h2><p>结合上一部分的几个关键点，最终的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;Agg&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;/path/to/my.jpg&#x27;</span>)</span><br><span class="line">img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line">h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">fig.set_size_inches(w/fig.dpi, h/fig.dpi)</span><br><span class="line"></span><br><span class="line">plt.imshow(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始 matplotlib的绘制</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关掉坐标轴的显示</span></span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加这一句，避免matplotlib的自动padding导致的空白</span></span><br><span class="line">plt.gca().set_position((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">fig.canvas.draw()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换plt canvas为string，再导入numpy</span></span><br><span class="line">vis_img = np.fromstring(fig.canvas.tostring_rgb(), dtype=np.uint8)</span><br><span class="line"><span class="comment"># 设置numpy数组大小为图像大小</span></span><br><span class="line">vis_img.shape = (h, w, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 将RGB格式转换为BGR格式</span></span><br><span class="line">vis_img = cv2.cvtColor(vis_img, cv2.COLOR_RGB2BGR)</span><br><span class="line"></span><br><span class="line">plt.close()</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;/path/to/vis_img.jpg&#x27;</span>, vis_img)</span><br></pre></td></tr></table></figure><p>需要注意的是，直接执行这段代码虽然可以得到你想要的结果，但本身是没有意义的，最核心的matplotlib调用需要你自己填写。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;有时候，我们需要使用Matplotlib库强大的绘图函数来在numpy.ndarray格式的图像上进行一些可视化，比如关键点绘制，投影点绘制。绘制完后，还需要把matplotlib的figure对象转换为numpy.ndarray 格式的对象，方便和原图进行比较。有时候为了可视化的美观，需要验证保证转换后的图像与原始图像大小一致。这里记录一下操作的流程，以及一些常遇到的问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="OpenCV" scheme="http://vra.github.io/tags/OpenCV/"/>
    
    <category term="Matplotlib" scheme="http://vra.github.io/tags/Matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>git 提交文件中的部分修改</title>
    <link href="http://vra.github.io/2022/06/17/git-add-part-of-a-file/"/>
    <id>http://vra.github.io/2022/06/17/git-add-part-of-a-file/</id>
    <published>2022-06-17T15:19:36.000Z</published>
    <updated>2022-06-17T23:56:04.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在 Git 提交一个文件的时候，有时候会在同一个文件中，包含两个不同功能的修改，或者一个功能完成了，而别的部分还没有完善不应该进入代码库，这时候如果使用<code>git add file-name</code>的话，会将这个文件中的所有更新都提交，达不到上述的需求。针对这种场景，git 提供了更细粒度的提交命令<code>git add -p</code>，可以分部分提交一个文件中的更新代码块，实测能满足常见的需求。这里简要记录一下如何使用这个命令。</p><span id="more"></span><h2 id="2-实现命令"><a href="#2-实现命令" class="headerlink" title="2. 实现命令"></a>2. 实现命令</h2><h3 id="2-1-原理解释"><a href="#2-1-原理解释" class="headerlink" title="2.1 原理解释"></a>2.1 原理解释</h3><p>git 中用”hunk”来表示一个文件中邻近区域中的代码修改块，比如用<code>git diff</code> 查看修改时，两个<code>@@</code>符号分割的一个区域就是一个hunk，其中行首是<code>-</code>，颜色为红色的为删去的行，而行首为<code>+</code>，颜色为绿色的为增加的行。<br><img src="/imgs/git_add_part/git_hunk_vis.jpg" alt="git_hunk_vis"></p><p>需要注意的是，git有一套默认的将文件中所有修改分成不同hunk的机制，但我们也可以将默认机制分的太大的hunk分割为多个小的hunk，这样能更精确地控制提交的粒度。</p><p>部分提交文件修改的原理简单来说是将所有的修改分成不同的hunk，通过对每个hunk来进行是否提交的判断，从而完成我们的需求。具体命令下面详细讲述。</p><h3 id="2-2-命令详解"><a href="#2-2-命令详解" class="headerlink" title="2.2 命令详解"></a>2.2 命令详解</h3><p><code>git add -p filename</code>就可以进入交互式的操作界面，所有的操作在该界面完成，其中<code>-p</code>是patch的缩写。界面如下:<br><img src="/imgs/git_add_part/git_part_add_2.jpg"><br>这里会自动载入第一个hunk，显示了修改的代码行，最底下一行显示了这是8个hunk里面的第一个，然后有一些选项让我们选择，这时候输入<code>?</code>，按会车会显示help信息:<br><img src="/imgs/git_add_part/git_part_add_2.jpg"></p><p>所有命令的含义如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">y - 将当前的hunk进行提交</span><br><span class="line">n - 不提交当前hunk</span><br><span class="line">q - 退出交互式界面，不提交当前hunk以及后面的所有hunk</span><br><span class="line">a - 提交当前hunk以及后面的所有hunk</span><br><span class="line">d - 不提交当前hunk以及后面的所有hunk，效果与q一样，也会退出交互式界面</span><br><span class="line">g - 选择一个hunk并跳转过去，输入后会列出所有hunk的编号，输入编号就跳转到对应的hunk</span><br><span class="line">/ - 输入一个正则表达式，选择一个包含搜索词的hunk进行跳转</span><br><span class="line">j - 暂时不确定是否保存当前hunk，跳转到下一个没确定的hunk</span><br><span class="line">J - 暂时不确定是否保存当前hunk，跳转到下一个hunk</span><br><span class="line">e - 手动修改hunk块的内容，将`-` 开头的行替换为 ` `则不会删去这行，删除`+`为首的行则不提交这个新增，以`<span class="comment">#`开始的行会被忽略</span></span><br><span class="line">? - 显示帮助信息 </span><br></pre></td></tr></table></figure><p>详细阅读上面的说明，结合实际的操作，就能掌握这个命令的所有用法。</p><p>简单来说，使用<code>y</code>来提交当前hunk，使用<code>n</code>来忽略当前hunk，如果hunk代码块太大，输入<code>s</code>会将其分割为小的hunk，在上面继续操作，hunk间上下跳转用vim的快捷键<code>k</code> 和<code>j</code>，要退出则输入<code>q</code>。</p><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><ol><li><a href="https://stackoverflow.com/questions/1085162/commit-only-part-of-a-file-in-git">https://stackoverflow.com/questions/1085162/commit-only-part-of-a-file-in-git</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;在 Git 提交一个文件的时候，有时候会在同一个文件中，包含两个不同功能的修改，或者一个功能完成了，而别的部分还没有完善不应该进入代码库，这时候如果使用&lt;code&gt;git add file-name&lt;/code&gt;的话，会将这个文件中的所有更新都提交，达不到上述的需求。针对这种场景，git 提供了更细粒度的提交命令&lt;code&gt;git add -p&lt;/code&gt;，可以分部分提交一个文件中的更新代码块，实测能满足常见的需求。这里简要记录一下如何使用这个命令。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
