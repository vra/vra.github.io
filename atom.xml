<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yunfeng&#39;s Simple Blog</title>
  
  <subtitle>Love, Life, Linux</subtitle>
  <link href="http://vra.github.io/atom.xml" rel="self"/>
  
  <link href="http://vra.github.io/"/>
  <updated>2023-05-26T17:19:20.646Z</updated>
  <id>http://vra.github.io/</id>
  
  <author>
    <name>Yunfeng Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mac 编译问题解决——building for macOS-x86_64 but attempting to link with file built for xxx</title>
    <link href="http://vra.github.io/2023/05/27/mac-ranlib-issue/"/>
    <id>http://vra.github.io/2023/05/27/mac-ranlib-issue/</id>
    <published>2023-05-26T17:17:15.000Z</published>
    <updated>2023-05-26T17:19:20.646Z</updated>
    
    <content type="html"><![CDATA[<p>在编译TVM的一个<a href="https://github.com/mlc-ai/relax">fork版本</a>时，遇到下面的报错：</p><blockquote><p>ld: warning: ignoring file libbacktrace/lib/libbacktrace.a, building for macOS-x86_64 but attempting to link with file built for unknown-unsupported file format ( 0x21 0x3C 0x61 0x72 0x63 0x68 0x3E 0x0A<br> 0x2F 0x20 0x20 0x20 0x20 0x20 0x20 0x20 )<br>Undefined symbols for architecture x86_64:<br>  “_backtrace_create_state”, referenced from:<br>      __GLOBAL__sub_I_logging.cc in logging.cc.o<br>  “_backtrace_full”, referenced from:<br>      tvm::runtime::Backtrace() in logging.cc.o<br>  “_backtrace_syminfo”, referenced from:<br>      tvm::runtime::(anonymous namespace)::BacktraceFullCallback(void*, unsigned long, char const*, int, char const*) in logging.cc.o<br>ld: symbol(s) not found for architecture x86_64<br>clang: error: linker command failed with exit code 1 (use -v to see invocation)<br>make[3]: *** [libtvm_runtime.dylib] Error 1<br>make[2]: *** [CMakeFiles/tvm_runtime.dir/all] Error 2<br>make[2]: *** Waiting for unfinished jobs….</p></blockquote><p>搜索了一下，发现核心原因是Mac下ranlib命令采用了GNU版本，而非Apple版本导致的，下面详细展开报错原因和解决办法。</p><span id="more"></span><p>在Mac下，有两套编译工具链，GNU的和Apple（通过Xcode安装）的，GNU的以<code>gcc</code>为代表，而Apple的则以<code>clang</code>为代表，在这两个核心编译工具周围，又有很多别的小的编译工具。</p><p>通过log输出发现，编译工具用的是<code>/usr/bin/cc</code>, 执行<code>/usr/bin/cc --version</code> 命令，输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/cc --version</span><br><span class="line">Apple clang version 14.0.0 (clang-1400.0.29.202)</span><br><span class="line">Target: x86_64-apple-darwin22.2.0</span><br><span class="line">Thread model: posix</span><br><span class="line">InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin</span><br></pre></td></tr></table></figure><p>可以看到是Apple的编译工具链Apple clang。</p><p>在编译过程中，发现log中有下面的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibtool: install: ranlib /path/to/relax/build/libbacktrace/lib/libbacktrace.a</span><br></pre></td></tr></table></figure><p>可以看到调用了<code>ranlib</code>命令来生成<code>libbacktrace.a</code>。</p><p>通过<code>which ranlib</code> 验证ranlib的路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> ranlib</span><br><span class="line">/usr/<span class="built_in">local</span>/opt/binutils/bin/ranlib</span><br><span class="line"></span><br><span class="line">$ ranlib --version</span><br><span class="line">GNU ranlib (GNU Binutils) 2.40</span><br><span class="line">Copyright (C) 2023 Free Software Foundation, Inc.</span><br><span class="line">This program is free software; you may redistribute it under the terms of</span><br><span class="line">the GNU General Public License version 3 or (at your option) any later version.</span><br><span class="line">This program has absolutely no warranty.</span><br></pre></td></tr></table></figure><p>可以看到，找到的是GPN版本的ranlib，而不是跟编译工具匹配的Apple的ranlib（路径是<code>/usr/bin/ranlib</code>)。</p><p>如果是Apple的ranlib工具的话，<code>ranlib --version</code>输出应该是下面这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ranlib</span> --version</span><br><span class="line">error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib: unknown option character `-<span class="string">&#x27; in: --version</span></span><br><span class="line"><span class="string">Usage: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib [-sactfqLT] [-] archive [...]</span></span><br></pre></td></tr></table></figure><p>那为什么会有两套工具链混合使用导致出错的问题？这是因为路径设置优先级的原因，在PATH中，<code>/usr/local/opt/binutils/bin</code>在<code>/usr/bin</code>的前面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">...:/usr/<span class="built_in">local</span>/opt/binutils/bin:/usr/bin:...</span><br></pre></td></tr></table></figure><p>所以在搜索可执行文件时，先找到了GNU的ranlib，而这个又与Apple的编译工具链不兼容。导致编译出错。</p><p>那<code>ranlib</code>是干什么用的呢？根据ChatGPT， ranlib功能如下：</p><blockquote><p>ranlib是一个命令行工具，用于在静态库中创建索引（也称为符号表）。索引提供静态库中所有符号（函数、变量等）的列表。它帮助编译器和链接器在链接时更快地查找和解析符号。当一个程序需要链接静态库时，链接器会使用ranlib创建的索引来确定静态库中包含的符号，以便正确地链接程序。</p></blockquote><p>可以看到，ranlib对于编译静态库来说，是必不可少的（与<code>ar -s</code>完全等效）。</p><p>其实我不记得在PATH中添加过<code>/usr/local/opt/binutils/bin</code>这个目录，应该是安装某些包后自动更新的。</p><p>那这个问题该怎么解决呢？通过上面的分析，我们也能发现其实解决办法也比较直观，总体来说有两种，一种是修改PATH中两个目录的寻找优先级，保证先找到的是Apple的工具，也就是<code>/usr/bin</code>目录在<code>/usr/local/opt</code> 前面；另一种是直接卸载GNU的工具<code>binutils</code>，这样就不会有冲突。</p><p>在这里我选择执行第二种，具体命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew uninstall binutils</span><br></pre></td></tr></table></figure><p>然后再检查<code>ranlib --version</code> 命令的输出，确认是Apple的工具链后再<code>make clean</code>，重新编译即可。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://stackoverflow.com/a/72904009">https://stackoverflow.com/a/72904009</a></li><li><a href="https://github.com/bitcoin/bitcoin/issues/20825#issuecomment-753444519">https://github.com/bitcoin/bitcoin/issues/20825#issuecomment-753444519</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在编译TVM的一个&lt;a href=&quot;https://github.com/mlc-ai/relax&quot;&gt;fork版本&lt;/a&gt;时，遇到下面的报错：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ld: warning: ignoring file libbacktrace/lib/libbacktrace.a, building for macOS-x86_64 but attempting to link with file built for unknown-unsupported file format ( 0x21 0x3C 0x61 0x72 0x63 0x68 0x3E 0x0A&lt;br&gt; 0x2F 0x20 0x20 0x20 0x20 0x20 0x20 0x20 )&lt;br&gt;Undefined symbols for architecture x86_64:&lt;br&gt;  “_backtrace_create_state”, referenced from:&lt;br&gt;      __GLOBAL__sub_I_logging.cc in logging.cc.o&lt;br&gt;  “_backtrace_full”, referenced from:&lt;br&gt;      tvm::runtime::Backtrace() in logging.cc.o&lt;br&gt;  “_backtrace_syminfo”, referenced from:&lt;br&gt;      tvm::runtime::(anonymous namespace)::BacktraceFullCallback(void*, unsigned long, char const*, int, char const*) in logging.cc.o&lt;br&gt;ld: symbol(s) not found for architecture x86_64&lt;br&gt;clang: error: linker command failed with exit code 1 (use -v to see invocation)&lt;br&gt;make[3]: *** [libtvm_runtime.dylib] Error 1&lt;br&gt;make[2]: *** [CMakeFiles/tvm_runtime.dir/all] Error 2&lt;br&gt;make[2]: *** Waiting for unfinished jobs….&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;搜索了一下，发现核心原因是Mac下ranlib命令采用了GNU版本，而非Apple版本导致的，下面详细展开报错原因和解决办法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="macOS" scheme="http://vra.github.io/tags/macOS/"/>
    
    <category term="GNU" scheme="http://vra.github.io/tags/GNU/"/>
    
    <category term="Apple" scheme="http://vra.github.io/tags/Apple/"/>
    
    <category term="XCode" scheme="http://vra.github.io/tags/XCode/"/>
    
    <category term="ranlib" scheme="http://vra.github.io/tags/ranlib/"/>
    
    <category term="binutils" scheme="http://vra.github.io/tags/binutils/"/>
    
    <category term="TVM" scheme="http://vra.github.io/tags/TVM/"/>
    
  </entry>
  
  <entry>
    <title>用 Material for MkDocs 来生成专业的技术文档</title>
    <link href="http://vra.github.io/2023/05/17/mkdocs-material-tutorial/"/>
    <id>http://vra.github.io/2023/05/17/mkdocs-material-tutorial/</id>
    <published>2023-05-17T11:31:37.000Z</published>
    <updated>2023-05-17T11:37:34.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>对于程序员来说，写技术文档是一项必备的技能。由于GitHub和Markdown格式的普及，很多时候我们可以用markdown来简便地写出技术文档，并且 通过GitHub Pages等工具快速地进行技术文档的部署。</p><p>虽然GItHub Pages默认支持静态文档框架<a href="https://jekyllrb.com/">Jekyll</a>，也包含一些简单的<a href="https://pages.github.com/themes/">主题</a>，但对于文档和教程比较多的项目来说，使用GitHub Pages的默认部署工具还不够用，主要体现在下面几个方面：</p><ul><li>Markdown本身支持的语法比较简单，一些复杂的像Warning等提示没法直接用Pages的默认主题来实现</li><li>Pages 默认显示的是单页文档，没有侧边栏、导航栏等工具</li><li>Pages 默认主题无法搜索文档内容</li><li>Pages 不支持选择<code>Linux</code>或<code>Windows</code> 后显示不同执行语句的功能</li><li>…</li></ul><p><a href="https://squidfunk.github.io/mkdocs-material/">Material for MkDocs</a> 是 <a href="https://www.mkdocs.org/">MkDocs</a>的一个主题配置，同时也是一个功能齐全的静态网站生成工具，能够解决上面提到的GitHub Pages的问题。</p><p>Material for MkDocs 使用广泛，下面是一些大公司和知名开源项目的使用例子：</p><ul><li><a href="https://aws.github.io/copilot-cli/">AWS Copilot CLI </a></li><li><a href="https://google.github.io/accompanist/">Google Accompanist</a></li><li><a href="https://microsoft.github.io/code-with-engineering-playbook/">MicroSoft Code With Engineering Playbook</a></li><li><a href="https://mozillafoundation.github.io/engineering-handbook/">Mozilla Foundation Engineering Handbook</a></li><li><a href="https://netflix.github.io/titus/">Netflix Titus</a></li><li><a href="https://docs.infra.centos.org/">CentOS Infra docs</a></li><li><a href="https://www.electron.build/">electron-builder</a></li><li><a href="https://kops.sigs.k8s.io/">Kubernetes</a></li></ul><p>虽然我还没有比较复杂的开源项目需要用mkdocs-material来管理文档，但看到GitHub Pages的一些限制，最近有空还是学了一下这个工具，以备后续项目中使用。这里做一些简单记录，方便以后查找。</p><p>需要说明的是，Material for MkDocs 是一个比较复杂的工具，很多配置项这里没有提到，根据需要在官方<a href="https://squidfunk.github.io/mkdocs-material/setup/">Setup</a>文档中查看使用说明。</p><p>另外一种学习配置的方式是直接查看上面提到的开源项目源码根目录下的<code>mkdocs.yml</code>文件，复制这个文件过去，就能得到类似的布局效果。</p><p>这个教程里面的示例页面：<a href="https://vra.github.io/mkdocs-material-example/">https://vra.github.io/mkdocs-material-example/</a><br>示例页面的配置文件：<a href="https://github.com/vra/mkdocs-material-example/blob/main/mkdocs.yml">https://github.com/vra/mkdocs-material-example/blob/main/mkdocs.yml</a></p><span id="more"></span><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><p>可以直接使用 <code>pip</code> 来安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mkdocs-material</span><br></pre></td></tr></table></figure><p>使用下面的命令测试是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdocs -h</span><br></pre></td></tr></table></figure><p>其他从docker安装、从GitHub安装的方式参考<a href="https://squidfunk.github.io/mkdocs-material/getting-started/#with-docker">官方文档</a>。</p><h3 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h3><p>mkdocs-material 的使用命令比较简单，概括来说就是三板斧：</p><ol><li><code>mkdocs new .</code>： 在当前目录生成<code>docs</code>目录和<code>mkdocs.yml</code> 配置文件</li><li><code>mkdocs serve</code>： 在本地运行文档生成服务，可在浏览器中访问<code>localhost:8000</code>查看文档的效果</li><li><code>mkdocs build</code>： 非必需，在<code>sites</code> 目录中生成最终的HTML文件</li></ol><p>由于命令比较简单，没有什么太多东西，因而核心要做的事情其实是：</p><ul><li>写markdown 格式的文档文件</li><li>修改配置文件<code>mkdocs.yml</code></li></ul><p>在<code>mkdocs serve</code> 运行的过程中，更新完 <code>mkdocs.yml</code>配置文件后，文档生成效果实时更新。</p><h3 id="2-3-上传文档到-GitHub-Pages"><a href="#2-3-上传文档到-GitHub-Pages" class="headerlink" title="2.3 上传文档到 GitHub Pages"></a>2.3 上传文档到 GitHub Pages</h3><p>mkdocs-material 一个很棒的特性是可以一键将代码部署到GIthub Pages上，并且通过GitHub Actions配置，Push 代码时自动更新文档。<br>假如你的GitHub 仓库地址是<code>https://github.com/user/repo</code>，那完成配置后你就可以在<code>https://user.github.io/repo</code> 网址查看你的mkdocs-material 文档了。</p><p>具体来说，假设你已经创建了一个Git 仓库，需要做下面的事情：</p><ol><li>将<code>mkdocs.yml</code> 和<code>docs</code> 目录提交到Git仓库</li><li>增加GitHub Action 配置文件<code>.github/workflows/ci.yml</code>，写入下面的内容并提交到GitHub:<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">ci</span> </span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"><span class="attr">permissions:</span></span><br><span class="line">  <span class="attr">contents:</span> <span class="string">write</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-python@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">python-version:</span> <span class="number">3.</span><span class="string">x</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;cache_id=$(date --utc &#x27;+%V&#x27;)&quot;</span> <span class="string">&gt;&gt;</span> <span class="string">$GITHUB_ENV</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/cache@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">mkdocs-material-$&#123;&#123;</span> <span class="string">env.cache_id</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">.cache</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            mkdocs-material-</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">mkdocs-material</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">mkdocs</span> <span class="string">gh-deploy</span> <span class="string">--force</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>在GitHub仓库的<code>Settings</code> -&gt; <code>Pages</code> -&gt; <code>Build and deployment</code> 部分，Source 选项选择”Deploy from a branch”, Branch 选择<code>gh-pages</code>, folder选择<code>/(root)</code><br>经过这个配置后，每次向<code>master</code> 或<code>main</code> 分支push代码，会自动更新<code>user.github.io/repo</code>下的文档。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;对于程序员来说，写技术文档是一项必备的技能。由于GitHub和Markdown格式的普及，很多时候我们可以用markdown来简便地写出技术文档，并且 通过GitHub Pages等工具快速地进行技术文档的部署。&lt;/p&gt;
&lt;p&gt;虽然GItHub Pages默认支持静态文档框架&lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;，也包含一些简单的&lt;a href=&quot;https://pages.github.com/themes/&quot;&gt;主题&lt;/a&gt;，但对于文档和教程比较多的项目来说，使用GitHub Pages的默认部署工具还不够用，主要体现在下面几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Markdown本身支持的语法比较简单，一些复杂的像Warning等提示没法直接用Pages的默认主题来实现&lt;/li&gt;
&lt;li&gt;Pages 默认显示的是单页文档，没有侧边栏、导航栏等工具&lt;/li&gt;
&lt;li&gt;Pages 默认主题无法搜索文档内容&lt;/li&gt;
&lt;li&gt;Pages 不支持选择&lt;code&gt;Linux&lt;/code&gt;或&lt;code&gt;Windows&lt;/code&gt; 后显示不同执行语句的功能&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://squidfunk.github.io/mkdocs-material/&quot;&gt;Material for MkDocs&lt;/a&gt; 是 &lt;a href=&quot;https://www.mkdocs.org/&quot;&gt;MkDocs&lt;/a&gt;的一个主题配置，同时也是一个功能齐全的静态网站生成工具，能够解决上面提到的GitHub Pages的问题。&lt;/p&gt;
&lt;p&gt;Material for MkDocs 使用广泛，下面是一些大公司和知名开源项目的使用例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://aws.github.io/copilot-cli/&quot;&gt;AWS Copilot CLI &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://google.github.io/accompanist/&quot;&gt;Google Accompanist&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://microsoft.github.io/code-with-engineering-playbook/&quot;&gt;MicroSoft Code With Engineering Playbook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mozillafoundation.github.io/engineering-handbook/&quot;&gt;Mozilla Foundation Engineering Handbook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://netflix.github.io/titus/&quot;&gt;Netflix Titus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.infra.centos.org/&quot;&gt;CentOS Infra docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.electron.build/&quot;&gt;electron-builder&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kops.sigs.k8s.io/&quot;&gt;Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然我还没有比较复杂的开源项目需要用mkdocs-material来管理文档，但看到GitHub Pages的一些限制，最近有空还是学了一下这个工具，以备后续项目中使用。这里做一些简单记录，方便以后查找。&lt;/p&gt;
&lt;p&gt;需要说明的是，Material for MkDocs 是一个比较复杂的工具，很多配置项这里没有提到，根据需要在官方&lt;a href=&quot;https://squidfunk.github.io/mkdocs-material/setup/&quot;&gt;Setup&lt;/a&gt;文档中查看使用说明。&lt;/p&gt;
&lt;p&gt;另外一种学习配置的方式是直接查看上面提到的开源项目源码根目录下的&lt;code&gt;mkdocs.yml&lt;/code&gt;文件，复制这个文件过去，就能得到类似的布局效果。&lt;/p&gt;
&lt;p&gt;这个教程里面的示例页面：&lt;a href=&quot;https://vra.github.io/mkdocs-material-example/&quot;&gt;https://vra.github.io/mkdocs-material-example/&lt;/a&gt;&lt;br&gt;示例页面的配置文件：&lt;a href=&quot;https://github.com/vra/mkdocs-material-example/blob/main/mkdocs.yml&quot;&gt;https://github.com/vra/mkdocs-material-example/blob/main/mkdocs.yml&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Docs" scheme="http://vra.github.io/tags/Docs/"/>
    
    <category term="Markdown" scheme="http://vra.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Rye:一个实验性质的Python包管理系统</title>
    <link href="http://vra.github.io/2023/05/17/rye-intro/"/>
    <id>http://vra.github.io/2023/05/17/rye-intro/</id>
    <published>2023-05-17T02:08:32.000Z</published>
    <updated>2023-05-17T02:17:20.438Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mitsuhiko.github.io/rye/">Rye</a> 是<a href="https://flask.palletsprojects.com/en/2.3.x/">Flask</a>的作者<a href="https://github.com/mitsuhiko">Armin Ronacher</a>最近推出的一个实验性质的Python包管理系统，目的是解决Python包管理目前面临的工具链碎片化的问题。</p><p>大家知道，Python目前的包管理系统很多，包括 poetry, pip, pipenv, pyenv, venv, virtualenv, pdm, hatch 等等，它们都是优秀的工具，提出时都是解决了一定的问题，但没有哪个工具能够做到主流，因此也增加了系统的碎片化程度。</p><p>另一方面，conda等工具能提供不同版本的 Python，管理不同的环境，但每个环境的 Python 不是共享的，环境创建一多，环境目录就变得很大，且内部机制很不透明，有时也会遇到冲突没法解决的问题。</p><p>另一方面，Python 在Linux/macOS上的安装也面临一些问题，例如用包管理器安装的  Python和用户手动安装的 Python 有的时候会混淆，导致一些混乱，例如在 Fedora 上，用<code>pip install</code> 安装包可能会导致系统的包管理命令<code>dnf</code> 出错。<a href="https://peps.python.org/pep-0668">PEP 668</a>尝试对这些问题给出一个解决方案，但也需要不同的系统来支持，目前看还任重道远。</p><p>由于Armin也是一个Rust 开发者，而Rust基于标准化的<code>rustup</code>和<code>cargo</code>两个工具，配合配置文件来进行包管理，目前做的比较好，没有Python面临的碎片化问题。受Rust的启发，作者提出了Rye，并且期望能够启发Python社区提出类似Rust的标准包管理工具。</p><p>具体来说，Rye 提出了一些解决这些问题的思路：</p><ul><li>提出一个workspace的概念，workspace类似一个项目目录，或者一个git仓库，一个workspace下只有一个Python版本，不同workspace Python版本相互隔离，每个项目采用<code>pyproject.toml</code>来进行配置</li><li>不使用系统自带的Python，相反地，在每个项目目录的中下载一个standalone的python，解决不同版本的冲突问题</li><li>不暴露pip命令，通过<code>rye add</code> + <code>rye sync</code> 来管理包的依赖，避免包A和包B依赖不同版本的包C而导致的不兼容问题</li><li>区分开发环境和正式环境，因为一些包在开发时会用到一些调试工具，但作为第三方库被引入的时候并不需要</li><li>支持import本地workspace作为第三方库包</li></ul><p>但同时也有一个问题：rye会不会是另一个做不到主流的Python包管理系统，从而进一步增加Python包管理的碎片化呢？作者也有这个考虑，因此写了一个讨论帖 <a href="https://github.com/mitsuhiko/rye/discussions/6">Should Rye Exist?</a>来讨论这个问题，同时关于Rye的设计初衷，可以参考<a href="https://mitsuhiko.github.io/rye/philosophy/">这里</a>作者的思考。</p><p>个人观点：Rye的出现给Python社区引入了一些新鲜的解决现有问题的思路。使用Rye一段时间后，发现至少使用standalone 的Python版本是一个解决冲突的好的方式。通过几个简单的命令来解决版本管理的问题是比较直观的，提出Rye应该是利大于弊的，也就是有益程度大于碎片化增加的程度。</p><p>总之不管是<a href="https://peps.python.org/pep-0668">PEP 668</a>中标记版本管理是系统的还是Python的，还是<a href="https://peps.python.org/pep-0711/">PEP 711</a>来单独下发Python解释器二进制文件，还是Rye的出现，都是Python社区意识到Python包管理问题的严重性，进而做出的一些有益尝试。期待在未来，有更标准化的工具，Python的开发也更容易。</p><p>下面将对Rye的安装和使用进行简单介绍。</p><span id="more"></span><h3 id="2-1-安装rustup"><a href="#2-1-安装rustup" class="headerlink" title="2.1 安装rustup"></a>2.1 安装rustup</h3><p>Rye是基于Rust 开发的，而Rust 有标准的包安装工具<code>cargo</code>，Rust编译器和<code>cargo</code>都需要用<code>rustup</code>来安装，因此安装预编译的Rye包需要先安装<code>rustup</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure><p>执行完后，重启Shell，输入<code>cargo -V</code>，如果不报错，说明安装成功。</p><h3 id="2-2-安装Rye"><a href="#2-2-安装Rye" class="headerlink" title="2.2 安装Rye"></a>2.2 安装Rye</h3><p>有了cargo后，使用下面的命令安装Rye:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install --git https://github.com/mitsuhiko/rye rye</span><br></pre></td></tr></table></figure><p>通过命令行执行<code>rye -h</code> 来判断 Rye是否安装成功。</p><p>同时可以将<code>$HOME/.rye/shims</code> 添加到环境变量<code>PATH</code> 中，这样打开Shell后运行<code>python</code> 就用的是Rye安装到standalone Python，否则你需要用<code>rye run python</code> 来启用Rye的Python解释器。</p><p>更新Rye到最新版：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rye self update</span><br></pre></td></tr></table></figure><p>删除Rye:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo uninstall rye</span><br></pre></td></tr></table></figure><h3 id="2-3-初始化一个Rye项目"><a href="#2-3-初始化一个Rye项目" class="headerlink" title="2.3 初始化一个Rye项目"></a>2.3 初始化一个Rye项目</h3><p>使用<code>rye init project-name</code> 来创建一个Rye项目目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rye init test_rye</span><br><span class="line"><span class="built_in">cd</span> test_rye</span><br><span class="line">tree</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── .git</span><br><span class="line">├── .gitignore</span><br><span class="line">├── .python-version</span><br><span class="line">├── README.md</span><br><span class="line">├── pyproject.toml</span><br><span class="line">└── src</span><br><span class="line">    └── test_rye</span><br><span class="line">        └── __init__.py</span><br></pre></td></tr></table></figure><p>可以看到创建了.git 目录， .gitignore 文件，README.md，配置文件<code>pyproject.toml</code> 和一个示例的源码文件<code>src/test_rye/__init__.py</code>。</p><h3 id="2-4-Python-版本管理"><a href="#2-4-Python-版本管理" class="headerlink" title="2.4 Python 版本管理"></a>2.4 Python 版本管理</h3><p>为了固定开发环境，我们可以利用<code>rye pin python-version</code> 来固定Python的版本，例如<code>rye pin cpython@3.10.11</code> 会将Python版本固定为3.10.11。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cpython@可以省略</span></span><br><span class="line">rye pin cpython@3.10.11</span><br><span class="line">rye pin 3.10.11</span><br></pre></td></tr></table></figure><p>由于默认使用的Python版本是Cpython的，因此在执行rye命令时可以将<code>Cpython@</code> 前缀省去。</p><p>注意 <code>rye pin</code>命令并不立即改变Python的版本，只是修改配置文件<code>.python-version</code>，在<code>rye sync</code> 执行时才进行实际的修改。</p><p>可以多次执行<code>rye pin</code> 来调整Python的版本。</p><p>然后执行<code>rye sync</code> 来同步配置，具体来说，第一次执行这个命令的时候，Rye会下载一个单独的Python解释器，放置到<code>$HOME/.rye/py</code>目录下，链接到项目的<code>.venv</code> 目录下，因此同一个Python版本在磁盘上只有一份，这与conda是不同的。</p><p>更一般地，可以使用<code>rye toolchain</code> 来查看、拉取和删除Python版本。</p><p><code>rye toolchain list</code> 用来显示所有已经安装的Python版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rye toolcahin list</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cpython@3.11.3 (/Users/yunfeng/.rye/py/cpython@3.11.3/install/bin/python3)</span><br><span class="line">cpython@3.11.1 (/Users/yunfeng/.rye/py/cpython@3.11.1/install/bin/python3)</span><br><span class="line">cpython@3.10.11 (/Users/yunfeng/.rye/py/cpython@3.10.11/install/bin/python3)</span><br><span class="line">cpython@3.10.9 (/Users/yunfeng/.rye/py/cpython@3.10.9/install/bin/python3)</span><br></pre></td></tr></table></figure><p><code>rye toolchain list --include-downloadable</code> 会列出所有可以下载的Python版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`rye toolchain list --include-downloadable` </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cpython@3.10.8 (downloadable)</span><br><span class="line">cpython@3.10.7 (downloadable)</span><br><span class="line">cpython@3.10.6 (downloadable)</span><br><span class="line">cpython@3.10.5 (downloadable)</span><br><span class="line">cpython@3.10.4 (downloadable)</span><br><span class="line">cpython@3.10.3 (downloadable)</span><br><span class="line">cpython@3.10.2 (downloadable)</span><br><span class="line">cpython@3.10.0 (downloadable)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意已经下载的Python版本不在这个输出中。</p><p><code>rye toolchain fetch</code>（简写为<code>rye fetch</code>) 可以直接拉取某个Python版本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rye toolchain fetch 3.8.16</span><br></pre></td></tr></table></figure><p><code>rye toolchain remove</code> 可以删除某个Python版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rye toolchain remove 3.8.16</span><br></pre></td></tr></table></figure><h3 id="2-5-添加依赖包"><a href="#2-5-添加依赖包" class="headerlink" title="2.5 添加依赖包"></a>2.5 添加依赖包</h3><p>可以通过<code>rye add package-name</code> 来安装像numpy等第三方，这个命令支持安装GitHub和本地的包，一些示例的用法如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rye add numpy</span><br><span class="line"><span class="comment"># 同时安装几个包</span></span><br><span class="line">rye add six easydict</span><br><span class="line"><span class="comment"># 设置安装包的版本</span></span><br><span class="line">rye add <span class="string">&quot;Flask&gt;=2.0&quot;</span></span><br><span class="line"><span class="comment"># 只在development环境添加包</span></span><br><span class="line">rye add --dev black</span><br><span class="line"><span class="comment"># 添加github上的包</span></span><br><span class="line">rye add Flask --git=https://github.com/pallets/flask</span><br><span class="line"><span class="comment"># 添加本地目录的包</span></span><br><span class="line">rye add My-Utility --path ./my-utility</span><br></pre></td></tr></table></figure><p>同样的，<code>rye add</code>并不会实际安装包，只会修改配置文件<code>pyproject.toml</code> 中的<code>dependencies</code> 项，等执行<code>rye sync</code>的时候才真正安装。</p><h3 id="2-6-Rye工作流"><a href="#2-6-Rye工作流" class="headerlink" title="2.6 Rye工作流"></a>2.6 Rye工作流</h3><p>我自己探索的Rye工作流大概是这样：</p><ol><li><code>rye init project-name</code> 来初始化项目目录</li><li><code>git add</code> 和<code>git commit</code> 来提交初始状态的代码，方便定位后续代码和配置文件的更新</li><li><code>rye pin</code> 指定Python版本</li><li>修改代码，<code>rye add package-name</code> 来增加代码依赖的包</li><li><code>rye sync</code>来安装Python，安装依赖包，更新配置文件</li><li><code>rye run python</code> 执行代码测试</li><li>可选：<code>rye build</code> 来生成可发布的wheel文件</li><li>可选：<code>rye publish</code> 上传包到pypi</li></ol><p>需要注意的是，Rye只负责依赖管理，具体的调试代码工作，还需要自己来进行，使用你熟悉的代码测试方式就可以了。</p><p>额外补充一下，可以使用<code>rye shell</code> 来打开一个新的启用了Rye Python的Shell来进行代码调试。</p><h3 id="2-7-安装可执行的-global-Python工具"><a href="#2-7-安装可执行的-global-Python工具" class="headerlink" title="2.7 安装可执行的 global Python工具"></a>2.7 安装可执行的 global Python工具</h3><p>某些python包除了包含Python源码外，还包含一些命令行工具，Rye称这些工具为<code>global tool</code> ，因为它们不是在某个环境中才能使用，而是全局可使用的。这些工具可以用<code>rye install package-name</code>来安装，例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rye install black</span><br></pre></td></tr></table></figure><p>使用方式为<code>rye run tool-name</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rye run black -h</span><br></pre></td></tr></table></figure><p>这些包都存放在<code>$HOME/.rye/shims</code> 目录下。<br>如果要删除 global tool，可以使用<code>rye uninstall</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rye uninstall black</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mitsuhiko.github.io/rye/&quot;&gt;Rye&lt;/a&gt; 是&lt;a href=&quot;https://flask.palletsprojects.com/en/2.3.x/&quot;&gt;Flask&lt;/a&gt;的作者&lt;a href=&quot;https://github.com/mitsuhiko&quot;&gt;Armin Ronacher&lt;/a&gt;最近推出的一个实验性质的Python包管理系统，目的是解决Python包管理目前面临的工具链碎片化的问题。&lt;/p&gt;
&lt;p&gt;大家知道，Python目前的包管理系统很多，包括 poetry, pip, pipenv, pyenv, venv, virtualenv, pdm, hatch 等等，它们都是优秀的工具，提出时都是解决了一定的问题，但没有哪个工具能够做到主流，因此也增加了系统的碎片化程度。&lt;/p&gt;
&lt;p&gt;另一方面，conda等工具能提供不同版本的 Python，管理不同的环境，但每个环境的 Python 不是共享的，环境创建一多，环境目录就变得很大，且内部机制很不透明，有时也会遇到冲突没法解决的问题。&lt;/p&gt;
&lt;p&gt;另一方面，Python 在Linux/macOS上的安装也面临一些问题，例如用包管理器安装的  Python和用户手动安装的 Python 有的时候会混淆，导致一些混乱，例如在 Fedora 上，用&lt;code&gt;pip install&lt;/code&gt; 安装包可能会导致系统的包管理命令&lt;code&gt;dnf&lt;/code&gt; 出错。&lt;a href=&quot;https://peps.python.org/pep-0668&quot;&gt;PEP 668&lt;/a&gt;尝试对这些问题给出一个解决方案，但也需要不同的系统来支持，目前看还任重道远。&lt;/p&gt;
&lt;p&gt;由于Armin也是一个Rust 开发者，而Rust基于标准化的&lt;code&gt;rustup&lt;/code&gt;和&lt;code&gt;cargo&lt;/code&gt;两个工具，配合配置文件来进行包管理，目前做的比较好，没有Python面临的碎片化问题。受Rust的启发，作者提出了Rye，并且期望能够启发Python社区提出类似Rust的标准包管理工具。&lt;/p&gt;
&lt;p&gt;具体来说，Rye 提出了一些解决这些问题的思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提出一个workspace的概念，workspace类似一个项目目录，或者一个git仓库，一个workspace下只有一个Python版本，不同workspace Python版本相互隔离，每个项目采用&lt;code&gt;pyproject.toml&lt;/code&gt;来进行配置&lt;/li&gt;
&lt;li&gt;不使用系统自带的Python，相反地，在每个项目目录的中下载一个standalone的python，解决不同版本的冲突问题&lt;/li&gt;
&lt;li&gt;不暴露pip命令，通过&lt;code&gt;rye add&lt;/code&gt; + &lt;code&gt;rye sync&lt;/code&gt; 来管理包的依赖，避免包A和包B依赖不同版本的包C而导致的不兼容问题&lt;/li&gt;
&lt;li&gt;区分开发环境和正式环境，因为一些包在开发时会用到一些调试工具，但作为第三方库被引入的时候并不需要&lt;/li&gt;
&lt;li&gt;支持import本地workspace作为第三方库包&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但同时也有一个问题：rye会不会是另一个做不到主流的Python包管理系统，从而进一步增加Python包管理的碎片化呢？作者也有这个考虑，因此写了一个讨论帖 &lt;a href=&quot;https://github.com/mitsuhiko/rye/discussions/6&quot;&gt;Should Rye Exist?&lt;/a&gt;来讨论这个问题，同时关于Rye的设计初衷，可以参考&lt;a href=&quot;https://mitsuhiko.github.io/rye/philosophy/&quot;&gt;这里&lt;/a&gt;作者的思考。&lt;/p&gt;
&lt;p&gt;个人观点：Rye的出现给Python社区引入了一些新鲜的解决现有问题的思路。使用Rye一段时间后，发现至少使用standalone 的Python版本是一个解决冲突的好的方式。通过几个简单的命令来解决版本管理的问题是比较直观的，提出Rye应该是利大于弊的，也就是有益程度大于碎片化增加的程度。&lt;/p&gt;
&lt;p&gt;总之不管是&lt;a href=&quot;https://peps.python.org/pep-0668&quot;&gt;PEP 668&lt;/a&gt;中标记版本管理是系统的还是Python的，还是&lt;a href=&quot;https://peps.python.org/pep-0711/&quot;&gt;PEP 711&lt;/a&gt;来单独下发Python解释器二进制文件，还是Rye的出现，都是Python社区意识到Python包管理问题的严重性，进而做出的一些有益尝试。期待在未来，有更标准化的工具，Python的开发也更容易。&lt;/p&gt;
&lt;p&gt;下面将对Rye的安装和使用进行简单介绍。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="Rust" scheme="http://vra.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>git 回滚代码并保留提交历史</title>
    <link href="http://vra.github.io/2023/05/16/git-roll-back-code-and-save-commit-history/"/>
    <id>http://vra.github.io/2023/05/16/git-roll-back-code-and-save-commit-history/</id>
    <published>2023-05-16T07:55:28.000Z</published>
    <updated>2023-05-16T07:56:23.905Z</updated>
    
    <content type="html"><![CDATA[<p>在使用git时，有时候需要回退最新代码到之前的某次提交或某个tag，将中间的所有代码提交去掉。同时保持中间的提交记录。实际应用时发现这个动作没有比较好的实现方式。</p><p>例如，如果使用<code>git revert commit-id</code>, 那么只会会退<code>commit-id</code> 对应的那次提交，之后的提交不受影响，仍然存在，不是我们想要的效果。</p><p>如果使用<code>git reset</code>, 那操作就比较麻烦，需要使用<code>--hard</code> 和<code>--force</code> 等比较危险的命令，具体如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit-id</span><br><span class="line">git push --force</span><br></pre></td></tr></table></figure><p>这样做除了使用比较危险的命令选项外，还有个问题是没法保留中间的提交历史，这不是我们想要的。</p><p>搜索发现，利用git diff和git apply可以来比较清晰的完成这个需求，整体的思路是：</p><ol><li>得到当前最新提交到回退提交之间的代码diff，将diff保存为文件</li><li>利用<code>git apply</code> 将diff作用到代码上，回到之前的代码状态</li><li>提交代码</li></ol><p>具体来说，假设当前最新提交就在分支<code>current-branch</code>上，回退提交为<code>prev-commit</code>,这个回退提交可以是一次commit id，也可以是一个tag，也可以是一个分支名。执行命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout prev-commit</span><br><span class="line">git diff current-branch &gt; ~/diff.patch</span><br><span class="line">git checkout current-branch</span><br><span class="line">cat ~/diff.patch | git apply</span><br><span class="line">git commit -am <span class="string">&quot;roll back to prev-commit&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>这样就能既回退代码，又保留提交历史。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://stackoverflow.com/a/33890073">https://stackoverflow.com/a/33890073</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用git时，有时候需要回退最新代码到之前的某次提交或某个tag，将中间的所有代码提交去掉。同时保持中间的提交记录。实际应用时发现这个动作没有比较好的实现方式。&lt;/p&gt;
&lt;p&gt;例如，如果使用&lt;code&gt;git revert commit-id&lt;/code&gt;, 那么只会会退</summary>
      
    
    
    
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>talkGPT4All</title>
    <link href="http://vra.github.io/2023/04/02/chatbot4all/"/>
    <id>http://vra.github.io/2023/04/02/chatbot4all/</id>
    <published>2023-04-01T22:11:54.000Z</published>
    <updated>2023-04-02T00:45:18.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>TL;DR: talkGPT4All 是一个在PC本地运行的基于talkGPT和GPT4All的语音聊天程序，通过OpenAI Whisper将输入语音转文本，再将输入文本传给GPT4All获取回答文本，最后利用发音程序将文本读出来，构建了完整的语音交互聊天过程。</p><p>实际使用效果<a href="https://www.zhihu.com/zvideo/1625779747656515584">视频</a>。</p><p>实际上，它只是几个工具的简易组合，没有什么创新的地方（甚至不支持多轮聊天，只支持英文），但 talkGPT4All 有下面几个比较好的特点</p><ul><li>所有算法本地运行，不涉及API的调用，避免了国内无法访问OpenAI API的问题</li><li>CPU 运行，无须 GPU 显卡</li><li>占内存小，实测8G内存就可以跑起来</li><li>速度还可以，测试8G Windows 一轮聊天小于1分钟， 16G Mac 一轮聊天小于30秒</li><li>集成的AI还算智能，至少答能对题，回答看起来是符合英语语法的</li></ul><p>目前支持平台和验证的情况如下:</p><ul><li>Mac M1，已经验证可用</li><li>Windows，已经验证可用</li><li>Mac intel，未验证</li><li>Linux，未验证<br>如果有对应机器的朋友感兴趣的话，可以帮忙验证一下，有问题可以提PR和issue。</li></ul><p>想体验的朋友可以参考 GitHub README进行快速安装，也可以在这篇文章中跟着我一步步来进行。</p><span id="more"></span><h2 id="2-为什么造这个轮子"><a href="#2-为什么造这个轮子" class="headerlink" title="2. 为什么造这个轮子"></a>2. 为什么造这个轮子</h2><p>聊天机器人是我比较喜欢的一个应用，机器+人类的思维是一个很有意思的场景。另一方面，通过一个智能机器人来练习英语口语，也是一个很实际的应用。</p><p>一直以来，想要做一个含有智能的聊天机器人应用都是难度很大的，尤其是智能化的程度，受学术研究进展的制约，没法做到很高。然而近期的AI LLM大爆发，让开发一个真正智能的AI聊天机器人越来越容易。</p><p>最早看到的是基于<a href="https://github.com/ggerganov/whisper.cpp">whisper.cpp</a>的<a href="https://github.com/ggerganov/whisper.cpp/tree/master/examples/talk.wasm">talk.wasm</a>, 一个基于Whisper+GPT-2的浏览器对话机器人，实际测试后发现GPT-2还不够智能，回答很多时候都答非所问。</p><p>然后是在ChatGPT出来后，我在想能不能做一个Whisper + ChatGPT的智能聊天机器人呢，搜索后发现whisper.cpp的讨论区已经有人在<a href="https://github.com/ggerganov/whisper.cpp/discussions/167#discussioncomment-4334628">讨论</a>这个事情，不过没看到成品。</p><p>在ChatGPT 开放API后，有人做了一个MacOS上的基于OpenAI API的语音聊天机器人<a href="https://github.com/chenyukang/talkGPT">talkGPT</a>，简单好用，唯一的问题是需要借助OpenAI API，目前国内是不太好访问的。</p><p>再然后是<a href="https://github.com/ggerganov/llama.cpp">llama.cpp</a>，通过量化和大量工程优化，让原本参数量很大的<a href="https://github.com/facebookresearch/llama">LLaMA</a>模型可以跑在普通的笔记本上（现在甚至支持在Android上运行！)，但实际测试经过量化后 LLaMA 7B 模型智能程度不太高，有时候会出错，而 更大的LLaMA 15B 和 30B 在8GB内存的Windows 机器上跑起来就比较难了（最新进展：大小20GB的30B模型可以在8G的系统上运行了，参见这个<a href="https://github.com/ggerganov/llama.cpp/pull/613">优化</a>和这里的<a href="https://github.com/ggerganov/llama.cpp/discussions/638">讨论</a>)。</p><p>这周又出现了<a href="https://github.com/nomic-ai/gpt4all">gpt4all</a>，基于 LLaMA 7B模型，采集近80万的GPT-3.5-Turbo对话数据进行finetune，效果看起来比 LLaMA 7B 要好。作者发布了他们训练好的经过量化的模型，大小3.9G，以及可以直接在PC上运行的二进制聊天程序，可以直接在各个平台运行。</p><p>然后长久以来的TODO 可以实现了，在缝合了talkGPT和GPT4All后，就有了talkGPT4All。简单来说，是把talkGPT的OpenAI API 换成了 GPT4All提供的本地可以运行的量化模型，也可以说是在GPT4All的基础上添加了语音转文本和文本转语音的功能。</p><p>那下面我们来看看怎么安装和运行这个缝合怪吧。</p><h2 id="3-构建环境"><a href="#3-构建环境" class="headerlink" title="3. 构建环境"></a>3. 构建环境</h2><p>由于整个程序设计到 Python 代码环境的搭建、Whisper 语音转文本模型的下载、GPT4All 语言模型的下载、GPT4All 聊天程序的下载、文本转语音程序的下载，整体链路略长，下面分步骤分平台分别进行详细说明。</p><h3 id="3-1-Python环境的搭建"><a href="#3-1-Python环境的搭建" class="headerlink" title="3.1 Python环境的搭建"></a>3.1 Python环境的搭建</h3><p>在不同平台 Python 代码环境的搭建是一致的。</p><p>推荐使用&gt;= 3.8的Python版本，因为新版本的Python有一定的速度提升。低版本可能一些功能不支持。<br>首先clone代码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/vra/talkGPT4All.git</span><br></pre></td></tr></table></figure><p>后面假设代码仓库的根目录为<code>&lt;ROOT&gt;</code>来进行命令说明。</p><p>基于 Python自带的 venv 来搭建隔离的环境，并进行依赖安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;ROOT&gt;</span><br><span class="line">python -m venv talkgpt4all</span><br><span class="line"><span class="built_in">source</span> talkgpt4all/bin/activate</span><br><span class="line">pip install -U pip</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><h3 id="3-2-Whisper-语音转文本模型下载"><a href="#3-2-Whisper-语音转文本模型下载" class="headerlink" title="3.2 Whisper 语音转文本模型下载"></a>3.2 Whisper 语音转文本模型下载</h3><p>Whisper 模型在调用时会自动下载，但有时候在命令行下载速度比较慢，我们可以在浏览器中提前下载后放置到对应目录，解决这个问题。<br>Whisper 的所有模型地址参见<a href="https://github.com/openai/whisper/blob/b80bcf610d89960bc658b61af9c333fc6d978d78/whisper/__init__.py#L18-L29">这里</a>，我们用的是<code>base.pt</code>，地址是<a href="https://openaipublic.azureedge.net/main/whisper/models/ed3a0b6b1c0edf879ad9b11b1af5a0e6ab5db9205f891f668f8b0e6c6326e34e/base.pt">https://openaipublic.azureedge.net/main/whisper/models/ed3a0b6b1c0edf879ad9b11b1af5a0e6ab5db9205f891f668f8b0e6c6326e34e/base.pt</a>，放置的目录是<code>$HOME/.cache/whisper</code>（Windows上是<code>C:\Users\username\.cache\whisper</code>),通过浏览器或 wget 下载<code>base.pt</code>到这个目录就行。</p><h3 id="3-3-GPT4All-语言模型的下载"><a href="#3-3-GPT4All-语言模型的下载" class="headerlink" title="3.3 GPT4All 语言模型的下载"></a>3.3 GPT4All 语言模型的下载</h3><p>语言模型放置目录是<code>&lt;ROOT&gt;/models</code>，根据 GPT4All <a href="https://github.com/nomic-ai/gpt4all#try-it-yourself">文档</a>，下载方式包括</p><ul><li><a href="https://the-eye.eu/public/AI/models/nomic-ai/gpt4all/gpt4all-lora-quantized.bin">链接</a>直接下载</li><li><a href="https://tinyurl.com/gpt4all-lora-quantized">torrent</a>下载</li></ul><p>选择其中一种方式，将下载后的模型放置到<code>&lt;ROOT&gt;/models</code>目录下。</p><h3 id="3-3-GPT4All-聊天程序下载"><a href="#3-3-GPT4All-聊天程序下载" class="headerlink" title="3.3 GPT4All 聊天程序下载"></a>3.3 GPT4All 聊天程序下载</h3><p>GPT4All 的作者打包了多平台的二进制聊天程序，可以下载后直接使用，不用从源码编译 C++ 文件。</p><p>聊天程序的放置目录是<code>&lt;ROOT&gt;/bin</code>，不同平台的下载地址如下：</p><ul><li>Mac M1: <a href="https://raw.githubusercontent.com/nomic-ai/gpt4all/main/chat/gpt4all-lora-quantized-OSX-m1">https://raw.githubusercontent.com/nomic-ai/gpt4all/main/chat/gpt4all-lora-quantized-OSX-m1</a></li><li>Mac Intel : <a href="https://raw.githubusercontent.com/nomic-ai/gpt4all/main/chat/gpt4all-lora-quantized-OSX-Intel">https://raw.githubusercontent.com/nomic-ai/gpt4all/main/chat/gpt4all-lora-quantized-OSX-Intel</a></li><li>Linux : <a href="https://raw.githubusercontent.com/nomic-ai/gpt4all/main/chat/gpt4all-lora-quantized-linux-x86">https://raw.githubusercontent.com/nomic-ai/gpt4all/main/chat/gpt4all-lora-quantized-linux-x86</a></li><li>Windows : <a href="https://raw.githubusercontent.com/nomic-ai/gpt4all/main/chat/gpt4all-lora-quantized-win64.exe">https://raw.githubusercontent.com/nomic-ai/gpt4all/main/chat/gpt4all-lora-quantized-win64.exe</a></li></ul><p>下载你的平台的文件，放置到<code>&lt;ROOT&gt;/bin</code>。</p><h3 id="3-4-文本转语音程序下载"><a href="#3-4-文本转语音程序下载" class="headerlink" title="3.4 文本转语音程序下载"></a>3.4 文本转语音程序下载</h3><p>在 Mac 下，自带<a href="https://ss64.com/osx/say.html">say命令</a>，可以将文本转语音，因此不需要额外安装工具。</p><p>在 Linux 下，有<a href="https://espeak.sourceforge.net/">espeak</a>命令可以来完成文本转语音，但需要额外安装，Ubuntu下的安装命令为<code>sudo apt install espeak</code>，别的发行版也可以用包管理安装。如果不行的话，尝试<a href="https://espeak.sourceforge.net/download.html">下载源码</a>自行编译安装。</p><p>Windows 下有一个 say 命令的替代 <a href="https://github.com/p-groarke/wsay">wsay</a>, 可以在<a href="https://github.com/p-groarke/wsay/releases/tag/v1.5.0">这里</a>下载 wsay.exe，放置到<code>&lt;ROOT&gt;/bin</code>目录下。</p><h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h3><p>安装完成后，进入<code>&lt;ROOT&gt;</code>目录，启用虚拟环境，使用<code>python chat.py --platform &lt;platform&gt;</code>运行程序，<code>&lt;platform&gt;</code>分别是<code>mac-m1</code>, <code>mac-intel</code>, <code>linux</code>, <code>windows</code>。</p><p>Mac M1:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python chat.py --platform mac-m1</span><br></pre></td></tr></table></figure><p>Mac Intel:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python chat.py --platform mac-intel</span><br></pre></td></tr></table></figure><p>Linux:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python chat.py --platform linux</span><br></pre></td></tr></table></figure><p>Windows:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python chat.py --platform windows</span><br></pre></td></tr></table></figure><p>⚠️注意：目前只测试过 Mac M1 和 Windows，别的平台未测试，如有问题，欢迎提 <a href="https://github.com/vra/talkGPT4All/issues">issue</a> 和 <a href="https://github.com/vra/talkGPT4All/pulls">PR</a> 。</p><p>在 Mac 上使用效果如下:<br><img data-src="/imgs/talkgpt4all-mac-m1.jpg"></p><p>也可以参见本文开头的视频或<a href="https://www.zhihu.com/zvideo/1625779747656515584">这里</a>。</p><h3 id="5-后续改进思路"><a href="#5-后续改进思路" class="headerlink" title="5. 后续改进思路"></a>5. 后续改进思路</h3><p>目前实现还是比较粗糙，计划后续会增加下面的功能（按实现难度从低到高排列）：</p><ul><li>验证 Linux，Mac Intel 和 WSL2 下能否正常运行</li><li>增加多轮对话支持</li><li>增加中文支持</li><li>去掉编译好的二进制程序，包含 llama.cpp 源码，自行编译，支持更灵活的使用</li><li>更多效果更好模型的添加</li></ul><p>欢迎基于这个仓库进行修改和代码分发，期待创造出更有新意、更有应用价值的东西～</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;TL;DR: talkGPT4All 是一个在PC本地运行的基于talkGPT和GPT4All的语音聊天程序，通过OpenAI Whisper将输入语音转文本，再将输入文本传给GPT4All获取回答文本，最后利用发音程序将文本读出来，构建了完整的语音交互聊天过程。&lt;/p&gt;
&lt;p&gt;实际使用效果&lt;a href=&quot;https://www.zhihu.com/zvideo/1625779747656515584&quot;&gt;视频&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;实际上，它只是几个工具的简易组合，没有什么创新的地方（甚至不支持多轮聊天，只支持英文），但 talkGPT4All 有下面几个比较好的特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有算法本地运行，不涉及API的调用，避免了国内无法访问OpenAI API的问题&lt;/li&gt;
&lt;li&gt;CPU 运行，无须 GPU 显卡&lt;/li&gt;
&lt;li&gt;占内存小，实测8G内存就可以跑起来&lt;/li&gt;
&lt;li&gt;速度还可以，测试8G Windows 一轮聊天小于1分钟， 16G Mac 一轮聊天小于30秒&lt;/li&gt;
&lt;li&gt;集成的AI还算智能，至少答能对题，回答看起来是符合英语语法的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前支持平台和验证的情况如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mac M1，已经验证可用&lt;/li&gt;
&lt;li&gt;Windows，已经验证可用&lt;/li&gt;
&lt;li&gt;Mac intel，未验证&lt;/li&gt;
&lt;li&gt;Linux，未验证&lt;br&gt;如果有对应机器的朋友感兴趣的话，可以帮忙验证一下，有问题可以提PR和issue。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;想体验的朋友可以参考 GitHub README进行快速安装，也可以在这篇文章中跟着我一步步来进行。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="AI" scheme="http://vra.github.io/tags/AI/"/>
    
    <category term="ChatBot" scheme="http://vra.github.io/tags/ChatBot/"/>
    
    <category term="GPT" scheme="http://vra.github.io/tags/GPT/"/>
    
    <category term="Whisper" scheme="http://vra.github.io/tags/Whisper/"/>
    
    <category term="Mac" scheme="http://vra.github.io/tags/Mac/"/>
    
    <category term="Windows" scheme="http://vra.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>neovim telescope 插件简要教程</title>
    <link href="http://vra.github.io/2023/03/28/neovim-telescope/"/>
    <id>http://vra.github.io/2023/03/28/neovim-telescope/</id>
    <published>2023-03-28T15:44:37.000Z</published>
    <updated>2023-03-28T16:23:19.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><a href="https://github.com/nvim-telescope/telescope.nvim/">telescope</a> 是一款强大的 neovim 插件，可以在 neovim 中提供文件名搜索和文本内容搜索的功能，以及更多复杂的功能，具体的show case可以看<a href="https://github.com/nvim-telescope/telescope.nvim/wiki/Showcase">这里</a>。我安装 telescope 主要是想利用它在大型项目中的文件名搜索和文本内容搜索能力，这里记录一下安装流程和使用概要。</p><span id="more"></span><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><p>首先需要安装 neovim。具体步骤可以看<a href="https://github.com/neovim/neovim/wiki/Installing-Neovim">这里</a>。</p><p>注意 telescope 需要nvim 0.7.0及以后的版本，因此如果你neovim 版本本身比较低的话，需要升级。</p><p>安装 neovim 后还需要进行配置。我的 neovim 配置是复制的这个<a href="https://github.com/bigeagle/neovim-config">仓库</a>，按照README来进行操作，可以快速地安装好，这里不赘述。</p><p>telescope 支持多种插件系统，我使用的 vim-plug，在<code>~/.config/nvim/init.vim</code> 添加下面两行：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Plug <span class="string">&#x27;nvim-lua/plenary.nvim&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;nvim-telescope/telescope.nvim&#x27;</span>, &#123; <span class="string">&#x27;tag&#x27;</span>: <span class="string">&#x27;0.1.1&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>然后在nvim中输入<code>:PlugInstall</code> 来安装插件。</p><p>由于插件是在GitHub上下载的，有时候可能安装会卡住，需要多尝试几次，即多次执行<code>:PlugInstall</code>命令。</p><p>安装完成后，执行<code>:Telescope find_files</code>来验证安装是否正确。如果能弹出输入框，说明安装成功了。</p><p>这个命令用来模糊匹配当前目录下的所有文件名，对于快速切换编辑文件非常方便。</p><h2 id="3-live-grep-功能"><a href="#3-live-grep-功能" class="headerlink" title="3. live_grep 功能"></a>3. <code>live_grep</code> 功能</h2><p>除了<code>find_files</code>命令，<code>live_grep</code>也是一个很有用的命令，可以快速搜索某些代码，把含搜索代码的文件打开。</p><p>这个功能需要依赖<a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>，因此要先安装它，具体安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mac</span></span><br><span class="line">brew install ripgrep</span><br><span class="line"></span><br><span class="line"><span class="comment"># debian/ubuntu</span></span><br><span class="line">sudo apt-get install ripgrep</span><br><span class="line"></span><br><span class="line"><span class="comment"># arch</span></span><br><span class="line">pacman -S ripgrep</span><br><span class="line"></span><br><span class="line"><span class="comment"># centos</span></span><br><span class="line">sudo yum-config-manager --add-repo=https://copr.fedorainfracloud.org/coprs/carlwgeorge/ripgrep/repo/epel-7/carlwgeorge-ripgrep-epel-7.repo</span><br><span class="line">sudo yum install ripgrep</span><br><span class="line"></span><br><span class="line"><span class="comment"># windows </span></span><br><span class="line">scoop install ripgrep</span><br></pre></td></tr></table></figure><p>安装完后在命令行输入<code>ag -h</code> 验证安装是否成功。</p><p>ag 安装完成后，在nvim输入<code>:Telescope live_grep</code> 就可以搜索你想要的代码了。</p><h2 id="4-快捷键"><a href="#4-快捷键" class="headerlink" title="4. 快捷键"></a>4. 快捷键</h2><p>上面的两个常用功能输入都比较繁琐，有没有什么快捷键可以快速打开呢？是有的，官方GitHub给出了几行代码，加入到<code>~/.config/nvim/init.vim</code>的最后：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&quot; Find files using Telescope command-line sugar.</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span>ff <span class="symbol">&lt;cmd&gt;</span>Telescope find_files<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span>fg <span class="symbol">&lt;cmd&gt;</span>Telescope live_grep<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span>fb <span class="symbol">&lt;cmd&gt;</span>Telescope <span class="keyword">buffers</span><span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span>fh <span class="symbol">&lt;cmd&gt;</span>Telescope help_tags<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Using Lua functions</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span>ff <span class="symbol">&lt;cmd&gt;</span><span class="keyword">lua</span> require(<span class="string">&#x27;telescope.builtin&#x27;</span>).find_files()<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span>fg <span class="symbol">&lt;cmd&gt;</span><span class="keyword">lua</span> require(<span class="string">&#x27;telescope.builtin&#x27;</span>).live_grep()<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span>fb <span class="symbol">&lt;cmd&gt;</span><span class="keyword">lua</span> require(<span class="string">&#x27;telescope.builtin&#x27;</span>).<span class="keyword">buffers</span>()<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span>fh <span class="symbol">&lt;cmd&gt;</span><span class="keyword">lua</span> require(<span class="string">&#x27;telescope.builtin&#x27;</span>).help_tags()<span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure><p>然后在Normal模式输入<code>\ff</code>就可以打开<code>find_files</code>命令窗口，输入<code>\fg</code>就可以打开<code>live_grep</code>窗口了。</p><p>更多详细命令和功能参见GitHub 页面。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/nvim-telescope/telescope.nvim/&quot;&gt;telescope&lt;/a&gt; 是一款强大的 neovim 插件，可以在 neovim 中提供文件名搜索和文本内容搜索的功能，以及更多复杂的功能，具体的show case可以看&lt;a href=&quot;https://github.com/nvim-telescope/telescope.nvim/wiki/Showcase&quot;&gt;这里&lt;/a&gt;。我安装 telescope 主要是想利用它在大型项目中的文件名搜索和文本内容搜索能力，这里记录一下安装流程和使用概要。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="Vim" scheme="http://vra.github.io/tags/Vim/"/>
    
    <category term="NeoVim" scheme="http://vra.github.io/tags/NeoVim/"/>
    
  </entry>
  
  <entry>
    <title>libtorch系列教程2：torch::Tensor的使用</title>
    <link href="http://vra.github.io/2023/02/25/libtorch-tutorial2/"/>
    <id>http://vra.github.io/2023/02/25/libtorch-tutorial2/</id>
    <published>2023-02-25T09:15:46.000Z</published>
    <updated>2023-02-27T04:48:49.191Z</updated>
    
    <content type="html"><![CDATA[<p>系列教程列表：</p><ul><li><a href="https://vra.github.io/2023/02/25/libtorch-tutorial1/">Libtorch系列教程1：一个丝滑的C++ Tensor库</a> </li><li><a href="https://vra.github.io/2023/02/25/libtorch-tutorial2/">Libtorch系列教程2：torch::Tensor的使用</a> </li></ul><p>这篇文章中，我们暂时忽略网络训练和推理，详细展开Libtorch中Tensor对象的使用，看看将Libtorch当作一个纯粹的Tensor库来使用时，有哪些注意事项。如有未涉及的内容，请访问Libtorch<a href="https://pytorch.org/cppdocs/">官方文档</a>，通过搜索框获取更多的信息。Libtorch的环境搭建参考<a href="https://vra.github.io/2023/02/25/libtorch-tutorial1/">上一篇文章</a>。</p><span id="more"></span><h2 id="1-torch-Tensor基本操作"><a href="#1-torch-Tensor基本操作" class="headerlink" title="1. torch::Tensor基本操作"></a>1. torch::Tensor基本操作</h2><p>Libtorch中的Tensor是与Pytorch中的Tensor对应的，使用方式上很类似，只在一些Python语法C++不支持的时候有些不同，例如slice操作。<br>使用Libtorch前需要包含 Libtorch 的头文件<code>torch/torch.h</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;torch/torch.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这篇文章用到的所有函数都在此头文件中声明，而且所有的函数namespace都是<code>torch</code>，因此都可以以<code>torch::xxx</code>的形式来调用。</p><h3 id="1-1-Tensor创建"><a href="#1-1-Tensor创建" class="headerlink" title="1.1 Tensor创建"></a>1.1 Tensor创建</h3><p>Tensor 创建的方式比较多，包括从字面量创建，从C++ 原生的数组创建，从vector创建，从Libtorch自带的函数创建等。</p><p>从字面量创建:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch::Tensor foo = torch::<span class="built_in">tensor</span>(&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;);</span><br></pre></td></tr></table></figure><p>从C++ 原生的float数组创建，使用<code>from_blob</code>函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> arr[] = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;;</span><br><span class="line"><span class="comment">// 第二个参数表示创建的Tensor shape，会自动对原生数组进行reshape</span></span><br><span class="line">torch::Tensor bar = torch::<span class="built_in">from_blob</span>(arr, &#123;<span class="number">1</span>, <span class="number">4</span>&#125;); <span class="comment">// shape是[1, 4]</span></span><br><span class="line">bar = torch::<span class="built_in">from_blob</span>(arr, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;); <span class="comment">// shape是[2, 2]</span></span><br></pre></td></tr></table></figure><p>其中第二个参数表示创建的Tensor shape，会自动对原生数组进行reshape。</p><p>从vector 创建，使用<code>from_blob</code>函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">float</span>&gt; v = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;;</span><br><span class="line">bar = torch::<span class="built_in">from_blob</span>(v.<span class="built_in">data</span>(), &#123;<span class="number">2</span>, <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p>还可以用Libtorch的函数创建，跟Numpy和Pytorch类似:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo = torch::<span class="built_in">arange</span>(<span class="number">4</span>);</span><br><span class="line">foo = torch::<span class="built_in">eye</span>(<span class="number">2</span>);</span><br><span class="line">foo = torch::<span class="built_in">ones</span>(<span class="number">2</span>);</span><br><span class="line">bar = torch::<span class="built_in">ones_like</span>(foo);</span><br><span class="line">foo = torch::<span class="built_in">rand</span>(<span class="number">4</span>);</span><br><span class="line">foo = torch::<span class="built_in">randn</span>(<span class="number">4</span>);</span><br><span class="line">foo = torch::<span class="built_in">zeros</span>(<span class="number">2</span>);</span><br><span class="line">bar = torch::<span class="built_in">zeros_like</span>(foo);</span><br></pre></td></tr></table></figure><p>创建好以后，Tensor对应可以直接用<code>std::cout</code>来输出:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch::Tensor foo = torch::<span class="built_in">tensor</span>(&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;);</span><br><span class="line">std::cout &lt;&lt;<span class="string">&quot;==&gt; foo is:\n&quot;</span> &lt;&lt; foo &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==&gt; foo is:</span><br><span class="line"> 1</span><br><span class="line"> 2</span><br><span class="line"> 3</span><br><span class="line"> 4</span><br><span class="line">[ CPUFloatType&#123;4&#125; ]</span><br></pre></td></tr></table></figure><p>可以看到最后打印了Tensor的类型。</p><h3 id="1-2-Tensor对象的属性函数"><a href="#1-2-Tensor对象的属性函数" class="headerlink" title="1.2 Tensor对象的属性函数"></a>1.2 Tensor对象的属性函数</h3><p>创建Tensor后，我们还需要看到它的一些属性，判断是否跟预期相符。注意Libtorch的Tensor是没有公开可访问的属性attribute的，Tensor信息需要属性函数来获取。常见的属性函数包括:</p><ul><li>dim(): Tensor的维度</li><li>sizes(): 跟Pytorch中的shape属性一样</li><li>size(n): 第N个维度的shape</li><li>numel(): 总的元素数目，sizes中的每个元素相乘</li><li>dtype(): 数据类型</li><li>device(): Tensor所在的设备类型，CPU, CUDA, MPS等。</li></ul><p>使用方式如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tensor 属性函数</span></span><br><span class="line">torch::Tensor foo = torch::<span class="built_in">randn</span>(&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>&#125;);</span><br><span class="line"><span class="keyword">auto</span> dim = foo.<span class="built_in">dim</span>(); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">auto</span> sizes = foo.<span class="built_in">sizes</span>(); <span class="comment">// [1, 3, 224, 224]</span></span><br><span class="line"><span class="keyword">auto</span> size_0 = foo.<span class="built_in">size</span>(<span class="number">0</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">auto</span> numel = foo.<span class="built_in">numel</span>(); <span class="comment">// 150528</span></span><br><span class="line"><span class="keyword">auto</span> dtype = foo.<span class="built_in">dtype</span>(); <span class="comment">// float</span></span><br><span class="line"><span class="keyword">auto</span> scalar_type = foo.<span class="built_in">scalar_type</span>(); <span class="comment">// Float</span></span><br><span class="line"><span class="keyword">auto</span> device = foo.<span class="built_in">device</span>(); <span class="comment">// cpu</span></span><br></pre></td></tr></table></figure><h3 id="1-3-Tensor对象的索引"><a href="#1-3-Tensor对象的索引" class="headerlink" title="1.3 Tensor对象的索引"></a>1.3 Tensor对象的索引</h3><p>Tensor 默认是支持<code>[]</code>操作符的，因此可以使用这样的方式来获取元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> foo = torch::<span class="built_in">randn</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line"><span class="keyword">float</span> value = foo[<span class="number">0</span>][<span class="number">1</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>另一种方式是用Tensor对象的<code>index</code>函数，它的优势是支持slice。<br>对于单个元素，可以类似Pytorch中，直接用<code>index(&#123;i, j, k&#125;)</code>的方式来索引：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> foo = torch::<span class="built_in">randn</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line"><span class="keyword">float</span> value = foo.<span class="built_in">index</span>(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p>那么python中很常用的slice呢？例如<code>foo[..., :2, 1:, :-1]</code>，该怎么在Libtorch中表示？<br>这里需要用到<code>torch::indexing::Slice</code> 对象，来实现Python中的Slice，看看下面的例子你就明白了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> torch::indexing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> foo = torch::<span class="built_in">randn</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line"><span class="comment">// 等效于Python中的foo[:, 0:1, 2:, :-1]</span></span><br><span class="line"><span class="keyword">auto</span> bar = foo.<span class="built_in">index</span>(&#123;<span class="built_in">Slice</span>(), <span class="built_in">Slice</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="built_in">Slice</span>(<span class="number">2</span>, None), <span class="built_in">Slice</span>(None, <span class="number">-1</span>)&#125;);</span><br></pre></td></tr></table></figure><p>应该是能满足Python中slice同样的使用场景。</p><h3 id="1-4-更新Tensor中元素的值"><a href="#1-4-更新Tensor中元素的值" class="headerlink" title="1.4 更新Tensor中元素的值"></a>1.4 更新Tensor中元素的值</h3><p>有了索引之后，我们就可以更新Tensor的值了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">torch::Tensor foo = torch::<span class="built_in">tensor</span>(&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;);</span><br><span class="line">foo[<span class="number">0</span>] = <span class="number">10.0</span>;</span><br><span class="line">foo.<span class="built_in">index</span>(&#123;<span class="number">0</span>&#125;) = <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure><p>但还没找到用给部分Tensor元素赋值的方法，类似Python中的<code>foo[:2] = bar</code>，欢迎补充。</p><h3 id="1-5-获取Tensor中的数据"><a href="#1-5-获取Tensor中的数据" class="headerlink" title="1.5 获取Tensor中的数据"></a>1.5 获取Tensor中的数据</h3><p>Tensor是一个Libtorch的对象，那怎么把它中的数据拿出来保存到文件中或传给别的函数呢？<br>使用<code>data_ptr</code>函数就可以:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch::Tensor foo = torch::<span class="built_in">randn</span>(&#123;<span class="number">3</span>, <span class="number">3</span>&#125;);</span><br><span class="line"><span class="keyword">float</span>* data = foo.data_ptr&lt;<span class="keyword">float</span>&gt;();</span><br></pre></td></tr></table></figure><p>对于单个元素的Tensor，还可以用<code>item</code>函数得到具体的数值:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch::Tensor one_element_tensor = foo.<span class="built_in">index</span>(&#123;<span class="built_in">Slice</span>(), <span class="built_in">Slice</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="built_in">Slice</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="built_in">Slice</span>(<span class="number">0</span>, <span class="number">1</span>)&#125;);</span><br><span class="line"><span class="keyword">float</span> value = one_element_tensor.item&lt;<span class="keyword">float</span>&gt;();</span><br></pre></td></tr></table></figure><h3 id="1-6-数据类型"><a href="#1-6-数据类型" class="headerlink" title="1.6 数据类型"></a>1.6 数据类型</h3><p>Libtorch中支持float16, float32, float64, int8, int16, int32, uint8这几类的Tensor数据类型，可以用<code>to</code>函数来进行类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据类型, 参见 https://pytorch.org/cppdocs/api/file_torch_csrc_api_include_torch_types.h.html#variables</span></span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kF16);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kF32);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kF64);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kFloat16);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kFloat32);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kFloat64);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kI8);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kI16);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kI32);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kI64);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kInt8);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kInt16);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kInt32);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kInt64);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kU8);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kUInt8);</span><br></pre></td></tr></table></figure><p>全部数据类型，参见官方文档的<a href="https://pytorch.org/cppdocs/api/file_torch_csrc_api_include_torch_types.h.html#variables">数据类型页面</a>。</p><h3 id="1-7-设备类型"><a href="#1-7-设备类型" class="headerlink" title="1.7 设备类型"></a>1.7 设备类型</h3><p>设备类型是Tensor保存的设备的种类。由于Libtorch不仅仅支持CPU，还支持各种类型的GPU，因此有很多设备类型。</p><p>所有的设备类型参见<a href="https://pytorch.org/cppdocs/api/file_c10_core_DeviceType.h.html#variables">这里</a>。<br>需要注意的是，设备是跟编译时的配置，机器是否支持强相关的，而且某些设备支持并不好，例如我想用下面的代码将CPU上的Tensor转移到MPS上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> foo = torch::<span class="built_in">randn</span>(&#123;<span class="number">3</span>, <span class="number">3</span>&#125;);</span><br><span class="line"><span class="keyword">auto</span> bar = foo.<span class="built_in">to</span>(torch::kMPS);</span><br></pre></td></tr></table></figure><p>编译是没有问题的，但运行时会报下面的错:</p><blockquote><p>libc++abi: terminating with uncaught exception of type c10::TypeError: Cannot convert a MPS Tensor to float64 dtype as the MPS framework doesn’t support float64. Please use float32 instead.</p></blockquote><p>提示说MPS不支持float64，但我打印<code>foo</code>的类型，它其实是float32，本身报错比较奇怪，搜了一圈也没找到怎么解决。</p><h3 id="1-8-Tensor-变形函数"><a href="#1-8-Tensor-变形函数" class="headerlink" title="1.8 Tensor 变形函数"></a>1.8 Tensor 变形函数</h3><p>很多时候我们需要将Tensor进行形状的修改，这方面Libtorch支持的比较好，这些操作都支持:</p><ul><li>reshape</li><li>flatten</li><li>squeeze</li><li>unsqueeze</li><li>transpose</li><li>cat/concat/concatenate</li></ul><p>而且支持<code>torch::reshape</code>这种静态函数和<code>tensor.reshape</code>这种对象函数。下面是一些例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变形操作</span></span><br><span class="line">bar = foo.<span class="built_in">reshape</span>(&#123;<span class="number">2</span>, <span class="number">-1</span>&#125;);</span><br><span class="line">bar = foo.<span class="built_in">flatten</span>();</span><br><span class="line">bar = foo.<span class="built_in">squeeze</span>();</span><br><span class="line">bar = foo.<span class="built_in">unsqueeze</span>(<span class="number">0</span>);</span><br><span class="line">bar = torch::<span class="built_in">unsqueeze</span>(foo, <span class="number">-1</span>);</span><br><span class="line">bar = foo.<span class="built_in">transpose</span>(<span class="number">0</span>, <span class="number">1</span>).<span class="built_in">transpose</span>(<span class="number">2</span>, <span class="number">3</span>).<span class="built_in">transpose</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">bar = torch::<span class="built_in">transpose</span>(foo, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">bar = torch::<span class="built_in">cat</span>(&#123;foo, foo&#125;, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>一个比较特殊的地方是transpose只支持两个轴的交换，多个轴的交换需要调用多次来实现。</p><h3 id="1-9-Tensor之间的操作函数"><a href="#1-9-Tensor之间的操作函数" class="headerlink" title="1.9 Tensor之间的操作函数"></a>1.9 Tensor之间的操作函数</h3><p>Tensor库中，Tensor和Tensor之间的操作是很常见的，比如求矩阵相乘，内积外积等，有内置的函数支持能避免很多额外的开发工作。这里是一些例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo = torch::<span class="built_in">randn</span>(&#123;<span class="number">3</span>, <span class="number">3</span>&#125;);</span><br><span class="line">bar = torch::<span class="built_in">matmul</span>(foo, foo);</span><br><span class="line">bar = foo.<span class="built_in">matmul</span>(foo);</span><br><span class="line">bar = torch::<span class="built_in">cross</span>(foo, foo);</span><br><span class="line">bar = torch::<span class="built_in">mul</span>(foo, foo);</span><br></pre></td></tr></table></figure><h3 id="1-10-线性代数相关函数"><a href="#1-10-线性代数相关函数" class="headerlink" title="1.10 线性代数相关函数"></a>1.10 线性代数相关函数</h3><p><code>torch::linalg</code> namespace中包含常见的线性代数操作，几个简单的使用例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bar = torch::linalg::<span class="built_in">inv</span>(foo);</span><br><span class="line">bar = torch::linalg::<span class="built_in">norm</span>(foo, <span class="number">2</span>, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, <span class="literal">false</span>, torch::nullopt);</span><br></pre></td></tr></table></figure><p>所有支持的函数详见<a href="https://pytorch.org/cppdocs/api/file_torch_csrc_api_include_torch_linalg.h.html#file-torch-csrc-api-include-torch-linalg-h">官方文档</a></p><h3 id="1-11-神经网络相关函数"><a href="#1-11-神经网络相关函数" class="headerlink" title="1.11 神经网络相关函数"></a>1.11 神经网络相关函数</h3><p>神经网络是torch的核心模块，常见的一些激活函数，卷积层都可以以函数的形式作用在Tensor上，这里写几个简单的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bar = torch::<span class="built_in">softmax</span>(foo, <span class="number">-1</span>);</span><br><span class="line">bar = torch::<span class="built_in">sigmoid</span>(foo);</span><br><span class="line">bar = torch::<span class="built_in">relu</span>(foo);</span><br><span class="line">bar = torch::<span class="built_in">gelu</span>(foo);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;系列教程列表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://vra.github.io/2023/02/25/libtorch-tutorial1/&quot;&gt;Libtorch系列教程1：一个丝滑的C++ Tensor库&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://vra.github.io/2023/02/25/libtorch-tutorial2/&quot;&gt;Libtorch系列教程2：torch::Tensor的使用&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章中，我们暂时忽略网络训练和推理，详细展开Libtorch中Tensor对象的使用，看看将Libtorch当作一个纯粹的Tensor库来使用时，有哪些注意事项。如有未涉及的内容，请访问Libtorch&lt;a href=&quot;https://pytorch.org/cppdocs/&quot;&gt;官方文档&lt;/a&gt;，通过搜索框获取更多的信息。Libtorch的环境搭建参考&lt;a href=&quot;https://vra.github.io/2023/02/25/libtorch-tutorial1/&quot;&gt;上一篇文章&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="C++" scheme="http://vra.github.io/tags/C/"/>
    
    <category term="Pytorch" scheme="http://vra.github.io/tags/Pytorch/"/>
    
    <category term="Libtorch" scheme="http://vra.github.io/tags/Libtorch/"/>
    
  </entry>
  
  <entry>
    <title>Libtorch系列教程1：一个丝滑的C++ Tensor库</title>
    <link href="http://vra.github.io/2023/02/25/libtorch-tutorial1/"/>
    <id>http://vra.github.io/2023/02/25/libtorch-tutorial1/</id>
    <published>2023-02-24T19:03:51.000Z</published>
    <updated>2023-02-27T00:32:59.543Z</updated>
    
    <content type="html"><![CDATA[<p>系列教程列表：</p><ul><li><a href="https://vra.github.io/2023/02/25/libtorch-tutorial1/">Libtorch系列教程1：一个丝滑的C++ Tensor库</a> </li><li><a href="https://vra.github.io/2023/02/25/libtorch-tutorial2/">Libtorch系列教程2：torch::Tensor的使用</a> </li></ul><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><a href="https://pytorch.org/cppdocs/installing.html">Libtorch</a>是Pytorch的C++接口，实现了在C++中进行网络训练、网络推理的功能。</p><p>除此之外，由于Libtorch中的大部份接口都是与Pytorch一致的，所以Libtorch还是一个很强大的张量库，有着类似Pytorch的清晰接口，这在C++中很难得的。如果你用过C++ Tensor库，就会发现写法比较复杂，学习成本。因为强类型的限制和通用容器类型的缺失，C++相比Python天然更复杂，库设计者因为语言使用习惯，以及为了性能等因素，设计的接口一般都是高效但难用的。而Libtorch采用了与Pytorch类似的函数接口，如果你使用过Pytorch的话，使用Libtorch学习成本很低，后面会看到具体的例子。</p><p>另一个问题是，很多Python库中基础的操作，例如<code>numpy.einsum</code>函数，在C++中没有合适的替代，看看<a href="https://stackoverflow.com/questions/65347170/numpy-einsum-equivalent-for-xtensor-c">这些</a>搜索你就知道了。Libtorch解决了这个问题，Pytorch中有的它都有，所以在C++中可以简单地用<code>torch::einsum</code>来使用einsum函数，简直是C++开发者的福音。</p><p>此外Libtorch 是支持GPU的，主要用于模型的推理过程，但我猜测使用GPU的话，Libtorch的Tensor操作在速度上相比别的C++ Tensor 库可能有优势，具体速度需要测试对比。当然使用C++代码的话速度不是瓶颈，本身CPU代码就够快了。</p><p>Libtorch另一个优势是编译简单，只要你安装了Pytorch，Libtorch就可以直接使用，省去了复杂的安装和配置，一分钟内就能跑起来一个简单的的示例程序。</p><p>总结来说，Libtorch有以下很吸引人的特性：</p><ul><li>强大如Numpy和Pytorch的C++ Tensor库，写法优雅丝滑，并且是支持GPU的。</li><li>可以训练神经网络</li><li>可以推理神经网络模型，用在C++环境的模型部署场景</li><li>编译简单</li></ul><p>由于Pytorch开发团队是以Python优先的思路来进行Pytorch的开发的，因此我感觉Libtorch的重视程度不是很高，文档和教程也比较少，官网的示例也几乎没有，因此写一个比较完善的教程是比较有意义的。</p><p>这个系列文章中，我会对Libtorch 的Tensor库和推理神经网络过程进行介绍，因为这些内容在实际对于用Libtorch来进行网络训练的部分进行跳过，因为这部分使用的场景不是很多（用Python训练网络比C++香多了)。</p><p>本篇以Mac下的操作为例，对Libtorch的安装和简单使用进行介绍，后续内容近期会更新，敬请关注。</p><span id="more"></span><h2 id="2-Libtorch-安装"><a href="#2-Libtorch-安装" class="headerlink" title="2. Libtorch 安装"></a>2. Libtorch 安装</h2><p>如果你已经安装过Pytorch，那么就不用额外安装Libtorch了，因为Pytorch自带了Libtorch的CMake config 文件，使用<code>torch.utils.cmake_prefix_path</code>语句就能打印出来，可以直接被CMake使用，编译时添加如下的选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-DCMAKE_PREFIX_PATH=`python -c <span class="string">&#x27;import torch;print(torch.utils.cmake_prefix_path)&#x27;</span></span><br></pre></td></tr></table></figure><p>如果没有安装过Pytorch，那直接去<a href="https://pytorch.org/">Pytorch官网</a>下载Libtorch 压缩包，解压到本地目录即可，后面使用CMake来指向这里的路径就行。假如解压到<code>LIBTORCH_ROOT</code>目录，编译时添加下面的选项:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-DCMAKE_PREFIX_PATH=&lt;LIBTORCH_ROOT&gt;</span><br></pre></td></tr></table></figure><h2 id="3-使用CMake-编译一个简单例子"><a href="#3-使用CMake-编译一个简单例子" class="headerlink" title="3. 使用CMake 编译一个简单例子"></a>3. 使用CMake 编译一个简单例子</h2><p>这里写一个简单的Libtorch例子，创建一个5x5的矩阵，然后调用<code>einsum</code>函数来计算矩阵的迹（对角线元素的和）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入Torch头文件，Tensor类在此头文件中，别的类会在另外的头文件中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;torch/torch.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用arange构造一个一维向量，再用reshape变换到5x5的矩阵</span></span><br><span class="line">  torch::Tensor foo = torch::<span class="built_in">arange</span>(<span class="number">25</span>).<span class="built_in">reshape</span>(&#123;<span class="number">5</span>, <span class="number">5</span>&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算矩阵的迹</span></span><br><span class="line">  torch::Tensor bar  = torch::<span class="built_in">einsum</span>(<span class="string">&quot;ii&quot;</span>, foo);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出矩阵和对应的迹</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;==&gt; matrix is:\n &quot;</span> &lt;&lt; foo &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;==&gt; trace of it is:\n &quot;</span> &lt;&lt; bar &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意reshape中需要用花括号，因为C++没有tuple类型，Python中的<code>(5,5)</code>需要在C++中改写为<code>&#123;5, 5&#125;</code>。除此之外，是不是跟Python代码很相似？</p><p>记得保存上面的代码为<code>libtorch_trace.cpp</code>，因为CMake配置中需要写文件名。</p><p>然后在同级目录编写<code>CMakeLists.txt</code>文件:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(libtorch_trace)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要找到Libtorch</span></span><br><span class="line"><span class="keyword">find_package</span>(Torch REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; $&#123;TORCH_CXX_FLAGS&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> libtorch_trace.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="string">&quot;$&#123;TORCH_LIBRARIES&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Libtorch是基于C++14来实现的</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span> PROPERTY CXX_STANDARD <span class="number">14</span>)</span><br></pre></td></tr></table></figure><p>然后执行下面的命令来编译:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"><span class="comment"># 如果是通过Pytorch</span></span><br><span class="line">cmake -DCMAKE_PREFIX_PATH=`python -c <span class="string">&#x27;import torch;print(torch.utils.cmake_prefix_path)&#x27;</span>` ..</span><br><span class="line"><span class="comment">#下载的单独Libtorch</span></span><br><span class="line"><span class="comment"># cmake -DCMAKE_PREFIX_PATH=&lt;LIBTORCH_ROOT&gt; ..</span></span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure><p>编译完成后使用下面的命令来执行可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./libtorch_trace</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">==&gt; matrix is:</span><br><span class="line">   0   1   2   3   4</span><br><span class="line">  5   6   7   8   9</span><br><span class="line"> 10  11  12  13  14</span><br><span class="line"> 15  16  17  18  19</span><br><span class="line"> 20  21  22  23  24</span><br><span class="line">[ CPULongType&#123;5,5&#125; ]</span><br><span class="line">==&gt; trace of it is:</span><br><span class="line"> 60</span><br><span class="line">[ CPULongType&#123;&#125; ]</span><br></pre></td></tr></table></figure><p>那么我们的第一个例子就完成了。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul><li><a href="https://pytorch.org/cppdocs/installing.html">https://pytorch.org/cppdocs/installing.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;系列教程列表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://vra.github.io/2023/02/25/libtorch-tutorial1/&quot;&gt;Libtorch系列教程1：一个丝滑的C++ Tensor库&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://vra.github.io/2023/02/25/libtorch-tutorial2/&quot;&gt;Libtorch系列教程2：torch::Tensor的使用&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://pytorch.org/cppdocs/installing.html&quot;&gt;Libtorch&lt;/a&gt;是Pytorch的C++接口，实现了在C++中进行网络训练、网络推理的功能。&lt;/p&gt;
&lt;p&gt;除此之外，由于Libtorch中的大部份接口都是与Pytorch一致的，所以Libtorch还是一个很强大的张量库，有着类似Pytorch的清晰接口，这在C++中很难得的。如果你用过C++ Tensor库，就会发现写法比较复杂，学习成本。因为强类型的限制和通用容器类型的缺失，C++相比Python天然更复杂，库设计者因为语言使用习惯，以及为了性能等因素，设计的接口一般都是高效但难用的。而Libtorch采用了与Pytorch类似的函数接口，如果你使用过Pytorch的话，使用Libtorch学习成本很低，后面会看到具体的例子。&lt;/p&gt;
&lt;p&gt;另一个问题是，很多Python库中基础的操作，例如&lt;code&gt;numpy.einsum&lt;/code&gt;函数，在C++中没有合适的替代，看看&lt;a href=&quot;https://stackoverflow.com/questions/65347170/numpy-einsum-equivalent-for-xtensor-c&quot;&gt;这些&lt;/a&gt;搜索你就知道了。Libtorch解决了这个问题，Pytorch中有的它都有，所以在C++中可以简单地用&lt;code&gt;torch::einsum&lt;/code&gt;来使用einsum函数，简直是C++开发者的福音。&lt;/p&gt;
&lt;p&gt;此外Libtorch 是支持GPU的，主要用于模型的推理过程，但我猜测使用GPU的话，Libtorch的Tensor操作在速度上相比别的C++ Tensor 库可能有优势，具体速度需要测试对比。当然使用C++代码的话速度不是瓶颈，本身CPU代码就够快了。&lt;/p&gt;
&lt;p&gt;Libtorch另一个优势是编译简单，只要你安装了Pytorch，Libtorch就可以直接使用，省去了复杂的安装和配置，一分钟内就能跑起来一个简单的的示例程序。&lt;/p&gt;
&lt;p&gt;总结来说，Libtorch有以下很吸引人的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强大如Numpy和Pytorch的C++ Tensor库，写法优雅丝滑，并且是支持GPU的。&lt;/li&gt;
&lt;li&gt;可以训练神经网络&lt;/li&gt;
&lt;li&gt;可以推理神经网络模型，用在C++环境的模型部署场景&lt;/li&gt;
&lt;li&gt;编译简单&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于Pytorch开发团队是以Python优先的思路来进行Pytorch的开发的，因此我感觉Libtorch的重视程度不是很高，文档和教程也比较少，官网的示例也几乎没有，因此写一个比较完善的教程是比较有意义的。&lt;/p&gt;
&lt;p&gt;这个系列文章中，我会对Libtorch 的Tensor库和推理神经网络过程进行介绍，因为这些内容在实际对于用Libtorch来进行网络训练的部分进行跳过，因为这部分使用的场景不是很多（用Python训练网络比C++香多了)。&lt;/p&gt;
&lt;p&gt;本篇以Mac下的操作为例，对Libtorch的安装和简单使用进行介绍，后续内容近期会更新，敬请关注。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="C++" scheme="http://vra.github.io/tags/C/"/>
    
    <category term="Pytorch" scheme="http://vra.github.io/tags/Pytorch/"/>
    
    <category term="Libtorch" scheme="http://vra.github.io/tags/Libtorch/"/>
    
  </entry>
  
  <entry>
    <title>nanoGPT + 鲁迅</title>
    <link href="http://vra.github.io/2023/02/12/nanogpt-and-luxun/"/>
    <id>http://vra.github.io/2023/02/12/nanogpt-and-luxun/</id>
    <published>2023-02-12T15:24:02.000Z</published>
    <updated>2023-02-12T16:33:42.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-起因"><a href="#1-起因" class="headerlink" title="1. 起因"></a>1. 起因</h2><p>今晚看到了Simon Willison 的只使用自己的博客内容来训练nanoGPT的<a href="https://til.simonwillison.net/llms/training-nanogpt-on-my-blog">实验</a>，觉得挺有意思，突发奇想，能不能在鲁迅的文集上训练一个nanoGPT，然后生成很具辨识度的鲁迅风格的文字呢？由于nanoGPT结构简单，鲁迅的文集在GitHub上可以下载到，因此通过简单的代码修改加实验，就得到一个在鲁迅作品上训练的GPT2模型(无别的语料库的预训练），简单测试下，以“故乡”开头，让模型生成鲁迅风格的文字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">故乡，债是佩服的。</span><br><span class="line"> 我一向对于新青年的态度，先来说话，谢容易做的，然而伏园已经见过几样，感觉的是另外捧之数，以为先前的例子。今但近来做了做事，自己也还不做，不能先行通，所以生在冷静和“人生”，三妇一苦闷，觉得大约是如此隔膜</span><br><span class="line">和曹操，于是非意模茶炛，可以说是太高了，所以现在便能教育，竟�如此。</span><br><span class="line"> 但汝实在有给法历代的，不久就在绝末年间，我想显出向大家饮一趟，而汉子大毒是怀旧的，就要贫足有打劫，可以永掠的。这种事情，中国有一个大官左翼阿，（陀思妥习），有敢请佛喜，总要适说一点�</span><br></pre></td></tr></table></figure><p>还算有鲁迅文字的风格，但逻辑一窍不通，整体还是难让人满意，不知道是GPT2能力的问题还是我实验设置的问题。 Anyway，这里共享一下我实验的流程，有兴趣的朋友可以参考，进行改进。本文涉及的代码修改代码已经提交到这个<a href="https://github.com/vra/nanoGPT">仓库了</a>，可以参考，文末会附上更多例子。</p><span id="more"></span><h2 id="2-操作流程"><a href="#2-操作流程" class="headerlink" title="2. 操作流程"></a>2. 操作流程</h2><h3 id="2-1-下载nanoGPT源码并安装依赖"><a href="#2-1-下载nanoGPT源码并安装依赖" class="headerlink" title="2.1 下载nanoGPT源码并安装依赖"></a>2.1 下载nanoGPT源码并安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/karpathy/nanoGPT</span><br><span class="line"><span class="built_in">cd</span> nanoGPT</span><br><span class="line">conda create --name nanogpt  python=3.9</span><br><span class="line">conda activate nanogpt</span><br><span class="line">pip install transformers datasets tiktoken tqdm wandb numpy httpx torch torchvision</span><br></pre></td></tr></table></figure><h3 id="2-2-数据预处理"><a href="#2-2-数据预处理" class="headerlink" title="2.2 数据预处理"></a>2.2 数据预处理</h3><p>进入代码目录后，重建文件夹<code>data/lunxun</code>，用于存放数据。</p><p>从<a href="https://github.com/gzx1996/luxun/blob/master/book/book.txt">这里</a>下载鲁迅全集，放到<code>data/luxun</code>目录下，然后进行下面的处理：</p><ul><li>去掉所有编者加的注释(由于注释都是以<code>[n]</code>这种形式开头的，因此在VIM中可以用<code>0,$s/^\[.\+//g</code>命令来去掉)</li><li>由于我们想要的是鲁迅白话文的风格，因此手动去掉所有文言文的作品和翻译作品(文言文在最开头的《坟》集子里，翻译作品在最后)</li><li>去掉单行的日期文字（如<code>(一九一八年二月二日)</code>，可以在VIM中用<code>g/^(一九.\+/d</code>去掉)</li></ul><p>我处理后的文本地址在<a href="https://github.com/vra/nanoGPT/tree/master/data/luxun/book.txt">这里</a>。</p><p>然后编写代码<code>prepare.py</code>, 读取文本，构造训练集和验证集，数据比例9:1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> tiktoken</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">input_file_path = os.path.join(os.path.dirname(__file__), <span class="string">&quot;book.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">entries = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(input_file_path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="keyword">if</span> line.strip() <span class="keyword">and</span> <span class="built_in">len</span>(line) &gt; <span class="number">2</span>:</span><br><span class="line">            entries.append(line)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;len of lines: <span class="subst">&#123;<span class="built_in">len</span>(entries)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># Shuffle entries</span></span><br><span class="line">random.shuffle(entries)</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">len</span>(entries)</span><br><span class="line">train_entries = entries[: <span class="built_in">int</span>(n * <span class="number">0.9</span>)]</span><br><span class="line">val_entries = entries[<span class="built_in">int</span>(n * <span class="number">0.9</span>):]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Turn those into strings</span></span><br><span class="line">train_data = <span class="string">&quot; &quot;</span>.join(<span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(entry) <span class="keyword">for</span> entry <span class="keyword">in</span> train_entries)</span><br><span class="line">val_data = <span class="string">&quot; &quot;</span>.join(<span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(entry) <span class="keyword">for</span> entry <span class="keyword">in</span> val_entries)</span><br><span class="line"></span><br><span class="line"><span class="comment"># encode with tiktoken gpt2 bpe</span></span><br><span class="line">enc = tiktoken.get_encoding(<span class="string">&quot;gpt2&quot;</span>)</span><br><span class="line">train_ids = enc.encode_ordinary(train_data)</span><br><span class="line">val_ids = enc.encode_ordinary(val_data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;train has <span class="subst">&#123;<span class="built_in">len</span>(train_ids):,&#125;</span> tokens&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;val has <span class="subst">&#123;<span class="built_in">len</span>(val_ids):,&#125;</span> tokens&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># export to bin files</span></span><br><span class="line">train_ids = np.array(train_ids, dtype=np.uint16)</span><br><span class="line">val_ids = np.array(val_ids, dtype=np.uint16)</span><br><span class="line">train_ids.tofile(os.path.join(os.path.dirname(__file__), <span class="string">&quot;train.bin&quot;</span>))</span><br><span class="line">val_ids.tofile(os.path.join(os.path.dirname(__file__), <span class="string">&quot;val.bin&quot;</span>))</span><br></pre></td></tr></table></figure><p>处理好的训练验证集在<a href="https://github.com/vra/nanoGPT/tree/master/data/luxun">这里</a>，可以直接使用。</p><h3 id="2-3-训练网络"><a href="#2-3-训练网络" class="headerlink" title="2.3 训练网络"></a>2.3 训练网络</h3><p>数据集构建完成后，就可以训练模型了。在代码库根目录，执行下面的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python train.py \</span><br><span class="line">  --dataset=luxun \</span><br><span class="line">--compile=False \</span><br><span class="line">--batch_size=8 \</span><br><span class="line">--dtype=float16</span><br></pre></td></tr></table></figure><p>具体训练参数可以查看<code>train.py</code>，包括训练的层数、batch size，训练后端等等。</p><p>训练的模型默认保存在<code>out/ckpt.pt</code>。</p><p>训练22000次迭代的时候我停止了实验，loss是0.15左右。</p><h3 id="2-4-测试模型"><a href="#2-4-测试模型" class="headerlink" title="2.4 测试模型"></a>2.4 测试模型</h3><p>测试代码在<code>sample.py</code>，默认提示词为空(<code>start=&#39;\n&#39;</code>)可以通过添加<code>--start=&quot;xxx&quot;</code>来修改提示词:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sample.py --start=<span class="string">&quot;故乡&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3-更多例子"><a href="#3-更多例子" class="headerlink" title="3. 更多例子"></a>3. 更多例子</h2><h3 id="3-1-人工智能"><a href="#3-1-人工智能" class="headerlink" title="3.1 人工智能"></a>3.1 人工智能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">人工智能力。两社丈一多，西辛，是发昏了的结果，但去的四五十岁，死的陈源教授却很不通，我也就不再有了。忍不知道阿Ｑ的名字是怎么写的？这不过是一个问境。他总还拿着四个年的过头放在心里，说道，“哀，遇的。他可</span><br><span class="line">是弯口，道是阿Ｑ；近来已经做了杜师长了，半年的大武人，你还和他对面具汗说：‘非常救命！’‘是情愧 夫子’的学理论矛盾的工人，……而且跳不过是这三秒……。”</span><br><span class="line"> 而已 偶战线告了一个大问题，拿去做的纠纷，而他们就癖在《试玈书》的第一幅，来因为又是删节的，还和所放的做。不过如果加以细见，不想多写了东�</span><br></pre></td></tr></table></figure><h3 id="3-2-文艺复兴"><a href="#3-2-文艺复兴" class="headerlink" title="3.2 文艺复兴"></a>3.2 文艺复兴</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">文艺复兴运动，也是指惺把文艺当承受照时代，更易于政治家，中国并不见立刻，万分折中间，更何况失了国家，只有拜读之处，这就是政治心软到新舖式的必读书。……”</span><br><span class="line"> 我们──由此满可知道河南的内心眼和明白的点灵魂。我在曾经想做以看空虚洋，决不叫看情形。因为我想，便可以支持生活的原因，至少，更进一步而到中国来，他们也给了世界上的美�家所指见的最多也并非精微坏，莫非看翻译</span><br><span class="line">，可说是不算太多了。</span><br><span class="line"> 问题。</span><br><span class="line"> “我们没有见过这种东西，便怎么办呢？”</span><br><span class="line"> 递进句也不是有许多话。</span><br><span class="line"> “可以可以，”四铭吃了点</span><br></pre></td></tr></table></figure><h3 id="3-3-新文化"><a href="#3-3-新文化" class="headerlink" title="3.3 新文化"></a>3.3 新文化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">新文化运动，也许因为他们已经有了“力”这句话的责任了。在那里和他们的风化是并不相禁多的。</span><br><span class="line"> 阿呼呜呼兮呜呼阿呼，</span><br><span class="line"> 八九年</span><br><span class="line"> 二、浙江艳七百</span><br><span class="line"> 一九二五年十二月三十日风雨之夜示，此地声声流鼓近山腌至责诼谢。</span><br><span class="line"> 阿Ｑ的讲到文学说，他们会打断了阿Ｑ的名目退向王的头发，向公司被挤出去了。</span><br><span class="line"> 最末的批评，是“没有话派的书，对于政府来往往解释，加以泄除，以政治的运命，至于失败，那倒是往往会说，我非常危险。</span><br><span class="line"> 小娘枟不用小说的经济字的由校的文章，使是屠戮政府，是凡这些的，但我知道画家一致攻，一致的经历</span><br></pre></td></tr></table></figure><p>如果本文操作中有误的地方，还请专业人士多指出讨论。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-起因&quot;&gt;&lt;a href=&quot;#1-起因&quot; class=&quot;headerlink&quot; title=&quot;1. 起因&quot;&gt;&lt;/a&gt;1. 起因&lt;/h2&gt;&lt;p&gt;今晚看到了Simon Willison 的只使用自己的博客内容来训练nanoGPT的&lt;a href=&quot;https://til.simonwillison.net/llms/training-nanogpt-on-my-blog&quot;&gt;实验&lt;/a&gt;，觉得挺有意思，突发奇想，能不能在鲁迅的文集上训练一个nanoGPT，然后生成很具辨识度的鲁迅风格的文字呢？由于nanoGPT结构简单，鲁迅的文集在GitHub上可以下载到，因此通过简单的代码修改加实验，就得到一个在鲁迅作品上训练的GPT2模型(无别的语料库的预训练），简单测试下，以“故乡”开头，让模型生成鲁迅风格的文字：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;故乡，债是佩服的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 我一向对于新青年的态度，先来说话，谢容易做的，然而伏园已经见过几样，感觉的是另外捧之数，以为先前的例子。今但近来做了做事，自己也还不做，不能先行通，所以生在冷静和“人生”，三妇一苦闷，觉得大约是如此隔膜&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;和曹操，于是非意模茶炛，可以说是太高了，所以现在便能教育，竟�如此。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 但汝实在有给法历代的，不久就在绝末年间，我想显出向大家饮一趟，而汉子大毒是怀旧的，就要贫足有打劫，可以永掠的。这种事情，中国有一个大官左翼阿，（陀思妥习），有敢请佛喜，总要适说一点�&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;还算有鲁迅文字的风格，但逻辑一窍不通，整体还是难让人满意，不知道是GPT2能力的问题还是我实验设置的问题。 Anyway，这里共享一下我实验的流程，有兴趣的朋友可以参考，进行改进。本文涉及的代码修改代码已经提交到这个&lt;a href=&quot;https://github.com/vra/nanoGPT&quot;&gt;仓库了&lt;/a&gt;，可以参考，文末会附上更多例子。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="AI" scheme="http://vra.github.io/tags/AI/"/>
    
    <category term="GPT" scheme="http://vra.github.io/tags/GPT/"/>
    
    <category term="Pytorch" scheme="http://vra.github.io/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>关于 np.float 被删除的问题</title>
    <link href="http://vra.github.io/2023/02/05/numpy-remove-np-float/"/>
    <id>http://vra.github.io/2023/02/05/numpy-remove-np-float/</id>
    <published>2023-02-05T03:34:04.000Z</published>
    <updated>2023-02-13T08:37:25.163Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>在Numpy 1.24版本中，<a href="https://numpy.org/doc/stable/release/1.24.0-notes.html#expired-deprecations">删除</a>了像<code>np.float</code>、<code>np.int</code> 这样的 Python 内置类型的 alias，因此以后在代码中使用这些类型会报错<code>AttributeError: module &#39;numpy&#39; has no attribute &#39;float&#39;</code>, 涉及的类型包括：</p><ul><li><code>numpy.bool</code></li><li><code>numpy.int</code></li><li><code>numpy.float</code></li><li><code>numpy.complex</code></li><li><code>numpy.object</code></li><li><code>numpy.str</code></li><li><code>numpy.long</code></li><li><code>numpy.unicode</code></li></ul><p>那该怎么解决这个错误呢？</p><p>TL;DR</p><ul><li>对于在标量上的操作，直接使用Python内置类型替换<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo = np.random.rand(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 原先用法，注意foo[0]是一个标量</span></span><br><span class="line">bar = np.<span class="built_in">float</span>(foo[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 新用法</span></span><br><span class="line">bar = <span class="built_in">float</span>(foo[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></li><li>对于在<code>np.ndarray</code> 上的操作，使用<code>np.float64</code> 或<code>np.float32</code> 来替代，具体选择哪个需要自己根据情况来确定，不同类型精度会有不同，下面举两个例子:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原先用法</span></span><br><span class="line">foo = np.random.rand(<span class="number">10</span>, dtype=np.<span class="built_in">float</span>)</span><br><span class="line"><span class="comment"># 新用法</span></span><br><span class="line">foo = np.random.rand(<span class="number">10</span>, dtype=np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原先用法</span></span><br><span class="line">foo = np.random.rand(<span class="number">10</span>).astype(np.<span class="built_in">float</span>)</span><br><span class="line"><span class="comment"># 新用法</span></span><br><span class="line">foo = np.random.rand(<span class="number">10</span>).astype(np.float32)</span><br></pre></td></tr></table></figure></li></ul><p>这里列出来了删除类型在标量和<code>np.ndarray</code> 上的替代，方便查找</p><table><thead><tr><th>原先类型</th><th>标量替换类型</th><th><code>np.ndarray</code>替换类型</th></tr></thead><tbody><tr><td>np.int</td><td>int</td><td>np.int32/np.int64</td></tr><tr><td>np.float</td><td>float</td><td>np.float32/np.float64</td></tr><tr><td>np.bool</td><td>bool</td><td>np.bool_</td></tr><tr><td>np.complex</td><td>complex</td><td>np.complex128</td></tr><tr><td>np.object</td><td>object</td><td>-</td></tr><tr><td>np.str</td><td>str</td><td>np.str_</td></tr><tr><td>np.long</td><td>int</td><td>np.int32/np.int64</td></tr><tr><td>np.unicode</td><td>str</td><td>np.str_</td></tr></tbody></table><p>详细说明参考<a href="https://numpy.org/doc/stable/release/1.20.0-notes.html#deprecations">NumPy 1.20.0 Release Notes</a>。</p><p>下面详细说说事情的来龙去脉。</p><span id="more"></span><h3 id="2-代码验证"><a href="#2-代码验证" class="headerlink" title="2. 代码验证"></a>2. 代码验证</h3><p>下面我搭建 Numpy 1.20.0 和 1.24.0 的环境进行简单测试，以及分析为什么会弃用这些类型。</p><p>首先是 Numpy 1.20.0 环境搭建与简单测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python -m venv np1.20</span><br><span class="line"><span class="built_in">source</span> np1.20/bin/activate</span><br><span class="line">pip install numpy==1.20</span><br><span class="line">python -c <span class="string">&quot;import numpy as np; a = np.array([1.0], dtype=np.float)&quot;</span></span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;string&gt;:1: DeprecationWarning: `np.float` is a deprecated <span class="built_in">alias</span> <span class="keyword">for</span> the <span class="built_in">builtin</span> `<span class="built_in">float</span>`. To silence this warning, use `<span class="built_in">float</span>` by itself. Doing this will not modify any behavior and is safe. If you specifically wanted the numpy scalar <span class="built_in">type</span>, use `np.float64` here.</span><br><span class="line">Deprecated <span class="keyword">in</span> NumPy 1.20; <span class="keyword">for</span> more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html<span class="comment">#deprecations</span></span><br></pre></td></tr></table></figure><p>仔细看这段输出的话，可以发现从 Numpy 1.20 版本开始，Numpy已经弃用<code>np.float</code> 类型了，并且给出了替换建议，以及详细的说明文档<a href="https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations">地址</a>。</p><p>而在 Numpy 1.24版本里面，正式删除了<code>np.float</code>，可以用下面的代码来测试。<br>首先我们创建一个新的环境，安装Numpy 1.24版本，然后创建一个<code>np.float</code>类型的数组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python -m venv np1.24</span><br><span class="line"><span class="built_in">source</span> np1.24/bin/activate</span><br><span class="line">pip install numpy==1.24</span><br><span class="line">python -c <span class="string">&quot;import numpy as np; a = np.array([1.0], dtype=np.float)&quot;</span></span><br></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;string&gt;&quot;</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;/Users/name/np1.24/lib/python3.9/site-packages/numpy/__init__.py&quot;</span>, line 284, <span class="keyword">in</span> __getattr__</span><br><span class="line">    raise AttributeError(<span class="string">&quot;module &#123;!r&#125; has no attribute &quot;</span></span><br><span class="line">AttributeError: module <span class="string">&#x27;numpy&#x27;</span> has no attribute <span class="string">&#x27;float&#x27;</span></span><br></pre></td></tr></table></figure><p>直接就报了我们开头提到的属性错误。</p><h3 id="3-Why"><a href="#3-Why" class="headerlink" title="3. Why"></a>3. Why</h3><p>其实早在2015年，Numpy 开发者就在<a href="https://github.com/numpy/numpy/pull/6103">策划</a>删除这些类型了，只不过当时使用范围太广，删除造成的影响太大，所以在近8年，1.20-1.24 4个版本的Warning后，才正式删除。<br>为什么要删除这些操作呢？我自己觉得是因为<code>np.float</code> 这种类型太容易误用了。大家都以为<code>np.float</code>是一个Numpy的数据类型，是<code>np.float32</code>的alias，但实际它是内置类型，是<code>int</code>类型的alias。<br>就像下面这个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = np.array([<span class="number">10</span>], dtype=np.int32)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar = np.<span class="built_in">int</span>(foo)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(bar)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">baz</span> = <span class="title">np</span>.<span class="title">int32</span>(<span class="params">foo</span>)</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span>(<span class="params">baz</span>)</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">numpy</span>.<span class="title">ndarray</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，对<code>np.ndarray</code> 数组进行<code>np.int</code> 和<code>np.int32</code>的操作，一个得到<code>int</code>类型的变量，另一个得到的是<code>np.ndarray</code>类型的变量。</p><p>详细的原因可以参考上面的 issue 链接。</p><p>那最早为什么还要引入<code>np.float</code>呢？直接用Python内置的类型不好吗？其实这是在很早的Numpy版本中错误地引入的，那个版本<code>np.float</code>的含义就是<code>np.float64</code> ，只不过后来版本中<code>np.float</code> 的含义修改了，但如果直接删除<code>np.float</code>，有人使用老版本的Numpy，就会在执行<code>from numpy import *</code> 报错。当前那个老版本已经很少有人用了 ，所以就删除了。</p><h3 id="4-带来的影响"><a href="#4-带来的影响" class="headerlink" title="4. 带来的影响"></a>4. 带来的影响</h3><p>这个改动带来的影响可以说是非常大了，简单来说，在 Numpy 1.24.0以上的版本中，使用<code>np.float</code>的代码都会直接报错。而 Numpy 作为 Python 在科学计算中的基础包，被广泛使用的程度无需我赘述。<br>简单在GitHub 搜索了一下，光涉及到<code>np.float</code>的(<a href="https://github.com/search?q=np.float)++lang:Python++&ref=opensearch&type=code">结果1</a>， <a href="https://github.com/search?q=np.float(+lang:Python++&ref=opensearch&type=code">结果2</a>）就有近9万行代码，我自己短期内就在两个仓库中遇到这个问题。好在解决办法也比较直接，希望可以顺利的过渡过去。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;在Numpy 1.24版本中，&lt;a href=&quot;https://numpy.org/doc/stable/release/1.24.0-notes.html#expired-deprecations&quot;&gt;删除&lt;/a&gt;了像&lt;code&gt;np.float&lt;/code&gt;、&lt;code&gt;np.int&lt;/code&gt; 这样的 Python 内置类型的 alias，因此以后在代码中使用这些类型会报错&lt;code&gt;AttributeError: module &amp;#39;numpy&amp;#39; has no attribute &amp;#39;float&amp;#39;&lt;/code&gt;, 涉及的类型包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;numpy.bool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;numpy.int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;numpy.float&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;numpy.complex&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;numpy.object&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;numpy.str&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;numpy.long&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;numpy.unicode&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那该怎么解决这个错误呢？&lt;/p&gt;
&lt;p&gt;TL;DR&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于在标量上的操作，直接使用Python内置类型替换&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;foo = np.random.rand(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 原先用法，注意foo[0]是一个标量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bar = np.&lt;span class=&quot;built_in&quot;&gt;float&lt;/span&gt;(foo[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 新用法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bar = &lt;span class=&quot;built_in&quot;&gt;float&lt;/span&gt;(foo[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;对于在&lt;code&gt;np.ndarray&lt;/code&gt; 上的操作，使用&lt;code&gt;np.float64&lt;/code&gt; 或&lt;code&gt;np.float32&lt;/code&gt; 来替代，具体选择哪个需要自己根据情况来确定，不同类型精度会有不同，下面举两个例子:&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 原先用法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo = np.random.rand(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, dtype=np.&lt;span class=&quot;built_in&quot;&gt;float&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 新用法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo = np.random.rand(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, dtype=np.float32)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 原先用法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo = np.random.rand(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;).astype(np.&lt;span class=&quot;built_in&quot;&gt;float&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 新用法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo = np.random.rand(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;).astype(np.float32)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里列出来了删除类型在标量和&lt;code&gt;np.ndarray&lt;/code&gt; 上的替代，方便查找&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;原先类型&lt;/th&gt;
&lt;th&gt;标量替换类型&lt;/th&gt;
&lt;th&gt;&lt;code&gt;np.ndarray&lt;/code&gt;替换类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;np.int&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;np.int32/np.int64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;np.float&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;np.float32/np.float64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;np.bool&lt;/td&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;np.bool_&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;np.complex&lt;/td&gt;
&lt;td&gt;complex&lt;/td&gt;
&lt;td&gt;np.complex128&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;np.object&lt;/td&gt;
&lt;td&gt;object&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;np.str&lt;/td&gt;
&lt;td&gt;str&lt;/td&gt;
&lt;td&gt;np.str_&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;np.long&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;np.int32/np.int64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;np.unicode&lt;/td&gt;
&lt;td&gt;str&lt;/td&gt;
&lt;td&gt;np.str_&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;详细说明参考&lt;a href=&quot;https://numpy.org/doc/stable/release/1.20.0-notes.html#deprecations&quot;&gt;NumPy 1.20.0 Release Notes&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面详细说说事情的来龙去脉。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="Numpy" scheme="http://vra.github.io/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>手机上看arxiv上论文的方法</title>
    <link href="http://vra.github.io/2023/01/27/arxiv-on-mobile/"/>
    <id>http://vra.github.io/2023/01/27/arxiv-on-mobile/</id>
    <published>2023-01-27T14:44:41.000Z</published>
    <updated>2023-01-27T15:16:22.167Z</updated>
    
    <content type="html"><![CDATA[<p>有时候想要在手机上访问Arxiv上的论文，打开arxiv.com，发现体验比较差，没有响应式设计，需要不断移动页面才能读完一行文字，影响阅读。偶然发现了<a href="https://www.arxiv-vanity.com/">arxiv-vanity</a>这个网站，发现能很好的满足手机上看arxiv论文的需求，收藏了。</p><span id="more"></span><p>首先看下arxiv-vanity网站的介绍:</p><blockquote><p>arXiv Vanity renders academic papers from arXiv as responsive web pages so you don’t have to squint at a PDF.</p></blockquote><p>翻译成中文就是:</p><blockquote><p>arXiv Vanity 将 arXiv 的学术论文呈现为响应式网页，因此您不必眯着眼睛看 PDF。</p></blockquote><p>exactly what I need!</p><p>那么该如何使用呢？</p><p>在<a href="https://www.arxiv-vanity.com/">arxiv-vanity</a>首页的搜索框中输入arxiv论文的摘要页面，如<code>https://arxiv.org/abs/1605.07683</code>，按右边的按钮，就能将论文转换为HTML文件，并且在不同的设备下自适应地调整大小。</p><p>另外也可以通过<code>https://www.arxiv-vanity.com/papers/&lt;paper_id&gt;</code>的方式访问转换后的HTML页面，比如<code>https://www.arxiv-vanity.com/papers/1605.07683/</code>。</p><p>大概原理是使用<a href="https://dlmf.nist.gov/LaTeXML/">LaTeXML</a>将Latex原文件转换为HTML，再进行显示。具体实现参见<a href="https://github.com/arxiv-vanity/engrafo">源码</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有时候想要在手机上访问Arxiv上的论文，打开arxiv.com，发现体验比较差，没有响应式设计，需要不断移动页面才能读完一行文字，影响阅读。偶然发现了&lt;a href=&quot;https://www.arxiv-vanity.com/&quot;&gt;arxiv-vanity&lt;/a&gt;这个网站，发现能很好的满足手机上看arxiv论文的需求，收藏了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Latex" scheme="http://vra.github.io/tags/Latex/"/>
    
    <category term="HTML" scheme="http://vra.github.io/tags/HTML/"/>
    
    <category term="Web" scheme="http://vra.github.io/tags/Web/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux小技巧：使用find命令来删除空文件</title>
    <link href="http://vra.github.io/2023/01/20/linux-delete-empty-files/"/>
    <id>http://vra.github.io/2023/01/20/linux-delete-empty-files/</id>
    <published>2023-01-20T06:36:13.000Z</published>
    <updated>2023-01-20T07:16:39.999Z</updated>
    
    <content type="html"><![CDATA[<p>在某个目录下有很多代码创建的空文件，分布在不同层级的子目录中，我们有没有办法可以快速地全部把它们删掉呢？</p><p><a href="https://man7.org/linux/man-pages/man1/find.1.html">find</a>是Linux系统中的一个强大的命令，通过它我们可以找到空文件，然后将它们进行删除。</p><p>TL;DR<br>最终命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -size 0 -<span class="built_in">print</span> -delete</span><br></pre></td></tr></table></figure><p>几个参数详细的说明见下。</p><span id="more"></span><p><code>-type</code>表示匹配项的文件类型，<code>d</code>表示文件夹，<code>f</code>表示文件，<code>l</code>表示软链接等，完整的类型如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">b: block (buffered) special</span><br><span class="line"></span><br><span class="line">c: character (unbuffered) special</span><br><span class="line"></span><br><span class="line">d: directory</span><br><span class="line"></span><br><span class="line">p: named pipe (FIFO)</span><br><span class="line"></span><br><span class="line">f: regular file</span><br><span class="line"></span><br><span class="line">l: symbolic link; this is never true if the -L option</span><br><span class="line"> : or the -follow option is in effect, unless the</span><br><span class="line"> : symbolic link is broken.  If you want to search for</span><br><span class="line"> : symbolic links when -L is in effect, use -xtype.</span><br><span class="line"></span><br><span class="line">s: socket</span><br></pre></td></tr></table></figure><p>所以下面的命令只会列出当前目录下的所有文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f</span><br></pre></td></tr></table></figure><p><code>-size</code>用来进行文件和目录的大小判断，例如<code>-size 6c</code>表示大小等于6字节，<code>-size -6c</code>表示小于6字节，<code>-size +6c</code>表示大于6字节，大小单位包括：c：字节，w:双字节，k:1024字节，M：1024<em>1024字节，G：1024</em>1024*1024字节，不加单位的话，等于b:512字节:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 寻找当前目录下大小为0的文件或目录</span></span><br><span class="line">find . -size 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找当前目录下小于512字节的文件或目录</span></span><br><span class="line">find . -size -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找当前目录下大于1字节的文件或目录</span></span><br><span class="line">find . -size +1c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找当前目录下大于1M的文件或目录</span></span><br><span class="line">find . -size +1M</span><br></pre></td></tr></table></figure><p>有了这个选项，就能很容易地过滤出当前目录下的空文件了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -size 0</span><br></pre></td></tr></table></figure><p>另一个选项是<code>-delete</code>，它的作用是直接删除找到的文件。</p><p>还有一个选项是<code>-print</code>，即打印匹配的文件路径到标准输出。</p><p>结合这几个选项，我们就能删除当前目录下的所有空文件，并且在删除时打印文件名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -size 0 -<span class="built_in">print</span> -delete</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在某个目录下有很多代码创建的空文件，分布在不同层级的子目录中，我们有没有办法可以快速地全部把它们删掉呢？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://man7.org/linux/man-pages/man1/find.1.html&quot;&gt;find&lt;/a&gt;是Linux系统中的一个强大的命令，通过它我们可以找到空文件，然后将它们进行删除。&lt;/p&gt;
&lt;p&gt;TL;DR&lt;br&gt;最终命令如下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;find . -&lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt; f -size 0 -&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt; -delete&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;几个参数详细的说明见下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="find" scheme="http://vra.github.io/tags/find/"/>
    
  </entry>
  
  <entry>
    <title>python 多个with 语句一起使用</title>
    <link href="http://vra.github.io/2023/01/20/python-with-statement/"/>
    <id>http://vra.github.io/2023/01/20/python-with-statement/</id>
    <published>2023-01-20T05:37:24.000Z</published>
    <updated>2023-01-20T05:58:36.949Z</updated>
    
    <content type="html"><![CDATA[<p>在读《流畅的Python》时，偶然看到下面的语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> urlopen(URL) <span class="keyword">as</span> remote, <span class="built_in">open</span>(JSON, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> local:</span><br><span class="line">    local.write(remote.read())</span><br></pre></td></tr></table></figure><p>突然才发现，原来多个with语句可以写到一起!</p><span id="more"></span><p>我之前都是每个<code>with</code>一个层级，像下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;in_file&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;out_file&#x27;</span> <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> of:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            of.write(line)</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>这样写每个with语句需要缩进一次，阅读起来逻辑不连续，而且很容易超过每行的字符限制，导致需要换行等问题，不是很方便。</p><p>经过这个偶然的发现，以后上面的代码可以这样写了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;in_file&#x27;</span>) <span class="keyword">as</span> f, <span class="built_in">open</span>(<span class="string">&#x27;out_file&#x27;</span> <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> of:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        of.write(line)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>同时看 <code>with</code> 语句的<a href="https://docs.python.org/3/reference/compound_stmts.html#the-with-statement">官方文档</a>，发现从Python 3.10版本起，还可以用括号将多个with语句括起来:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (</span><br><span class="line">    <span class="built_in">open</span>(<span class="string">&quot;face_model_choice.txt&quot;</span>) <span class="keyword">as</span> f,</span><br><span class="line">    <span class="built_in">open</span>(<span class="string">&quot;ttt.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> of1,</span><br><span class="line">    <span class="built_in">open</span>(<span class="string">&quot;ttt2.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> of2,</span><br><span class="line">):</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        of1.write(line)</span><br><span class="line">        of2.write(line)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样看起来也更简洁了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在读《流畅的Python》时，偶然看到下面的语句：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; urlopen(URL) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; remote, &lt;span class=&quot;built_in&quot;&gt;open&lt;/span&gt;(JSON, &lt;span class=&quot;string&quot;&gt;&amp;#x27;wb&amp;#x27;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; local:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local.write(remote.read())&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;突然才发现，原来多个with语句可以写到一起!&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="TIL" scheme="http://vra.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg抽取高清图像帧</title>
    <link href="http://vra.github.io/2023/01/15/ffmpeg-extract-high-quality-images/"/>
    <id>http://vra.github.io/2023/01/15/ffmpeg-extract-high-quality-images/</id>
    <published>2023-01-15T14:27:33.000Z</published>
    <updated>2023-01-20T05:56:08.274Z</updated>
    
    <content type="html"><![CDATA[<p>使用<a href="https://ffmpeg.org/">ffmpeg</a>可以方便地从视频中抽取图像帧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i /path/to/video.mp4 image-folder/%06d.jpg</span><br></pre></td></tr></table></figure><p>但实际测试发现，抽取的图像帧比较模糊，有明显的块效应。</p><p>搜索时有人说可以加<code>-q:v 1 -qmin 1 -qmax 1</code>来提高图像质量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i /path/to/video.mp4 -q:v 1 -qmin 1 -qmax 1 image-folder/%06d.jpg</span><br></pre></td></tr></table></figure><p>测试发现确实有一些提升，但还是能看到明显的模糊。</p><p>最后发现，把抽取的图像格式从<code>.jpg</code>修改为<code>.png</code>，结果就是高清且无块效应的了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i /path/to/video.mp4 image-folder/%06d.png</span><br></pre></td></tr></table></figure><p>另外PNG格式的图像存储大小要大一些，但不会太大，还是能接受的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用&lt;a href=&quot;https://ffmpeg.org/&quot;&gt;ffmpeg&lt;/a&gt;可以方便地从视频中抽取图像帧：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla</summary>
      
    
    
    
    
    <category term="图像" scheme="http://vra.github.io/tags/%E5%9B%BE%E5%83%8F/"/>
    
    <category term="ffmpeg" scheme="http://vra.github.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>原来 git stash 应该这么用</title>
    <link href="http://vra.github.io/2023/01/15/git-stash/"/>
    <id>http://vra.github.io/2023/01/15/git-stash/</id>
    <published>2023-01-15T05:19:57.000Z</published>
    <updated>2023-01-20T06:19:01.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前段时间突然发现，我之前对<code>git stash</code>的使用都是错误的。</p><p>具体说来，我是这么使用的：在远端有新的提交，需要<code>git pull</code>来拉取合并时，发现本地有一些未提交的修改，功能也没实现，不适合做一次commit。这时候我执行<code>git stash</code>隐藏本地的修改，然后执行<code>git pull</code>来拉取远端的更新，在最新代码基础上<strong>重新实现</strong>stash的那些代码中的功能。</p><p>这里的问题是，重新实现stash代码中的那一步，其实完全可以用<code>git stash pop</code>来替代，执行这个命令会在最新代码基础上作用stash的代码，不用再重新实现一遍了（不过这时可能会有代码冲突需要解决）。所以我之前是把<code>git stash</code>当<code>git checkout -- .</code>来用了，也就是抛弃了本地的代码更新，显然是有问题的。</p><p>正确流程基本上是这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="comment"># 或者 git stash push，效果一样</span></span><br><span class="line">git pull <span class="comment"># 可能有冲突需要手动合并</span></span><br><span class="line">git stash pop <span class="comment"># 可能有冲突需要手动合并</span></span><br></pre></td></tr></table></figure><p>下面记录一下 git stash 提供的功能和一些参数。</p><span id="more"></span><h2 id="git-stash-具体用法"><a href="#git-stash-具体用法" class="headerlink" title="git stash 具体用法"></a>git stash 具体用法</h2><p><code>git stash</code>创建一个新的stash，效果与<code>git stash push</code> 一样，效果如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on master: c6771a5 doc: fix error during pre-commiting</span><br></pre></td></tr></table></figure><p>增加<code>-u</code>选项可以将未track的文件也隐藏起来。</p><p>你可以创建多个stash，最早的stash表示为<code>stash@&#123;0&#125;</code>，然后是<code>stash@&#123;1&#125;</code>，依次递加。</p><p><code>git stash list</code> 会列出所有的stash：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: c6771a5 doc: fix error during pre-commiting</span><br><span class="line">stash@&#123;1&#125;: WIP on master: c6771a5 doc: fix error during pre-commiting</span><br></pre></td></tr></table></figure><p><code>git stash show</code>可以查看最新stash中的修改，加上编号可以查看之前版本的修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash show stash@&#123;0&#125;</span><br><span class="line">version.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p><code>git stash apply</code> 可以应用最新的stash到当前的代码中，同样的，如果加上编号则可以应用之前版本的修改到当前代码。apply执行后记得调用<code>git stash drop</code> 来去除以及应用的stash。<br><code>git stash pop</code>效果等于<code>git stash apply</code> + <code>git stash drop</code>。</p><p><code>git stash branch</code>会基于老的提交代码创建一个分支，同时把最新的修改也作用过去，这样对于新的提交和老提交代码变化很大的场景比较好，避免在新的提交上apply stash时由于冲突太多造成的合并问题。</p><p><code>git stash clean</code> 会清空所有的stash，<strong>且没有任何提示</strong>，这意味着你所有隐藏的代码都会被删除，执行此命令前请三思！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;前段时间突然发现，我之前对&lt;code&gt;git stash&lt;/code&gt;的使用都是错误的。&lt;/p&gt;
&lt;p&gt;具体说来，我是这么使用的：在远端有新的提交，需要&lt;code&gt;git pull&lt;/code&gt;来拉取合并时，发现本地有一些未提交的修改，功能也没实现，不适合做一次commit。这时候我执行&lt;code&gt;git stash&lt;/code&gt;隐藏本地的修改，然后执行&lt;code&gt;git pull&lt;/code&gt;来拉取远端的更新，在最新代码基础上&lt;strong&gt;重新实现&lt;/strong&gt;stash的那些代码中的功能。&lt;/p&gt;
&lt;p&gt;这里的问题是，重新实现stash代码中的那一步，其实完全可以用&lt;code&gt;git stash pop&lt;/code&gt;来替代，执行这个命令会在最新代码基础上作用stash的代码，不用再重新实现一遍了（不过这时可能会有代码冲突需要解决）。所以我之前是把&lt;code&gt;git stash&lt;/code&gt;当&lt;code&gt;git checkout -- .&lt;/code&gt;来用了，也就是抛弃了本地的代码更新，显然是有问题的。&lt;/p&gt;
&lt;p&gt;正确流程基本上是这样：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git stash &lt;span class=&quot;comment&quot;&gt;# 或者 git stash push，效果一样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git pull &lt;span class=&quot;comment&quot;&gt;# 可能有冲突需要手动合并&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git stash pop &lt;span class=&quot;comment&quot;&gt;# 可能有冲突需要手动合并&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面记录一下 git stash 提供的功能和一些参数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>2022年终总结</title>
    <link href="http://vra.github.io/2022/12/31/summary-2022/"/>
    <id>http://vra.github.io/2022/12/31/summary-2022/</id>
    <published>2022-12-31T03:09:39.000Z</published>
    <updated>2023-01-02T16:59:23.374Z</updated>
    
    <content type="html"><![CDATA[<p>多年以后，想起2022，我会回忆起哪个画面？为了解答这个问题，我回想过去的这些年份，2021，2020，……2005，看能想到什么。除了有些年份里，我结婚，毕业，所以有记忆深刻的事件，大部分年份我甚至想不起任何事情。对于一个模糊的数字，在多年以后，我们确实难以将它和自己一天天度过的日常事情关联起来。虽然2022年发生了很多事情，但大部分还是会被遗忘，但我还是尽量想用详细的文字记录下来，这样当以后想会看那年我身上发生了什么的时候，我知道只要在浏览器里面输入<code>vra.github.io/2022/12/31/summary-2022</code>，这些时刻都会清晰地浮现在我眼前。</p><span id="more"></span><h2 id="今年做了什么"><a href="#今年做了什么" class="headerlink" title="今年做了什么"></a>今年做了什么</h2><p>今年在比赛和论文上，和亭枫参加了一个DLGC学术比赛，拿到了第一名，也发表了一篇对应的Workshop论文。去年合作投稿的论文今年辗转投稿了几次，最后投了期刊。今年组内还举办了一场ECCV学术比赛，我作为一个赛道的负责人，在合作方的支持下，构建了训练和测试数据，提供了Baseline，搭建了测评服务，写介绍文章，招募选手，在Slack上和合作的老师英文沟通，成长了挺多的。</p><p>到新团队后，在天猫App上线了一些创新算法驱动的的功能，也算是在亿级用户的App上开发过产品了。</p><p>在技术总结上，今年总共更新了共36篇技术博客，相比之前几年进步巨大。虽然没有太多有亮点的文章，但总算是开始形成比较好的更新习惯了。在大概10月的生活，发现了程序员大神 Simon Willison的<a href="https://simonwillison.net/">博客</a>，收获很多。让我收益的是他的TIL (Tody I Learned) 板块，就是记录每天学习到的技术，开始记录，然后慢慢地提高。基于这个思路，今年写了许多学习到的简单但有用的命令和操作，希望以后坚持下去。</p><h2 id="今年的遗憾"><a href="#今年的遗憾" class="headerlink" title="今年的遗憾"></a>今年的遗憾</h2><p>2022年也是一个充满遗憾的一年。春天晋升失败，虽然身处其中，但面对失败的那种难受感觉，相信你能懂。然后就是组织调整，猝不及防间，很多小伙伴离开了团队，人心惶惶。在公司的一道通知前，我们打工者只有默默接受。然后换到新的组，做新的事情，所幸做的东西差别不大，能够比较快的适应。</p><p>在回望工作这五年，发现工作中，虽然事情勉强能做好，但还远没做到让自己满意。没有发表什么好的论文，模型效果差强人意，做的项目也平平庸庸。</p><p>虽然不想承认，但在即将到来的2023年，我要满30周岁了。在能看到自身的各种问题，却没有好的解决方法的时候，我知道我遇到职业生涯的危机了。那么我自己的核心问题出在哪里？核心矛盾是：长期的目标与短期的行动之间没有匹配。长期的目标是明确的，但当目标被分解到日常的工作中时，很多核心问题没有被解决，而是其他紧急且必须但长远来看不核心的任务占用了绝大部分的时间，导致在不占用家庭和个人生活时间的情况下，没有足够的时间来做核心的工作。</p><p>正如大老板讲过的，通过换环境、换赛道来解决自己遇到问题的想法，是不切实际的。根本问题不解决，在新的赛道，新的环境，就算刚开始做的很顺利，在后面还是会遇到同样的问题，会踩同样的坑。</p><p>2023年，希望多一些清醒的思考，少一些每天只忙着做手头事情的混沌时刻。</p><h2 id="关于技术社区"><a href="#关于技术社区" class="headerlink" title="关于技术社区"></a>关于技术社区</h2><p>今年接触了Lobste.rs社区，发现里面很多编程大佬和很多高质量文章，高质量讨论。而且更为难得的是，社区氛围很好，每个讨论都是非常理性，就事论事，让人不禁想，国内能否有这样的纯粹的技术社区，学习，讨论，研发最新的技术。作为尝试的一小步，我用一个git仓库记录了每周我阅读的技术文章，至于怎么进一步增加讨论，还没有比较好的思路。</p><p>2023-01-03更新：在v2ex上看到了国内的Lobste.rs社区<a href="https://dto.pipecraft.net/">DTO</a>，欢迎在<a href="https://www.v2ex.com/t/905509">这里</a>或<a href="https://github.com/dev-topics-only/lobsters/issues/1">这里</a>发帖申请加入，为提高国内的技术氛围做一份贡献!</p><h2 id="关于AI和chatGPT"><a href="#关于AI和chatGPT" class="headerlink" title="关于AI和chatGPT"></a>关于AI和chatGPT</h2><p>去年体验了一下Copilot，当时的震撼现在还有印象，体验完后，我不禁想：相比Copilot，我们真人的优势在哪里，该如何与它共存？我没答案。<br>今年的chatGPT的爆火，进一步地让我看到AI工具对我们开发者的巨大影响。经过思考，我认为这些AI工具可能会替代我们程序员的某些工作，但不会替代程序员这个行业，只是会明显地改变程序员的编程行为，而且利用好这些工具，会是程序员的必修课。</p><p>从研究者的角度，chatGPT已经可以很好地理解大部分人类语言，所以我认为NLP研究已经到了一个里程碑的阶段，真正智能的AI语音助手不远了，未来几年也会有更多真正的语音助手进入普通人的生活中。</p><p>有点感慨，有时候技术的发展很慢，让人看不到希望，但有时候，技术又发展的太快，让人跟不上脚步。作为一个普通人技术人，还是要感谢那些顶尖的研究者，让我们在有生之年能看到如此激动人心的技术进步。</p><h2 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h2><p>说完技术，谈谈生活吧。今年6月份搬了一次家，从公司附近搬到了老婆上班的幼儿园附近，开始坐地铁上下班。<br>在地铁上，要么刷技术网站，要么刷gif和搞笑网站。在地铁19号线开通后，单程时间缩短到一个小时内，旅程没那么漫长，站着也没那么累了。</p><p>因为疫情封控，平时没怎么出去，周末基本躺家里，偶尔周末一个人去爬山，逛博物馆。有时候和老婆一起出去走走，有时候有同学来杭州来聚聚，大部分时候，坐地铁，上班，坐地铁，从热的蒸发的六月到有些寒冷的腊月。</p><p>印象最深刻的是夏天从地铁站到公司的那段路。那时候19号线还没开通，只能从5号线永福地铁站出来，然后骑共享单车去公司。有时候没有车了，就只能步行近20分钟去公司。2022年的夏天特别的热，一出地铁，刚到扶梯上，一股热浪就袭来，然后出去找单车，坐上去屁股都快烫熟了。在过十字路口前，找一片小树荫躲避烈日，一到绿灯，上班的人都骑着车过马路，在下一个路口继续寻找小树荫，到公司大部分时候后背都已经湿透了。</p><p>好在9月22日，杭州地铁19号线开通，开通当天的晚上，我就去体验了，从此回家快了不少，而且再也不用走那么远的路了。</p><p>平常的日子里，也有惊喜的时刻。9月1日，听到老婆怀孕的消息，我激动坏了。离当爸爸越来越近了，也有对于自己能否做个好爸爸的隐忧。</p><p>今年和小伙伴每天吃饭时讨论最多的话题就是疫情。没想到结局竟然是这样。这里也说说我开放之后变🐑的经历。12月22日是周四，冬至，嗓子开始有点涩的感觉，等到周五下午，浑身酸疼，差点撑不到下班。六点下班，到家后九点就开始睡觉，周六醒来浑身不疼了，到下午🈶又开始疼，头后面一抽一抽地疼。周日测了一下，果然是阳性。过了几天，浑身不疼了，但嗓子还有些难受。</p><h2 id="阅读的书籍"><a href="#阅读的书籍" class="headerlink" title="阅读的书籍"></a>阅读的书籍</h2><p>今年读了比较多的历史方面的书，让我一直思考”我们从哪来”的问题得到了更完整的理解。最难忘的是王鼎钧的回忆录系列，“插柳学诗”章节是我看过的对清末民初乡村士绅最好的介绍。《李宗仁回忆录》和《胡适口述自传》也让我对唐德刚老教授敬佩不已。下面列出一些基本看完且比较推荐的书，供以后查阅。</p><ul><li>《王鼎钧回忆录四部曲》</li><li>《李宗仁回忆录》</li><li>《五更盘道》</li><li>《依稀识得故乡痕：漆家山50年村史》</li><li>《人间杭州》</li><li>《红星照耀中国》</li><li>《晚清最后十八年》</li><li>《寻觅意义》</li><li>《尼安德特人》</li><li>《周恩来传》</li><li>《胡适口述自传》</li><li>《我的个天》</li><li>《左宗棠在甘肃》</li></ul><h2 id="观影"><a href="#观影" class="headerlink" title="观影"></a>观影</h2><p>今年还是在周末看了很多影视作品，难得的是有很多比较感兴趣的科幻和赛博朋克的影视作品出现，大饱眼福。这里按照我的喜好大致排序列出来一些推荐的影视作品。</p><ul><li>《万神殿》</li><li>《赛博朋克：边缘行者》</li><li>《隐入尘烟》</li><li>《史前星球》</li><li>《边缘世界》</li><li>《指环王力量之戒》</li><li>《白莲花度假村》</li><li>《狙击手》</li><li>《爱，死亡和机器人第三季》</li><li>《瞬息全宇宙》</li><li>《人生切割术》</li><li>《黑袍纠察队》</li><li>《1883》  </li><li>《利刃出鞘2》</li><li>《流人第一季》</li><li>《和平使者》</li><li>《塔尔萨之王》</li><li>《上载》</li><li>《法兰西特派》</li><li>《亚当计划》</li><li>《柏青哥》</li><li>《初创玩家》</li><li>《阶梯之间》</li><li>《替身演员》</li><li>《光环》</li><li>《欧比旺》</li><li>《三体动画》</li><li>《月光骑士》</li><li>《荒野迷案》</li><li>《雷神4》</li><li>《奇异博士2》</li><li>《我是格鲁特》</li></ul><h2 id="相聚与出游"><a href="#相聚与出游" class="headerlink" title="相聚与出游"></a>相聚与出游</h2><p>今年疫情反复，几乎没有出杭州，也没有和朋友太多相聚，努力的回忆这些难得的出行和相聚时刻，想起来还是很温暖。</p><ul><li>1月28日，先从杭州坐飞机到西安，由于西安到天水的航班取消了，我到西安后坐高铁到天水，然后在在天水去庄浪，待了两天后和彤彤一起回我家过年。在正月大雪初霁的初六坐车去杭州，先联系出租到县城，和二姐云亮吃了火锅，然后在二姐家住了一晚，第二天一大早出发，坐武山去天水的火车，然后去天水南站坐去杭州的高铁。</li><li>在武山去了前程的鱿鱼摊位，和他匆匆聊了几句，晚上去康智雄家，也是数年没见了。</li><li>2月份，去张凯家里坐了会，聊了聊各自工作的情况。</li><li>3月5日，植物园春游，灵峰山下梅花盛开，花团锦簇，游人如织。</li><li>4月9日，和彤彤去青山湖，从地铁站出来的湖边开阔处，一直走到杉树林，找到一个地方野餐。</li><li>4月17日，从五云山牌坊入口爬山，重游真迹寺，再走万林背山，到三分叉，从龙井村下山，走反了方向，朝九溪十八涧去了，没大路了才重新走回来打车。</li><li>5月3日，去凯旋家做客，他们俩热情地招待我们，吃完饭后玩了一会Switch</li><li>6月3日，7年后重游绍兴，坐地铁两个小时到鲁迅故居站，游鲁迅故居，王阳明故居，上次来吃的好吃饭店已经关门了。</li><li>6月4日，骑行杭州古城门，从西湖文化广场出发，先后去艮山门，庆春门，清泰门，望江门，候潮门至凤山水潮门，至此西湖的古城门算是都走过一圈了，虽然基本上出了一个写着名字的标志，没有别的什么留存了。</li><li>6月19日，高中同学东升换工作来杭州了，和他在青山湖科技城附近吃了饭，还吃到了他从家里带来的好吃的杏子。</li><li>7月1日，小团队去了西湖文体中心打羽毛球，攀岩，之后去西溪湿地里面聚餐。</li><li>7月9日，和彤彤夜游断桥。</li><li>7月14-7月17日，团队去成都outing，见了小爱，夜游锦江；团队去了杜甫草堂，武侯祠，乐山大佛，都江堰，大熊猫基地</li><li>7月24日，夜游钱塘江，骑自行车从近九堡大桥到新彭埠大桥</li><li>8月5日，和本科室友刘旸和他女朋友杨珈蒙聚餐</li><li>8月16日，和彤彤去杭州国家版本馆，里面的科技含量、文化含量远超预期，值得再去。</li><li>8月28日，和高中同学东升、聂小鹏在火车东站万象汇聚餐，和小鹏毕业后就没见过，已经11年了。</li><li>8月29日，独游钱王祠和万松书院，钱王祠的丹书铁券让人印象深刻，万松书院幽深高远，见湖亭上可远眺西湖雷峰塔。</li><li>8月30日，游杭州博物馆，杭州孔庙和西湖博物馆。</li><li>9月18日，独自去丰收湖，空无一人的公交和空荡荡的过街天桥，和充满孩子欢声笑语的公园形成鲜明的对比。</li><li>9月27日，和小伙伴们给实习生乃源饯行，他要去深圳实习了。 </li><li>10月4日，和彤彤去了春天去过的南苕溪，春去秋来，野草疯长，旧路难辨。</li><li>10月15日，与彤彤去植物园露营，待了大半天，桂花虽旺季已过，仍留有余香。</li><li>10月29日，独自去了飞来峰、灵隐寺，韬光寺，北高峰。灵隐寺建筑高大雄伟，里面香客稠密，代表的是寺庙鲜活的一面，而韬光寺需要走不少的山路才到，里面人不多，难得清净，但也难以寻觅白居易与韬光大师论道的踪迹.</li><li>11月5日，韶言师兄来杭参加云栖大会，实验室部分小伙伴在滨江浦江聚餐。</li><li>11月9日，下午小团队去爬老和山，日落后下山，穿过植物园，没人收门票。再次路过梅树区空无一人，之后去青芝坞旁的民宿体验客家菜，难忘的时刻.</li><li>11月27日，与彤彤从市民中心漫游到钱塘江边的城市阳台，路过杭州标志之一的大金球，在城市阳台看对面奥体中心附近的3D霓虹广告。</li></ul><h2 id="2023年的展望"><a href="#2023年的展望" class="headerlink" title="2023年的展望"></a>2023年的展望</h2><p>虽然断断续续写了一整天，在出租屋里，生活杂事和刷手机的冲动下，还是静不下心，感觉还有很多思考很多方面没写到，留待以后再补充吧。</p><p>2023年，给自己定一些小的要求，激励自己：</p><ul><li>遇到问题彻底搞懂再停止，不要提前选择简单的路径或似懂非懂，走hard但长久来看更根本的路径</li><li>做真正有影响力的工作，反思：如果别人来做，会做成怎么样，我比别人做的好在哪里？</li><li>提高工作效率，聚焦长期目标，突破工作上的瓶颈</li><li>不看微博热搜，不刷短视频，卸载快手和抖音，空闲时间多看书</li><li>保证每周写一篇技术博客，将遇到的技术问题和技术思考记录下来，锻炼思考总结能力</li><li>每周校准一次目标，确认是不是在短期任务上偏离了长期目标，如果出现偏差及时纠正</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在2022年，感谢身边的所有人，不管是陪在身边的老婆和肚子里的孩子，还是每天一起工作，一起吃食堂的干饭小伙伴，还是每周视频里远方的家人，还是偶尔在钉钉上问候一下的同学同事，还是躺在微信通讯录里面几年没联系的老友，你们构成了我这一年的思念和牵绊，也构成了我难忘的2022。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;多年以后，想起2022，我会回忆起哪个画面？为了解答这个问题，我回想过去的这些年份，2021，2020，……2005，看能想到什么。除了有些年份里，我结婚，毕业，所以有记忆深刻的事件，大部分年份我甚至想不起任何事情。对于一个模糊的数字，在多年以后，我们确实难以将它和自己一天天度过的日常事情关联起来。虽然2022年发生了很多事情，但大部分还是会被遗忘，但我还是尽量想用详细的文字记录下来，这样当以后想会看那年我身上发生了什么的时候，我知道只要在浏览器里面输入&lt;code&gt;vra.github.io/2022/12/31/summary-2022&lt;/code&gt;，这些时刻都会清晰地浮现在我眼前。&lt;/p&gt;</summary>
    
    
    
    
    <category term="年终总结" scheme="http://vra.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>git 更新历史提交</title>
    <link href="http://vra.github.io/2022/12/16/git-update-a-history-commit/"/>
    <id>http://vra.github.io/2022/12/16/git-update-a-history-commit/</id>
    <published>2022-12-16T01:01:45.000Z</published>
    <updated>2022-12-19T15:46:55.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>有时候我们在git commit后才发现，之前的一些提交有些问题，比如有些代码忘提交了或者有一些typo需要修改。如果要修改的地方是需要添加到最后一次提交上的，那么可以参考我的<a href="https://vra.github.io/2022/11/12/git-add-file-to-last-commit/">这篇博文</a>修改，如果是在非最后一次提交上的，那么就需要用<code>git rebase</code>来操作。这里简单记录一下操作的过程。</p><p><strong>TL;DR</strong><br>操作命令简要来说是这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用git log 查看历史提交，得到需要修改的那次提交的commit id</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 执行rebase命令，注意&lt;commit-id&gt;后面有一个^，表示修改在此次提交前</span></span><br><span class="line">git rebase -i <span class="string">&#x27;&lt;commmit-hash&gt;^&#x27;</span> <span class="comment"># 如果是修改第一次提交，使用 git rebase -i --root</span></span><br><span class="line"><span class="comment"># 修改代码</span></span><br><span class="line">vim changed-file</span><br><span class="line"><span class="comment"># git add 添加更新后的文件</span></span><br><span class="line">git add changed-file</span><br><span class="line"><span class="comment"># git commit 提交，注意需要使用后面三个选项，并且不需要加commit信息，因为会采用之前的commit信息</span></span><br><span class="line">git commit --all --amend --no-edit</span><br><span class="line"><span class="comment"># 使用--continue来完成 git rebase</span></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>后面会使用一个具体的（假）例子来演示这个过程。</p><span id="more"></span><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>假设我们创建了一个代码仓库<code>my_project</code>，先后创建并提交了<code>README.md</code>和<code>main.py</code>文件，但发现第一次的提交里面有一个typo，例如比<code>math</code>打成了<code>meth</code>，现在想要修改第一次提交。</p><p>首先构造”案发现场”:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir my_project &amp;&amp; <span class="built_in">cd</span> my_project</span><br><span class="line">git init</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is my meth library&quot;</span> &gt;&gt; README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;doc: add readme&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;import numpy as np&quot;</span> &gt;&gt; main.py</span><br><span class="line">git add main.py</span><br><span class="line">git commit -m <span class="string">&quot;feat: create main.py&quot;</span></span><br></pre></td></tr></table></figure><p>注意上面的typo <code>meth</code>。</p><p>我们发现了上述问题，但不想新建一个提交来修复，因为确实不算是新功能，那么就用<code>git rebase</code>来完成吧。</p><p>git rebase 是用来修改git commit的命令，提供了非常多的功能。这里我们用<code>git rebase -i</code>来交互式地修改某次commit。</p><p>首先用 <code>git log</code>查看commit ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">* 9bec788 - (HEAD -&gt; main) add sigmoid (31 minutes ago) &lt;xyz&gt;</span><br><span class="line">* ea833e9 - doc: add doc (31 minutes ago) &lt;xyz&gt;</span><br></pre></td></tr></table></figure><p>假如要修改第二次提交，那我们可以用<code>git rebase -i &#39;9bec788^</code>，但我们要修改的是第一次提交，没有之前的状态，所以要用下面的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i --root</span><br><span class="line">Successfully rebased and updated refs/heads/main.</span><br></pre></td></tr></table></figure><p>出来的交互式界面:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pick ea833e9 doc: add doc</span><br><span class="line">pick 9bec788 add sigmoid</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase 9bec788 onto 927493a (2 commands)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment"># p, pick &lt;commit&gt; = use commit</span></span><br><span class="line"><span class="comment"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment"># e, edit &lt;commit&gt; = use commit, but stop for amending</span></span><br><span class="line"><span class="comment"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment"># f, fixup [-C | -c] &lt;commit&gt; = like &quot;squash&quot; but keep only the previous</span></span><br><span class="line"><span class="comment">#                    commit&#x27;s log message, unless -C is used, in which case</span></span><br><span class="line"><span class="comment">#                    keep only this commit&#x27;s message; -c is same as -C but</span></span><br><span class="line"><span class="comment">#                    opens the editor</span></span><br><span class="line"><span class="comment"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span></span><br><span class="line"><span class="comment"># d, drop &lt;commit&gt; = remove commit</span></span><br><span class="line"><span class="comment"># l, label &lt;label&gt; = label current HEAD with a name</span></span><br><span class="line"><span class="comment"># t, reset &lt;label&gt; = reset HEAD to a label</span></span><br><span class="line"><span class="comment"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span><br><span class="line"><span class="comment">#         create a merge commit using the original merge commit&#x27;s</span></span><br><span class="line"><span class="comment">#         message (or the oneline, if no original merge commit was</span></span><br><span class="line"><span class="comment">#         specified); use -c &lt;commit&gt; to reword the commit message</span></span><br><span class="line"><span class="comment"># u, update-ref &lt;ref&gt; = track a placeholder for the &lt;ref&gt; to be updated</span></span><br><span class="line"><span class="comment">#                       to this position in the new commits. The &lt;ref&gt; is</span></span><br><span class="line"><span class="comment">#                       updated at the end of the rebase</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br></pre></td></tr></table></figure><p>底下注释中给出了rebase支持的一些命令和对应的缩写，我们将需要修改的提交前面的命令修改为<code>edit</code>，然后保存退出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">edit ea833e9 doc: add doc</span><br><span class="line">pick 9bec788 add sigmoid</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase 9bec788 onto e3f4cea (2 commands)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment"># p, pick &lt;commit&gt; = use commit</span></span><br><span class="line"><span class="comment"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment"># e, edit &lt;commit&gt; = use commit, but stop for amending</span></span><br><span class="line"><span class="comment"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment"># f, fixup [-C | -c] &lt;commit&gt; = like &quot;squash&quot; but keep only the previous</span></span><br><span class="line"><span class="comment">#                    commit&#x27;s log message, unless -C is used, in which case</span></span><br><span class="line"><span class="comment">#                    keep only this commit&#x27;s message; -c is same as -C but</span></span><br><span class="line"><span class="comment">#                    opens the editor</span></span><br><span class="line"><span class="comment"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span></span><br><span class="line"><span class="comment"># d, drop &lt;commit&gt; = remove commit</span></span><br><span class="line"><span class="comment"># l, label &lt;label&gt; = label current HEAD with a name</span></span><br><span class="line"><span class="comment"># t, reset &lt;label&gt; = reset HEAD to a label</span></span><br><span class="line"><span class="comment"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span><br><span class="line"><span class="comment">#         create a merge commit using the original merge commit&#x27;s</span></span><br><span class="line"><span class="comment">#         message (or the oneline, if no original merge commit was</span></span><br><span class="line"><span class="comment">#         specified); use -c &lt;commit&gt; to reword the commit message</span></span><br><span class="line"><span class="comment"># u, update-ref &lt;ref&gt; = track a placeholder for the &lt;ref&gt; to be updated</span></span><br><span class="line"><span class="comment">#                       to this position in the new commits. The &lt;ref&gt; is</span></span><br><span class="line"><span class="comment">#                       updated at the end of the rebase</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span><br></pre></td></tr></table></figure><p>保存后输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stopped at ea833e9...  doc: add doc</span><br><span class="line">You can amend the commit now, with</span><br><span class="line"></span><br><span class="line">  git commit --amend</span><br><span class="line"></span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line"></span><br><span class="line">  git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>用<code>git status</code> 查看代码状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interactive rebase <span class="keyword">in</span> progress; onto e3f4cea</span><br><span class="line">Last <span class="built_in">command</span> <span class="keyword">done</span> (1 <span class="built_in">command</span> <span class="keyword">done</span>):</span><br><span class="line">   edit ea833e9 doc: add doc</span><br><span class="line">Next <span class="built_in">command</span> to <span class="keyword">do</span> (1 remaining <span class="built_in">command</span>):</span><br><span class="line">   pick 9bec788 add sigmoid</span><br><span class="line">  (use <span class="string">&quot;git rebase --edit-todo&quot;</span> to view and edit)</span><br><span class="line">You are currently editing a commit <span class="keyword">while</span> rebasing branch <span class="string">&#x27;main&#x27;</span> on <span class="string">&#x27;e3f4cea&#x27;</span>.</span><br><span class="line">  (use <span class="string">&quot;git commit --amend&quot;</span> to amend the current commit)</span><br><span class="line">  (use <span class="string">&quot;git rebase --continue&quot;</span> once you are satisfied with your changes)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>git 的提示信息还是很丰富的，按照提示来操作代码，将<code>meth</code> 修改为<code>math</code>，再<code>git add</code>, <code>git commit --all --amend --no-edit</code>和 <code>git rebase --continue</code> 来结束rebase:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git add README.md</span><br><span class="line"></span><br><span class="line">$ git commit --all --amend --no-edit</span><br><span class="line">[detached HEAD 3b83a85] doc: add doc</span><br><span class="line"> Date: Sat Dec 17 18:00:12 2022 +0800</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br><span class="line"> create mode 100644 README.md</span><br><span class="line"></span><br><span class="line">$ git rebase --<span class="built_in">continue</span></span><br><span class="line">Successfully rebased and updated refs/heads/main.</span><br></pre></td></tr></table></figure><p>然后用<code>git log</code>查看命令，可以看到修改的那次提交和后续提交的编号都已经更新了，意味着这是全新的提交，跟之前的提交没有关系了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;有时候我们在git commit后才发现，之前的一些提交有些问题，比如有些代码忘提交了或者有一些typo需要修改。如果要修改的地方是需要添加到最后一次提交上的，那么可以参考我的&lt;a href=&quot;https://vra.github.io/2022/11/12/git-add-file-to-last-commit/&quot;&gt;这篇博文&lt;/a&gt;修改，如果是在非最后一次提交上的，那么就需要用&lt;code&gt;git rebase&lt;/code&gt;来操作。这里简单记录一下操作的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;&lt;br&gt;操作命令简要来说是这样:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 使用git log 查看历史提交，得到需要修改的那次提交的commit id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 执行rebase命令，注意&amp;lt;commit-id&amp;gt;后面有一个^，表示修改在此次提交前&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git rebase -i &lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;lt;commmit-hash&amp;gt;^&amp;#x27;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# 如果是修改第一次提交，使用 git rebase -i --root&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 修改代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vim changed-file&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# git add 添加更新后的文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git add changed-file&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# git commit 提交，注意需要使用后面三个选项，并且不需要加commit信息，因为会采用之前的commit信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit --all --amend --no-edit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 使用--continue来完成 git rebase&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git rebase --&lt;span class=&quot;built_in&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;后面会使用一个具体的（假）例子来演示这个过程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>使用 defaultdict 来简化 dict 的初始化</title>
    <link href="http://vra.github.io/2022/12/10/python-defaultdict-usage/"/>
    <id>http://vra.github.io/2022/12/10/python-defaultdict-usage/</id>
    <published>2022-12-10T07:17:17.000Z</published>
    <updated>2022-12-10T07:57:10.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在我们使用Python中的dict时，常常需要判断某个关键字是否已经在dict中，如果不存在则创建，非空则进行另外的操作。例如统计一篇文章中所有单词出现次数的代码，大致写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">words_num = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> words_num.keys():</span><br><span class="line">        words_num[word] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        words_num[word] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样写总是需要判断key是否在dict中，不是很优雅。</p><p>Python标准库collections中<a href="https://docs.python.org/3/library/collections.html#defaultdict-objects">defaultdict</a>类可以很好的解决这个问题。这个类使用与dict几乎一样，除了可以在初始化时设置key的默认类型和数值。类的声明格式为<code>defaultdict(default_factory=None, /[, ...])</code>，<code>default_factory</code>是一个<code>callable</code>的变量。</p><p>别的使用与dict无异，正常使用即可。</p><span id="more"></span><p>例如，<code>foo = defaultdict(int)</code>表示foo中的key的默认类型是int，且默认值为int的默认值0，我们可以获取<strong>任意</strong>的key，不需要手动初始化key:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;whatever&#x27;</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>所以最开始的例子可以简化为如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">words_num = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    words_num[word] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看到使用defaultdict后，代码中只需要关注上层逻辑（统计单词的出现次数），而不需要关注具体的语法的代码实现（dict是否存在某个key，没有的话xxx，有的话xxx），因此世界变得更美好了一些。</p><p>除了int外，用list，tuple，dict，set等作为变量也比较常见。除了内置类型外，还可以自定义函数，比如设置key的默认值为<code>&#39;China&#39;</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_default_contry</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">&quot;China&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from = defaultdict(set_default_contry)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from[<span class="string">&#x27;张三&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;China&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from[<span class="string">&#x27;李四&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;China&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from[<span class="string">&#x27;Tim&#x27;</span>] = <span class="string">&#x27;USA&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from</span><br><span class="line">defaultdict(&lt;function set_default_contry at <span class="number">0x10896eca0</span>&gt;, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;China&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>: <span class="string">&#x27;China&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>: <span class="string">&#x27;China&#x27;</span>, <span class="string">&#x27;Tim&#x27;</span>: <span class="string">&#x27;USA&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p><code>defauldict</code>是一个简单但很好用的功能，在日常的使用中还是能减少一些代码复杂度的。希望这篇小文能给让你写代码更容易，更开心。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;在我们使用Python中的dict时，常常需要判断某个关键字是否已经在dict中，如果不存在则创建，非空则进行另外的操作。例如统计一篇文章中所有单词出现次数的代码，大致写法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;words_num = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; word &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; words:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; word &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; words_num.keys():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        words_num[word] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        words_num[word] += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样写总是需要判断key是否在dict中，不是很优雅。&lt;/p&gt;
&lt;p&gt;Python标准库collections中&lt;a href=&quot;https://docs.python.org/3/library/collections.html#defaultdict-objects&quot;&gt;defaultdict&lt;/a&gt;类可以很好的解决这个问题。这个类使用与dict几乎一样，除了可以在初始化时设置key的默认类型和数值。类的声明格式为&lt;code&gt;defaultdict(default_factory=None, /[, ...])&lt;/code&gt;，&lt;code&gt;default_factory&lt;/code&gt;是一个&lt;code&gt;callable&lt;/code&gt;的变量。&lt;/p&gt;
&lt;p&gt;别的使用与dict无异，正常使用即可。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>git如何添加文件到最新的提交</title>
    <link href="http://vra.github.io/2022/11/12/git-add-file-to-last-commit/"/>
    <id>http://vra.github.io/2022/11/12/git-add-file-to-last-commit/</id>
    <published>2022-11-12T09:54:22.000Z</published>
    <updated>2022-12-16T00:54:01.016Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，在git commit后，我们会发现一些文件忘了提交了，或者需要修改，而且这些提交和修改是与上一次commit的主题一致的，这时候再执行一遍相同的git commit就会让提交记录显得比较冗余，有没有办法将修改后的文件加到最后一次的提交记录里面呢？搜索后发现<a href="https://stackoverflow.com/a/40503483">这里</a>给了一个解决办法，git add文件后调用<code>git commit --amend -no-edit</code>即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file_path&gt;</span><br><span class="line">git commit --amend --no-edit</span><br></pre></td></tr></table></figure><p><strong>注意：如果之前的代码已经提交的话，需要执行<code>git push --force</code>来推送代码以替代之前的提交记录。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有时候，在git commit后，我们会发现一些文件忘了提交了，或者需要修改，而且这些提交和修改是与上一次commit的主题一致的，这时候再执行一遍相同的git commit就会让提交记录显得比较冗余，有没有办法将修改后的文件加到最后一次的提交记录里面呢？搜索后发现&lt;a h</summary>
      
    
    
    
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
    <category term="TIL" scheme="http://vra.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>执行du命令时统计隐藏文件和目录</title>
    <link href="http://vra.github.io/2022/11/07/du-show-hidden-folders/"/>
    <id>http://vra.github.io/2022/11/07/du-show-hidden-folders/</id>
    <published>2022-11-07T15:32:23.000Z</published>
    <updated>2022-11-07T15:38:24.784Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux和Mac下，执行<code>du -sh</code> 来统计目录大小时，默认不统计以点开头的文件或者目录，比如<code>.local</code>，因此得到不准确的统计结果。从<a href="https://superuser.com/a/633808">这里</a>知道，要统计隐藏文件和目录，可以这么用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只统计隐藏文件或者目录</span></span><br><span class="line">du -sh .[^.]*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计隐藏文件或者目录和常规文件</span></span><br><span class="line">du -sh .[^.]* *</span><br></pre></td></tr></table></figure><p>结合 <code>sort -h</code>，可以快速得到比较大的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh .[^.]* * |sort -h</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Linux和Mac下，执行&lt;code&gt;du -sh&lt;/code&gt; 来统计目录大小时，默认不统计以点开头的文件或者目录，比如&lt;code&gt;.local&lt;/code&gt;，因此得到不准确的统计结果。从&lt;a href=&quot;https://superuser.com/a/633808&quot;&gt;</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="TIL" scheme="http://vra.github.io/tags/TIL/"/>
    
  </entry>
  
</feed>
