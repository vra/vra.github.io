<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yunfeng&#39;s Simple Blog</title>
  
  <subtitle>Love, Life, Linux</subtitle>
  <link href="http://vra.github.io/atom.xml" rel="self"/>
  
  <link href="http://vra.github.io/"/>
  <updated>2022-03-20T14:02:56.929Z</updated>
  <id>http://vra.github.io/</id>
  
  <author>
    <name>Yunfeng Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从Python传递参数到C++</title>
    <link href="http://vra.github.io/2022/03/20/cpp-read-binary-file-from-python/"/>
    <id>http://vra.github.io/2022/03/20/cpp-read-binary-file-from-python/</id>
    <published>2022-03-20T13:05:30.000Z</published>
    <updated>2022-03-20T14:02:56.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>有些场景下，需要将Python里面计算得到的参数或者结果传入到C++来进行工程部署。一个常见问题是，Python该以什么格式 (二进制还是文本) 保存这些参数，然后从C++代码里面来读取呢，各有什么优劣？这里我们简单实验一下，并写一些趁手的代码，供查阅。</p><span id="more"></span><h2 id="二进制格式和文本格式对比"><a href="#二进制格式和文本格式对比" class="headerlink" title="二进制格式和文本格式对比"></a>二进制格式和文本格式对比</h2><p>假设我们有一组参数是存储在Numpy的<code>ndarray</code>格式中的，为了在C++中使用，我们需要保存它们到硬盘的文件中。一般有两种保存方法：二进制文件保存和文本文件保存。</p><p>假设我们有一个1024x1024的浮点型参数待保存：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params = np.random.rand(<span class="number">1024</span>, <span class="number">1024</span>).astype(<span class="string">&#x27;float32&#x27;</span>)</span><br></pre></td></tr></table></figure><p>二进制保存很简单，直接调用Numpy的<code>tofile</code>文件即可：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params.tofile(<span class="string">&quot;params.bin&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果用文本文件保存，有两种保存方式，分别为调用<code>savetxt</code>函数和将每个值转换为<code>str</code>并用分隔符分开依次存入文件:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文本文件保存方式1</span></span><br><span class="line">np.savetxt(<span class="string">&quot;params_1.txt&quot;</span>, params)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文本文件保存方式2</span></span><br><span class="line">delimiter = <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;params_2.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> params:</span><br><span class="line">        f.write(<span class="built_in">str</span>(p) + delimiter)</span><br></pre></td></tr></table></figure><p>猜猜看这三种情况分别大小是多少？</p><p>结论如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4.0M params.bin</span><br><span class="line">25M params_1.txt</span><br><span class="line">11M params_2.txt</span><br></pre></td></tr></table></figure><p>可以看到，二进制格式存储空间是最小的，分别是两种文本形式存储空间的16%和36%，存储压缩比例还是比较明显的。</p><p>因此推荐以二进制形式存储, 存储脚本简单总结如下:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># rand默认格式是float64，我们使用float32就可以</span></span><br><span class="line">params = np.random.rand(<span class="number">1024</span>, <span class="number">1024</span>).astype(<span class="string">&quot;float32&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉平成一维，为了在C++里面方便处理</span></span><br><span class="line">params = params.flatten()</span><br><span class="line"></span><br><span class="line">params.tofile(<span class="string">&quot;params.bin&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="C-读取二进制文件"><a href="#C-读取二进制文件" class="headerlink" title="C++ 读取二进制文件"></a>C++ 读取二进制文件</h2><p>C++ 去读二进制的代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_binary</span><span class="params">(<span class="keyword">const</span> std::string &amp;file_path, <span class="keyword">float</span> *data, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  std::ifstream in_file;</span><br><span class="line">  in_file.<span class="built_in">open</span>(file_path, std::ios::binary | std::ios::in);</span><br><span class="line">  in_file.<span class="built_in">read</span>((<span class="keyword">char</span> *)data, size * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>));</span><br><span class="line">  in_file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string file_path = <span class="string">&quot;params.bin&quot;</span>;</span><br><span class="line">  <span class="keyword">int</span> size = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用stack上空间来创建数组，有大小限制，不推荐</span></span><br><span class="line">  <span class="comment">// float params[size];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用new来构建heap上空间, 无大小限制，但需要自己释放内存</span></span><br><span class="line">  <span class="keyword">float</span> *params = <span class="keyword">new</span> <span class="keyword">float</span>[size];</span><br><span class="line">  <span class="built_in">read_binary</span>(file_path, params, size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印前10个参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    std::cout &lt;&lt; params[i] &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>[] params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意新建数组的时候，有在栈上或者堆上构建两种方式，栈上构建有大小限制，如果数组维度太大就会报错，如下面的代码:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行会报错:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ g++ stack_over.cpp &amp;&amp; ./a.out</span><br><span class="line">[1]    89415 segmentation fault  ./a.out</span><br></pre></td></tr></table></figure><p>因此推荐用堆上创建数组，详见上述代码的注释。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;有些场景下，需要将Python里面计算得到的参数或者结果传入到C++来进行工程部署。一个常见问题是，Python该以什么格式 (二进制还是文本) 保存这些参数，然后从C++代码里面来读取呢，各有什么优劣？这里我们简单实验一下，并写一些趁手的代码，供查阅。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="C++" scheme="http://vra.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch模型转ONNX时cross操作不支持的解决方法</title>
    <link href="http://vra.github.io/2022/03/20/pytorch-cross-to-onnx/"/>
    <id>http://vra.github.io/2022/03/20/pytorch-cross-to-onnx/</id>
    <published>2022-03-20T10:34:46.000Z</published>
    <updated>2022-03-20T11:50:08.922Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Pytorch很灵活，支持各种OP和Python的动态语法。但是转换到onnx的时候，有些OP（目前）并不支持，比如<code>torch.cross</code>。这里以一个最小化的例子来演示这个过程，以及对应的解决办法。</p><span id="more"></span><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>考虑下面这个简单的Pytorch转ONNX的例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file name: pytorch_cross_to_onnx.py</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModel</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MyModel, self).__init__()</span><br><span class="line">        self.conv = nn.Conv2d(<span class="number">3</span>, <span class="number">10</span>, <span class="number">3</span>, stride=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = torch.cross(x, x)</span><br><span class="line">        y = self.conv(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = MyModel()</span><br><span class="line"></span><br><span class="line">dummy_input = torch.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>, device=<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">input_names = [<span class="string">&quot;x&quot;</span>]</span><br><span class="line">output_names = [<span class="string">&quot;y&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># opset_version 选择范围：[7,15]</span></span><br><span class="line">torch.onnx.export(</span><br><span class="line">    model,</span><br><span class="line">    dummy_input,</span><br><span class="line">    <span class="string">&quot;my_model.onnx&quot;</span>,</span><br><span class="line">    input_names=input_names,</span><br><span class="line">    output_names=output_names,</span><br><span class="line">    opset_version=<span class="number">14</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>运行这个脚本，会报下面的错误：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 pytorch_cross_to_onnx.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;pytorch_cross.py&quot;</span>, line 25, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    torch.onnx.export(model, dummy_input, <span class="string">&quot;my_model.onnx&quot;</span>, input_names=input_names, output_names=output_names, opset_version=14)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/__init__.py&quot;</span>, line 320, <span class="keyword">in</span> <span class="built_in">export</span></span><br><span class="line">    custom_opsets, enable_onnx_checker, use_external_data_format)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/utils.py&quot;</span>, line 111, <span class="keyword">in</span> <span class="built_in">export</span></span><br><span class="line">    custom_opsets=custom_opsets, use_external_data_format=use_external_data_format)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/utils.py&quot;</span>, line 729, <span class="keyword">in</span> _export</span><br><span class="line">    dynamic_axes=dynamic_axes)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/utils.py&quot;</span>, line 501, <span class="keyword">in</span> _model_to_graph</span><br><span class="line">    module=module)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/utils.py&quot;</span>, line 216, <span class="keyword">in</span> _optimize_graph</span><br><span class="line">    graph = torch._C._jit_pass_onnx(graph, operator_export_type)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/__init__.py&quot;</span>, line 373, <span class="keyword">in</span> _run_symbolic_function</span><br><span class="line">    <span class="built_in">return</span> utils._run_symbolic_function(*args, **kwargs)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/utils.py&quot;</span>, line 1028, <span class="keyword">in</span> _run_symbolic_function</span><br><span class="line">    symbolic_fn = _find_symbolic_in_registry(domain, op_name, opset_version, operator_export_type)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/utils.py&quot;</span>, line 982, <span class="keyword">in</span> _find_symbolic_in_registry</span><br><span class="line">    <span class="built_in">return</span> sym_registry.get_registered_op(op_name, domain, opset_version)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.7/site-packages/torch/onnx/symbolic_registry.py&quot;</span>, line 125, <span class="keyword">in</span> get_registered_op</span><br><span class="line">    raise RuntimeError(msg)</span><br><span class="line">RuntimeError: Exporting the operator cross to ONNX opset version 14 is not supported. Please feel free to request support or submit a pull request on PyTorch GitHub.</span><br></pre></td></tr></table></figure><p>注意最后一句的报错:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RuntimeError: Exporting the operator cross to ONNX opset version 14 is not supported. Please feel free to request support or submit a pull request on PyTorch GitHub.</span><br></pre></td></tr></table></figure><p>也就是说目前版本是不支持<code>torch.cross</code>转onnx的，同时提示你”feel free” 去Pytorch 的 GitHub 上提交/贡献一个转换操作。不过2020年03月就有人提了<a href="https://github.com/onnx/onnx/issues/2683">issue</a>，至今仍没有g官方的解决方案。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>上面的issue里有人给出了解决思路，就是用元素相乘替代<code>cross</code>操作。具体来说，实现如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_cross</span>(<span class="params">x, y, dim=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">assert</span> x.dim() == y.dim() <span class="keyword">and</span> dim &lt; x.dim()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> torch.stack(</span><br><span class="line">        (</span><br><span class="line">            x[:, <span class="number">1</span>, ...] * y[:, <span class="number">2</span>, ...] - x[:, <span class="number">2</span>, ...] * y[:, <span class="number">1</span>, ...],</span><br><span class="line">            x[:, <span class="number">2</span>, ...] * y[:, <span class="number">0</span>, ...] - x[:, <span class="number">0</span>, ...] * y[:, <span class="number">2</span>, ...],</span><br><span class="line">            x[:, <span class="number">0</span>, ...] * y[:, <span class="number">1</span>, ...] - x[:, <span class="number">1</span>, ...] * y[:, <span class="number">0</span>, ...],</span><br><span class="line">        ),</span><br><span class="line">        dim=dim,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p><strong>注意：这里是以dim=1为例写的实现，如果是在别的维度进行cross操作，需要修改dim参数，同时修改对应stack的维度。</strong></p><p>同时在Pytorch doc网站上看到，如果<code>torch.cross</code>不指定<code>dim</code>参数的话，默认是从前往后找第一个维度为3的维度，因此这个可能是你所不期望的，建议显式指定这个参数。</p><p>因此总结下来，下面是修改后的代码:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_cross</span>(<span class="params">x, y, dim=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">assert</span> x.dim() == y.dim() <span class="keyword">and</span> dim &lt; x.dim()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> torch.stack(</span><br><span class="line">        (</span><br><span class="line">            x[:, <span class="number">1</span>, ...] * y[:, <span class="number">2</span>, ...] - x[:, <span class="number">2</span>, ...] * y[:, <span class="number">1</span>, ...],</span><br><span class="line">            x[:, <span class="number">2</span>, ...] * y[:, <span class="number">0</span>, ...] - x[:, <span class="number">0</span>, ...] * y[:, <span class="number">2</span>, ...],</span><br><span class="line">            x[:, <span class="number">0</span>, ...] * y[:, <span class="number">1</span>, ...] - x[:, <span class="number">1</span>, ...] * y[:, <span class="number">0</span>, ...],</span><br><span class="line">        ),</span><br><span class="line">        dim=dim,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModel</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MyModel, self).__init__()</span><br><span class="line">        self.conv = nn.Conv2d(<span class="number">3</span>, <span class="number">10</span>, <span class="number">3</span>, stride=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># x = torch.cross(x, x)</span></span><br><span class="line">        x = my_cross(x, x)</span><br><span class="line">        y = self.conv(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = MyModel()</span><br><span class="line"></span><br><span class="line">dummy_input = torch.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>, device=<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">output = model(dummy_input)</span><br><span class="line">input_names = [<span class="string">&quot;x&quot;</span>]</span><br><span class="line">output_names = [<span class="string">&quot;y&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># opset_version 选择范围：[7,15]</span></span><br><span class="line">torch.onnx.export(</span><br><span class="line">    model,</span><br><span class="line">    dummy_input,</span><br><span class="line">    <span class="string">&quot;my_model.onnx&quot;</span>,</span><br><span class="line">    input_names=input_names,</span><br><span class="line">    output_names=output_names,</span><br><span class="line">    opset_version=<span class="number">14</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>为了验证我们的实现与Pytorch的实现是否一致，可以用下面的函数验证:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_torch_cross_and_my_cross</span>():</span></span><br><span class="line">    x = torch.randn(<span class="number">10</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">    y = torch.randn(<span class="number">10</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;my_cross == torch.cross:&quot;</span>, torch.allclose(torch.cross(x, y), my_cross(x, y)))</span><br></pre></td></tr></table></figure><p>执行后输出如下:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">my_cross == torch.cross: True</span><br></pre></td></tr></table></figure><p>说明这个实现是正确的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://github.com/onnx/onnx/issues/2683">https://github.com/onnx/onnx/issues/2683</a></li><li><a href="https://pytorch.org/docs/stable/generated/torch.cross.html">https://pytorch.org/docs/stable/generated/torch.cross.html</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Pytorch很灵活，支持各种OP和Python的动态语法。但是转换到onnx的时候，有些OP（目前）并不支持，比如&lt;code&gt;torch.cross&lt;/code&gt;。这里以一个最小化的例子来演示这个过程，以及对应的解决办法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="Deep Learning" scheme="http://vra.github.io/tags/Deep-Learning/"/>
    
    <category term="Pytorch" scheme="http://vra.github.io/tags/Pytorch/"/>
    
    <category term="ONNX" scheme="http://vra.github.io/tags/ONNX/"/>
    
    <category term="Torchscript" scheme="http://vra.github.io/tags/Torchscript/"/>
    
  </entry>
  
  <entry>
    <title>2021年终总结</title>
    <link href="http://vra.github.io/2021/12/31/summary-2021/"/>
    <id>http://vra.github.io/2021/12/31/summary-2021/</id>
    <published>2021-12-31T11:53:14.000Z</published>
    <updated>2022-01-01T01:01:02.256Z</updated>
    
    <content type="html"><![CDATA[<p>2021快结束了，看的年初定的14条大大小小的目标，完成的只有三四条，惨不忍睹。这里总结一下这一年的大大小小的事情，留一个纪念。</p><span id="more"></span><h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><p>总体来说2021是平稳的一年，工作大部分时候有序进行，同事和领导们待人友善，团队氛围和谐，夫妻感情和睦，家人身体都还算好，收入够日常开销，在一个城市的同学朋友们能偶尔聚聚，聊天吃饭，这样想想就已经很知足了。</p><p>工作方面还是有很多可以改进的地方的。<br>之前的工作思维是快速完成功能，导致很多代码都未经打磨，充满各种问题。今年也看到一些比较好的身边的例子，决定放慢速度，以创造作品的方式来写代码，多考虑可用性，边界条件和文档。团队整体的节奏其实是允许这样做的，只不过以前做了一个粗糙版本就去干别的了，没有真正地做好它。</p><p>还有一个是对偏理论的知识的畏惧感需要克服。总体来说这还是惰性思维的表现，不愿意深入地探索背后的原理。</p><p>更多的时间去改造自己，学习新知，更好地为社会创造价值。</p><h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><p>今年团队参加了一个ICCV比赛，并且拿到了第一名，算是在技术上取得了一个成果，真诚地感谢一起努力的小伙伴。  </p><p>开源项目上，没有新的进展，前一段时间把flopth的功能加强了一下，后面会写一个更全面的说明。  </p><p>博客更新了14篇，总体达到每个月一篇的目标了，但质量还需要提高。  </p><h4 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h4><p>年初定了读书202.1小时的目标，不过没达到，新的一年继续努力。<br>读完了的几本书：</p><ul><li> 老残游记》</li><li>儒林外史》</li><li>《毛泽东的书单》</li><li>《万历十五年》</li><li>《老舍和他的作品》</li></ul><p>读了一部分的书:</p><ul><li>《雨》</li><li>《我的个天》</li><li>《西行漫记》</li><li>《能人》</li><li>《中外名画彩图馆》</li></ul><h4 id="影视"><a href="#影视" class="headerlink" title="影视"></a>影视</h4><p>周末大部分时间会刷一刷剧，所以今年电影和剧集看的挺多的。还是有许多好看的电影，给人感动。</p><ul><li>《苍穹浩瀚》惊喜连连的太空剧，强烈推荐</li><li>《健听女孩》</li><li>《基地》</li><li>《鹰眼》</li><li>《假如…？》</li><li>《洛基》</li><li>《猎鹰与冬兵》</li><li>《旺达幻视》</li><li>《x特遣队》</li><li>《倒数时刻》</li><li>《芬奇》</li><li>《性教育第三季》</li><li>《黑寡妇》</li><li>《尚气与十环传奇》</li><li>《红色通缉令》</li><li>《大佛普拉斯》</li><li>《同学麦娜丝》</li><li>《杀手妻子的保镖2》</li><li>《寂静之地2》</li><li>《爱，死亡与机器人2》</li><li>《雪国列车》</li><li>《活着》</li></ul><h4 id="相聚时刻"><a href="#相聚时刻" class="headerlink" title="相聚时刻"></a>相聚时刻</h4><p>这一年，和同学，同事，家人相聚的次数还比较多，每次相聚都值得纪念，这里把这些欢聚时刻都记录下来。</p><ul><li>1.3日，和研究生张鹏师兄，孙翠蓉师姐，吕玥和sun可在张鹏师兄家聚餐</li><li>2月12日，在杭州和彤彤过春节</li><li>3月27日，清明前一周，我回家里,和爸还有外甥女听听去上坟。这是爷爷奶奶去世十余年，第一次去给他们上坟。</li><li>4月11日，和高中同学马仲海在西湖边的清真餐厅聚餐，他来杭州参加会议。</li><li>6月5日，我去吉林榆树参加大学同学栾京的婚礼，这也是我第一次去东北。东北一望无际的平原让人印象深刻。第二天我们凌晨2点起来去准备接亲，那边凌晨四点天就亮了。</li><li>6月14日，和旸哥杨珈蒙在公司打羽毛球，打完后去陕西面馆吃了大盘鸡。</li><li>6月15日，和在阿里的武山老乡聚了餐，加了初中同级同学孙健的微信。</li><li>6月26日，天琦师兄来附近找房子，我带他们看了房子，然后去亲橙里吃了烤鱼。</li><li>7月2日，团队组织去舟山市的普陀山和东极岛团建，在祖国的最东边度过了几天难忘的日子。</li><li>7月24日，和彤彤回庄浪，参加彤彤大姐的婚礼。爸妈在岳父岳母的邀请下，也到庄浪了，彤彤妹妹和妹夫也从江苏赶过来，我们在庄浪待了逛了好几天。因为疫情的原因多请了一天假。</li><li>8月15日，我和彤彤和刘凯旋夫妻俩还有华哥在天街吃了饭。</li><li>国庆节，我和彤彤回家了，云亮也回家了，全家给云亮过了生日。回家搬玉米，剥玉米，劳动了一下。</li><li>10月10日，实验室师弟鹤臻来参加VALSE，我也赶过去参加了这次会议，结束后我们去吃了饭，聊了聊实验室最近的事情。</li><li>11月16日，高中同学小雨来杭州出差，我下班后去找他，他请我们吃了烤肉，吃完后我们去星巴克坐了会，聊了很多关于创业的事情，他现在是在投资机构上班。</li><li>11月20日，实验室师弟周浩来杭州参加校招活动，我们召集了小天和师妹魏承承，在新榆园吃了饭，后面又和周浩在园区食堂吃了饭</li><li>11月22日，和张鹏师兄，孙可在园区吃了面。</li><li>12月29日，小组去爬了西湖群山，从老和云起到秦亭，再到灵峰山，最后去了北高峰，然后下山。</li></ul><p>除了这些具体的相聚时刻，公司小组时常在开完组会后去聚餐，塞远带我们吃遍了周围的各种饭店，这些时刻都值得纪念。一个温和的团队值得珍惜，给了我们稳定的工作环境，可以专心做自己喜欢的事情，确实很难得，因此更要倍加珍惜。</p><h4 id="最后的感想"><a href="#最后的感想" class="headerlink" title="最后的感想"></a>最后的感想</h4><p>相比去年，今年的我多了一些笃定吧。这一年发生了很多事情，个人，公司，国家。总体来说，这是往好发展的一年，通过一年的工作，渐渐想通了，通过现在的工作，积累的知识和能力，会在未来某个时间点达到质变，因此别太着急，努力地去做好每件事情，写好每行代码，写好每个注释，写好每个文档，搞懂每个疑惑，弄懂每个知识点，会往好的方向发展的。</p><p>最近读了《西行漫记》，为其中的红军的精神所感染，反观自己现在的状态，用文中的话来说，是“消极的满足”，没有持久的梦想驱动。这种状态确实挺可怕的，所以新的一年，要想清楚未来几年的目标，持续地朝这个目标努力，保持积极的求索，跳出消极的满足的温水煮青蛙陷阱。</p><p>毕业已经三年，刚毕业定了一个三年的目标，现在看来基本都没实现。这还是对我有很大的警醒作用的。下一个三年，是不是还会继续这样失败呢，如何才能定好三年目标并一步步完成它呢？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2021快结束了，看的年初定的14条大大小小的目标，完成的只有三四条，惨不忍睹。这里总结一下这一年的大大小小的事情，留一个纪念。&lt;/p&gt;</summary>
    
    
    
    
    <category term="年终总结" scheme="http://vra.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    <category term="2021" scheme="http://vra.github.io/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>Mac OpenGL入门：显示颜色</title>
    <link href="http://vra.github.io/2021/11/21/mac-opengl-red/"/>
    <id>http://vra.github.io/2021/11/21/mac-opengl-red/</id>
    <published>2021-11-21T08:18:23.000Z</published>
    <updated>2021-11-21T08:34:06.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这里以显示一个红色的窗口为例，展示Mac下运行OpenGL代码的一些配置项。这里采用c++ 和cmake来编译代码的方式，比用xcode更直观。</p><span id="more"></span><h2 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install glfw3 glew cmake</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>C++源码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(GLFWwindow* window)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> currentTime)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>()) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mac增加的代码</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line"></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">600</span>, <span class="number">600</span>, <span class="string">&quot;Chapter 2 - program1&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">        <span class="built_in">display</span>(window, <span class="built_in">glfwGetTime</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cmake文件"><a href="#cmake文件" class="headerlink" title="cmake文件"></a>cmake文件</h2><p>cmake 代码：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(show_box)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(/usr/local/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(/usr/local/Cellar/glew/<span class="number">2.2</span>.<span class="number">0</span>_1/lib)</span><br><span class="line"><span class="keyword">link_directories</span>(/usr/local/Cellar/glfw/<span class="number">3.3</span>.<span class="number">4</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> ch2.<span class="number">1</span>.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">GLEW</span><br><span class="line">GLFW</span><br><span class="line"><span class="string">&quot;-framework OpenGL&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make -j8</span><br><span class="line">./show_box</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;这里以显示一个红色的窗口为例，展示Mac下运行OpenGL代码的一些配置项。这里采用c++ 和cmake来编译代码的方式，比用xcode更直观。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://vra.github.io/tags/C/"/>
    
    <category term="OpenGL" scheme="http://vra.github.io/tags/OpenGL/"/>
    
    <category term="Mac" scheme="http://vra.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mac上如何运行OpenGL:第一个例子</title>
    <link href="http://vra.github.io/2021/11/20/mac-opengl-first-example/"/>
    <id>http://vra.github.io/2021/11/20/mac-opengl-first-example/</id>
    <published>2021-11-20T00:33:37.000Z</published>
    <updated>2021-11-20T00:46:09.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>搜索发现，OpengGL在mac下其实运行还是比较容易的，这里做一个简单的总结。</p><span id="more"></span><h2 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h2><p>安装依赖项:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install glfw3 glew cmake</span><br></pre></td></tr></table></figure><h2 id="编写OpenGL代码"><a href="#编写OpenGL代码" class="headerlink" title="编写OpenGL代码"></a>编写OpenGL代码</h2><p>编写OpenGL代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> &lt;iostream&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="comment">/* Poll for and process events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="编写CMake-配置文件"><a href="#编写CMake-配置文件" class="headerlink" title="编写CMake 配置文件"></a>编写CMake 配置文件</h2><p>为了简单可复现，这里我们直接编写<code>CMakeLists.txt</code>, 内容如下：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(opengl_first_example)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(/usr/local/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(/usr/local/Cellar/glew/<span class="number">2.2</span>.<span class="number">0</span>_1/lib)</span><br><span class="line"><span class="keyword">link_directories</span>(/usr/local/Cellar/glfw/<span class="number">3.3</span>.<span class="number">4</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> GLEW GLFW)</span><br></pre></td></tr></table></figure><p><strong>需要修改其中第5行和第6行路径中的glew和glfw为你自己电脑安装的版本</strong></p><h2 id="编译执行代码"><a href="#编译执行代码" class="headerlink" title="编译执行代码"></a>编译执行代码</h2><p>编译代码，使用CMake的常规流程:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. </span><br><span class="line">make -j8 </span><br></pre></td></tr></table></figure><p>编译完成后运行生成的可执行文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./opengl_first_example</span><br></pre></td></tr></table></figure><p>可以看到一个图窗弹出来，说明OpenGL调用成功了.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/153550789">https://zhuanlan.zhihu.com/p/153550789</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;搜索发现，OpengGL在mac下其实运行还是比较容易的，这里做一个简单的总结。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://vra.github.io/tags/C/"/>
    
    <category term="macOS" scheme="http://vra.github.io/tags/macOS/"/>
    
    <category term="OpenGL" scheme="http://vra.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>检测Python代码中没有用到的函数和变量</title>
    <link href="http://vra.github.io/2021/11/07/detect-unused-function-and-variable-in-python/"/>
    <id>http://vra.github.io/2021/11/07/detect-unused-function-and-variable-in-python/</id>
    <published>2021-11-07T11:57:22.000Z</published>
    <updated>2021-11-07T12:09:02.560Z</updated>
    
    <content type="html"><![CDATA[<p>在重构Python代码的时候，需要统计有哪些函数和变量没有用到，搜索后发现一个简单的工具<a href="https://pypi.org/project/vulture/">vulture</a>，可以完成这个功能。 </p><p>操作也很简单, pip 安装包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install vulture</span><br></pre></td></tr></table></figure><p>检测代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vulture tester.py</span><br></pre></td></tr></table></figure><p>输出大概是这样:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tester.py:19: unused import <span class="string">&#x27;time&#x27;</span> (90% confidence)</span><br><span class="line">tester.py:181: unused variable <span class="string">&#x27;raw_img&#x27;</span> (100% confidence)</span><br><span class="line">tester.py:300: unused method <span class="string">&#x27;run_on_video&#x27;</span> (60% confidence)</span><br><span class="line">tester.py:403: unused method <span class="string">&#x27;render_results&#x27;</span> (60% confidence)</span><br></pre></td></tr></table></figure><p>可以看到，每一行是一个检测结果，包含文件名称，行数，检测结果以及检测的置信度，可以根据这个输出来重构代码。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><a href="https://stackoverflow.com/questions/693070/how-can-you-find-unused-functions-in-python-code">https://stackoverflow.com/questions/693070/how-can-you-find-unused-functions-in-python-code</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在重构Python代码的时候，需要统计有哪些函数和变量没有用到，搜索后发现一个简单的工具&lt;a href=&quot;https://pypi.org/project/vulture/&quot;&gt;vulture&lt;/a&gt;，可以完成这个功能。 &lt;/p&gt;
&lt;p&gt;操作也很简单, pip 安装包：&lt;/p</summary>
      
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>neovim/vim 中遇到jedi-vim 插件报错解决</title>
    <link href="http://vra.github.io/2021/11/06/neovim-jedi-error/"/>
    <id>http://vra.github.io/2021/11/06/neovim-jedi-error/</id>
    <published>2021-11-06T06:45:03.000Z</published>
    <updated>2021-11-06T06:56:25.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><a href="https://github.com/davidhalter/jedi-vim">jedi-vim</a>是vim/neovim的Python代码自动补全插件，很好用，不过最近遇到这样一个问题，用neovim 打开python文件时，会有这样的提示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error: jedi-vim failed to initialize Python: jedi<span class="comment">#setup_python_imports: ImportError: bad magic number in &#x27;jedi.common&#x27;:</span></span><br></pre></td></tr></table></figure><p>这里记录一下解决办法.</p><span id="more"></span><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>这个问题可能是更新<code>jedi-vim</code>插件时, 缓存的<code>.pyc</code> 文件没删除导致的，因此我们找到插件目录，手动删除这种类型的文件就行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果使用的是vim，将下面路径中的~/.nvim 替换为~/.vim</span></span><br><span class="line"><span class="built_in">cd</span> ~/.nvim/bundle/jedi-vim</span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.pyc&quot;</span> -<span class="built_in">exec</span> rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://github.com/davidhalter/jedi-vim/issues/1026">https://github.com/davidhalter/jedi-vim/issues/1026</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/davidhalter/jedi-vim&quot;&gt;jedi-vim&lt;/a&gt;是vim/neovim的Python代码自动补全插件，很好用，不过最近遇到这样一个问题，用neovim 打开python文件时，会有这样的提示：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Error: jedi-vim failed to initialize Python: jedi&lt;span class=&quot;comment&quot;&gt;#setup_python_imports: ImportError: bad magic number in &amp;#x27;jedi.common&amp;#x27;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里记录一下解决办法.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="错误汇总" scheme="http://vra.github.io/tags/%E9%94%99%E8%AF%AF%E6%B1%87%E6%80%BB/"/>
    
    <category term="neovim" scheme="http://vra.github.io/tags/neovim/"/>
    
  </entry>
  
  <entry>
    <title>Mac 下 Unable to load OpenGL library 的解决办法</title>
    <link href="http://vra.github.io/2021/11/04/mac-opengl-load-error/"/>
    <id>http://vra.github.io/2021/11/04/mac-opengl-load-error/</id>
    <published>2021-11-04T12:03:02.000Z</published>
    <updated>2021-11-06T05:12:33.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在Mac上使用Pyrender时，出现了OpenGL无法加载的错误，具体复现情况如下:<br>打开Python的REPL, 输入下面的命令(前提是安装pyrender):</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyrender</span><br></pre></td></tr></table></figure><p>报下面的错：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">raise ImportError(<span class="string">&quot;Unable to load OpenGL library&quot;</span>, *err.args)</span><br><span class="line">ImportError: (<span class="string">&#x27;Unable to load OpenGL library&#x27;</span>, <span class="string">&quot;dlopen(OpenGL, 0x000A): tried: &#x27;OpenGL&#x27; (no such file), &#x27;/usr/local/lib/OpenGL&#x27; (no such file), &#x27;/usr/lib/OpenGL&#x27; (no such file), &#x27;/usr/local/lib/OpenGL&#x27; (no such file), &#x27;/usr/lib/OpenGL&#x27; (no such file)&quot;</span>, <span class="string">&#x27;OpenGL&#x27;</span>, None)</span><br></pre></td></tr></table></figure><p>这里记录一下解决的办法。</p><span id="more"></span><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>解决办法比较简单，首先找到<code>OpenGL</code>的安装目录:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> python3 -c <span class="string">&quot;import OpenGL; print(OpenGL.__path__)&quot;</span></span><br><span class="line"> <span class="comment"># 输出路径</span></span><br><span class="line">[<span class="string">&#x27;/usr/local/lib/python3.7/site-packages/OpenGL&#x27;</span>]</span><br></pre></td></tr></table></figure><p>有了包路径后，修改包目录下的<code>platform/ctypesloader.py</code>文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /usr/<span class="built_in">local</span>/lib/python3.7/site-packages/OpenGL/platform/ctypesloader.py</span><br></pre></td></tr></table></figure><p>将第35行注释掉，添加新的一行代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原先的代码</span></span><br><span class="line"><span class="comment">#fullName = util.find_library( name )</span></span><br><span class="line"><span class="comment"># 新的代码</span></span><br><span class="line">fullName = <span class="string">&#x27;/System/Library/Frameworks/OpenGL.framework/OpenGL&#x27;</span></span><br></pre></td></tr></table></figure><p>然后就可以正常运行了。<br>注意：不用确认路径<code>/System/Library/Frameworks/OpenGL.framework/OpenGL</code>是否存在，只需原样修改代码即可.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://stackoverflow.com/questions/63475461/unable-to-import-opengl-gl-in-python-on-macos/64021312#64021312">https://stackoverflow.com/questions/63475461/unable-to-import-opengl-gl-in-python-on-macos/64021312#64021312</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;在Mac上使用Pyrender时，出现了OpenGL无法加载的错误，具体复现情况如下:&lt;br&gt;打开Python的REPL, 输入下面的命令(前提是安装pyrender):&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pyrender&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;报下面的错：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;raise ImportError(&lt;span class=&quot;string&quot;&gt;&amp;quot;Unable to load OpenGL library&amp;quot;&lt;/span&gt;, *err.args)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ImportError: (&lt;span class=&quot;string&quot;&gt;&amp;#x27;Unable to load OpenGL library&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;dlopen(OpenGL, 0x000A): tried: &amp;#x27;OpenGL&amp;#x27; (no such file), &amp;#x27;/usr/local/lib/OpenGL&amp;#x27; (no such file), &amp;#x27;/usr/lib/OpenGL&amp;#x27; (no such file), &amp;#x27;/usr/local/lib/OpenGL&amp;#x27; (no such file), &amp;#x27;/usr/lib/OpenGL&amp;#x27; (no such file)&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;OpenGL&amp;#x27;&lt;/span&gt;, None)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里记录一下解决的办法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="macOS" scheme="http://vra.github.io/tags/macOS/"/>
    
    <category term="OpenGL" scheme="http://vra.github.io/tags/OpenGL/"/>
    
    <category term="错误汇总" scheme="http://vra.github.io/tags/%E9%94%99%E8%AF%AF%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>git 从别的分支复制文件或目录</title>
    <link href="http://vra.github.io/2021/09/25/git-copy-from-another-branch/"/>
    <id>http://vra.github.io/2021/09/25/git-copy-from-another-branch/</id>
    <published>2021-09-25T02:46:43.000Z</published>
    <updated>2021-09-25T03:22:48.049Z</updated>
    
    <content type="html"><![CDATA[<p>有时候我们需要从别的分支复制文件或者目录，这里总结一些简单的命令供查看。</p><span id="more"></span><p>假设我们的当前分支为<code>branch1</code>, 想要复制文件或者目录的分支为<code>branch2</code>, 两个分支下文件结构是不同的，具体如下：<br>branch1: </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── README.md</span><br><span class="line">├── cpp</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   └── test.hpp</span><br><span class="line">│   └── src</span><br><span class="line">│       └── test.cpp</span><br><span class="line">└── python</span><br><span class="line">    └── setup.py</span><br></pre></td></tr></table></figure><p>branch2:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── README.md</span><br><span class="line">└── java</span><br><span class="line">    └── test.java</span><br><span class="line">    └── main.java</span><br></pre></td></tr></table></figure><p>假设我们当前在<code>branch1</code>, 目录为仓库根目录，想要复制<code>branch2</code> 的 java/test.java` 到当前目录，执行下面的语句:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout branch2 -- java/test.java</span><br></pre></td></tr></table></figure><p><strong>⚠️注意：这里还是会创建一个<code>java</code>目录，而不是把<code>test.java</code>放到根目录下。</strong></p><p>如果当前进入了<code>cpp</code> 子目录，后面的路径也需要改成相对路径:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout branch2 -- ../java/test.java</span><br></pre></td></tr></table></figure><p>如果想要复制整个目录，也是一样的:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout branch2 -- java</span><br></pre></td></tr></table></figure><p>此外还可以利用提交的hash值来复制文件，这样就会复制当次提交时候的文件内容:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 941b6dd java/test.java</span><br></pre></td></tr></table></figure><p>参考：</p><ol><li><a href="https://www.tutsway.com/how-to-copy-file-or-folder-from-one-branch-to-another-in-git.php">https://www.tutsway.com/how-to-copy-file-or-folder-from-one-branch-to-another-in-git.php</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;有时候我们需要从别的分支复制文件或者目录，这里总结一些简单的命令供查看。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>back-to-landscape——博客迁移记录2021</title>
    <link href="http://vra.github.io/2021/09/04/back-to-landscape/"/>
    <id>http://vra.github.io/2021/09/04/back-to-landscape/</id>
    <published>2021-09-04T15:46:21.000Z</published>
    <updated>2021-09-04T16:11:08.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>2019年的时候，写了一篇<a href="https://vra.github.io/2019/02/27/mv-to-next/">博客</a>来记录博客历史的迁移记录，这两年又经过工作变化、硬盘损坏，博客也是几经变迁。</p><p>尝试了基于Go的hugo框架，总体美观度和Hexo还是没法比，因此还是切换回了Hexo，换用了默认的landscape主题，重心放到有效的内容的记录上。评论系统还是采用valine，而在landscape下，设置valine还比Next复杂一些，我从<a href="http://hypo1986.com/blog/2019/06/10/hexo-landscape-add-valine/">这里</a> 看到除了配置landscape项目，还需要在ejs文件里面设置，这里记录下。</p><span id="more"></span><h2 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h2><p>修改主题config 文件 <code>HEXO_ROOT/themes/landscape/_config.yml</code>, 添加下面内容:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># valine comment system. https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># if you want use valine,please set this value is true</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="string">wwwwweirowjreojwreoz</span> <span class="comment"># leancloud application app id</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="string">weiojwoerjoerj#</span> <span class="string">leancloud</span> <span class="string">application</span> <span class="string">app</span> <span class="string">key</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># valine mail notify (true/false) https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># valine verify code (true/false)</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># comment list page size</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># gravatar style https://valine.js.org/#/avatar</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">zh-cn</span> <span class="comment"># i18n: zh-cn/en</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">欢迎留言交流~~</span> <span class="comment"># valine comment input placeholder(like: Please leave your footprints )</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment">#valine comment header info</span></span><br></pre></td></tr></table></figure><p>appid 和 appkey 从 leancloud 网站获取.</p><p>修改ejs文件<code>HEXO_ROOT/themes/landscape/layout/_partial/after-footer.ejs</code>，添加下面内容：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span>(theme.valine.enable &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey)&#123; %&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/valine/dist/Valine.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> GUEST_INFO = [<span class="string">&#x27;nick&#x27;</span>,<span class="string">&#x27;mail&#x27;</span>,<span class="string">&#x27;link&#x27;</span>];</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> guest_info = <span class="string">&#x27;&lt;%= theme.valine.guest_info %&gt;&#x27;</span>.split(<span class="string">&#x27;,&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span> GUEST_INFO.indexOf(item) &gt; -<span class="number">1</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> notify = <span class="string">&#x27;&lt;%= theme.valine.notify %&gt;&#x27;</span> == <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> verify = <span class="string">&#x27;&lt;%= theme.valine.verify %&gt;&#x27;</span> == <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">new</span> Valine(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">el</span>: <span class="string">&#x27;.vcomment&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">notify</span>: notify,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">verify</span>: verify,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">appId</span>: <span class="string">&quot;&lt;%= theme.valine.appid %&gt;&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">appKey</span>: <span class="string">&quot;&lt;%= theme.valine.appkey %&gt;&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">placeholder</span>: <span class="string">&quot;&lt;%= theme.valine.placeholder %&gt;&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">pageSize</span>: <span class="string">&#x27;&lt;%= theme.valine.pageSize %&gt;&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">avatar</span>: <span class="string">&#x27;&lt;%= theme.valine.avatar %&gt;&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">lang</span>: <span class="string">&#x27;&lt;%= theme.valine.lang %&gt;&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">visitor</span>: <span class="string">&#x27;true&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>修改<code>HEXO_ROOT/themes/landscape/layout/_partial/article.ejs</code> 文件，最后添加下面内容：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (!index &amp;&amp; post.comments &amp;&amp; theme.valine.enable &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey)&#123; %&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;comments&quot;</span> <span class="attr">class</span>=<span class="string">&quot;vcomment&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;2019年的时候，写了一篇&lt;a href=&quot;https://vra.github.io/2019/02/27/mv-to-next/&quot;&gt;博客&lt;/a&gt;来记录博客历史的迁移记录，这两年又经过工作变化、硬盘损坏，博客也是几经变迁。&lt;/p&gt;
&lt;p&gt;尝试了基于Go的hugo框架，总体美观度和Hexo还是没法比，因此还是切换回了Hexo，换用了默认的landscape主题，重心放到有效的内容的记录上。评论系统还是采用valine，而在landscape下，设置valine还比Next复杂一些，我从&lt;a href=&quot;http://hypo1986.com/blog/2019/06/10/hexo-landscape-add-valine/&quot;&gt;这里&lt;/a&gt; 看到除了配置landscape项目，还需要在ejs文件里面设置，这里记录下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="迁移记录" scheme="http://vra.github.io/tags/%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Hexo" scheme="http://vra.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>C++ 耗时统计代码片段</title>
    <link href="http://vra.github.io/2021/09/04/cpp-time-count/"/>
    <id>http://vra.github.io/2021/09/04/cpp-time-count/</id>
    <published>2021-09-04T03:44:38.000Z</published>
    <updated>2021-09-04T04:25:31.125Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 耗时统计代码片段</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::chrono::milliseconds ms;</span><br><span class="line"><span class="keyword">using</span> clk = std::chrono::system_clock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_my_work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// work code here</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> begin_time = clk::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">do_my_work</span>();</span><br><span class="line"><span class="keyword">auto</span> end_time = clk::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> duration_nn = std::chrono::duration_cast&lt;ms&gt;(end_time - begin_time);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;timecost: &quot;</span> &lt;&lt; (<span class="keyword">double</span>)duration_nn.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C++ 耗时统计代码片段&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="C++" scheme="http://vra.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>VIM 查漏补缺</title>
    <link href="http://vra.github.io/2021/08/28/vim-learn/"/>
    <id>http://vra.github.io/2021/08/28/vim-learn/</id>
    <published>2021-08-28T14:56:29.000Z</published>
    <updated>2021-09-04T14:49:31.143Z</updated>
    
    <content type="html"><![CDATA[<p>命令<br>shift-v： 选择一整行</p><p><code>*</code>：向下搜索光标所在的词<br><code>#</code>：向上搜索光标所在的词</p><p><code>w</code>: 移动到下一个单词<br><code>b</code>: 移动到上一个单词<br><code>F</code>: 搜索当前行光标前的字母<br><code>&lt;n&gt;G</code>: 移动到第n行行首<br><code>ctrl-e</code>: 屏幕向下移动，效果同<code>j</code></p><p><code>dgg</code>: 删除文档开头到当前行的内容<br><code>dG</code>: 删除当前行到文档末尾的内容<br><code>ggdG</code>: 删除文档所有内容</p><p><code>dip</code>: 删除当前行所在段落(到下一个空行)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;命令&lt;br&gt;shift-v： 选择一整行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt;：向下搜索光标所在的词&lt;br&gt;&lt;code&gt;#&lt;/code&gt;：向上搜索光标所在的词&lt;/p&gt;
&lt;p&gt;&lt;code&gt;w&lt;/code&gt;: 移动到下一个单词&lt;br&gt;&lt;code&gt;b&lt;/code&gt;: 移动到</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="Vim" scheme="http://vra.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch使用交叉熵损失时的一个坑</title>
    <link href="http://vra.github.io/2021/08/21/pytorch-cross-entropy/"/>
    <id>http://vra.github.io/2021/08/21/pytorch-cross-entropy/</id>
    <published>2021-08-20T23:03:13.000Z</published>
    <updated>2021-08-20T23:25:14.412Z</updated>
    
    <content type="html"><![CDATA[<p>在Pytorch里面使用交叉熵loss函数的时候，发现结果最是比较差，通过搜索才发现这样一段话：</p><blockquote><p>You should pass raw logits to nn.CrossEntropyLoss, since the function itself applies F.log_softmax and nn.NLLLoss() on the input.</p></blockquote><p>也就是用交叉熵损失的时候，不能在网络的最后用 <code>log_softmax</code> 或者 <code>Softmax</code>层，因为交叉熵损失相当与是 <code>log_softmax</code> + <code>NLLLos</code>的组合。</p><p>如果网络最后用了Softmax层的话，需要使用 <code>NLLLoss</code> 或者 <code>MSE loss</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><ol><li><a href="https://discuss.pytorch.org/t/logsoftmax-vs-softmax/21386/9">https://discuss.pytorch.org/t/logsoftmax-vs-softmax/21386/9</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Pytorch里面使用交叉熵loss函数的时候，发现结果最是比较差，通过搜索才发现这样一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You should pass raw logits to nn.CrossEntropyLoss, since the functio</summary>
      
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="Deep Learning" scheme="http://vra.github.io/tags/Deep-Learning/"/>
    
    <category term="Pytorch" scheme="http://vra.github.io/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>我关注的一些独立技术博客</title>
    <link href="http://vra.github.io/2021/08/21/blog-list/"/>
    <id>http://vra.github.io/2021/08/21/blog-list/</id>
    <published>2021-08-20T16:25:39.000Z</published>
    <updated>2021-08-20T16:29:39.792Z</updated>
    
    <content type="html"><![CDATA[<p>这里列出了我平时关注的一些技术博客列表，希望给看到这个页面的你一些新的知识来源：</p><ol><li><a href="https://ruanyifeng.com/">https://ruanyifeng.com/</a> 阮一峰的网络日志，应该不需要我介绍他是谁了吧</li><li><a href="https://ring0.me/">https://ring0.me/</a> 科大师兄的网站</li><li><a href="http://blog.devtang.com/">http://blog.devtang.com/</a> </li><li><a href="https://www.yejianye.com/">https://www.yejianye.com/</a></li><li><a href="https://ewind.us/">https://ewind.us/</a></li><li><a href="https://www.barretlee.com/entry/">https://www.barretlee.com/entry/</a></li><li><a href="https://www.hahack.com/">https://www.hahack.com/</a></li></ol><p>另外发现，最近大家不怎么更新自己的博客了，至于为什么，我想了几个可能的原因。</p><p>一个是缺少来自用户的反馈，或者激励。大部分博客，来自读者的反馈少，不像知乎，微信公众号，有方便及时的用户反馈和激励（点赞，在看，收藏)，反馈少对作者写作的积极性应该还是很有很大影响的。</p><p>另一个是写博客还是有一定成本的。自己搭建的博客，需要自己维护环境，不像公众号和知乎，打开网页就能写，实时保存草稿。</p><p>在中文互联网越来越碎片化和圈地化的今天，希望独立的技术博客能给我们带来新的思路，新的启发，新的激动人心的东西。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里列出了我平时关注的一些技术博客列表，希望给看到这个页面的你一些新的知识来源：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://ruanyifeng.com/&quot;&gt;https://ruanyifeng.com/&lt;/a&gt; 阮一峰的网络日志，应该不需要我介绍他是谁了</summary>
      
    
    
    
    
    <category term="杂谈" scheme="http://vra.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>C++中使用pytorch保存的tensor</title>
    <link href="http://vra.github.io/2021/03/21/torch-tensor-python-to-cpp/"/>
    <id>http://vra.github.io/2021/03/21/torch-tensor-python-to-cpp/</id>
    <published>2021-03-21T10:19:28.000Z</published>
    <updated>2021-08-20T15:48:01.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近在学习Libtorch——即Pytorch的C++版本，需要使用 Pytorch 导出的 tensor 以便对模型进行 debug。下面是转换代码，总体原理是将 tensor 转换为二进制数据，再在 C++ 里面读入。</p><span id="more"></span><p>下面是 Pytorch 中的导出 tensor 示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_tensor</span>(<span class="params">device</span>):</span></span><br><span class="line">    my_tensor = torch.rand(<span class="number">3</span>, <span class="number">3</span>).to(device);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[python] my_tensor: &quot;</span>, my_tensor)</span><br><span class="line">    f = io.BytesIO()</span><br><span class="line">    torch.save(my_tensor, f, _use_new_zipfile_serialization=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;my_tensor_%s.pt&#x27;</span> % device, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> out_f:</span><br><span class="line">        <span class="comment"># Copy the BytesIO stream to the output file</span></span><br><span class="line">        out_f.write(f.getbuffer())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    save_tensor(<span class="string">&#x27;cpu&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里以导出 cpu tensor 为例，cuda tensor 也是同理。</p><p>在 C++ 中的调用示例如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;torch/torch.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">char</span>&gt; <span class="title">get_the_bytes</span><span class="params">(std::string filename)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">input</span><span class="params">(filename, std::ios::binary)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">char</span>&gt; <span class="title">bytes</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        (std::istreambuf_iterator&lt;<span class="keyword">char</span>&gt;(input)),</span></span></span><br><span class="line"><span class="params"><span class="function">        (std::istreambuf_iterator&lt;<span class="keyword">char</span>&gt;()))</span></span>;</span><br><span class="line"></span><br><span class="line">    input.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">char</span>&gt; f = <span class="built_in">get_the_bytes</span>(<span class="string">&quot;my_tensor_cpu.pt&quot;</span>);</span><br><span class="line">    torch::IValue x = torch::<span class="built_in">pickle_load</span>(f);</span><br><span class="line">    torch::Tensor my_tensor = x.<span class="built_in">toTensor</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[cpp] my_tensor: &quot;</span> &lt;&lt; my_tensor &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>torch的Python和C++版本需要保持一致，否则转换可能不成功.</li></ol><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>最近在学习Libtorch——即Pytorch的C++版本，发现使用起来异常的丝滑，写C++有了Python的体验，妙不可言。<br>后面会更新一些关于libtorch使用的文章，敬请关注。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://discuss.pytorch.org/t/how-to-load-python-tensor-in-c/88813">https://discuss.pytorch.org/t/how-to-load-python-tensor-in-c/88813</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;最近在学习Libtorch——即Pytorch的C++版本，需要使用 Pytorch 导出的 tensor 以便对模型进行 debug。下面是转换代码，总体原理是将 tensor 转换为二进制数据，再在 C++ 里面读入。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="C++" scheme="http://vra.github.io/tags/C/"/>
    
    <category term="Pytorch" scheme="http://vra.github.io/tags/Pytorch/"/>
    
    <category term="Libtorch" scheme="http://vra.github.io/tags/Libtorch/"/>
    
  </entry>
  
  <entry>
    <title>doctest 用法简介</title>
    <link href="http://vra.github.io/2021/02/02/doctest-intro/"/>
    <id>http://vra.github.io/2021/02/02/doctest-intro/</id>
    <published>2021-02-02T14:43:43.000Z</published>
    <updated>2021-08-20T15:48:01.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://docs.python.org/3/library/doctest.html">doctest</a> 是 python 系统库中用于交互式会话例子测试的工具，用于搜索以 <code>&gt;&gt;&gt;</code> 开头的语句，并且将其作为Python命令，对结果进行测试。</p><p>这个工具可以方便地用于检测自己写的库是否有bug，例如某些函数功能可能发生改变，借此工具可以方便地对代码中的示例语句进行测试。</p><span id="more"></span><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>假如我们有一个 Python 脚本 <code>foo.py</code>, 其中有一些 <code>&gt;&gt;&gt;</code> 命令：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file name: foo.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">My square function.</span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>a = my_square(4)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>b = my_square(3)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>a + b</span></span><br><span class="line"><span class="string">25</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_square</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">return</span> num * num</span><br></pre></td></tr></table></figure><p>为了测试我们的 docstring 中的示例用法（即以<code>&gt;&gt;&gt;</code> 开头的命令）是否跟代码实现相符合，可以使用下面的命令来操作：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m doctest foo.py</span><br></pre></td></tr></table></figure><p>没有报错的话默认是没有输出的，如果要看中间的执行信息，可以增加 <code>-v</code> 参数:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m doctest -v foo.py</span><br></pre></td></tr></table></figure><p>另外针对只有运行命令记录，没有 python 语句的情况，可以把把命令记录保存到 <code>.txt</code> 文件中，然后使用同样的调用命令。例如把下面的内容保存到 <code>foo.txt</code> 文件中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a, b = 2, 3</span><br><span class="line">&gt;&gt;&gt; a+b</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>那么就可以使用下面的命令调用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m doctest -v foo.txt</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Trying:</span><br><span class="line">    a, b = 2, 3</span><br><span class="line">Expecting nothing</span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    a+b</span><br><span class="line">Expecting:</span><br><span class="line">    5</span><br><span class="line">ok</span><br><span class="line">1 items passed all tests:</span><br><span class="line">   2 tests <span class="keyword">in</span> foo.txt</span><br><span class="line">2 tests <span class="keyword">in</span> 1 items.</span><br><span class="line">2 passed and 0 failed.</span><br><span class="line">Test passed.</span><br></pre></td></tr></table></figure><p>可以看到 <code>doctest</code> 会对文件中的每一行进行读取，然后计算期望的值和实际的值是否一样，如果不一样就会报错。例如我们尝试修改上面的 <code>foo.txt</code> 为下面的内容:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a, b = 2, 3</span><br><span class="line">&gt;&gt;&gt; a+b</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>即故意把2+3的结果修改为6，执行 <code>doctest</code> 命令，结果如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Trying:</span><br><span class="line">    a, b = 2, 3</span><br><span class="line">Expecting nothing</span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    a+b</span><br><span class="line">Expecting:</span><br><span class="line">    6</span><br><span class="line">**********************************************************************</span><br><span class="line">File <span class="string">&quot;foo.txt&quot;</span>, line 2, <span class="keyword">in</span> foo.txt</span><br><span class="line">Failed example:</span><br><span class="line">    a+b</span><br><span class="line">Expected:</span><br><span class="line">    6</span><br><span class="line">Got:</span><br><span class="line">    5</span><br><span class="line">**********************************************************************</span><br><span class="line">1 items had failures:</span><br><span class="line">   1 of   2 <span class="keyword">in</span> foo.txt</span><br><span class="line">2 tests <span class="keyword">in</span> 1 items.</span><br><span class="line">1 passed and 1 failed.</span><br><span class="line">***Test Failed*** 1 failures.</span><br></pre></td></tr></table></figure><p>可以看到，测试出错了，而且出错的详细信息也列出来了。</p><p>另一种使用的方法是在 python 脚本中增加 <code>doctest.testmod()</code> 函数调用，方法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file-name: foo.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">example usage:</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>a, b = 2, 3</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>a+b</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></table></figure><p>使用下面的命令来执行脚本:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 foo.py -v</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Trying:</span><br><span class="line">    a, b = 2, 3</span><br><span class="line">Expecting nothing</span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    a+b</span><br><span class="line">Expecting:</span><br><span class="line">    5</span><br><span class="line">ok</span><br><span class="line">1 items passed all tests:</span><br><span class="line">   2 tests <span class="keyword">in</span> __main__</span><br><span class="line">2 tests <span class="keyword">in</span> 1 items.</span><br><span class="line">2 passed and 0 failed.</span><br><span class="line">Test passed.</span><br></pre></td></tr></table></figure><p>对于 <code>.txt</code> 文件的测试，使用 <code>doctest.testfile()</code> 函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> doctest</span><br><span class="line">doctest.testfile(<span class="string">&quot;example.txt&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="一些使用注意点"><a href="#一些使用注意点" class="headerlink" title="一些使用注意点"></a>一些使用注意点</h2><ol><li><code>&gt;&gt;&gt;</code> 缩进多个层次对结果没有影响，<code>doctest</code> 测试之前会对每行前面的空格进行删除。</li><li>doctest 也可以对Error 进行测试，如果想要测试各种特殊case导致的错误的话，doctest是个不错的工具</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/library/doctest.html&quot;&gt;doctest&lt;/a&gt; 是 python 系统库中用于交互式会话例子测试的工具，用于搜索以 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 开头的语句，并且将其作为Python命令，对结果进行测试。&lt;/p&gt;
&lt;p&gt;这个工具可以方便地用于检测自己写的库是否有bug，例如某些函数功能可能发生改变，借此工具可以方便地对代码中的示例语句进行测试。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="Unit Test" scheme="http://vra.github.io/tags/Unit-Test/"/>
    
  </entry>
  
  <entry>
    <title>C++中的string_view</title>
    <link href="http://vra.github.io/2021/01/23/cpp-summary-stringview/"/>
    <id>http://vra.github.io/2021/01/23/cpp-summary-stringview/</id>
    <published>2021-01-23T07:40:39.000Z</published>
    <updated>2021-08-20T15:48:01.043Z</updated>
    
    <content type="html"><![CDATA[<p>C++17标准库里面引入了轻量级的只读字符串表示类型<code>string_view</code>，用来替代<code>const char*</code> 和<code>const string&amp;</code>，在传入函数的时候减小内存开销(因为<code>string_view</code>类只包含字符串的指针和字符串的长度值，开销小于<code>string</code>类型)。</p><span id="more"></span><p><code>string_view</code> 定义在头文件<code>&lt;string_view&gt;</code>中。</p><p>具体来说，C++17里面引入了模板类<code>basic_string_view</code>类，而<code>string_view</code>是针对<code>char</code>特化的类，如头文件中所表示的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> string_view = basic_string_view&lt;<span class="keyword">char</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> u8string_view = basic_string_view&lt;<span class="keyword">char8_t</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> u16string_view = basic_string_view&lt;<span class="keyword">char16_t</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> u32string_view = basic_string_view&lt;<span class="keyword">char32_t</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> wstring_view   = basic_string_view&lt;<span class="keyword">wchar_t</span>&gt;;</span><br></pre></td></tr></table></figure><p>可以看到针对不同类型的字符数组，都有对应的只读view。<br>顺便提一下，上述代码中用到的<code>using</code>用法是C++11引入的类型重定义（type alias)，可以给类型和函数起别名，下面是官方给的示例用法:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// type alias, identical to</span></span><br><span class="line"><span class="comment">// typedef std::ios_base::fmtflags flags;</span></span><br><span class="line"><span class="keyword">using</span> flags = std::ios_base::fmtflags;</span><br><span class="line"><span class="comment">// the name &#x27;flags&#x27; now denotes a type:</span></span><br><span class="line">flags fl = std::ios_base::dec;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// type alias, identical to</span></span><br><span class="line"><span class="comment">// typedef void (*func)(int, int);</span></span><br><span class="line"><span class="keyword">using</span> func = <span class="built_in"><span class="keyword">void</span></span> (*) (<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// the name &#x27;func&#x27; now denotes a pointer to function:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">func f = example;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// alias template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">using</span> ptr = T*; </span><br><span class="line"><span class="comment">// the name &#x27;ptr&lt;T&gt;&#x27; is now an alias for pointer to T</span></span><br><span class="line">ptr&lt;<span class="keyword">int</span>&gt; x;</span><br></pre></td></tr></table></figure><p><code>string_view</code> 使用方法与<code>string</code>一样，而且可以由<code>string</code>类型对象相互初始化，如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string_view <span class="title">sv1</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">s1</span><span class="params">(sv1)</span></span>;</span><br><span class="line"><span class="function">std::string_view <span class="title">sv2</span><span class="params">(s1)</span></span>;</span><br></pre></td></tr></table></figure><p>实际测试发现，相同的字符串，<code>string_view</code> 对象的大小确实比<code>string</code>对象要小，比如下面的例子：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::string_view <span class="title">sv1</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">s1</span><span class="params">(sv1)</span></span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size of string_view: &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(sv1) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size of string: &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s1) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在32位的机器下(x86)，输出如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">size of string_view: 8</span><br><span class="line">size of string: 28</span><br></pre></td></tr></table></figure><p>因为<code>string_view</code> 只包含一个指向字符串的指针(*)和一个表示数组大小的整型数值(<code>int</code>)，因此总大小是4+4=8。而<code>string</code>是容器类型，内部结构我不太清楚，看输出整体是要比<code>string_view</code>大挺多的。</p><p>如果想在C++11的环境下使用C++17才引入的<code>string_view</code>，可以使用谷歌推出的<a href="https://github.com/abseil/abseil-cpp">absl库</a>，这个库在C++11的环境下实现了很多C++14，17甚至20里面才提出的新特性，可以尝试一下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++17标准库里面引入了轻量级的只读字符串表示类型&lt;code&gt;string_view&lt;/code&gt;，用来替代&lt;code&gt;const char*&lt;/code&gt; 和&lt;code&gt;const string&amp;amp;&lt;/code&gt;，在传入函数的时候减小内存开销(因为&lt;code&gt;string_view&lt;/code&gt;类只包含字符串的指针和字符串的长度值，开销小于&lt;code&gt;string&lt;/code&gt;类型)。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://vra.github.io/tags/C/"/>
    
    <category term="C++17" scheme="http://vra.github.io/tags/C-17/"/>
    
  </entry>
  
  <entry>
    <title>python虚拟环境管理工具venv教程</title>
    <link href="http://vra.github.io/2021/01/03/venv-intro/"/>
    <id>http://vra.github.io/2021/01/03/venv-intro/</id>
    <published>2021-01-03T01:56:04.000Z</published>
    <updated>2021-08-20T15:48:01.049Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-概述"><a href="#0-概述" class="headerlink" title="0. 概述"></a>0. 概述</h3><p>Python有各种各样的系统包和第三方开发的包，让我们的开发变得异常容易。不过也引入了一个问题，不同代码需要的包版本可能是不一样的，所以常常回出现这种情况，为了代码B修改了依赖包的版本，代码B能work了，之前使用的代码A就没法正常工作了。因此常常需要对不同的代码设置不同的Python虚拟环境。<a href="https://docs.python.org/zh-cn/3/tutorial/venv.html">venv</a>是Python自带的虚拟环境管理工具，使用很方便，这里简单记录一下使用方法。</p><span id="more"></span><p>需要注意的是，venv 工具没法创建不同版本的python环境，也就是如果你用python3.5没法创建python3.6的虚拟环境。如果想要使用不同python版本的虚拟环境，请安装 virtual env包。</p><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>python3.6及以上已经默认安装，python3.5需要通过系统的包管理工具安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-venv</span><br></pre></td></tr></table></figure><h3 id="2-创建虚拟环境"><a href="#2-创建虚拟环境" class="headerlink" title="2. 创建虚拟环境"></a>2. 创建虚拟环境</h3><p>在<code>~/test_env</code>目录下创建虚拟环境：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m venv test_env</span><br></pre></td></tr></table></figure><h3 id="3-启用虚拟环境"><a href="#3-启用虚拟环境" class="headerlink" title="3. 启用虚拟环境"></a>3. 启用虚拟环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/test_env/bin/activate</span><br></pre></td></tr></table></figure><p>可以看到，命令行的提示符前面会出现括号，里面是虚拟环境名称。</p><p>使用<code>pip</code>安装需要的包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install tensorflow</span><br></pre></td></tr></table></figure><p>注意这里不需要root权限，因此无需添加<code>sudo</code>。</p><p>安装的包会放在<code>~/test_env/lib/pythonx.x/site-packages</code> 目录下。</p><h3 id="4-退出虚拟环境"><a href="#4-退出虚拟环境" class="headerlink" title="4. 退出虚拟环境"></a>4. 退出虚拟环境</h3><p>退出虚拟的python环境，在命令行执行下面的命令即可：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;0-概述&quot;&gt;&lt;a href=&quot;#0-概述&quot; class=&quot;headerlink&quot; title=&quot;0. 概述&quot;&gt;&lt;/a&gt;0. 概述&lt;/h3&gt;&lt;p&gt;Python有各种各样的系统包和第三方开发的包，让我们的开发变得异常容易。不过也引入了一个问题，不同代码需要的包版本可能是不一样的，所以常常回出现这种情况，为了代码B修改了依赖包的版本，代码B能work了，之前使用的代码A就没法正常工作了。因此常常需要对不同的代码设置不同的Python虚拟环境。&lt;a href=&quot;https://docs.python.org/zh-cn/3/tutorial/venv.html&quot;&gt;venv&lt;/a&gt;是Python自带的虚拟环境管理工具，使用很方便，这里简单记录一下使用方法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="venv" scheme="http://vra.github.io/tags/venv/"/>
    
  </entry>
  
  <entry>
    <title>2020年终总结</title>
    <link href="http://vra.github.io/2021/01/02/summary-2020/"/>
    <id>http://vra.github.io/2021/01/02/summary-2020/</id>
    <published>2021-01-02T01:06:13.000Z</published>
    <updated>2021-08-20T15:48:01.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2020流水记录"><a href="#2020流水记录" class="headerlink" title="2020流水记录"></a>2020流水记录</h2><p>新的一年又开始了，记录一下2020年发生的一些事情，作为对这不平凡的一年的简单的回顾。</p><p>1月14日，农历腊月二十，我和彤彤在我家结婚了，作为主人翁参与其中，是一种很神奇却很美好的感觉，结婚的大小事情都是爸妈和村里的亲戚邻居一起来做的，很感谢爸妈亲戚邻居们的付出，让寒冬里面的腊月二十热闹而温暖。</p><p>关于结婚几天发生的事情，我写了一些流水账记录，不过后面没有完全写完，等有空了再回忆回忆，完全写完再发出来吧，也算是给自己一个交代。</p><p>总之非常感谢所有人的帮助和支持。</p><span id="more"></span><p>结完婚没多久就过年了，因为疫情影响，各个村都封路了，因此很多亲戚都没能走成，一年一度的见面也落空了。那段时间只能待在家里，每天看关于疫情的新闻，心里很紧张，担心疫情失控。我甚至还想过，疫情会不会让人像恐龙一样，因为突发事件而灭绝，现在看来是太悲观了，而且杞人忧天不止一星半点。</p><p>转眼春节假期结束了，关于开工的问题，公司决定远程上班两周，再回北京到办公室上班。彤彤和云亮的单位也是类似的政策。因此我们体验了在家里上班的有趣的日子。</p><p>每天早上起来，妈已经做好了早饭，吃完后就去上阁房的桌子前办公，网不好时去中间屋子看看网。一早上是电话开会，开完会开始干活，晚上写日报。云亮和彤彤也是类似的样子，开会，看资料，写总结。</p><p>这次疫情证明了远程办公其实是可行的，这让我不禁想，也许未来我就在老家的房子里，烤着温暖的炉子，吃着妈做的好吃的饭，远程为某个遥远的大城市的公司干活。这样家人和工作都能两全，是我理想中想要的生活。当然还有一些需要解决的问题，比如远程工作如何保证效率等等。</p><p>两周后，农历二月二一过，我和云亮就在包叔的车的接送下，穿过封锁状况未知的村村镇镇，达到陇西火车站，坐上了回北京的车。走之前爸专门去村里的大队部开了一个类似通行证的材料，证明我们没有接触过感染人员，请让我们通行，有种类似护照的感觉，也算是今年这个特殊时刻特别的纪念物品了吧。</p><p>我还记得刚到北京，地铁里面空荡荡的，大街上也没有多少人，有点像一座空城。</p><p>后来渐渐地，在强大的国家的有效管控以及医护人员巨大的付出下，疫情受到控制，小区也从进出严格登记，到检查通行证，到最后基本不检查，年中的时候带口罩就好了。</p><p>因为结婚了，我俩开始更具体地想以后的生活，最直接的是，去哪座城市定居。我们考虑过成都，西安，杭州，南京这些地方，最后因为一些机遇，我俩决定去杭州，后面的规划和目标也渐渐清晰了起来。</p><p>6在月底的时候，我们转移到杭州了。还好有云亮在北京，我们这次转移才比较容易，很多东西都是他后面给我们寄过来的。</p><p>还记得刚到杭州的那天晚上，出永福地铁站的时候，天已经全黑了，外面下着小雨，我俩看着陌生的地方，想着要开始一段全新的旅程，心里激动不已。</p><p>然后我们开始租房子，确定住哪边。在梅雨季节里，我们体验了杭州的潮湿和闷热，好在出梅后，一切都还算适应。</p><p>然后开始上班，周末和假日也去玩了很多地方，包括云栖竹径，五云寺，北高峰，杭州植物园，良渚文化村，西溪湿地，还有西湖。</p><p>七月份组内出游活动，我们组去了爬了黄山，去宏村参观了古村落，还去屯溪老街转了转。当然出去玩是一方面，更重要的是团队建设，也是了解组内氛围的好机会，确实借此机会，我也了解到组内公开透明，相互尊重的氛围，让我印象很深刻，也确信是值得加入的。</p><p>国庆假期，我和彤彤在秦安下高铁后，坐出租去庄浪，一路上听出租车司机讲了很多有意思的事情。晚上9点多到县城，少华已经在等我们了。到家后很晚了，家人们都在，团聚在一起，聊了很多。</p><p>让我印象很深的是，第二天少华，爸还有我去楼下吃牛肉面。那家店味道很好，而且一大早一起吃牛肉面的经历，也让我觉得值得记录，是家的另一种存在形式吧。</p><p>第二天高中室友老六结婚，我一大早过去，和朝哥，彦斌帮了下忙，也见到了好几年没有见的老六的爸妈和姐。高中那会他们经常来兰州看老六，每次来都请我们吃饭，带很多水果给我们，我心里很感激。高中毕业那年，我们宿舍组团来庄浪玩，度过了一个快乐又难忘的夏天。</p><p>国庆第四天彤彤家新房入住，来了很多亲戚，很热闹。这是岳父岳母自己这些年辛苦赚钱买的房子，是一个了不起的人生成就。能感觉到他们还是很自豪很开心的。我和大姐的孩子奥博玩了很久，很感叹他的学习能力。下午全家人和亲戚去饭店吃饭，我和彤彤提前离开，去坐回家的车。晚上到我家。到家后和全家人团聚在一起，是开心幸福的。</p><p>家里的葡萄成熟了，而且今年长得比较繁，吃起来比外面买的葡萄甜多了，也好吃。</p><p>在家的几天，和姨夫聊了聊，因为疫情原因过年也没见面。也和三舅三妗子聊了聊，聊了一些跑计划生育时在我家暂住时的事情。和小学同学斌斌结婚，去他家和小学同学聊了聊。去带婷婷和豪豪爬了一次山，所以才有了封面的这张照片。</p><p>国庆结束后，10月8号就回杭州继续上班了。</p><p>后面有段时间工作很忙，遇到了很难解决的问题，一行行调试代码，两三周没搞出来，心态快要崩了。某个周末，搞了两天，还是没能解决，周日晚上搞到很晚，头脑一片混乱，不得不在不甘中睡下。周一早上起来发现居然神奇地解决了，激动地哭了。后来塞远请我们吃饭，犒劳我们辛苦的几周.</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3><p>今年只写了一个标注图像的工具，<a href="https://github.com/vra/easybox">https://github.com/vra/easybox</a>，可以对图像中的物体进行矩形框标注，特色是即插即用，支持多平台，支持文件夹标注，每张图片支持任意个标注框，可以通过 <code>pip install easybox</code> 来安装使用。</p><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><p>今年又是命途多舛的一年，和飞哥，鑫焱去年投的CVPR没有中，今年先是改投eccv，没中后又改投accv，仍没有中，最后就放到了arxiv上。总之还是感谢飞哥和鑫焱的辛勤付出，大家都付出了很多，很不容易。</p><h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>今年读书有点少，只看完了不到五本，flag倒的有点厉害。分析发现，通勤时间没了，所以平均每天看书时间减少了20分钟；而且周末大部分时间在看电影和剧集，读书的时间就更少了。不过《中共党史珍闻录》对我触动很大，从第三者的角度反思了历史上的一些事件，没有粉饰也没有诋毁，太难得了。同时也让我开始思考，伟大如斯的人物都难免犯错，如我等平凡人，做错事更是容易，所以更需要跳出自我麻痹，正视自己的正确与错误，努力改进。</p><ol><li>《人体简史》</li><li>《山核桃大街谋杀案》</li><li>《流畅的Python》</li><li>《中共党史珍闻录》</li><li>《三少爷的剑》</li><li>《白发魔女传》</li></ol><h2 id="影视"><a href="#影视" class="headerlink" title="影视"></a>影视</h2><p>今年周末看了很多电影和剧集，最喜欢《小谢尔顿》了，温暖的家庭剧，大部分时候是搞笑的，有时候家人和成长的故事还是很让人动容。</p><h3 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h3><ol><li>《Hello!树先生》：小县城的场景太熟悉了，主角有点魔幻</li><li>《Her》</li><li>《树上有个好地方》：想起了小学的很多事情</li><li>《星球大战8》</li><li>《星球大战9》</li><li>《1917》：唯美的战争画面</li><li>《他们已不再变老》</li><li>《异形系列》</li><li>《真心半解》</li><li>《绅士们》</li><li>《八恶人》</li><li>《无耻混蛋》</li><li>《拯救大兵瑞恩》</li><li>《小妇人》</li><li>《婚姻故事》</li><li>《乔乔的异想世界》：感动到哭的电影</li><li>《利刃出鞘》：好的故事，引人入胜</li><li>《婚姻故事》</li><li>《绿皮书》</li><li>《波西米亚狂想曲》：主角塑造的太好了</li><li>《华盛顿邮报》</li><li>《楚门的世界》</li><li>《闻香识女人》</li><li>《银翼杀手2049》</li><li>《双子杀手》</li><li>《阿拉丁》</li><li>《白蛇·缘起》</li><li>《哪吒之魔瞳降世》</li><li>《星际探索》</li></ol><h3 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h3><ol><li>《小谢尔顿1-4季》</li><li>《爱，死亡与机器人第1季》</li><li>《曼达洛人1-2季》</li><li>《性教育第2季》</li><li>《异星灾变第1季》</li><li>《环形物语第1季》</li><li>《我们的父辈》</li><li>《生活大爆炸第12季》</li></ol><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>周末我们都会自己做饭，因为自己做的好吃也便宜。我也尝试了自己做饭，做出来味道还不坏，心里还是挺开心的。</p><p>年末的时候开始和彤彤跳绳了，每天500到1000个，感受肌肉劳累然后完成任务放松的感觉，也许跟做事情一样的道理，no pain, no gain。希望我们能坚持。</p><p>我们租的房子在12层，往西看就是很高的欧美金融城，晴天傍晚的风光很美。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>今年一直在想的一个问题是，我们是否会想现在一样，衣食无忧，每天辛勤工作，最后也会买房子生孩子，养家糊口，但最终没能给这个世界带去大的改变？<br>如果要做更多贡献，该从哪里开始改变这条常规之路呢？</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;2020流水记录&quot;&gt;&lt;a href=&quot;#2020流水记录&quot; class=&quot;headerlink&quot; title=&quot;2020流水记录&quot;&gt;&lt;/a&gt;2020流水记录&lt;/h2&gt;&lt;p&gt;新的一年又开始了，记录一下2020年发生的一些事情，作为对这不平凡的一年的简单的回顾。&lt;/p&gt;
&lt;p&gt;1月14日，农历腊月二十，我和彤彤在我家结婚了，作为主人翁参与其中，是一种很神奇却很美好的感觉，结婚的大小事情都是爸妈和村里的亲戚邻居一起来做的，很感谢爸妈亲戚邻居们的付出，让寒冬里面的腊月二十热闹而温暖。&lt;/p&gt;
&lt;p&gt;关于结婚几天发生的事情，我写了一些流水账记录，不过后面没有完全写完，等有空了再回忆回忆，完全写完再发出来吧，也算是给自己一个交代。&lt;/p&gt;
&lt;p&gt;总之非常感谢所有人的帮助和支持。&lt;/p&gt;</summary>
    
    
    
    
    <category term="年终总结" scheme="http://vra.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    <category term="2020" scheme="http://vra.github.io/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>NumPy的C++替代NumCpp使用教程</title>
    <link href="http://vra.github.io/2020/12/26/numcpp-intro/"/>
    <id>http://vra.github.io/2020/12/26/numcpp-intro/</id>
    <published>2020-12-26T03:26:36.000Z</published>
    <updated>2021-08-20T15:48:01.033Z</updated>
    
    <content type="html"><![CDATA[<p>NumPy提供了很多开箱即用的函数，用处非常大，所以写C++的时候，让人无比怀念，要是有一个替代版本，就太好了。最近搜索发现， <a href="https://github.com/dpilger26/NumCpp">NumCpp</a> 这是我想要的，而且因为是 <code>Header-only</code>的库，因此使用时不需要编译，直接添加到头文件包含目录即可，使用很方便。不过NumCpp使用了boost库，需要进行一些下载和配置，这里记录一下。</p><span id="more"></span><p>总结下来下面是需要下载的东西，我写成了几行代码，在Ubuntu下测试是可以执行的：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir includes</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/dpilger26/NumCpp.git </span><br><span class="line">mv NumCpp/include includes/NumCpp</span><br><span class="line">wget https://dl.bintray.com/boostorg/release/1.75.0/<span class="built_in">source</span>/boost_1_75_0.zip</span><br><span class="line">unzip boost_1_75_0.zip</span><br><span class="line">mv boost_1_75_0/boost includes/NumCpp</span><br></pre></td></tr></table></figure><p>这里我们创建了一个<code>includes</code>目录，用来存放NumCpp和Boost库的头文件，这里以现在 (2020-12-26) 最新的Boost 1.75.0 为例，后面boost库肯定会更新，可以从这里找到最新boost的下载地址：<a href="https://www.boost.org/users/download">https://www.boost.org/users/download</a>.</p><p>执行上面的命令后，就可以使用了NumCpp了，下面是一个使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：test_num_cpp.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;NumCpp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nc::NdArray&lt;<span class="keyword">float</span>&gt; a = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">        nc::NdArray&lt;<span class="keyword">float</span>&gt; b = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">        nc::NdArray&lt;<span class="keyword">float</span>&gt; c = a * b;</span><br><span class="line">        std::cout &lt;&lt; c[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子里面，简单地调用NumCpp最基本的类 <code>nc::NdArray</code>来进行两个2维数组的矩阵乘操作。<br>详细的教程参考：<a href="https://github.com/dpilger26/NumCpp">https://github.com/dpilger26/NumCpp</a>.<br>接下来就是编译C++代码，这里以Linux下g++编译为例说明，需要注意的有2个点:</p><ul><li>NumCpp只支持C++14以及以上版本，所以编译时需要加<code>--std=c++14</code></li><li>需要将NumCpp所在的目录添加到头文件包含指令<code>-I</code>里</li></ul><p>具体如下:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ test_num_cpp.cpp --std=c++14 -Iincludes/</span><br></pre></td></tr></table></figure><p>编译完后运行生成的可执行文件:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./a.out</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;NumPy提供了很多开箱即用的函数，用处非常大，所以写C++的时候，让人无比怀念，要是有一个替代版本，就太好了。最近搜索发现， &lt;a href=&quot;https://github.com/dpilger26/NumCpp&quot;&gt;NumCpp&lt;/a&gt; 这是我想要的，而且因为是 &lt;code&gt;Header-only&lt;/code&gt;的库，因此使用时不需要编译，直接添加到头文件包含目录即可，使用很方便。不过NumCpp使用了boost库，需要进行一些下载和配置，这里记录一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://vra.github.io/tags/C/"/>
    
    <category term="NumPy" scheme="http://vra.github.io/tags/NumPy/"/>
    
    <category term="NumCpp" scheme="http://vra.github.io/tags/NumCpp/"/>
    
  </entry>
  
</feed>
