<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yunfeng&#39;s Simple Blog</title>
  
  <subtitle>Love, Life, Linux</subtitle>
  <link href="http://vra.github.io/atom.xml" rel="self"/>
  
  <link href="http://vra.github.io/"/>
  <updated>2023-02-27T00:22:23.451Z</updated>
  <id>http://vra.github.io/</id>
  
  <author>
    <name>Yunfeng Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>libtorch系列教程2：torch::Tensor的使用</title>
    <link href="http://vra.github.io/2023/02/25/libtorch-tutorial2/"/>
    <id>http://vra.github.io/2023/02/25/libtorch-tutorial2/</id>
    <published>2023-02-25T09:15:46.000Z</published>
    <updated>2023-02-27T00:22:23.451Z</updated>
    
    <content type="html"><![CDATA[<p>系列教程列表：</p><ul><li><a href="https://vra.github.io/2023/02/25/libtorch-tutorial1/">Libtorch系列教程1：一个丝滑的C++ Tensor库</a> </li><li><a href="https://vra.github.io/2023/02/25/libtorch-tutorial2/">Libtorch系列教程2：torch::Tensor的使用</a> </li></ul><p>这篇文章中，我们暂时忽略网络训练和推理，详细展开Libtorch中Tensor对象的使用，看看将Libtorch当作一个纯粹的Tensor库来使用时，有哪些注意事项。如有未涉及的内容，请访问Libtorch<a href="https://pytorch.org/cppdocs/">官方文档</a>，通过搜索框获取更多的信息。</p><span id="more"></span><h2 id="1-torch-Tensor基本操作"><a href="#1-torch-Tensor基本操作" class="headerlink" title="1. torch::Tensor基本操作"></a>1. torch::Tensor基本操作</h2><p>Libtorch中的Tensor是与Pytorch中的Tensor对应的，使用方式上很类似，只在一些Python语法C++不支持的时候有些不同，例如slice操作。<br>Libtorch的环境搭建参考<a href="https://vra.github.io/2023/02/25/libtorch-tutorial1/">上一篇文章</a>。<br>使用Libtorch前需要包含 Libtorch 的头文件<code>torch/torch.h</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;torch/torch.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这篇文章用到的所有函数都在此头文件中声明，而且所有的函数namespace都是<code>torch</code>，因此都可以以<code>torch::xxx</code>的形式来调用。</p><h3 id="1-1-Tensor创建"><a href="#1-1-Tensor创建" class="headerlink" title="1.1 Tensor创建"></a>1.1 Tensor创建</h3><p>Tensor 创建的方式比较多，包括从字面量创建，从C++ 原生的数组创建，从vector创建，从Libtorch自带的函数创建等。</p><p>从字面量创建:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch::Tensor foo = torch::<span class="built_in">tensor</span>(&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;);</span><br></pre></td></tr></table></figure><p>从C++ 原生的float数组创建，使用<code>from_blob</code>函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> arr[] = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;;</span><br><span class="line"><span class="comment">// 第二个参数表示创建的Tensor shape，会自动对原生数组进行reshape</span></span><br><span class="line">torch::Tensor bar = torch::<span class="built_in">from_blob</span>(arr, &#123;<span class="number">1</span>, <span class="number">4</span>&#125;); <span class="comment">// shape是[1, 4]</span></span><br><span class="line">bar = torch::<span class="built_in">from_blob</span>(arr, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;); <span class="comment">// shape是[2, 2]</span></span><br></pre></td></tr></table></figure><p>其中第二个参数表示创建的Tensor shape，会自动对原生数组进行reshape。</p><p>从vector 创建，使用<code>from_blob</code>函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">float</span>&gt; v = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;;</span><br><span class="line">bar = torch::<span class="built_in">from_blob</span>(v.<span class="built_in">data</span>(), &#123;<span class="number">2</span>, <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p>还可以用Libtorch的函数创建，跟Numpy和Pytorch类似:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo = torch::<span class="built_in">arange</span>(<span class="number">4</span>);</span><br><span class="line">foo = torch::<span class="built_in">eye</span>(<span class="number">2</span>);</span><br><span class="line">foo = torch::<span class="built_in">ones</span>(<span class="number">2</span>);</span><br><span class="line">bar = torch::<span class="built_in">ones_like</span>(foo);</span><br><span class="line">foo = torch::<span class="built_in">rand</span>(<span class="number">4</span>);</span><br><span class="line">foo = torch::<span class="built_in">randn</span>(<span class="number">4</span>);</span><br><span class="line">foo = torch::<span class="built_in">zeros</span>(<span class="number">2</span>);</span><br><span class="line">bar = torch::<span class="built_in">zeros_like</span>(foo);</span><br></pre></td></tr></table></figure><p>创建好以后，Tensor对应可以直接用<code>std::cout</code>来输出:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch::Tensor foo = torch::<span class="built_in">tensor</span>(&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;);</span><br><span class="line">std::cout &lt;&lt;<span class="string">&quot;==&gt; foo is:\n&quot;</span> &lt;&lt; foo &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==&gt; foo is:</span><br><span class="line"> 1</span><br><span class="line"> 2</span><br><span class="line"> 3</span><br><span class="line"> 4</span><br><span class="line">[ CPUFloatType&#123;4&#125; ]</span><br></pre></td></tr></table></figure><p>可以看到最后打印了Tensor的类型。</p><h3 id="1-2-Tensor对象的属性函数"><a href="#1-2-Tensor对象的属性函数" class="headerlink" title="1.2 Tensor对象的属性函数"></a>1.2 Tensor对象的属性函数</h3><p>创建Tensor后，我们还需要看到它的一些属性，判断是否跟预期相符。注意Libtorch的Tensor是没有公开可访问的属性attribute的，Tensor信息需要属性函数来获取。常见的属性函数包括:</p><ul><li>dim(): Tensor的维度</li><li>sizes(): 跟Pytorch中的shape属性一样</li><li>size(n): 第N个维度的shape</li><li>numel(): 总的元素数目，sizes中的每个元素相乘</li><li>dtype(): 数据类型</li><li>device(): Tensor所在的设备类型，CPU, CUDA, MPS等。</li></ul><p>使用方式如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tensor 属性函数</span></span><br><span class="line">torch::Tensor foo = torch::<span class="built_in">randn</span>(&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>&#125;);</span><br><span class="line"><span class="keyword">auto</span> dim = foo.<span class="built_in">dim</span>(); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">auto</span> sizes = foo.<span class="built_in">sizes</span>(); <span class="comment">// [1, 3, 224, 224]</span></span><br><span class="line"><span class="keyword">auto</span> size_0 = foo.<span class="built_in">size</span>(<span class="number">0</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">auto</span> numel = foo.<span class="built_in">numel</span>(); <span class="comment">// 150528</span></span><br><span class="line"><span class="keyword">auto</span> dtype = foo.<span class="built_in">dtype</span>(); <span class="comment">// float</span></span><br><span class="line"><span class="keyword">auto</span> scalar_type = foo.<span class="built_in">scalar_type</span>(); <span class="comment">// Float</span></span><br><span class="line"><span class="keyword">auto</span> device = foo.<span class="built_in">device</span>(); <span class="comment">// cpu</span></span><br></pre></td></tr></table></figure><h3 id="1-3-Tensor对象的索引"><a href="#1-3-Tensor对象的索引" class="headerlink" title="1.3 Tensor对象的索引"></a>1.3 Tensor对象的索引</h3><p>Tensor 默认是支持<code>[]</code>操作符的，因此可以使用这样的方式来获取元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> foo = torch::<span class="built_in">randn</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line"><span class="keyword">float</span> value = foo[<span class="number">0</span>][<span class="number">1</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>另一种方式是用Tensor对象的<code>index</code>函数，它的优势是支持slice。<br>对于单个元素，可以类似Pytorch中，直接用index({i, j, k})`的方式来索引：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> foo = torch::<span class="built_in">randn</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line"><span class="keyword">float</span> value = foo.<span class="built_in">index</span>(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p>那么python中很常用的slice呢？例如<code>foo[..., :2, 1:, :-1]</code>，该怎么在Libtorch中表示？<br>这里需要用到torch::indexing::Slice` 对象，来实现Python中的Slice，看看下面的例子你就明白了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> torch::indexing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> foo = torch::<span class="built_in">randn</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line"><span class="comment">// 等效于Python中的foo[:, 0:1, 2:, :-1]</span></span><br><span class="line"><span class="keyword">auto</span> bar = foo.<span class="built_in">index</span>(&#123;<span class="built_in">Slice</span>(), <span class="built_in">Slice</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="built_in">Slice</span>(<span class="number">2</span>, None), <span class="built_in">Slice</span>(None, <span class="number">-1</span>)&#125;);</span><br></pre></td></tr></table></figure><p>应该是能满足Python中slice同样的使用场景。</p><h3 id="1-4-更新Tensor中元素的值"><a href="#1-4-更新Tensor中元素的值" class="headerlink" title="1.4 更新Tensor中元素的值"></a>1.4 更新Tensor中元素的值</h3><p>有了索引之后，我们就可以更新Tensor的值了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">torch::Tensor foo = torch::<span class="built_in">tensor</span>(&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;);</span><br><span class="line">foo[<span class="number">0</span>] = <span class="number">10.0</span>;</span><br><span class="line">foo.<span class="built_in">index</span>(&#123;<span class="number">0</span>&#125;) = <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure><p>但还没找到用给部分Tensor元素赋值的方法，类似Python中的<code>foo[:2] = bar</code>，欢迎补充。</p><h3 id="1-5-获取Tensor中的数据"><a href="#1-5-获取Tensor中的数据" class="headerlink" title="1.5 获取Tensor中的数据"></a>1.5 获取Tensor中的数据</h3><p>Tensor是一个Libtorch的对象，那怎么把它中的数据拿出来保存到文件中或传给别的函数呢？<br>使用<code>data_ptr</code>函数就可以:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch::Tensor foo = torch::<span class="built_in">randn</span>(&#123;<span class="number">3</span>, <span class="number">3</span>&#125;);</span><br><span class="line"><span class="keyword">float</span>* data = foo.data_ptr&lt;<span class="keyword">float</span>&gt;();</span><br></pre></td></tr></table></figure><p>对于单个元素的Tensor，还可以用<code>item</code>函数得到具体的数值:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch::Tensor one_element_tensor = foo.<span class="built_in">index</span>(&#123;<span class="built_in">Slice</span>(), <span class="built_in">Slice</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="built_in">Slice</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="built_in">Slice</span>(<span class="number">0</span>, <span class="number">1</span>)&#125;);</span><br><span class="line"><span class="keyword">float</span> value = one_element_tensor.item&lt;<span class="keyword">float</span>&gt;();</span><br></pre></td></tr></table></figure><h3 id="1-6-数据类型"><a href="#1-6-数据类型" class="headerlink" title="1.6 数据类型"></a>1.6 数据类型</h3><p>Libtorch中支持float16, float32, float64, int8, int16, int32, uint8这几类的Tensor数据类型，可以用<code>to</code>函数来进行类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据类型, 参见 https://pytorch.org/cppdocs/api/file_torch_csrc_api_include_torch_types.h.html#variables</span></span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kF16);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kF32);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kF64);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kFloat16);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kFloat32);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kFloat64);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kI8);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kI16);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kI32);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kI64);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kInt8);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kInt16);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kInt32);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kInt64);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kU8);</span><br><span class="line">bar = foo.<span class="built_in">to</span>(torch::kUInt8);</span><br></pre></td></tr></table></figure><p>全部数据类型，参见官方文档的<a href="https://pytorch.org/cppdocs/api/file_torch_csrc_api_include_torch_types.h.html#variables">数据类型页面</a></p><h3 id="1-7-设备类型"><a href="#1-7-设备类型" class="headerlink" title="1.7 设备类型"></a>1.7 设备类型</h3><p>设备类型是Tensor保存的设备的种类。由于Libtorch不仅仅支持CPU，还支持各种类型的GPU，因此有很多设备类型。</p><p>所有的设备类型参见<a href="https://pytorch.org/cppdocs/api/file_c10_core_DeviceType.h.html#variables">这里</a><br>需要注意的是，设备是跟编译时的配置，机器是否支持强相关的，而且某些设备支持并不好，例如我想用下面的代码将CPU上的Tensor转移到MPS上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> foo = torch::<span class="built_in">randn</span>(&#123;<span class="number">3</span>, <span class="number">3</span>&#125;);</span><br><span class="line"><span class="keyword">auto</span> bar = foo.<span class="built_in">to</span>(torch::kMPS);</span><br></pre></td></tr></table></figure><p>编译是没有问题的，但运行时会报下面的错:</p><blockquote><p>libc++abi: terminating with uncaught exception of type c10::TypeError: Cannot convert a MPS Tensor to float64 dtype as the MPS framework doesn’t support float64. Please use float32 instead.<br>提示说MPS不支持float64，但我打印<code>foo</code>的类型，它其实是float32，本身报错比较奇怪，搜了一圈也没找到怎么解决。</p></blockquote><h3 id="1-8-Tensor-变形函数"><a href="#1-8-Tensor-变形函数" class="headerlink" title="1.8 Tensor 变形函数"></a>1.8 Tensor 变形函数</h3><p>很多时候我们需要将Tensor进行形状的修改，这方面Libtorch支持的比较好，这些操作都支持:</p><ul><li>reshape</li><li>flatten</li><li>squeeze</li><li>unsqueeze</li><li>transpose</li><li>cat/concat/concatenate</li></ul><p>而且支持torch::reshape这种静态函数和<code>tensor.reshape</code>这种对象函数。下面是一些例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变形操作</span></span><br><span class="line">bar = foo.<span class="built_in">reshape</span>(&#123;<span class="number">2</span>, <span class="number">-1</span>&#125;);</span><br><span class="line">bar = foo.<span class="built_in">flatten</span>();</span><br><span class="line">bar = foo.<span class="built_in">squeeze</span>();</span><br><span class="line">bar = foo.<span class="built_in">unsqueeze</span>(<span class="number">0</span>);</span><br><span class="line">bar = torch::<span class="built_in">unsqueeze</span>(foo, <span class="number">-1</span>);</span><br><span class="line">bar = foo.<span class="built_in">transpose</span>(<span class="number">0</span>, <span class="number">1</span>).<span class="built_in">transpose</span>(<span class="number">2</span>, <span class="number">3</span>).<span class="built_in">transpose</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">bar = torch::<span class="built_in">transpose</span>(foo, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">bar = torch::<span class="built_in">cat</span>(&#123;foo, foo&#125;, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>一个比较特殊的地方是transpose只支持两个轴的交换，多个轴的交换需要调用多次来实现。</p><h3 id="1-9-Tensor之间的操作函数"><a href="#1-9-Tensor之间的操作函数" class="headerlink" title="1.9 Tensor之间的操作函数"></a>1.9 Tensor之间的操作函数</h3><p>Tensor库中，Tensor和Tensor之间的操作是很常见的，比如求矩阵相乘，内积外积等，有内置的函数支持能避免很多额外的开发工作。这里是一些例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo = torch::<span class="built_in">randn</span>(&#123;<span class="number">3</span>, <span class="number">3</span>&#125;);</span><br><span class="line">bar = torch::<span class="built_in">matmul</span>(foo, foo);</span><br><span class="line">bar = foo.<span class="built_in">matmul</span>(foo);</span><br><span class="line">bar = torch::<span class="built_in">cross</span>(foo, foo);</span><br><span class="line">bar = torch::<span class="built_in">mul</span>(foo, foo);</span><br></pre></td></tr></table></figure><h3 id="1-10-线性代数相关函数"><a href="#1-10-线性代数相关函数" class="headerlink" title="1.10 线性代数相关函数"></a>1.10 线性代数相关函数</h3><p><code>torch::linalg</code> namespace中包含常见的线性代数操作，几个简单的使用例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bar = torch::linalg::<span class="built_in">inv</span>(foo);</span><br><span class="line">std::cout &lt;&lt;<span class="string">&quot;==&gt; bar4: &quot;</span>&lt;&lt; bar &lt;&lt; std::endl;</span><br><span class="line">bar = torch::linalg::<span class="built_in">norm</span>(foo, <span class="number">2</span>, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, <span class="literal">false</span>, torch::nullopt);</span><br></pre></td></tr></table></figure><p>所有支持的函数详见<a href="https://pytorch.org/cppdocs/api/file_torch_csrc_api_include_torch_linalg.h.html#file-torch-csrc-api-include-torch-linalg-h">官方文档</a></p><h3 id="1-11-神经网络相关函数"><a href="#1-11-神经网络相关函数" class="headerlink" title="1.11 神经网络相关函数"></a>1.11 神经网络相关函数</h3><p>神经网络是torch的核心模块，常见的一些激活函数，卷积层都可以以函数的形式作用在Tensor上，这里写几个简单的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bar = torch::<span class="built_in">softmax</span>(foo, <span class="number">-1</span>);</span><br><span class="line">bar = torch::<span class="built_in">sigmoid</span>(foo);</span><br><span class="line">bar = torch::<span class="built_in">relu</span>(foo);</span><br><span class="line">bar = torch::<span class="built_in">gelu</span>(foo);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;系列教程列表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://vra.github.io/2023/02/25/libtorch-tutorial1/&quot;&gt;Libtorch系列教程1：一个丝滑的C++ Tensor库&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://vra.github.io/2023/02/25/libtorch-tutorial2/&quot;&gt;Libtorch系列教程2：torch::Tensor的使用&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章中，我们暂时忽略网络训练和推理，详细展开Libtorch中Tensor对象的使用，看看将Libtorch当作一个纯粹的Tensor库来使用时，有哪些注意事项。如有未涉及的内容，请访问Libtorch&lt;a href=&quot;https://pytorch.org/cppdocs/&quot;&gt;官方文档&lt;/a&gt;，通过搜索框获取更多的信息。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="C++" scheme="http://vra.github.io/tags/C/"/>
    
    <category term="Pytorch" scheme="http://vra.github.io/tags/Pytorch/"/>
    
    <category term="Libtorch" scheme="http://vra.github.io/tags/Libtorch/"/>
    
  </entry>
  
  <entry>
    <title>Libtorch系列教程1：一个丝滑的C++ Tensor库</title>
    <link href="http://vra.github.io/2023/02/25/libtorch-tutorial1/"/>
    <id>http://vra.github.io/2023/02/25/libtorch-tutorial1/</id>
    <published>2023-02-24T19:03:51.000Z</published>
    <updated>2023-02-27T00:32:59.543Z</updated>
    
    <content type="html"><![CDATA[<p>系列教程列表：</p><ul><li><a href="https://vra.github.io/2023/02/25/libtorch-tutorial1/">Libtorch系列教程1：一个丝滑的C++ Tensor库</a> </li><li><a href="https://vra.github.io/2023/02/25/libtorch-tutorial2/">Libtorch系列教程2：torch::Tensor的使用</a> </li></ul><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><a href="https://pytorch.org/cppdocs/installing.html">Libtorch</a>是Pytorch的C++接口，实现了在C++中进行网络训练、网络推理的功能。</p><p>除此之外，由于Libtorch中的大部份接口都是与Pytorch一致的，所以Libtorch还是一个很强大的张量库，有着类似Pytorch的清晰接口，这在C++中很难得的。如果你用过C++ Tensor库，就会发现写法比较复杂，学习成本。因为强类型的限制和通用容器类型的缺失，C++相比Python天然更复杂，库设计者因为语言使用习惯，以及为了性能等因素，设计的接口一般都是高效但难用的。而Libtorch采用了与Pytorch类似的函数接口，如果你使用过Pytorch的话，使用Libtorch学习成本很低，后面会看到具体的例子。</p><p>另一个问题是，很多Python库中基础的操作，例如<code>numpy.einsum</code>函数，在C++中没有合适的替代，看看<a href="https://stackoverflow.com/questions/65347170/numpy-einsum-equivalent-for-xtensor-c">这些</a>搜索你就知道了。Libtorch解决了这个问题，Pytorch中有的它都有，所以在C++中可以简单地用<code>torch::einsum</code>来使用einsum函数，简直是C++开发者的福音。</p><p>此外Libtorch 是支持GPU的，主要用于模型的推理过程，但我猜测使用GPU的话，Libtorch的Tensor操作在速度上相比别的C++ Tensor 库可能有优势，具体速度需要测试对比。当然使用C++代码的话速度不是瓶颈，本身CPU代码就够快了。</p><p>Libtorch另一个优势是编译简单，只要你安装了Pytorch，Libtorch就可以直接使用，省去了复杂的安装和配置，一分钟内就能跑起来一个简单的的示例程序。</p><p>总结来说，Libtorch有以下很吸引人的特性：</p><ul><li>强大如Numpy和Pytorch的C++ Tensor库，写法优雅丝滑，并且是支持GPU的。</li><li>可以训练神经网络</li><li>可以推理神经网络模型，用在C++环境的模型部署场景</li><li>编译简单</li></ul><p>由于Pytorch开发团队是以Python优先的思路来进行Pytorch的开发的，因此我感觉Libtorch的重视程度不是很高，文档和教程也比较少，官网的示例也几乎没有，因此写一个比较完善的教程是比较有意义的。</p><p>这个系列文章中，我会对Libtorch 的Tensor库和推理神经网络过程进行介绍，因为这些内容在实际对于用Libtorch来进行网络训练的部分进行跳过，因为这部分使用的场景不是很多（用Python训练网络比C++香多了)。</p><p>本篇以Mac下的操作为例，对Libtorch的安装和简单使用进行介绍，后续内容近期会更新，敬请关注。</p><span id="more"></span><h2 id="2-Libtorch-安装"><a href="#2-Libtorch-安装" class="headerlink" title="2. Libtorch 安装"></a>2. Libtorch 安装</h2><p>如果你已经安装过Pytorch，那么就不用额外安装Libtorch了，因为Pytorch自带了Libtorch的CMake config 文件，使用<code>torch.utils.cmake_prefix_path</code>语句就能打印出来，可以直接被CMake使用，编译时添加如下的选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-DCMAKE_PREFIX_PATH=`python -c <span class="string">&#x27;import torch;print(torch.utils.cmake_prefix_path)&#x27;</span></span><br></pre></td></tr></table></figure><p>如果没有安装过Pytorch，那直接去<a href="https://pytorch.org/">Pytorch官网</a>下载Libtorch 压缩包，解压到本地目录即可，后面使用CMake来指向这里的路径就行。假如解压到<code>LIBTORCH_ROOT</code>目录，编译时添加下面的选项:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-DCMAKE_PREFIX_PATH=&lt;LIBTORCH_ROOT&gt;</span><br></pre></td></tr></table></figure><h2 id="3-使用CMake-编译一个简单例子"><a href="#3-使用CMake-编译一个简单例子" class="headerlink" title="3. 使用CMake 编译一个简单例子"></a>3. 使用CMake 编译一个简单例子</h2><p>这里写一个简单的Libtorch例子，创建一个5x5的矩阵，然后调用<code>einsum</code>函数来计算矩阵的迹（对角线元素的和）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入Torch头文件，Tensor类在此头文件中，别的类会在另外的头文件中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;torch/torch.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用arange构造一个一维向量，再用reshape变换到5x5的矩阵</span></span><br><span class="line">  torch::Tensor foo = torch::<span class="built_in">arange</span>(<span class="number">25</span>).<span class="built_in">reshape</span>(&#123;<span class="number">5</span>, <span class="number">5</span>&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算矩阵的迹</span></span><br><span class="line">  torch::Tensor bar  = torch::<span class="built_in">einsum</span>(<span class="string">&quot;ii&quot;</span>, foo);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出矩阵和对应的迹</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;==&gt; matrix is:\n &quot;</span> &lt;&lt; foo &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;==&gt; trace of it is:\n &quot;</span> &lt;&lt; bar &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意reshape中需要用花括号，因为C++没有tuple类型，Python中的<code>(5,5)</code>需要在C++中改写为<code>&#123;5, 5&#125;</code>。除此之外，是不是跟Python代码很相似？</p><p>记得保存上面的代码为<code>libtorch_trace.cpp</code>，因为CMake配置中需要写文件名。</p><p>然后在同级目录编写<code>CMakeLists.txt</code>文件:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(libtorch_trace)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要找到Libtorch</span></span><br><span class="line"><span class="keyword">find_package</span>(Torch REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; $&#123;TORCH_CXX_FLAGS&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> libtorch_trace.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="string">&quot;$&#123;TORCH_LIBRARIES&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Libtorch是基于C++14来实现的</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span> PROPERTY CXX_STANDARD <span class="number">14</span>)</span><br></pre></td></tr></table></figure><p>然后执行下面的命令来编译:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"><span class="comment"># 如果是通过Pytorch</span></span><br><span class="line">cmake -DCMAKE_PREFIX_PATH=`python -c <span class="string">&#x27;import torch;print(torch.utils.cmake_prefix_path)&#x27;</span>` ..</span><br><span class="line"><span class="comment">#下载的单独Libtorch</span></span><br><span class="line"><span class="comment"># cmake -DCMAKE_PREFIX_PATH=&lt;LIBTORCH_ROOT&gt; ..</span></span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure><p>编译完成后使用下面的命令来执行可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./libtorch_trace</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">==&gt; matrix is:</span><br><span class="line">   0   1   2   3   4</span><br><span class="line">  5   6   7   8   9</span><br><span class="line"> 10  11  12  13  14</span><br><span class="line"> 15  16  17  18  19</span><br><span class="line"> 20  21  22  23  24</span><br><span class="line">[ CPULongType&#123;5,5&#125; ]</span><br><span class="line">==&gt; trace of it is:</span><br><span class="line"> 60</span><br><span class="line">[ CPULongType&#123;&#125; ]</span><br></pre></td></tr></table></figure><p>那么我们的第一个例子就完成了。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul><li><a href="https://pytorch.org/cppdocs/installing.html">https://pytorch.org/cppdocs/installing.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;系列教程列表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://vra.github.io/2023/02/25/libtorch-tutorial1/&quot;&gt;Libtorch系列教程1：一个丝滑的C++ Tensor库&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://vra.github.io/2023/02/25/libtorch-tutorial2/&quot;&gt;Libtorch系列教程2：torch::Tensor的使用&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://pytorch.org/cppdocs/installing.html&quot;&gt;Libtorch&lt;/a&gt;是Pytorch的C++接口，实现了在C++中进行网络训练、网络推理的功能。&lt;/p&gt;
&lt;p&gt;除此之外，由于Libtorch中的大部份接口都是与Pytorch一致的，所以Libtorch还是一个很强大的张量库，有着类似Pytorch的清晰接口，这在C++中很难得的。如果你用过C++ Tensor库，就会发现写法比较复杂，学习成本。因为强类型的限制和通用容器类型的缺失，C++相比Python天然更复杂，库设计者因为语言使用习惯，以及为了性能等因素，设计的接口一般都是高效但难用的。而Libtorch采用了与Pytorch类似的函数接口，如果你使用过Pytorch的话，使用Libtorch学习成本很低，后面会看到具体的例子。&lt;/p&gt;
&lt;p&gt;另一个问题是，很多Python库中基础的操作，例如&lt;code&gt;numpy.einsum&lt;/code&gt;函数，在C++中没有合适的替代，看看&lt;a href=&quot;https://stackoverflow.com/questions/65347170/numpy-einsum-equivalent-for-xtensor-c&quot;&gt;这些&lt;/a&gt;搜索你就知道了。Libtorch解决了这个问题，Pytorch中有的它都有，所以在C++中可以简单地用&lt;code&gt;torch::einsum&lt;/code&gt;来使用einsum函数，简直是C++开发者的福音。&lt;/p&gt;
&lt;p&gt;此外Libtorch 是支持GPU的，主要用于模型的推理过程，但我猜测使用GPU的话，Libtorch的Tensor操作在速度上相比别的C++ Tensor 库可能有优势，具体速度需要测试对比。当然使用C++代码的话速度不是瓶颈，本身CPU代码就够快了。&lt;/p&gt;
&lt;p&gt;Libtorch另一个优势是编译简单，只要你安装了Pytorch，Libtorch就可以直接使用，省去了复杂的安装和配置，一分钟内就能跑起来一个简单的的示例程序。&lt;/p&gt;
&lt;p&gt;总结来说，Libtorch有以下很吸引人的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强大如Numpy和Pytorch的C++ Tensor库，写法优雅丝滑，并且是支持GPU的。&lt;/li&gt;
&lt;li&gt;可以训练神经网络&lt;/li&gt;
&lt;li&gt;可以推理神经网络模型，用在C++环境的模型部署场景&lt;/li&gt;
&lt;li&gt;编译简单&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于Pytorch开发团队是以Python优先的思路来进行Pytorch的开发的，因此我感觉Libtorch的重视程度不是很高，文档和教程也比较少，官网的示例也几乎没有，因此写一个比较完善的教程是比较有意义的。&lt;/p&gt;
&lt;p&gt;这个系列文章中，我会对Libtorch 的Tensor库和推理神经网络过程进行介绍，因为这些内容在实际对于用Libtorch来进行网络训练的部分进行跳过，因为这部分使用的场景不是很多（用Python训练网络比C++香多了)。&lt;/p&gt;
&lt;p&gt;本篇以Mac下的操作为例，对Libtorch的安装和简单使用进行介绍，后续内容近期会更新，敬请关注。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="C++" scheme="http://vra.github.io/tags/C/"/>
    
    <category term="Pytorch" scheme="http://vra.github.io/tags/Pytorch/"/>
    
    <category term="Libtorch" scheme="http://vra.github.io/tags/Libtorch/"/>
    
  </entry>
  
  <entry>
    <title>nanoGPT + 鲁迅</title>
    <link href="http://vra.github.io/2023/02/12/nanogpt-and-luxun/"/>
    <id>http://vra.github.io/2023/02/12/nanogpt-and-luxun/</id>
    <published>2023-02-12T15:24:02.000Z</published>
    <updated>2023-02-12T16:33:42.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-起因"><a href="#1-起因" class="headerlink" title="1. 起因"></a>1. 起因</h2><p>今晚看到了Simon Willison 的只使用自己的博客内容来训练nanoGPT的<a href="https://til.simonwillison.net/llms/training-nanogpt-on-my-blog">实验</a>，觉得挺有意思，突发奇想，能不能在鲁迅的文集上训练一个nanoGPT，然后生成很具辨识度的鲁迅风格的文字呢？由于nanoGPT结构简单，鲁迅的文集在GitHub上可以下载到，因此通过简单的代码修改加实验，就得到一个在鲁迅作品上训练的GPT2模型(无别的语料库的预训练），简单测试下，以“故乡”开头，让模型生成鲁迅风格的文字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">故乡，债是佩服的。</span><br><span class="line"> 我一向对于新青年的态度，先来说话，谢容易做的，然而伏园已经见过几样，感觉的是另外捧之数，以为先前的例子。今但近来做了做事，自己也还不做，不能先行通，所以生在冷静和“人生”，三妇一苦闷，觉得大约是如此隔膜</span><br><span class="line">和曹操，于是非意模茶炛，可以说是太高了，所以现在便能教育，竟�如此。</span><br><span class="line"> 但汝实在有给法历代的，不久就在绝末年间，我想显出向大家饮一趟，而汉子大毒是怀旧的，就要贫足有打劫，可以永掠的。这种事情，中国有一个大官左翼阿，（陀思妥习），有敢请佛喜，总要适说一点�</span><br></pre></td></tr></table></figure><p>还算有鲁迅文字的风格，但逻辑一窍不通，整体还是难让人满意，不知道是GPT2能力的问题还是我实验设置的问题。 Anyway，这里共享一下我实验的流程，有兴趣的朋友可以参考，进行改进。本文涉及的代码修改代码已经提交到这个<a href="https://github.com/vra/nanoGPT">仓库了</a>，可以参考，文末会附上更多例子。</p><span id="more"></span><h2 id="2-操作流程"><a href="#2-操作流程" class="headerlink" title="2. 操作流程"></a>2. 操作流程</h2><h3 id="2-1-下载nanoGPT源码并安装依赖"><a href="#2-1-下载nanoGPT源码并安装依赖" class="headerlink" title="2.1 下载nanoGPT源码并安装依赖"></a>2.1 下载nanoGPT源码并安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/karpathy/nanoGPT</span><br><span class="line"><span class="built_in">cd</span> nanoGPT</span><br><span class="line">conda create --name nanogpt  python=3.9</span><br><span class="line">conda activate nanogpt</span><br><span class="line">pip install transformers datasets tiktoken tqdm wandb numpy httpx torch torchvision</span><br></pre></td></tr></table></figure><h3 id="2-2-数据预处理"><a href="#2-2-数据预处理" class="headerlink" title="2.2 数据预处理"></a>2.2 数据预处理</h3><p>进入代码目录后，重建文件夹<code>data/lunxun</code>，用于存放数据。</p><p>从<a href="https://github.com/gzx1996/luxun/blob/master/book/book.txt">这里</a>下载鲁迅全集，放到<code>data/luxun</code>目录下，然后进行下面的处理：</p><ul><li>去掉所有编者加的注释(由于注释都是以<code>[n]</code>这种形式开头的，因此在VIM中可以用<code>0,$s/^\[.\+//g</code>命令来去掉)</li><li>由于我们想要的是鲁迅白话文的风格，因此手动去掉所有文言文的作品和翻译作品(文言文在最开头的《坟》集子里，翻译作品在最后)</li><li>去掉单行的日期文字（如<code>(一九一八年二月二日)</code>，可以在VIM中用<code>g/^(一九.\+/d</code>去掉)</li></ul><p>我处理后的文本地址在<a href="https://github.com/vra/nanoGPT/tree/master/data/luxun/book.txt">这里</a>。</p><p>然后编写代码<code>prepare.py</code>, 读取文本，构造训练集和验证集，数据比例9:1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> tiktoken</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">input_file_path = os.path.join(os.path.dirname(__file__), <span class="string">&quot;book.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">entries = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(input_file_path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="keyword">if</span> line.strip() <span class="keyword">and</span> <span class="built_in">len</span>(line) &gt; <span class="number">2</span>:</span><br><span class="line">            entries.append(line)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;len of lines: <span class="subst">&#123;<span class="built_in">len</span>(entries)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># Shuffle entries</span></span><br><span class="line">random.shuffle(entries)</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">len</span>(entries)</span><br><span class="line">train_entries = entries[: <span class="built_in">int</span>(n * <span class="number">0.9</span>)]</span><br><span class="line">val_entries = entries[<span class="built_in">int</span>(n * <span class="number">0.9</span>):]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Turn those into strings</span></span><br><span class="line">train_data = <span class="string">&quot; &quot;</span>.join(<span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(entry) <span class="keyword">for</span> entry <span class="keyword">in</span> train_entries)</span><br><span class="line">val_data = <span class="string">&quot; &quot;</span>.join(<span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(entry) <span class="keyword">for</span> entry <span class="keyword">in</span> val_entries)</span><br><span class="line"></span><br><span class="line"><span class="comment"># encode with tiktoken gpt2 bpe</span></span><br><span class="line">enc = tiktoken.get_encoding(<span class="string">&quot;gpt2&quot;</span>)</span><br><span class="line">train_ids = enc.encode_ordinary(train_data)</span><br><span class="line">val_ids = enc.encode_ordinary(val_data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;train has <span class="subst">&#123;<span class="built_in">len</span>(train_ids):,&#125;</span> tokens&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;val has <span class="subst">&#123;<span class="built_in">len</span>(val_ids):,&#125;</span> tokens&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># export to bin files</span></span><br><span class="line">train_ids = np.array(train_ids, dtype=np.uint16)</span><br><span class="line">val_ids = np.array(val_ids, dtype=np.uint16)</span><br><span class="line">train_ids.tofile(os.path.join(os.path.dirname(__file__), <span class="string">&quot;train.bin&quot;</span>))</span><br><span class="line">val_ids.tofile(os.path.join(os.path.dirname(__file__), <span class="string">&quot;val.bin&quot;</span>))</span><br></pre></td></tr></table></figure><p>处理好的训练验证集在<a href="https://github.com/vra/nanoGPT/tree/master/data/luxun">这里</a>，可以直接使用。</p><h3 id="2-3-训练网络"><a href="#2-3-训练网络" class="headerlink" title="2.3 训练网络"></a>2.3 训练网络</h3><p>数据集构建完成后，就可以训练模型了。在代码库根目录，执行下面的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python train.py \</span><br><span class="line">  --dataset=luxun \</span><br><span class="line">--compile=False \</span><br><span class="line">--batch_size=8 \</span><br><span class="line">--dtype=float16</span><br></pre></td></tr></table></figure><p>具体训练参数可以查看<code>train.py</code>，包括训练的层数、batch size，训练后端等等。</p><p>训练的模型默认保存在<code>out/ckpt.pt</code>。</p><p>训练22000次迭代的时候我停止了实验，loss是0.15左右。</p><h3 id="2-4-测试模型"><a href="#2-4-测试模型" class="headerlink" title="2.4 测试模型"></a>2.4 测试模型</h3><p>测试代码在<code>sample.py</code>，默认提示词为空(<code>start=&#39;\n&#39;</code>)可以通过添加<code>--start=&quot;xxx&quot;</code>来修改提示词:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sample.py --start=<span class="string">&quot;故乡&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3-更多例子"><a href="#3-更多例子" class="headerlink" title="3. 更多例子"></a>3. 更多例子</h2><h3 id="3-1-人工智能"><a href="#3-1-人工智能" class="headerlink" title="3.1 人工智能"></a>3.1 人工智能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">人工智能力。两社丈一多，西辛，是发昏了的结果，但去的四五十岁，死的陈源教授却很不通，我也就不再有了。忍不知道阿Ｑ的名字是怎么写的？这不过是一个问境。他总还拿着四个年的过头放在心里，说道，“哀，遇的。他可</span><br><span class="line">是弯口，道是阿Ｑ；近来已经做了杜师长了，半年的大武人，你还和他对面具汗说：‘非常救命！’‘是情愧 夫子’的学理论矛盾的工人，……而且跳不过是这三秒……。”</span><br><span class="line"> 而已 偶战线告了一个大问题，拿去做的纠纷，而他们就癖在《试玈书》的第一幅，来因为又是删节的，还和所放的做。不过如果加以细见，不想多写了东�</span><br></pre></td></tr></table></figure><h3 id="3-2-文艺复兴"><a href="#3-2-文艺复兴" class="headerlink" title="3.2 文艺复兴"></a>3.2 文艺复兴</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">文艺复兴运动，也是指惺把文艺当承受照时代，更易于政治家，中国并不见立刻，万分折中间，更何况失了国家，只有拜读之处，这就是政治心软到新舖式的必读书。……”</span><br><span class="line"> 我们──由此满可知道河南的内心眼和明白的点灵魂。我在曾经想做以看空虚洋，决不叫看情形。因为我想，便可以支持生活的原因，至少，更进一步而到中国来，他们也给了世界上的美�家所指见的最多也并非精微坏，莫非看翻译</span><br><span class="line">，可说是不算太多了。</span><br><span class="line"> 问题。</span><br><span class="line"> “我们没有见过这种东西，便怎么办呢？”</span><br><span class="line"> 递进句也不是有许多话。</span><br><span class="line"> “可以可以，”四铭吃了点</span><br></pre></td></tr></table></figure><h3 id="3-3-新文化"><a href="#3-3-新文化" class="headerlink" title="3.3 新文化"></a>3.3 新文化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">新文化运动，也许因为他们已经有了“力”这句话的责任了。在那里和他们的风化是并不相禁多的。</span><br><span class="line"> 阿呼呜呼兮呜呼阿呼，</span><br><span class="line"> 八九年</span><br><span class="line"> 二、浙江艳七百</span><br><span class="line"> 一九二五年十二月三十日风雨之夜示，此地声声流鼓近山腌至责诼谢。</span><br><span class="line"> 阿Ｑ的讲到文学说，他们会打断了阿Ｑ的名目退向王的头发，向公司被挤出去了。</span><br><span class="line"> 最末的批评，是“没有话派的书，对于政府来往往解释，加以泄除，以政治的运命，至于失败，那倒是往往会说，我非常危险。</span><br><span class="line"> 小娘枟不用小说的经济字的由校的文章，使是屠戮政府，是凡这些的，但我知道画家一致攻，一致的经历</span><br></pre></td></tr></table></figure><p>如果本文操作中有误的地方，还请专业人士多指出讨论。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-起因&quot;&gt;&lt;a href=&quot;#1-起因&quot; class=&quot;headerlink&quot; title=&quot;1. 起因&quot;&gt;&lt;/a&gt;1. 起因&lt;/h2&gt;&lt;p&gt;今晚看到了Simon Willison 的只使用自己的博客内容来训练nanoGPT的&lt;a href=&quot;https://til.simonwillison.net/llms/training-nanogpt-on-my-blog&quot;&gt;实验&lt;/a&gt;，觉得挺有意思，突发奇想，能不能在鲁迅的文集上训练一个nanoGPT，然后生成很具辨识度的鲁迅风格的文字呢？由于nanoGPT结构简单，鲁迅的文集在GitHub上可以下载到，因此通过简单的代码修改加实验，就得到一个在鲁迅作品上训练的GPT2模型(无别的语料库的预训练），简单测试下，以“故乡”开头，让模型生成鲁迅风格的文字：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;故乡，债是佩服的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 我一向对于新青年的态度，先来说话，谢容易做的，然而伏园已经见过几样，感觉的是另外捧之数，以为先前的例子。今但近来做了做事，自己也还不做，不能先行通，所以生在冷静和“人生”，三妇一苦闷，觉得大约是如此隔膜&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;和曹操，于是非意模茶炛，可以说是太高了，所以现在便能教育，竟�如此。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 但汝实在有给法历代的，不久就在绝末年间，我想显出向大家饮一趟，而汉子大毒是怀旧的，就要贫足有打劫，可以永掠的。这种事情，中国有一个大官左翼阿，（陀思妥习），有敢请佛喜，总要适说一点�&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;还算有鲁迅文字的风格，但逻辑一窍不通，整体还是难让人满意，不知道是GPT2能力的问题还是我实验设置的问题。 Anyway，这里共享一下我实验的流程，有兴趣的朋友可以参考，进行改进。本文涉及的代码修改代码已经提交到这个&lt;a href=&quot;https://github.com/vra/nanoGPT&quot;&gt;仓库了&lt;/a&gt;，可以参考，文末会附上更多例子。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="Pytorch" scheme="http://vra.github.io/tags/Pytorch/"/>
    
    <category term="GPT" scheme="http://vra.github.io/tags/GPT/"/>
    
    <category term="AI" scheme="http://vra.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>关于 np.float 被删除的问题</title>
    <link href="http://vra.github.io/2023/02/05/numpy-remove-np-float/"/>
    <id>http://vra.github.io/2023/02/05/numpy-remove-np-float/</id>
    <published>2023-02-05T03:34:04.000Z</published>
    <updated>2023-02-13T08:37:25.163Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>在Numpy 1.24版本中，<a href="https://numpy.org/doc/stable/release/1.24.0-notes.html#expired-deprecations">删除</a>了像<code>np.float</code>、<code>np.int</code> 这样的 Python 内置类型的 alias，因此以后在代码中使用这些类型会报错<code>AttributeError: module &#39;numpy&#39; has no attribute &#39;float&#39;</code>, 涉及的类型包括：</p><ul><li><code>numpy.bool</code></li><li><code>numpy.int</code></li><li><code>numpy.float</code></li><li><code>numpy.complex</code></li><li><code>numpy.object</code></li><li><code>numpy.str</code></li><li><code>numpy.long</code></li><li><code>numpy.unicode</code></li></ul><p>那该怎么解决这个错误呢？</p><p>TL;DR</p><ul><li>对于在标量上的操作，直接使用Python内置类型替换<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo = np.random.rand(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 原先用法，注意foo[0]是一个标量</span></span><br><span class="line">bar = np.<span class="built_in">float</span>(foo[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 新用法</span></span><br><span class="line">bar = <span class="built_in">float</span>(foo[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></li><li>对于在<code>np.ndarray</code> 上的操作，使用<code>np.float64</code> 或<code>np.float32</code> 来替代，具体选择哪个需要自己根据情况来确定，不同类型精度会有不同，下面举两个例子:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原先用法</span></span><br><span class="line">foo = np.random.rand(<span class="number">10</span>, dtype=np.<span class="built_in">float</span>)</span><br><span class="line"><span class="comment"># 新用法</span></span><br><span class="line">foo = np.random.rand(<span class="number">10</span>, dtype=np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原先用法</span></span><br><span class="line">foo = np.random.rand(<span class="number">10</span>).astype(np.<span class="built_in">float</span>)</span><br><span class="line"><span class="comment"># 新用法</span></span><br><span class="line">foo = np.random.rand(<span class="number">10</span>).astype(np.float32)</span><br></pre></td></tr></table></figure></li></ul><p>这里列出来了删除类型在标量和<code>np.ndarray</code> 上的替代，方便查找</p><table><thead><tr><th>原先类型</th><th>标量替换类型</th><th><code>np.ndarray</code>替换类型</th></tr></thead><tbody><tr><td>np.int</td><td>int</td><td>np.int32/np.int64</td></tr><tr><td>np.float</td><td>float</td><td>np.float32/np.float64</td></tr><tr><td>np.bool</td><td>bool</td><td>np.bool_</td></tr><tr><td>np.complex</td><td>complex</td><td>np.complex128</td></tr><tr><td>np.object</td><td>object</td><td>-</td></tr><tr><td>np.str</td><td>str</td><td>np.str_</td></tr><tr><td>np.long</td><td>int</td><td>np.int32/np.int64</td></tr><tr><td>np.unicode</td><td>str</td><td>np.str_</td></tr></tbody></table><p>详细说明参考<a href="https://numpy.org/doc/stable/release/1.20.0-notes.html#deprecations">NumPy 1.20.0 Release Notes</a>。</p><p>下面详细说说事情的来龙去脉。</p><span id="more"></span><h3 id="2-代码验证"><a href="#2-代码验证" class="headerlink" title="2. 代码验证"></a>2. 代码验证</h3><p>下面我搭建 Numpy 1.20.0 和 1.24.0 的环境进行简单测试，以及分析为什么会弃用这些类型。</p><p>首先是 Numpy 1.20.0 环境搭建与简单测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python -m venv np1.20</span><br><span class="line"><span class="built_in">source</span> np1.20/bin/activate</span><br><span class="line">pip install numpy==1.20</span><br><span class="line">python -c <span class="string">&quot;import numpy as np; a = np.array([1.0], dtype=np.float)&quot;</span></span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;string&gt;:1: DeprecationWarning: `np.float` is a deprecated <span class="built_in">alias</span> <span class="keyword">for</span> the <span class="built_in">builtin</span> `<span class="built_in">float</span>`. To silence this warning, use `<span class="built_in">float</span>` by itself. Doing this will not modify any behavior and is safe. If you specifically wanted the numpy scalar <span class="built_in">type</span>, use `np.float64` here.</span><br><span class="line">Deprecated <span class="keyword">in</span> NumPy 1.20; <span class="keyword">for</span> more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html<span class="comment">#deprecations</span></span><br></pre></td></tr></table></figure><p>仔细看这段输出的话，可以发现从 Numpy 1.20 版本开始，Numpy已经弃用<code>np.float</code> 类型了，并且给出了替换建议，以及详细的说明文档<a href="https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations">地址</a>。</p><p>而在 Numpy 1.24版本里面，正式删除了<code>np.float</code>，可以用下面的代码来测试。<br>首先我们创建一个新的环境，安装Numpy 1.24版本，然后创建一个<code>np.float</code>类型的数组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python -m venv np1.24</span><br><span class="line"><span class="built_in">source</span> np1.24/bin/activate</span><br><span class="line">pip install numpy==1.24</span><br><span class="line">python -c <span class="string">&quot;import numpy as np; a = np.array([1.0], dtype=np.float)&quot;</span></span><br></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;string&gt;&quot;</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;/Users/name/np1.24/lib/python3.9/site-packages/numpy/__init__.py&quot;</span>, line 284, <span class="keyword">in</span> __getattr__</span><br><span class="line">    raise AttributeError(<span class="string">&quot;module &#123;!r&#125; has no attribute &quot;</span></span><br><span class="line">AttributeError: module <span class="string">&#x27;numpy&#x27;</span> has no attribute <span class="string">&#x27;float&#x27;</span></span><br></pre></td></tr></table></figure><p>直接就报了我们开头提到的属性错误。</p><h3 id="3-Why"><a href="#3-Why" class="headerlink" title="3. Why"></a>3. Why</h3><p>其实早在2015年，Numpy 开发者就在<a href="https://github.com/numpy/numpy/pull/6103">策划</a>删除这些类型了，只不过当时使用范围太广，删除造成的影响太大，所以在近8年，1.20-1.24 4个版本的Warning后，才正式删除。<br>为什么要删除这些操作呢？我自己觉得是因为<code>np.float</code> 这种类型太容易误用了。大家都以为<code>np.float</code>是一个Numpy的数据类型，是<code>np.float32</code>的alias，但实际它是内置类型，是<code>int</code>类型的alias。<br>就像下面这个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = np.array([<span class="number">10</span>], dtype=np.int32)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar = np.<span class="built_in">int</span>(foo)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(bar)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">baz</span> = <span class="title">np</span>.<span class="title">int32</span>(<span class="params">foo</span>)</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span>(<span class="params">baz</span>)</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">numpy</span>.<span class="title">ndarray</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，对<code>np.ndarray</code> 数组进行<code>np.int</code> 和<code>np.int32</code>的操作，一个得到<code>int</code>类型的变量，另一个得到的是<code>np.ndarray</code>类型的变量。</p><p>详细的原因可以参考上面的 issue 链接。</p><p>那最早为什么还要引入<code>np.float</code>呢？直接用Python内置的类型不好吗？其实这是在很早的Numpy版本中错误地引入的，那个版本<code>np.float</code>的含义就是<code>np.float64</code> ，只不过后来版本中<code>np.float</code> 的含义修改了，但如果直接删除<code>np.float</code>，有人使用老版本的Numpy，就会在执行<code>from numpy import *</code> 报错。当前那个老版本已经很少有人用了 ，所以就删除了。</p><h3 id="4-带来的影响"><a href="#4-带来的影响" class="headerlink" title="4. 带来的影响"></a>4. 带来的影响</h3><p>这个改动带来的影响可以说是非常大了，简单来说，在 Numpy 1.24.0以上的版本中，使用<code>np.float</code>的代码都会直接报错。而 Numpy 作为 Python 在科学计算中的基础包，被广泛使用的程度无需我赘述。<br>简单在GitHub 搜索了一下，光涉及到<code>np.float</code>的(<a href="https://github.com/search?q=np.float)++lang:Python++&ref=opensearch&type=code">结果1</a>， <a href="https://github.com/search?q=np.float(+lang:Python++&ref=opensearch&type=code">结果2</a>）就有近9万行代码，我自己短期内就在两个仓库中遇到这个问题。好在解决办法也比较直接，希望可以顺利的过渡过去。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;在Numpy 1.24版本中，&lt;a href=&quot;https://numpy.org/doc/stable/release/1.24.0-notes.html#expired-deprecations&quot;&gt;删除&lt;/a&gt;了像&lt;code&gt;np.float&lt;/code&gt;、&lt;code&gt;np.int&lt;/code&gt; 这样的 Python 内置类型的 alias，因此以后在代码中使用这些类型会报错&lt;code&gt;AttributeError: module &amp;#39;numpy&amp;#39; has no attribute &amp;#39;float&amp;#39;&lt;/code&gt;, 涉及的类型包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;numpy.bool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;numpy.int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;numpy.float&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;numpy.complex&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;numpy.object&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;numpy.str&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;numpy.long&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;numpy.unicode&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那该怎么解决这个错误呢？&lt;/p&gt;
&lt;p&gt;TL;DR&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于在标量上的操作，直接使用Python内置类型替换&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;foo = np.random.rand(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 原先用法，注意foo[0]是一个标量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bar = np.&lt;span class=&quot;built_in&quot;&gt;float&lt;/span&gt;(foo[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 新用法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bar = &lt;span class=&quot;built_in&quot;&gt;float&lt;/span&gt;(foo[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;对于在&lt;code&gt;np.ndarray&lt;/code&gt; 上的操作，使用&lt;code&gt;np.float64&lt;/code&gt; 或&lt;code&gt;np.float32&lt;/code&gt; 来替代，具体选择哪个需要自己根据情况来确定，不同类型精度会有不同，下面举两个例子:&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 原先用法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo = np.random.rand(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, dtype=np.&lt;span class=&quot;built_in&quot;&gt;float&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 新用法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo = np.random.rand(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, dtype=np.float32)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 原先用法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo = np.random.rand(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;).astype(np.&lt;span class=&quot;built_in&quot;&gt;float&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 新用法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo = np.random.rand(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;).astype(np.float32)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里列出来了删除类型在标量和&lt;code&gt;np.ndarray&lt;/code&gt; 上的替代，方便查找&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;原先类型&lt;/th&gt;
&lt;th&gt;标量替换类型&lt;/th&gt;
&lt;th&gt;&lt;code&gt;np.ndarray&lt;/code&gt;替换类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;np.int&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;np.int32/np.int64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;np.float&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;np.float32/np.float64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;np.bool&lt;/td&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;np.bool_&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;np.complex&lt;/td&gt;
&lt;td&gt;complex&lt;/td&gt;
&lt;td&gt;np.complex128&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;np.object&lt;/td&gt;
&lt;td&gt;object&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;np.str&lt;/td&gt;
&lt;td&gt;str&lt;/td&gt;
&lt;td&gt;np.str_&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;np.long&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;np.int32/np.int64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;np.unicode&lt;/td&gt;
&lt;td&gt;str&lt;/td&gt;
&lt;td&gt;np.str_&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;详细说明参考&lt;a href=&quot;https://numpy.org/doc/stable/release/1.20.0-notes.html#deprecations&quot;&gt;NumPy 1.20.0 Release Notes&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面详细说说事情的来龙去脉。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="Numpy" scheme="http://vra.github.io/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>手机上看arxiv上论文的方法</title>
    <link href="http://vra.github.io/2023/01/27/arxiv-on-mobile/"/>
    <id>http://vra.github.io/2023/01/27/arxiv-on-mobile/</id>
    <published>2023-01-27T14:44:41.000Z</published>
    <updated>2023-01-27T15:16:22.167Z</updated>
    
    <content type="html"><![CDATA[<p>有时候想要在手机上访问Arxiv上的论文，打开arxiv.com，发现体验比较差，没有响应式设计，需要不断移动页面才能读完一行文字，影响阅读。偶然发现了<a href="https://www.arxiv-vanity.com/">arxiv-vanity</a>这个网站，发现能很好的满足手机上看arxiv论文的需求，收藏了。</p><span id="more"></span><p>首先看下arxiv-vanity网站的介绍:</p><blockquote><p>arXiv Vanity renders academic papers from arXiv as responsive web pages so you don’t have to squint at a PDF.</p></blockquote><p>翻译成中文就是:</p><blockquote><p>arXiv Vanity 将 arXiv 的学术论文呈现为响应式网页，因此您不必眯着眼睛看 PDF。</p></blockquote><p>exactly what I need!</p><p>那么该如何使用呢？</p><p>在<a href="https://www.arxiv-vanity.com/">arxiv-vanity</a>首页的搜索框中输入arxiv论文的摘要页面，如<code>https://arxiv.org/abs/1605.07683</code>，按右边的按钮，就能将论文转换为HTML文件，并且在不同的设备下自适应地调整大小。</p><p>另外也可以通过<code>https://www.arxiv-vanity.com/papers/&lt;paper_id&gt;</code>的方式访问转换后的HTML页面，比如<code>https://www.arxiv-vanity.com/papers/1605.07683/</code>。</p><p>大概原理是使用<a href="https://dlmf.nist.gov/LaTeXML/">LaTeXML</a>将Latex原文件转换为HTML，再进行显示。具体实现参见<a href="https://github.com/arxiv-vanity/engrafo">源码</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有时候想要在手机上访问Arxiv上的论文，打开arxiv.com，发现体验比较差，没有响应式设计，需要不断移动页面才能读完一行文字，影响阅读。偶然发现了&lt;a href=&quot;https://www.arxiv-vanity.com/&quot;&gt;arxiv-vanity&lt;/a&gt;这个网站，发现能很好的满足手机上看arxiv论文的需求，收藏了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Latex" scheme="http://vra.github.io/tags/Latex/"/>
    
    <category term="HTML" scheme="http://vra.github.io/tags/HTML/"/>
    
    <category term="Web" scheme="http://vra.github.io/tags/Web/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux小技巧：使用find命令来删除空文件</title>
    <link href="http://vra.github.io/2023/01/20/linux-delete-empty-files/"/>
    <id>http://vra.github.io/2023/01/20/linux-delete-empty-files/</id>
    <published>2023-01-20T06:36:13.000Z</published>
    <updated>2023-01-20T07:16:39.999Z</updated>
    
    <content type="html"><![CDATA[<p>在某个目录下有很多代码创建的空文件，分布在不同层级的子目录中，我们有没有办法可以快速地全部把它们删掉呢？</p><p><a href="https://man7.org/linux/man-pages/man1/find.1.html">find</a>是Linux系统中的一个强大的命令，通过它我们可以找到空文件，然后将它们进行删除。</p><p>TL;DR<br>最终命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -size 0 -<span class="built_in">print</span> -delete</span><br></pre></td></tr></table></figure><p>几个参数详细的说明见下。</p><span id="more"></span><p><code>-type</code>表示匹配项的文件类型，<code>d</code>表示文件夹，<code>f</code>表示文件，<code>l</code>表示软链接等，完整的类型如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">b: block (buffered) special</span><br><span class="line"></span><br><span class="line">c: character (unbuffered) special</span><br><span class="line"></span><br><span class="line">d: directory</span><br><span class="line"></span><br><span class="line">p: named pipe (FIFO)</span><br><span class="line"></span><br><span class="line">f: regular file</span><br><span class="line"></span><br><span class="line">l: symbolic link; this is never true if the -L option</span><br><span class="line"> : or the -follow option is in effect, unless the</span><br><span class="line"> : symbolic link is broken.  If you want to search for</span><br><span class="line"> : symbolic links when -L is in effect, use -xtype.</span><br><span class="line"></span><br><span class="line">s: socket</span><br></pre></td></tr></table></figure><p>所以下面的命令只会列出当前目录下的所有文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f</span><br></pre></td></tr></table></figure><p><code>-size</code>用来进行文件和目录的大小判断，例如<code>-size 6c</code>表示大小等于6字节，<code>-size -6c</code>表示小于6字节，<code>-size +6c</code>表示大于6字节，大小单位包括：c：字节，w:双字节，k:1024字节，M：1024<em>1024字节，G：1024</em>1024*1024字节，不加单位的话，等于b:512字节:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 寻找当前目录下大小为0的文件或目录</span></span><br><span class="line">find . -size 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找当前目录下小于512字节的文件或目录</span></span><br><span class="line">find . -size -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找当前目录下大于1字节的文件或目录</span></span><br><span class="line">find . -size +1c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找当前目录下大于1M的文件或目录</span></span><br><span class="line">find . -size +1M</span><br></pre></td></tr></table></figure><p>有了这个选项，就能很容易地过滤出当前目录下的空文件了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -size 0</span><br></pre></td></tr></table></figure><p>另一个选项是<code>-delete</code>，它的作用是直接删除找到的文件。</p><p>还有一个选项是<code>-print</code>，即打印匹配的文件路径到标准输出。</p><p>结合这几个选项，我们就能删除当前目录下的所有空文件，并且在删除时打印文件名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -size 0 -<span class="built_in">print</span> -delete</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在某个目录下有很多代码创建的空文件，分布在不同层级的子目录中，我们有没有办法可以快速地全部把它们删掉呢？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://man7.org/linux/man-pages/man1/find.1.html&quot;&gt;find&lt;/a&gt;是Linux系统中的一个强大的命令，通过它我们可以找到空文件，然后将它们进行删除。&lt;/p&gt;
&lt;p&gt;TL;DR&lt;br&gt;最终命令如下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;find . -&lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt; f -size 0 -&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt; -delete&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;几个参数详细的说明见下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="find" scheme="http://vra.github.io/tags/find/"/>
    
  </entry>
  
  <entry>
    <title>python 多个with 语句一起使用</title>
    <link href="http://vra.github.io/2023/01/20/python-with-statement/"/>
    <id>http://vra.github.io/2023/01/20/python-with-statement/</id>
    <published>2023-01-20T05:37:24.000Z</published>
    <updated>2023-01-20T05:58:36.949Z</updated>
    
    <content type="html"><![CDATA[<p>在读《流畅的Python》时，偶然看到下面的语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> urlopen(URL) <span class="keyword">as</span> remote, <span class="built_in">open</span>(JSON, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> local:</span><br><span class="line">    local.write(remote.read())</span><br></pre></td></tr></table></figure><p>突然才发现，原来多个with语句可以写到一起!</p><span id="more"></span><p>我之前都是每个<code>with</code>一个层级，像下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;in_file&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;out_file&#x27;</span> <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> of:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            of.write(line)</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>这样写每个with语句需要缩进一次，阅读起来逻辑不连续，而且很容易超过每行的字符限制，导致需要换行等问题，不是很方便。</p><p>经过这个偶然的发现，以后上面的代码可以这样写了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;in_file&#x27;</span>) <span class="keyword">as</span> f, <span class="built_in">open</span>(<span class="string">&#x27;out_file&#x27;</span> <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> of:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        of.write(line)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>同时看 <code>with</code> 语句的<a href="https://docs.python.org/3/reference/compound_stmts.html#the-with-statement">官方文档</a>，发现从Python 3.10版本起，还可以用括号将多个with语句括起来:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (</span><br><span class="line">    <span class="built_in">open</span>(<span class="string">&quot;face_model_choice.txt&quot;</span>) <span class="keyword">as</span> f,</span><br><span class="line">    <span class="built_in">open</span>(<span class="string">&quot;ttt.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> of1,</span><br><span class="line">    <span class="built_in">open</span>(<span class="string">&quot;ttt2.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> of2,</span><br><span class="line">):</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        of1.write(line)</span><br><span class="line">        of2.write(line)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样看起来也更简洁了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在读《流畅的Python》时，偶然看到下面的语句：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; urlopen(URL) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; remote, &lt;span class=&quot;built_in&quot;&gt;open&lt;/span&gt;(JSON, &lt;span class=&quot;string&quot;&gt;&amp;#x27;wb&amp;#x27;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; local:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local.write(remote.read())&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;突然才发现，原来多个with语句可以写到一起!&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="TIL" scheme="http://vra.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg抽取高清图像帧</title>
    <link href="http://vra.github.io/2023/01/15/ffmpeg-extract-high-quality-images/"/>
    <id>http://vra.github.io/2023/01/15/ffmpeg-extract-high-quality-images/</id>
    <published>2023-01-15T14:27:33.000Z</published>
    <updated>2023-01-20T05:56:08.274Z</updated>
    
    <content type="html"><![CDATA[<p>使用<a href="https://ffmpeg.org/">ffmpeg</a>可以方便地从视频中抽取图像帧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i /path/to/video.mp4 image-folder/%06d.jpg</span><br></pre></td></tr></table></figure><p>但实际测试发现，抽取的图像帧比较模糊，有明显的块效应。</p><p>搜索时有人说可以加<code>-q:v 1 -qmin 1 -qmax 1</code>来提高图像质量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i /path/to/video.mp4 -q:v 1 -qmin 1 -qmax 1 image-folder/%06d.jpg</span><br></pre></td></tr></table></figure><p>测试发现确实有一些提升，但还是能看到明显的模糊。</p><p>最后发现，把抽取的图像格式从<code>.jpg</code>修改为<code>.png</code>，结果就是高清且无块效应的了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i /path/to/video.mp4 image-folder/%06d.png</span><br></pre></td></tr></table></figure><p>另外PNG格式的图像存储大小要大一些，但不会太大，还是能接受的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用&lt;a href=&quot;https://ffmpeg.org/&quot;&gt;ffmpeg&lt;/a&gt;可以方便地从视频中抽取图像帧：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla</summary>
      
    
    
    
    
    <category term="图像" scheme="http://vra.github.io/tags/%E5%9B%BE%E5%83%8F/"/>
    
    <category term="ffmpeg" scheme="http://vra.github.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>原来 git stash 应该这么用</title>
    <link href="http://vra.github.io/2023/01/15/git-stash/"/>
    <id>http://vra.github.io/2023/01/15/git-stash/</id>
    <published>2023-01-15T05:19:57.000Z</published>
    <updated>2023-01-20T06:19:01.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前段时间突然发现，我之前对<code>git stash</code>的使用都是错误的。</p><p>具体说来，我是这么使用的：在远端有新的提交，需要<code>git pull</code>来拉取合并时，发现本地有一些未提交的修改，功能也没实现，不适合做一次commit。这时候我执行<code>git stash</code>隐藏本地的修改，然后执行<code>git pull</code>来拉取远端的更新，在最新代码基础上<strong>重新实现</strong>stash的那些代码中的功能。</p><p>这里的问题是，重新实现stash代码中的那一步，其实完全可以用<code>git stash pop</code>来替代，执行这个命令会在最新代码基础上作用stash的代码，不用再重新实现一遍了（不过这时可能会有代码冲突需要解决）。所以我之前是把<code>git stash</code>当<code>git checkout -- .</code>来用了，也就是抛弃了本地的代码更新，显然是有问题的。</p><p>正确流程基本上是这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="comment"># 或者 git stash push，效果一样</span></span><br><span class="line">git pull <span class="comment"># 可能有冲突需要手动合并</span></span><br><span class="line">git stash pop <span class="comment"># 可能有冲突需要手动合并</span></span><br></pre></td></tr></table></figure><p>下面记录一下 git stash 提供的功能和一些参数。</p><span id="more"></span><h2 id="git-stash-具体用法"><a href="#git-stash-具体用法" class="headerlink" title="git stash 具体用法"></a>git stash 具体用法</h2><p><code>git stash</code>创建一个新的stash，效果与<code>git stash push</code> 一样，效果如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on master: c6771a5 doc: fix error during pre-commiting</span><br></pre></td></tr></table></figure><p>增加<code>-u</code>选项可以将未track的文件也隐藏起来。</p><p>你可以创建多个stash，最早的stash表示为<code>stash@&#123;0&#125;</code>，然后是<code>stash@&#123;1&#125;</code>，依次递加。</p><p><code>git stash list</code> 会列出所有的stash：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: c6771a5 doc: fix error during pre-commiting</span><br><span class="line">stash@&#123;1&#125;: WIP on master: c6771a5 doc: fix error during pre-commiting</span><br></pre></td></tr></table></figure><p><code>git stash show</code>可以查看最新stash中的修改，加上编号可以查看之前版本的修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash show stash@&#123;0&#125;</span><br><span class="line">version.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p><code>git stash apply</code> 可以应用最新的stash到当前的代码中，同样的，如果加上编号则可以应用之前版本的修改到当前代码。apply执行后记得调用<code>git stash drop</code> 来去除以及应用的stash。<br><code>git stash pop</code>效果等于<code>git stash apply</code> + <code>git stash drop</code>。</p><p><code>git stash branch</code>会基于老的提交代码创建一个分支，同时把最新的修改也作用过去，这样对于新的提交和老提交代码变化很大的场景比较好，避免在新的提交上apply stash时由于冲突太多造成的合并问题。</p><p><code>git stash clean</code> 会清空所有的stash，<strong>且没有任何提示</strong>，这意味着你所有隐藏的代码都会被删除，执行此命令前请三思！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;前段时间突然发现，我之前对&lt;code&gt;git stash&lt;/code&gt;的使用都是错误的。&lt;/p&gt;
&lt;p&gt;具体说来，我是这么使用的：在远端有新的提交，需要&lt;code&gt;git pull&lt;/code&gt;来拉取合并时，发现本地有一些未提交的修改，功能也没实现，不适合做一次commit。这时候我执行&lt;code&gt;git stash&lt;/code&gt;隐藏本地的修改，然后执行&lt;code&gt;git pull&lt;/code&gt;来拉取远端的更新，在最新代码基础上&lt;strong&gt;重新实现&lt;/strong&gt;stash的那些代码中的功能。&lt;/p&gt;
&lt;p&gt;这里的问题是，重新实现stash代码中的那一步，其实完全可以用&lt;code&gt;git stash pop&lt;/code&gt;来替代，执行这个命令会在最新代码基础上作用stash的代码，不用再重新实现一遍了（不过这时可能会有代码冲突需要解决）。所以我之前是把&lt;code&gt;git stash&lt;/code&gt;当&lt;code&gt;git checkout -- .&lt;/code&gt;来用了，也就是抛弃了本地的代码更新，显然是有问题的。&lt;/p&gt;
&lt;p&gt;正确流程基本上是这样：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git stash &lt;span class=&quot;comment&quot;&gt;# 或者 git stash push，效果一样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git pull &lt;span class=&quot;comment&quot;&gt;# 可能有冲突需要手动合并&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git stash pop &lt;span class=&quot;comment&quot;&gt;# 可能有冲突需要手动合并&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面记录一下 git stash 提供的功能和一些参数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>2022年终总结</title>
    <link href="http://vra.github.io/2022/12/31/summary-2022/"/>
    <id>http://vra.github.io/2022/12/31/summary-2022/</id>
    <published>2022-12-31T03:09:39.000Z</published>
    <updated>2023-01-02T16:59:23.374Z</updated>
    
    <content type="html"><![CDATA[<p>多年以后，想起2022，我会回忆起哪个画面？为了解答这个问题，我回想过去的这些年份，2021，2020，……2005，看能想到什么。除了有些年份里，我结婚，毕业，所以有记忆深刻的事件，大部分年份我甚至想不起任何事情。对于一个模糊的数字，在多年以后，我们确实难以将它和自己一天天度过的日常事情关联起来。虽然2022年发生了很多事情，但大部分还是会被遗忘，但我还是尽量想用详细的文字记录下来，这样当以后想会看那年我身上发生了什么的时候，我知道只要在浏览器里面输入<code>vra.github.io/2022/12/31/summary-2022</code>，这些时刻都会清晰地浮现在我眼前。</p><span id="more"></span><h2 id="今年做了什么"><a href="#今年做了什么" class="headerlink" title="今年做了什么"></a>今年做了什么</h2><p>今年在比赛和论文上，和亭枫参加了一个DLGC学术比赛，拿到了第一名，也发表了一篇对应的Workshop论文。去年合作投稿的论文今年辗转投稿了几次，最后投了期刊。今年组内还举办了一场ECCV学术比赛，我作为一个赛道的负责人，在合作方的支持下，构建了训练和测试数据，提供了Baseline，搭建了测评服务，写介绍文章，招募选手，在Slack上和合作的老师英文沟通，成长了挺多的。</p><p>到新团队后，在天猫App上线了一些创新算法驱动的的功能，也算是在亿级用户的App上开发过产品了。</p><p>在技术总结上，今年总共更新了共36篇技术博客，相比之前几年进步巨大。虽然没有太多有亮点的文章，但总算是开始形成比较好的更新习惯了。在大概10月的生活，发现了程序员大神 Simon Willison的<a href="https://simonwillison.net/">博客</a>，收获很多。让我收益的是他的TIL (Tody I Learned) 板块，就是记录每天学习到的技术，开始记录，然后慢慢地提高。基于这个思路，今年写了许多学习到的简单但有用的命令和操作，希望以后坚持下去。</p><h2 id="今年的遗憾"><a href="#今年的遗憾" class="headerlink" title="今年的遗憾"></a>今年的遗憾</h2><p>2022年也是一个充满遗憾的一年。春天晋升失败，虽然身处其中，但面对失败的那种难受感觉，相信你能懂。然后就是组织调整，猝不及防间，很多小伙伴离开了团队，人心惶惶。在公司的一道通知前，我们打工者只有默默接受。然后换到新的组，做新的事情，所幸做的东西差别不大，能够比较快的适应。</p><p>在回望工作这五年，发现工作中，虽然事情勉强能做好，但还远没做到让自己满意。没有发表什么好的论文，模型效果差强人意，做的项目也平平庸庸。</p><p>虽然不想承认，但在即将到来的2023年，我要满30周岁了。在能看到自身的各种问题，却没有好的解决方法的时候，我知道我遇到职业生涯的危机了。那么我自己的核心问题出在哪里？核心矛盾是：长期的目标与短期的行动之间没有匹配。长期的目标是明确的，但当目标被分解到日常的工作中时，很多核心问题没有被解决，而是其他紧急且必须但长远来看不核心的任务占用了绝大部分的时间，导致在不占用家庭和个人生活时间的情况下，没有足够的时间来做核心的工作。</p><p>正如大老板讲过的，通过换环境、换赛道来解决自己遇到问题的想法，是不切实际的。根本问题不解决，在新的赛道，新的环境，就算刚开始做的很顺利，在后面还是会遇到同样的问题，会踩同样的坑。</p><p>2023年，希望多一些清醒的思考，少一些每天只忙着做手头事情的混沌时刻。</p><h2 id="关于技术社区"><a href="#关于技术社区" class="headerlink" title="关于技术社区"></a>关于技术社区</h2><p>今年接触了Lobste.rs社区，发现里面很多编程大佬和很多高质量文章，高质量讨论。而且更为难得的是，社区氛围很好，每个讨论都是非常理性，就事论事，让人不禁想，国内能否有这样的纯粹的技术社区，学习，讨论，研发最新的技术。作为尝试的一小步，我用一个git仓库记录了每周我阅读的技术文章，至于怎么进一步增加讨论，还没有比较好的思路。</p><p>2023-01-03更新：在v2ex上看到了国内的Lobste.rs社区<a href="https://dto.pipecraft.net/">DTO</a>，欢迎在<a href="https://www.v2ex.com/t/905509">这里</a>或<a href="https://github.com/dev-topics-only/lobsters/issues/1">这里</a>发帖申请加入，为提高国内的技术氛围做一份贡献!</p><h2 id="关于AI和chatGPT"><a href="#关于AI和chatGPT" class="headerlink" title="关于AI和chatGPT"></a>关于AI和chatGPT</h2><p>去年体验了一下Copilot，当时的震撼现在还有印象，体验完后，我不禁想：相比Copilot，我们真人的优势在哪里，该如何与它共存？我没答案。<br>今年的chatGPT的爆火，进一步地让我看到AI工具对我们开发者的巨大影响。经过思考，我认为这些AI工具可能会替代我们程序员的某些工作，但不会替代程序员这个行业，只是会明显地改变程序员的编程行为，而且利用好这些工具，会是程序员的必修课。</p><p>从研究者的角度，chatGPT已经可以很好地理解大部分人类语言，所以我认为NLP研究已经到了一个里程碑的阶段，真正智能的AI语音助手不远了，未来几年也会有更多真正的语音助手进入普通人的生活中。</p><p>有点感慨，有时候技术的发展很慢，让人看不到希望，但有时候，技术又发展的太快，让人跟不上脚步。作为一个普通人技术人，还是要感谢那些顶尖的研究者，让我们在有生之年能看到如此激动人心的技术进步。</p><h2 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h2><p>说完技术，谈谈生活吧。今年6月份搬了一次家，从公司附近搬到了老婆上班的幼儿园附近，开始坐地铁上下班。<br>在地铁上，要么刷技术网站，要么刷gif和搞笑网站。在地铁19号线开通后，单程时间缩短到一个小时内，旅程没那么漫长，站着也没那么累了。</p><p>因为疫情封控，平时没怎么出去，周末基本躺家里，偶尔周末一个人去爬山，逛博物馆。有时候和老婆一起出去走走，有时候有同学来杭州来聚聚，大部分时候，坐地铁，上班，坐地铁，从热的蒸发的六月到有些寒冷的腊月。</p><p>印象最深刻的是夏天从地铁站到公司的那段路。那时候19号线还没开通，只能从5号线永福地铁站出来，然后骑共享单车去公司。有时候没有车了，就只能步行近20分钟去公司。2022年的夏天特别的热，一出地铁，刚到扶梯上，一股热浪就袭来，然后出去找单车，坐上去屁股都快烫熟了。在过十字路口前，找一片小树荫躲避烈日，一到绿灯，上班的人都骑着车过马路，在下一个路口继续寻找小树荫，到公司大部分时候后背都已经湿透了。</p><p>好在9月22日，杭州地铁19号线开通，开通当天的晚上，我就去体验了，从此回家快了不少，而且再也不用走那么远的路了。</p><p>平常的日子里，也有惊喜的时刻。9月1日，听到老婆怀孕的消息，我激动坏了。离当爸爸越来越近了，也有对于自己能否做个好爸爸的隐忧。</p><p>今年和小伙伴每天吃饭时讨论最多的话题就是疫情。没想到结局竟然是这样。这里也说说我开放之后变🐑的经历。12月22日是周四，冬至，嗓子开始有点涩的感觉，等到周五下午，浑身酸疼，差点撑不到下班。六点下班，到家后九点就开始睡觉，周六醒来浑身不疼了，到下午🈶又开始疼，头后面一抽一抽地疼。周日测了一下，果然是阳性。过了几天，浑身不疼了，但嗓子还有些难受。</p><h2 id="阅读的书籍"><a href="#阅读的书籍" class="headerlink" title="阅读的书籍"></a>阅读的书籍</h2><p>今年读了比较多的历史方面的书，让我一直思考”我们从哪来”的问题得到了更完整的理解。最难忘的是王鼎钧的回忆录系列，“插柳学诗”章节是我看过的对清末民初乡村士绅最好的介绍。《李宗仁回忆录》和《胡适口述自传》也让我对唐德刚老教授敬佩不已。下面列出一些基本看完且比较推荐的书，供以后查阅。</p><ul><li>《王鼎钧回忆录四部曲》</li><li>《李宗仁回忆录》</li><li>《五更盘道》</li><li>《依稀识得故乡痕：漆家山50年村史》</li><li>《人间杭州》</li><li>《红星照耀中国》</li><li>《晚清最后十八年》</li><li>《寻觅意义》</li><li>《尼安德特人》</li><li>《周恩来传》</li><li>《胡适口述自传》</li><li>《我的个天》</li><li>《左宗棠在甘肃》</li></ul><h2 id="观影"><a href="#观影" class="headerlink" title="观影"></a>观影</h2><p>今年还是在周末看了很多影视作品，难得的是有很多比较感兴趣的科幻和赛博朋克的影视作品出现，大饱眼福。这里按照我的喜好大致排序列出来一些推荐的影视作品。</p><ul><li>《万神殿》</li><li>《赛博朋克：边缘行者》</li><li>《隐入尘烟》</li><li>《史前星球》</li><li>《边缘世界》</li><li>《指环王力量之戒》</li><li>《白莲花度假村》</li><li>《狙击手》</li><li>《爱，死亡和机器人第三季》</li><li>《瞬息全宇宙》</li><li>《人生切割术》</li><li>《黑袍纠察队》</li><li>《1883》  </li><li>《利刃出鞘2》</li><li>《流人第一季》</li><li>《和平使者》</li><li>《塔尔萨之王》</li><li>《上载》</li><li>《法兰西特派》</li><li>《亚当计划》</li><li>《柏青哥》</li><li>《初创玩家》</li><li>《阶梯之间》</li><li>《替身演员》</li><li>《光环》</li><li>《欧比旺》</li><li>《三体动画》</li><li>《月光骑士》</li><li>《荒野迷案》</li><li>《雷神4》</li><li>《奇异博士2》</li><li>《我是格鲁特》</li></ul><h2 id="相聚与出游"><a href="#相聚与出游" class="headerlink" title="相聚与出游"></a>相聚与出游</h2><p>今年疫情反复，几乎没有出杭州，也没有和朋友太多相聚，努力的回忆这些难得的出行和相聚时刻，想起来还是很温暖。</p><ul><li>1月28日，先从杭州坐飞机到西安，由于西安到天水的航班取消了，我到西安后坐高铁到天水，然后在在天水去庄浪，待了两天后和彤彤一起回我家过年。在正月大雪初霁的初六坐车去杭州，先联系出租到县城，和二姐云亮吃了火锅，然后在二姐家住了一晚，第二天一大早出发，坐武山去天水的火车，然后去天水南站坐去杭州的高铁。</li><li>在武山去了前程的鱿鱼摊位，和他匆匆聊了几句，晚上去康智雄家，也是数年没见了。</li><li>2月份，去张凯家里坐了会，聊了聊各自工作的情况。</li><li>3月5日，植物园春游，灵峰山下梅花盛开，花团锦簇，游人如织。</li><li>4月9日，和彤彤去青山湖，从地铁站出来的湖边开阔处，一直走到杉树林，找到一个地方野餐。</li><li>4月17日，从五云山牌坊入口爬山，重游真迹寺，再走万林背山，到三分叉，从龙井村下山，走反了方向，朝九溪十八涧去了，没大路了才重新走回来打车。</li><li>5月3日，去凯旋家做客，他们俩热情地招待我们，吃完饭后玩了一会Switch</li><li>6月3日，7年后重游绍兴，坐地铁两个小时到鲁迅故居站，游鲁迅故居，王阳明故居，上次来吃的好吃饭店已经关门了。</li><li>6月4日，骑行杭州古城门，从西湖文化广场出发，先后去艮山门，庆春门，清泰门，望江门，候潮门至凤山水潮门，至此西湖的古城门算是都走过一圈了，虽然基本上出了一个写着名字的标志，没有别的什么留存了。</li><li>6月19日，高中同学东升换工作来杭州了，和他在青山湖科技城附近吃了饭，还吃到了他从家里带来的好吃的杏子。</li><li>7月1日，小团队去了西湖文体中心打羽毛球，攀岩，之后去西溪湿地里面聚餐。</li><li>7月9日，和彤彤夜游断桥。</li><li>7月14-7月17日，团队去成都outing，见了小爱，夜游锦江；团队去了杜甫草堂，武侯祠，乐山大佛，都江堰，大熊猫基地</li><li>7月24日，夜游钱塘江，骑自行车从近九堡大桥到新彭埠大桥</li><li>8月5日，和本科室友刘旸和他女朋友杨珈蒙聚餐</li><li>8月16日，和彤彤去杭州国家版本馆，里面的科技含量、文化含量远超预期，值得再去。</li><li>8月28日，和高中同学东升、聂小鹏在火车东站万象汇聚餐，和小鹏毕业后就没见过，已经11年了。</li><li>8月29日，独游钱王祠和万松书院，钱王祠的丹书铁券让人印象深刻，万松书院幽深高远，见湖亭上可远眺西湖雷峰塔。</li><li>8月30日，游杭州博物馆，杭州孔庙和西湖博物馆。</li><li>9月18日，独自去丰收湖，空无一人的公交和空荡荡的过街天桥，和充满孩子欢声笑语的公园形成鲜明的对比。</li><li>9月27日，和小伙伴们给实习生乃源饯行，他要去深圳实习了。 </li><li>10月4日，和彤彤去了春天去过的南苕溪，春去秋来，野草疯长，旧路难辨。</li><li>10月15日，与彤彤去植物园露营，待了大半天，桂花虽旺季已过，仍留有余香。</li><li>10月29日，独自去了飞来峰、灵隐寺，韬光寺，北高峰。灵隐寺建筑高大雄伟，里面香客稠密，代表的是寺庙鲜活的一面，而韬光寺需要走不少的山路才到，里面人不多，难得清净，但也难以寻觅白居易与韬光大师论道的踪迹.</li><li>11月5日，韶言师兄来杭参加云栖大会，实验室部分小伙伴在滨江浦江聚餐。</li><li>11月9日，下午小团队去爬老和山，日落后下山，穿过植物园，没人收门票。再次路过梅树区空无一人，之后去青芝坞旁的民宿体验客家菜，难忘的时刻.</li><li>11月27日，与彤彤从市民中心漫游到钱塘江边的城市阳台，路过杭州标志之一的大金球，在城市阳台看对面奥体中心附近的3D霓虹广告。</li></ul><h2 id="2023年的展望"><a href="#2023年的展望" class="headerlink" title="2023年的展望"></a>2023年的展望</h2><p>虽然断断续续写了一整天，在出租屋里，生活杂事和刷手机的冲动下，还是静不下心，感觉还有很多思考很多方面没写到，留待以后再补充吧。</p><p>2023年，给自己定一些小的要求，激励自己：</p><ul><li>遇到问题彻底搞懂再停止，不要提前选择简单的路径或似懂非懂，走hard但长久来看更根本的路径</li><li>做真正有影响力的工作，反思：如果别人来做，会做成怎么样，我比别人做的好在哪里？</li><li>提高工作效率，聚焦长期目标，突破工作上的瓶颈</li><li>不看微博热搜，不刷短视频，卸载快手和抖音，空闲时间多看书</li><li>保证每周写一篇技术博客，将遇到的技术问题和技术思考记录下来，锻炼思考总结能力</li><li>每周校准一次目标，确认是不是在短期任务上偏离了长期目标，如果出现偏差及时纠正</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在2022年，感谢身边的所有人，不管是陪在身边的老婆和肚子里的孩子，还是每天一起工作，一起吃食堂的干饭小伙伴，还是每周视频里远方的家人，还是偶尔在钉钉上问候一下的同学同事，还是躺在微信通讯录里面几年没联系的老友，你们构成了我这一年的思念和牵绊，也构成了我难忘的2022。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;多年以后，想起2022，我会回忆起哪个画面？为了解答这个问题，我回想过去的这些年份，2021，2020，……2005，看能想到什么。除了有些年份里，我结婚，毕业，所以有记忆深刻的事件，大部分年份我甚至想不起任何事情。对于一个模糊的数字，在多年以后，我们确实难以将它和自己一天天度过的日常事情关联起来。虽然2022年发生了很多事情，但大部分还是会被遗忘，但我还是尽量想用详细的文字记录下来，这样当以后想会看那年我身上发生了什么的时候，我知道只要在浏览器里面输入&lt;code&gt;vra.github.io/2022/12/31/summary-2022&lt;/code&gt;，这些时刻都会清晰地浮现在我眼前。&lt;/p&gt;</summary>
    
    
    
    
    <category term="年终总结" scheme="http://vra.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>git 更新历史提交</title>
    <link href="http://vra.github.io/2022/12/16/git-update-a-history-commit/"/>
    <id>http://vra.github.io/2022/12/16/git-update-a-history-commit/</id>
    <published>2022-12-16T01:01:45.000Z</published>
    <updated>2022-12-19T15:46:55.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>有时候我们在git commit后才发现，之前的一些提交有些问题，比如有些代码忘提交了或者有一些typo需要修改。如果要修改的地方是需要添加到最后一次提交上的，那么可以参考我的<a href="https://vra.github.io/2022/11/12/git-add-file-to-last-commit/">这篇博文</a>修改，如果是在非最后一次提交上的，那么就需要用<code>git rebase</code>来操作。这里简单记录一下操作的过程。</p><p><strong>TL;DR</strong><br>操作命令简要来说是这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用git log 查看历史提交，得到需要修改的那次提交的commit id</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 执行rebase命令，注意&lt;commit-id&gt;后面有一个^，表示修改在此次提交前</span></span><br><span class="line">git rebase -i <span class="string">&#x27;&lt;commmit-hash&gt;^&#x27;</span> <span class="comment"># 如果是修改第一次提交，使用 git rebase -i --root</span></span><br><span class="line"><span class="comment"># 修改代码</span></span><br><span class="line">vim changed-file</span><br><span class="line"><span class="comment"># git add 添加更新后的文件</span></span><br><span class="line">git add changed-file</span><br><span class="line"><span class="comment"># git commit 提交，注意需要使用后面三个选项，并且不需要加commit信息，因为会采用之前的commit信息</span></span><br><span class="line">git commit --all --amend --no-edit</span><br><span class="line"><span class="comment"># 使用--continue来完成 git rebase</span></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>后面会使用一个具体的（假）例子来演示这个过程。</p><span id="more"></span><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>假设我们创建了一个代码仓库<code>my_project</code>，先后创建并提交了<code>README.md</code>和<code>main.py</code>文件，但发现第一次的提交里面有一个typo，例如比<code>math</code>打成了<code>meth</code>，现在想要修改第一次提交。</p><p>首先构造”案发现场”:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir my_project &amp;&amp; <span class="built_in">cd</span> my_project</span><br><span class="line">git init</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is my meth library&quot;</span> &gt;&gt; README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;doc: add readme&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;import numpy as np&quot;</span> &gt;&gt; main.py</span><br><span class="line">git add main.py</span><br><span class="line">git commit -m <span class="string">&quot;feat: create main.py&quot;</span></span><br></pre></td></tr></table></figure><p>注意上面的typo <code>meth</code>。</p><p>我们发现了上述问题，但不想新建一个提交来修复，因为确实不算是新功能，那么就用<code>git rebase</code>来完成吧。</p><p>git rebase 是用来修改git commit的命令，提供了非常多的功能。这里我们用<code>git rebase -i</code>来交互式地修改某次commit。</p><p>首先用 <code>git log</code>查看commit ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">* 9bec788 - (HEAD -&gt; main) add sigmoid (31 minutes ago) &lt;xyz&gt;</span><br><span class="line">* ea833e9 - doc: add doc (31 minutes ago) &lt;xyz&gt;</span><br></pre></td></tr></table></figure><p>假如要修改第二次提交，那我们可以用<code>git rebase -i &#39;9bec788^</code>，但我们要修改的是第一次提交，没有之前的状态，所以要用下面的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i --root</span><br><span class="line">Successfully rebased and updated refs/heads/main.</span><br></pre></td></tr></table></figure><p>出来的交互式界面:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pick ea833e9 doc: add doc</span><br><span class="line">pick 9bec788 add sigmoid</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase 9bec788 onto 927493a (2 commands)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment"># p, pick &lt;commit&gt; = use commit</span></span><br><span class="line"><span class="comment"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment"># e, edit &lt;commit&gt; = use commit, but stop for amending</span></span><br><span class="line"><span class="comment"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment"># f, fixup [-C | -c] &lt;commit&gt; = like &quot;squash&quot; but keep only the previous</span></span><br><span class="line"><span class="comment">#                    commit&#x27;s log message, unless -C is used, in which case</span></span><br><span class="line"><span class="comment">#                    keep only this commit&#x27;s message; -c is same as -C but</span></span><br><span class="line"><span class="comment">#                    opens the editor</span></span><br><span class="line"><span class="comment"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span></span><br><span class="line"><span class="comment"># d, drop &lt;commit&gt; = remove commit</span></span><br><span class="line"><span class="comment"># l, label &lt;label&gt; = label current HEAD with a name</span></span><br><span class="line"><span class="comment"># t, reset &lt;label&gt; = reset HEAD to a label</span></span><br><span class="line"><span class="comment"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span><br><span class="line"><span class="comment">#         create a merge commit using the original merge commit&#x27;s</span></span><br><span class="line"><span class="comment">#         message (or the oneline, if no original merge commit was</span></span><br><span class="line"><span class="comment">#         specified); use -c &lt;commit&gt; to reword the commit message</span></span><br><span class="line"><span class="comment"># u, update-ref &lt;ref&gt; = track a placeholder for the &lt;ref&gt; to be updated</span></span><br><span class="line"><span class="comment">#                       to this position in the new commits. The &lt;ref&gt; is</span></span><br><span class="line"><span class="comment">#                       updated at the end of the rebase</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br></pre></td></tr></table></figure><p>底下注释中给出了rebase支持的一些命令和对应的缩写，我们将需要修改的提交前面的命令修改为<code>edit</code>，然后保存退出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">edit ea833e9 doc: add doc</span><br><span class="line">pick 9bec788 add sigmoid</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase 9bec788 onto e3f4cea (2 commands)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment"># p, pick &lt;commit&gt; = use commit</span></span><br><span class="line"><span class="comment"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment"># e, edit &lt;commit&gt; = use commit, but stop for amending</span></span><br><span class="line"><span class="comment"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment"># f, fixup [-C | -c] &lt;commit&gt; = like &quot;squash&quot; but keep only the previous</span></span><br><span class="line"><span class="comment">#                    commit&#x27;s log message, unless -C is used, in which case</span></span><br><span class="line"><span class="comment">#                    keep only this commit&#x27;s message; -c is same as -C but</span></span><br><span class="line"><span class="comment">#                    opens the editor</span></span><br><span class="line"><span class="comment"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span></span><br><span class="line"><span class="comment"># d, drop &lt;commit&gt; = remove commit</span></span><br><span class="line"><span class="comment"># l, label &lt;label&gt; = label current HEAD with a name</span></span><br><span class="line"><span class="comment"># t, reset &lt;label&gt; = reset HEAD to a label</span></span><br><span class="line"><span class="comment"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span><br><span class="line"><span class="comment">#         create a merge commit using the original merge commit&#x27;s</span></span><br><span class="line"><span class="comment">#         message (or the oneline, if no original merge commit was</span></span><br><span class="line"><span class="comment">#         specified); use -c &lt;commit&gt; to reword the commit message</span></span><br><span class="line"><span class="comment"># u, update-ref &lt;ref&gt; = track a placeholder for the &lt;ref&gt; to be updated</span></span><br><span class="line"><span class="comment">#                       to this position in the new commits. The &lt;ref&gt; is</span></span><br><span class="line"><span class="comment">#                       updated at the end of the rebase</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span><br></pre></td></tr></table></figure><p>保存后输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stopped at ea833e9...  doc: add doc</span><br><span class="line">You can amend the commit now, with</span><br><span class="line"></span><br><span class="line">  git commit --amend</span><br><span class="line"></span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line"></span><br><span class="line">  git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>用<code>git status</code> 查看代码状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interactive rebase <span class="keyword">in</span> progress; onto e3f4cea</span><br><span class="line">Last <span class="built_in">command</span> <span class="keyword">done</span> (1 <span class="built_in">command</span> <span class="keyword">done</span>):</span><br><span class="line">   edit ea833e9 doc: add doc</span><br><span class="line">Next <span class="built_in">command</span> to <span class="keyword">do</span> (1 remaining <span class="built_in">command</span>):</span><br><span class="line">   pick 9bec788 add sigmoid</span><br><span class="line">  (use <span class="string">&quot;git rebase --edit-todo&quot;</span> to view and edit)</span><br><span class="line">You are currently editing a commit <span class="keyword">while</span> rebasing branch <span class="string">&#x27;main&#x27;</span> on <span class="string">&#x27;e3f4cea&#x27;</span>.</span><br><span class="line">  (use <span class="string">&quot;git commit --amend&quot;</span> to amend the current commit)</span><br><span class="line">  (use <span class="string">&quot;git rebase --continue&quot;</span> once you are satisfied with your changes)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>git 的提示信息还是很丰富的，按照提示来操作代码，将<code>meth</code> 修改为<code>math</code>，再<code>git add</code>, <code>git commit --all --amend --no-edit</code>和 <code>git rebase --continue</code> 来结束rebase:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git add README.md</span><br><span class="line"></span><br><span class="line">$ git commit --all --amend --no-edit</span><br><span class="line">[detached HEAD 3b83a85] doc: add doc</span><br><span class="line"> Date: Sat Dec 17 18:00:12 2022 +0800</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br><span class="line"> create mode 100644 README.md</span><br><span class="line"></span><br><span class="line">$ git rebase --<span class="built_in">continue</span></span><br><span class="line">Successfully rebased and updated refs/heads/main.</span><br></pre></td></tr></table></figure><p>然后用<code>git log</code>查看命令，可以看到修改的那次提交和后续提交的编号都已经更新了，意味着这是全新的提交，跟之前的提交没有关系了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;有时候我们在git commit后才发现，之前的一些提交有些问题，比如有些代码忘提交了或者有一些typo需要修改。如果要修改的地方是需要添加到最后一次提交上的，那么可以参考我的&lt;a href=&quot;https://vra.github.io/2022/11/12/git-add-file-to-last-commit/&quot;&gt;这篇博文&lt;/a&gt;修改，如果是在非最后一次提交上的，那么就需要用&lt;code&gt;git rebase&lt;/code&gt;来操作。这里简单记录一下操作的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;&lt;br&gt;操作命令简要来说是这样:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 使用git log 查看历史提交，得到需要修改的那次提交的commit id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 执行rebase命令，注意&amp;lt;commit-id&amp;gt;后面有一个^，表示修改在此次提交前&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git rebase -i &lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;lt;commmit-hash&amp;gt;^&amp;#x27;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# 如果是修改第一次提交，使用 git rebase -i --root&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 修改代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vim changed-file&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# git add 添加更新后的文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git add changed-file&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# git commit 提交，注意需要使用后面三个选项，并且不需要加commit信息，因为会采用之前的commit信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit --all --amend --no-edit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 使用--continue来完成 git rebase&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git rebase --&lt;span class=&quot;built_in&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;后面会使用一个具体的（假）例子来演示这个过程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>使用 defaultdict 来简化 dict 的初始化</title>
    <link href="http://vra.github.io/2022/12/10/python-defaultdict-usage/"/>
    <id>http://vra.github.io/2022/12/10/python-defaultdict-usage/</id>
    <published>2022-12-10T07:17:17.000Z</published>
    <updated>2022-12-10T07:57:10.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在我们使用Python中的dict时，常常需要判断某个关键字是否已经在dict中，如果不存在则创建，非空则进行另外的操作。例如统计一篇文章中所有单词出现次数的代码，大致写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">words_num = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> words_num.keys():</span><br><span class="line">        words_num[word] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        words_num[word] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样写总是需要判断key是否在dict中，不是很优雅。</p><p>Python标准库collections中<a href="https://docs.python.org/3/library/collections.html#defaultdict-objects">defaultdict</a>类可以很好的解决这个问题。这个类使用与dict几乎一样，除了可以在初始化时设置key的默认类型和数值。类的声明格式为<code>defaultdict(default_factory=None, /[, ...])</code>，<code>default_factory</code>是一个<code>callable</code>的变量。</p><p>别的使用与dict无异，正常使用即可。</p><span id="more"></span><p>例如，<code>foo = defaultdict(int)</code>表示foo中的key的默认类型是int，且默认值为int的默认值0，我们可以获取<strong>任意</strong>的key，不需要手动初始化key:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;whatever&#x27;</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>所以最开始的例子可以简化为如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">words_num = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    words_num[word] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看到使用defaultdict后，代码中只需要关注上层逻辑（统计单词的出现次数），而不需要关注具体的语法的代码实现（dict是否存在某个key，没有的话xxx，有的话xxx），因此世界变得更美好了一些。</p><p>除了int外，用list，tuple，dict，set等作为变量也比较常见。除了内置类型外，还可以自定义函数，比如设置key的默认值为<code>&#39;China&#39;</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_default_contry</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">&quot;China&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from = defaultdict(set_default_contry)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from[<span class="string">&#x27;张三&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;China&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from[<span class="string">&#x27;李四&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;China&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from[<span class="string">&#x27;Tim&#x27;</span>] = <span class="string">&#x27;USA&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_from</span><br><span class="line">defaultdict(&lt;function set_default_contry at <span class="number">0x10896eca0</span>&gt;, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;China&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>: <span class="string">&#x27;China&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>: <span class="string">&#x27;China&#x27;</span>, <span class="string">&#x27;Tim&#x27;</span>: <span class="string">&#x27;USA&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p><code>defauldict</code>是一个简单但很好用的功能，在日常的使用中还是能减少一些代码复杂度的。希望这篇小文能给让你写代码更容易，更开心。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;在我们使用Python中的dict时，常常需要判断某个关键字是否已经在dict中，如果不存在则创建，非空则进行另外的操作。例如统计一篇文章中所有单词出现次数的代码，大致写法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;words_num = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; word &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; words:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; word &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; words_num.keys():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        words_num[word] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        words_num[word] += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样写总是需要判断key是否在dict中，不是很优雅。&lt;/p&gt;
&lt;p&gt;Python标准库collections中&lt;a href=&quot;https://docs.python.org/3/library/collections.html#defaultdict-objects&quot;&gt;defaultdict&lt;/a&gt;类可以很好的解决这个问题。这个类使用与dict几乎一样，除了可以在初始化时设置key的默认类型和数值。类的声明格式为&lt;code&gt;defaultdict(default_factory=None, /[, ...])&lt;/code&gt;，&lt;code&gt;default_factory&lt;/code&gt;是一个&lt;code&gt;callable&lt;/code&gt;的变量。&lt;/p&gt;
&lt;p&gt;别的使用与dict无异，正常使用即可。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>git如何添加文件到最新的提交</title>
    <link href="http://vra.github.io/2022/11/12/git-add-file-to-last-commit/"/>
    <id>http://vra.github.io/2022/11/12/git-add-file-to-last-commit/</id>
    <published>2022-11-12T09:54:22.000Z</published>
    <updated>2022-12-16T00:54:01.016Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，在git commit后，我们会发现一些文件忘了提交了，或者需要修改，而且这些提交和修改是与上一次commit的主题一致的，这时候再执行一遍相同的git commit就会让提交记录显得比较冗余，有没有办法将修改后的文件加到最后一次的提交记录里面呢？搜索后发现<a href="https://stackoverflow.com/a/40503483">这里</a>给了一个解决办法，git add文件后调用<code>git commit --amend -no-edit</code>即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file_path&gt;</span><br><span class="line">git commit --amend --no-edit</span><br></pre></td></tr></table></figure><p><strong>注意：如果之前的代码已经提交的话，需要执行<code>git push --force</code>来推送代码以替代之前的提交记录。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有时候，在git commit后，我们会发现一些文件忘了提交了，或者需要修改，而且这些提交和修改是与上一次commit的主题一致的，这时候再执行一遍相同的git commit就会让提交记录显得比较冗余，有没有办法将修改后的文件加到最后一次的提交记录里面呢？搜索后发现&lt;a h</summary>
      
    
    
    
    
    <category term="Git" scheme="http://vra.github.io/tags/Git/"/>
    
    <category term="TIL" scheme="http://vra.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>执行du命令时统计隐藏文件和目录</title>
    <link href="http://vra.github.io/2022/11/07/du-show-hidden-folders/"/>
    <id>http://vra.github.io/2022/11/07/du-show-hidden-folders/</id>
    <published>2022-11-07T15:32:23.000Z</published>
    <updated>2022-11-07T15:38:24.784Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux和Mac下，执行<code>du -sh</code> 来统计目录大小时，默认不统计以点开头的文件或者目录，比如<code>.local</code>，因此得到不准确的统计结果。从<a href="https://superuser.com/a/633808">这里</a>知道，要统计隐藏文件和目录，可以这么用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只统计隐藏文件或者目录</span></span><br><span class="line">du -sh .[^.]*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计隐藏文件或者目录和常规文件</span></span><br><span class="line">du -sh .[^.]* *</span><br></pre></td></tr></table></figure><p>结合 <code>sort -h</code>，可以快速得到比较大的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh .[^.]* * |sort -h</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Linux和Mac下，执行&lt;code&gt;du -sh&lt;/code&gt; 来统计目录大小时，默认不统计以点开头的文件或者目录，比如&lt;code&gt;.local&lt;/code&gt;，因此得到不准确的统计结果。从&lt;a href=&quot;https://superuser.com/a/633808&quot;&gt;</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="TIL" scheme="http://vra.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>如何举办一个顶会学术比赛</title>
    <link href="http://vra.github.io/2022/10/30/how-to-host-a-challenge/"/>
    <id>http://vra.github.io/2022/10/30/how-to-host-a-challenge/</id>
    <published>2022-10-30T12:34:41.000Z</published>
    <updated>2022-10-30T16:13:55.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>今年我和团队成员一起组织了了ECCV上的一个<a href="https://sites.google.com/view/wcpa2022/home">学术比赛</a>。从1.31日开始准备材料开始，到前两天(10.28日) 把奖金和奖状发给选手，活动结束，整个周期持续了近9个月，真的是出乎意料。整体流程包括Workshop Proposal编写和申请、Workshop合并（多个申请团队合并成一个Workshop），网站搭建，比赛数据和baseline准备，比赛平台搭建，比赛奖金申请，比赛宣传和选手招募、比赛论文评审、参加线上Workshop介绍比赛，奖金和证书颁发等等，第一次参与组织这种比赛，学到了挺多东西，这里记录备忘，下次参考。需要说明的是，这里的分享的都是个人观点，与我所在公司无关。</p><span id="more"></span><h2 id="2-时间流水线记录"><a href="#2-时间流水线记录" class="headerlink" title="2. 时间流水线记录"></a>2. 时间流水线记录</h2><p>这里记录整个过程中的一些关键行动和一些注意事项。</p><h3 id="2-1-前期准备"><a href="#2-1-前期准备" class="headerlink" title="2.1. 前期准备"></a>2.1. 前期准备</h3><p>首先要注意，要申办Workshop或者比赛的话，涉及事务多，需要一个团队来共同来负责，而且周期长，占用时间比较多，办比赛的话还需要奖金的申请，这些都需要团队Leader的理解和支持。同时需要一些学术界有声望的教授来一起参与，这样申请通过的概率会大一些。我们组内有跟学术界的长期合作，这次也是一起申办的。另一个是比赛一般需要新的数据集，有内部的数据团队或者合作的数据公司也会更好一些，分担一些数据收集和准备的任务。<br>有这些条件后，还是得思考Workshop或者比赛的主题，也就是为了解决学术界还是工业界的什么核心问题，来举办这样一个比赛。这样比赛意义会更重大，参赛选手的方案也许能推进某个方向的SOTA。</p><p>确定要举办Workshop或者比赛后，就需要盘点参与人员，提前联系学术界和数据公司的合作方，通通气，确认参与意向。</p><h3 id="2-2-撰写-Workshop-Proposal"><a href="#2-2-撰写-Workshop-Proposal" class="headerlink" title="2.2 撰写 Workshop Proposal"></a>2.2 撰写 Workshop Proposal</h3><p>接下来就需要写 Workshop Proposal给大会，大会收到后通过申请，才可以正式举办 Workshop。</p><p>Workshop Proposal 的撰写参考大会给的要求，填写workshop主体，比赛任务描述和对应的指标描述，主办者的资料等。</p><h3 id="2-3-嘉宾邀请"><a href="#2-3-嘉宾邀请" class="headerlink" title="2.3 嘉宾邀请"></a>2.3 嘉宾邀请</h3><p>为了让Workshop Proprasl更容易通过，需要邀请一些学术界有声望的教授，作为Workshop的主席。同时还需要邀请一些人来做邀请嘉宾作报告。</p><h3 id="2-4-合并-Workshop"><a href="#2-4-合并-Workshop" class="headerlink" title="2.4. 合并 Workshop"></a>2.4. 合并 Workshop</h3><p>Proposal 提交上去后，主办方可能会反馈workshop申请太多，需要合并某几个workshop团队，一起举办一个workshop。这时候就需要团队一起讨论来决定了。最后我们和意大利的一个大学合办workshop，他们负责regular paper的接收和评审，我们负责challenge比赛部分。除了邮件沟通外，IM采用slack，整体使用还比较方便，双方用英文沟通。</p><h3 id="2-5-比赛网站构建"><a href="#2-5-比赛网站构建" class="headerlink" title="2.5. 比赛网站构建"></a>2.5. 比赛网站构建</h3><p>确定负责比赛后，我们制定了比赛的流程，包括什么时候开放队伍注册，测评服务开启，第一阶段和第二阶段，技术报告什么时候提交，workshop举办日期等。还有最重要的，奖金是多少。具体金额需要和宣传和财务部分确定。同时还有参赛者的条件，比如是否允许企业参加，是否允许公司内部人士参加等。所有这些信息都发布到比赛网站上，保证在宣传开始的时候，参赛者看到的是一个日期完整、奖金和名额分布清晰的比赛。</p><h3 id="2-6-比赛数据准备"><a href="#2-6-比赛数据准备" class="headerlink" title="2.6. 比赛数据准备"></a>2.6. 比赛数据准备</h3><p>数据需要按照train, validation, test 集合准备好，分validation和test是为了避免参赛者过拟合，可以在第一阶段用validation集，第二阶段用test集，筛选出啊泛化性更好的方案。</p><p>如有必要，参赛选手需要签署一份数据协议才能使用数据，协议内容可以包括选手只有数据的使用权，没有分发权等等，视你们的数据要求而定。</p><p>数据准备好后上传到网盘平台，为了保证国内外选手都可以访问，可以上传国内国外的多个平台。同时如有必要，对数据进行加密，只有签署了数据协议的人才可以解压数据，避免数据的泄漏。</p><h3 id="2-7-参赛选手审核"><a href="#2-7-参赛选手审核" class="headerlink" title="2.7 参赛选手审核"></a>2.7 参赛选手审核</h3><p>参赛选手需要是研究机构的，所以我们要求报名时填写学校邮箱，注明单位信息，提交数据声明。这些信息审核通过后，回复邮件确认。</p><h3 id="2-8-测评服务搭建与baseline准备"><a href="#2-8-测评服务搭建与baseline准备" class="headerlink" title="2.8. 测评服务搭建与baseline准备"></a>2.8. 测评服务搭建与baseline准备</h3><p>比赛平台可以选择公开的平台，Kaggle，CoLab，也可以选公司的平台。因为CV顶会的比赛面向的是全球的CVer，因此尽量选择中英文都支持的平台。</p><p>平台选择后，需要部署Evaluation Server，也就是参赛者上传代码或者输出，拿到分数的服务。首先需要确定输入和输出，以及最终榜单排名的评价指标，这部分需要在比赛开始的时候就在Workshop Propoal里面写出来，这里需要用具体的代码来实现出来。具体代码测评可以用平台已有的接口，因为大平台任务很多，接口都比较成熟。</p><p>然后在比赛网站写详细的教程，指导参赛者怎么下载数据、理解数据、跑baseline、提交结果、查看榜单。最好是给出一个quick start或者可以直接跑的代码，让参赛者能完整地走完流程，提交一个baseline的结果。</p><h3 id="2-9-比赛宣传和选手招募"><a href="#2-9-比赛宣传和选手招募" class="headerlink" title="2.9. 比赛宣传和选手招募"></a>2.9. 比赛宣传和选手招募</h3><p>比赛建立起来后，需要对比赛进行宣传，让更多的人来加入。这时候可以发表公司或部门的公众号文章来进行宣传，同时也可以针对专门的打比赛群和网站来找专门的人来宣传，比如在xxx公众号发表一篇相关的文章，不过大号价格都毕竟贵。</p><p>另外可以让实习生或者同学、学弟学妹在学校的论坛、BBS、系里面的群、实验室的群里面进行宣传。</p><h3 id="2-10-选手答疑"><a href="#2-10-选手答疑" class="headerlink" title="2.10. 选手答疑"></a>2.10. 选手答疑</h3><p>针对选手的问题，需要及时回复，如果是有共性的问题，要在论坛上或者网站上进行通知，让所有人都知道，也避免每个人都来问一遍。</p><h3 id="2-11-论文评审与代码查重"><a href="#2-11-论文评审与代码查重" class="headerlink" title="2.11. 论文评审与代码查重"></a>2.11. 论文评审与代码查重</h3><p>比赛结束后，参赛队伍需要提交一份比赛方案介绍的Report，来描述他们的方法，同时为了避免作弊，可能还需要参赛者上传一份代码，这里就涉及到对Report的评审和代码的查重。代码查重好做，利用查重软件或者类似工具就可以，Report的评审还需要花比较多时间来做。</p><p>我认为比赛Report评审的核心是比赛方案的介绍是否清楚，包括输入输出是否符合规范，网络细节、训练测试过程、超参是否描述清楚，数值对比和ablation study是否充分等等。与常规论文不同，比赛Report的创新性的占比其实不是太高的。</p><p>评审完后需要写反馈意见，确定论文是否被接收。是否接收需要综合考虑论文的质量和比赛的排名。尽可能写一些有用的comments给作者，然后参赛者写Camera Ready版本。</p><p>如果比赛论文走大会的proceeding的话，需要提醒作者注册大会，尽早购买早鸟票，因为作者不注册的话论文不能正常发表。一般一篇论文有一个作者注册大会就可以，所以在Camera Ready版本中可以添加中了正会论文的作者进来。</p><h3 id="2-12-比赛名次确定"><a href="#2-12-比赛名次确定" class="headerlink" title="2.12. 比赛名次确定"></a>2.12. 比赛名次确定</h3><p>在论文评审完后，需要根据是否存在违规和论文来确定最终的名次，不符合规定的团队不参与最终的排名，由后面的队伍补上。名次确定后需要在比赛网站上公示，让所有参赛者周知。</p><h3 id="2-13-Workshop比赛介绍与Winner-Talk-Host"><a href="#2-13-Workshop比赛介绍与Winner-Talk-Host" class="headerlink" title="2.13. Workshop比赛介绍与Winner Talk Host"></a>2.13. Workshop比赛介绍与Winner Talk Host</h3><p>在Workshop召开的时候，需要有一个人来做演讲介绍整个比赛，可以包括Organizers介绍，比赛背景，数据集情况，任务介绍，参与情况，以及获奖团队的介绍。这个部分的Slides组织可以参考历年CV顶会上的比赛介绍视频，学习他们做的比较好的地方。</p><p>比赛介绍完后，会议的主持人可能还会让你主持Winner Talk，所以提前准备下，介绍一下演讲团队，提一些问题，Move to next speaker等，讲完后对比赛做一个总结。</p><p>这里有一个细节，就是不需要比赛主办的所有成员都需要注册大会（注册大会费用很高），只要一个人注册，在大会网站上拿到zoom会议的链接后，可以发送给别的主办者，让他们加入zoom会议来演讲或者观看。</p><h3 id="2-14-奖金与证书颁发"><a href="#2-14-奖金与证书颁发" class="headerlink" title="2.14. 奖金与证书颁发"></a>2.14. 奖金与证书颁发</h3><p>奖金发放需要获奖者填写一张银行卡信息来收钱。这里需要保证团队的所有人都知情，避免一个队员填写自己的银行卡信息而未经别的组员同意，产生的纠纷。一些解决办法是大家签署奖金发放同意书，或者邮件抄送所有队员。</p><p>证书颁发涉及到证书制作，证书制作需要一个证书模板，可以采用Office网站上的<a href="https://templates.office.com/zh-cn/%e8%af%81%e4%b9%a6">证书模板</a>，选择喜欢的来修改。具体内容可以搜索一下CVPR，ICCV和ECCV这些大会往年的证书图片，自己参考下，或者让公司的设计团队来制作一个。制作好后可以发送电子版，如果可以线下举办的话，制作一份纸质版颁发给参赛者。</p><h2 id="3-感想"><a href="#3-感想" class="headerlink" title="3. 感想"></a>3. 感想</h2><h3 id="3-1-举办-Workshop的意义"><a href="#3-1-举办-Workshop的意义" class="headerlink" title="3.1 举办 Workshop的意义"></a>3.1 举办 Workshop的意义</h3><p>对于公司来说，如果能举办一个受欢迎的Workshop或者比赛，既可以宣传公司，也可以招揽一些参赛选手，同时如果比赛的方案如果能对业务中的难题有一些启发，那就更好了。<br>对于个人来说，参与举办Workshop绝对是一次受益颇多的经历。首先是锻炼沟通能力。此次过程中，沟通的团队包括自己团队、国内国外高校老师、合作公司、公司内部宣传部门、比赛平台部门、网盘部门、参赛选手，如何有效沟通，在规定的时间里高效地完成既定目标，如何避免突发事故，都很考验我们的沟通能力。同时是锻炼组织能力，比赛消息怎么传递给参赛者，面对参赛者的延期请求怎么处理，都是之前做research写代码没有遇到过的问题。最后还是英文的文档撰写和交流能力的提升，以及参与Workshop时对自身学术能力的提升。我觉得通过这样一次活动，对以后怎么组织类似的活动有信心了，也相信以后能组织好同样的活动。</p><h3 id="3-2-一些经验总结"><a href="#3-2-一些经验总结" class="headerlink" title="3.2 一些经验总结"></a>3.2 一些经验总结</h3><ul><li>决定尽早做，涉及到某些流程和方案修改的，需要尽早决定，不拖延，因为拖延意味着某些人还在按之前的方案进行，浪费了时间和精力，做了无用功</li><li>信息公布尽量做到公开透明，让需要了解的各方都了解变更，因为各方的意见可能不同，或者有更好的解决办法</li><li>每支队伍要设置一个固定的联络人，从始至终保持不变（特殊情况除外），并保证联络人能联系上，也就是有联络人的钉钉微信邮箱和电话，保证紧急情况下能联系上ta，由ta来进一步联络队员</li><li>对于参赛者的一些请求，如延长比赛时间，需要站在大多人参赛者的角度考虑，同时避免修改后影响后续流程。实际上每个修改在某些方面都是有积极意义的，这里需要做一些符合大家利益的取舍</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;今年我和团队成员一起组织了了ECCV上的一个&lt;a href=&quot;https://sites.google.com/view/wcpa2022/home&quot;&gt;学术比赛&lt;/a&gt;。从1.31日开始准备材料开始，到前两天(10.28日) 把奖金和奖状发给选手，活动结束，整个周期持续了近9个月，真的是出乎意料。整体流程包括Workshop Proposal编写和申请、Workshop合并（多个申请团队合并成一个Workshop），网站搭建，比赛数据和baseline准备，比赛平台搭建，比赛奖金申请，比赛宣传和选手招募、比赛论文评审、参加线上Workshop介绍比赛，奖金和证书颁发等等，第一次参与组织这种比赛，学到了挺多东西，这里记录备忘，下次参考。需要说明的是，这里的分享的都是个人观点，与我所在公司无关。&lt;/p&gt;</summary>
    
    
    
    
    <category term="总结" scheme="http://vra.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Computer Vision" scheme="http://vra.github.io/tags/Computer-Vision/"/>
    
    <category term="Workshop" scheme="http://vra.github.io/tags/Workshop/"/>
    
    <category term="Challenge" scheme="http://vra.github.io/tags/Challenge/"/>
    
  </entry>
  
  <entry>
    <title>Python中将图像切分为小的patch</title>
    <link href="http://vra.github.io/2022/10/15/python-split-image-to-grid-patch/"/>
    <id>http://vra.github.io/2022/10/15/python-split-image-to-grid-patch/</id>
    <published>2022-10-14T23:51:36.000Z</published>
    <updated>2022-10-15T03:37:09.291Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h3><p>假如有张1000x1000的图像，我们要将它切成20x20的小patch，该怎么处理呢？<br>最简单的方法就是采用两重for循环，每次计算小patch对应的下标，在原图上进行crop:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">size = <span class="number">1000</span></span><br><span class="line">ncols = <span class="number">20</span></span><br><span class="line">nrows = <span class="number">20</span></span><br><span class="line">img = np.random.rand(size, size)</span><br><span class="line"></span><br><span class="line">patches = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size//ncols):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(size//nrows):</span><br><span class="line">patch = img[ncols*i:ncols*(i+<span class="number">1</span>), nrows*j:nrows*(j+<span class="number">1</span>)]</span><br><span class="line">patches.append(patch)</span><br><span class="line"></span><br><span class="line">patches = np.array(patches)</span><br></pre></td></tr></table></figure><p>但这样总共需要循环50*x50=2500次，而我们知道 Python 的 for 循环比较慢，因此整体开销还是比较大的，有没有更快的方式呢？</p><span id="more"></span><h3 id="reshape-swapaxes"><a href="#reshape-swapaxes" class="headerlink" title="reshape + swapaxes"></a>reshape + swapaxes</h3><p>搜索发现可以使用 reshape + swapaxes函数的组合来完成这个功能:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">size = <span class="number">1000</span></span><br><span class="line">ncols = <span class="number">20</span></span><br><span class="line">nrows = <span class="number">20</span></span><br><span class="line">img = np.random.rand(size, size)</span><br><span class="line"></span><br><span class="line">patches = img.reshape(size // ncols, ncols, -<span class="number">1</span>, nrows).swapaxes(<span class="number">1</span>, <span class="number">2</span>).reshape(-<span class="number">1</span>, ncols, nrows)</span><br></pre></td></tr></table></figure><p>完整对比代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">size = <span class="number">1000</span></span><br><span class="line">ncols = <span class="number">20</span></span><br><span class="line">nrows = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计100次耗时</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    img = np.random.rand(size, size)</span><br><span class="line">    t0 = time.time()</span><br><span class="line">    patches0 = img.reshape(size // ncols, ncols, -<span class="number">1</span>, nrows).swapaxes(<span class="number">1</span>, <span class="number">2</span>).reshape(-<span class="number">1</span>, ncols, nrows)</span><br><span class="line"></span><br><span class="line">    t1 = time.time()</span><br><span class="line">    d1 = t1 - t0</span><br><span class="line"></span><br><span class="line">    patches = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size//ncols):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(size//nrows):</span><br><span class="line">            patch = img[ncols*i:ncols*(i+<span class="number">1</span>), nrows*j:nrows*(j+<span class="number">1</span>)]</span><br><span class="line">            patches.append(patch)</span><br><span class="line"></span><br><span class="line">    patches1 = np.array(patches)</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    d2 = t2 - t1</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;time ratio:&#x27;</span>, d2/d1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;diff:&#x27;</span>, (patches0-patches1).<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure><p>实际测试对于1000x1000的图像，采用reshape + swapaxes 要比循环快大约4倍。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">time ratio: 4.684571428571428</span><br><span class="line">diff: 0.0</span><br><span class="line">time ratio: 4.806614785992218</span><br><span class="line">diff: 0.0</span><br><span class="line">time ratio: 4.696482035928144</span><br><span class="line">diff: 0.0</span><br><span class="line">time ratio: 3.00382226469183</span><br><span class="line">diff: 0.0</span><br><span class="line">time ratio: 3.710854363028276</span><br><span class="line">diff: 0.0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="Pytorch中的实现？"><a href="#Pytorch中的实现？" class="headerlink" title="Pytorch中的实现？"></a>Pytorch中的实现？</h3><p>Pytorch相比numpy，又增加了许多操作tensor的函数，因此实现方式会更多，这里大概列一下几种实现，具体函数可以查询 Pytorch 的文档:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">patches1 = img.unfold(<span class="number">0</span>, ncols, nrows).unfold(<span class="number">1</span>, ncols, nrows).reshape(-<span class="number">1</span>, ncols, nrows)</span><br><span class="line">patches2 = img.reshape(size//ncols, ncols, -<span class="number">1</span>, nrows).swapaxes(<span class="number">1</span>, <span class="number">2</span>).reshape(-<span class="number">1</span>, ncols, nrows)</span><br><span class="line">patches3 = img.reshape(size//ncols, ncols, -<span class="number">1</span>, nrows).permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>).reshape(-<span class="number">1</span>, ncols, nrows)</span><br></pre></td></tr></table></figure><h3 id="其他相关操作"><a href="#其他相关操作" class="headerlink" title="其他相关操作"></a>其他相关操作</h3><p>ShuffleNet中的ShuffleBlock中的channel shuffle也是通过reshape+维度变换来完成的，可以参考<a href="https://github.com/MegEngine/Models/blob/master/official/vision/classification/shufflenet/model.py#L98">这里</a> 和<a href="https://iq.opengenus.org/shufflenet-implementation-using-pytorch/">这里</a>的实现。</p><p>另外之前一篇做分割的论文<a href="https://arxiv.org/abs/1702.08502">DUC</a>里面也用到了类似的把图像特征重排列来Upsample的操作，<a href="https://github.com/ycszen/pytorch-segmentation/blob/master/duc.py#L18">搜索了下</a>对应的实现，是用Pytorch的PixelShuffle来做的，具体用法参考<a href="https://pytorch.org/docs/stable/generated/torch.nn.PixelShuffle.html">文档</a>，还有个匹配的PixelUnShuffle来进行逆向操作。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://stackoverflow.com/questions/16856788/slice-2d-array-into-smaller-2d-arrays/16858283#16858283">https://stackoverflow.com/questions/16856788/slice-2d-array-into-smaller-2d-arrays/16858283#16858283</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;问题定义&quot;&gt;&lt;a href=&quot;#问题定义&quot; class=&quot;headerlink&quot; title=&quot;问题定义&quot;&gt;&lt;/a&gt;问题定义&lt;/h3&gt;&lt;p&gt;假如有张1000x1000的图像，我们要将它切成20x20的小patch，该怎么处理呢？&lt;br&gt;最简单的方法就是采用两重for循环，每次计算小patch对应的下标，在原图上进行crop:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;size = &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ncols = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nrows = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;img = np.random.rand(size, size)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;patches = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;range&lt;/span&gt;(size//ncols):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;range&lt;/span&gt;(size//nrows):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		patch = img[ncols*i:ncols*(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), nrows*j:nrows*(j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		patches.append(patch)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;patches = np.array(patches)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;但这样总共需要循环50*x50=2500次，而我们知道 Python 的 for 循环比较慢，因此整体开销还是比较大的，有没有更快的方式呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="Numpy" scheme="http://vra.github.io/tags/Numpy/"/>
    
    <category term="Pytorch" scheme="http://vra.github.io/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>用Python将图片转换为base64字符串</title>
    <link href="http://vra.github.io/2022/10/07/convert-image-to-base64/"/>
    <id>http://vra.github.io/2022/10/07/convert-image-to-base64/</id>
    <published>2022-10-07T14:19:37.000Z</published>
    <updated>2022-10-07T14:26:06.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>无他，这篇博文记录一下利用Python将OpenCV图片转换为base64字符串并在网页上进行展示的过程，权当备忘。可在<a href="https://github.com/vra/image-to-base64">这里</a>查看源码。</p><span id="more"></span><h3 id="2-Show-the-code"><a href="#2-Show-the-code" class="headerlink" title="2. Show the code"></a>2. Show the code</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_to_base64</span>(<span class="params">img_path</span>):</span></span><br><span class="line">    img = cv2.imread(img_path)</span><br><span class="line"></span><br><span class="line">    _, buffer = cv2.imencode(<span class="string">&#x27;.jpg&#x27;</span>, img)</span><br><span class="line">    text = base64.b64encode(buffer).decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_html_file</span>(<span class="params">text, file_name</span>):</span></span><br><span class="line">    html_pattern = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;img src=&quot;data:image/png;base64,&#123;&#125;&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;/html&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    html = html_pattern.<span class="built_in">format</span>(text)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img_path = <span class="string">&#x27;data/cat.jpg&#x27;</span></span><br><span class="line">    html_file_name = <span class="string">&#x27;data/show_img.html&#x27;</span></span><br><span class="line"></span><br><span class="line">    text = img_to_base64(img_path)</span><br><span class="line">    create_html_file(text, html_file_name)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;无他，这篇博文记录一下利用Python将OpenCV图片转换为base64字符串并在网页上进行展示的过程，权当备忘。可在&lt;a href=&quot;https://github.com/vra/image-to-base64&quot;&gt;这里&lt;/a&gt;查看源码。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="HTML" scheme="http://vra.github.io/tags/HTML/"/>
    
    <category term="OpenCV" scheme="http://vra.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>fly.io 使用指南</title>
    <link href="http://vra.github.io/2022/10/06/fly-io-tutorial/"/>
    <id>http://vra.github.io/2022/10/06/fly-io-tutorial/</id>
    <published>2022-10-06T00:18:04.000Z</published>
    <updated>2022-12-19T16:16:09.680Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>最近看技术论坛，发现提到 <a href="https://fly.io/">fly.io</a> 的次数越来越多了。 fly.io 是一个容器化的部署平台，只需要一个<code>Dockerfile</code>文件就能部署代码到fly.io 的服务器上，同时还自动生成域名。其他的好处多多，我根据自己体验，我总结成了下面的这些条：</p><ul><li><p><del>有免费使用的额度。不填写信用卡信息可以创建一个App，完全不收费；填写信用卡信息后每月有一定额度的免费流量，超过额度会额外收费。所以想做个小demo完全可以不填信用卡试用。</del> 目前已经不支持无信用卡使用了，参见<a href="https://community.fly.io/t/is-it-free-getting-error-we-need-your-payment-information-to-continue/8871">这里</a>的讨论</p></li><li><p>自动生成域名。比如你创建一个名字叫<code>my_demo</code>的App，那么部署完成后，就会生成<code>my_demo.fly.dev</code>的域名，可以全球访问，不用自己单独买域名了。</p></li><li><p>可以 SSH 连接进入服务器。部署完成后，可以通过<code>flyctl ssh console</code> 命令登录部署的服务器，所以相当于你有了一台免费的VPS，可以做你想做的任何事情。</p></li><li><p>部署简单，采用<code>flyctl</code> 命令集合统一部署;支持各种语言的各种框架来搭建部署环境，能自动识别当前目录下代码所采用的是哪个框架，自动部署。</p></li></ul><p>下面简单记录一下使用的流程和一些教程里面没提及的使用命令。</p><span id="more"></span><h3 id="2-部署一个应用"><a href="#2-部署一个应用" class="headerlink" title="2. 部署一个应用"></a>2. 部署一个应用</h3><p>这里以Python 的 Flask 框架为例，进行部署的步骤总结，其实fly.io支持很多框架，可以在<a href="https://fly.io/docs/speedrun/">这里</a>查看。</p><h4 id="2-1-安装-flyctl"><a href="#2-1-安装-flyctl" class="headerlink" title="2.1 安装 flyctl"></a>2.1 安装 flyctl</h4><p>首先需要安装 flyctl 这个工具：<br>Mac:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install flyctl</span><br></pre></td></tr></table></figure><p>Linux:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://fly.io/install.sh | sh</span><br></pre></td></tr></table></figure><p>Windows:<br>在Powershell中运行下面的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iwr https://fly.io/install.ps1 -useb | iex</span><br></pre></td></tr></table></figure><p>如果执行<code>flyctl version</code> 不报错，就说明安装成功了。</p><p><strong>一个小技巧，flyctl还有个alias fly，敲起来更简短些。</strong></p><p>安装这个工具是一次性的，后面不需要再操作</p><h4 id="2-2-创建并登录账号"><a href="#2-2-创建并登录账号" class="headerlink" title="2.2 创建并登录账号"></a>2.2 创建并登录账号</h4><p>创建账号:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fly auth signup</span><br></pre></td></tr></table></figure><p>会打开网页，选择自己要创建账号的方式，GitHub账号或者邮箱等。</p><p>创建完成后登录账号:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fly auth login</span><br></pre></td></tr></table></figure><h4 id="2-3-先在本地将Flask-demo跑起来"><a href="#2-3-先在本地将Flask-demo跑起来" class="headerlink" title="2.3 先在本地将Flask demo跑起来"></a>2.3 先在本地将Flask demo跑起来</h4><p>这里采用 fly.io 提供的Flask demo 代码，先在本地跑起来:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/fly-apps/python-hellofly-flask</span><br><span class="line"><span class="built_in">cd</span> python-hellofly-flask</span><br><span class="line">python -m venv flask-env</span><br><span class="line"><span class="built_in">source</span> flask-env/bin/activate</span><br><span class="line">python -m pip install -r requirements.txt</span><br><span class="line">FLASK_APP=hellofly flask run</span><br></pre></td></tr></table></figure><p>然后访问<code>http://127.0.0.1:5000</code> 就能看到网站，说明本地搭建成功了。</p><h3 id="2-4-部署到-fly-io"><a href="#2-4-部署到-fly-io" class="headerlink" title="2.4 部署到 fly.io"></a>2.4 部署到 fly.io</h3><p>在当前目录下，执行<code>fly launch</code>，进入交互式界面创建App:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">flyctl launch</span><br><span class="line">Creating app <span class="keyword">in</span> /Users/username/project/demo/flyio_demo/python-hellofly-flask</span><br><span class="line">Scanning <span class="built_in">source</span> code</span><br><span class="line">Detected a Python app</span><br><span class="line">Using the following build configuration:</span><br><span class="line">        Builder: paketobuildpacks/builder:base</span><br><span class="line">? Overwrite <span class="string">&quot;/Users/username/project/demo/flyio_demo/python-hellofly-flask/Procfile&quot;</span>? No</span><br><span class="line">? App Name (leave blank to use an auto-generated name): treehole</span><br><span class="line">Automatically selected personal organization: username</span><br><span class="line">? Select region: hkg (Hong Kong, Hong Kong)</span><br><span class="line">Created app treehole <span class="keyword">in</span> organization personal</span><br><span class="line">Wrote config file fly.toml</span><br><span class="line">? Would you like to <span class="built_in">set</span> up a Postgresql database now? No</span><br><span class="line">We have generated a simple Procfile <span class="keyword">for</span> you. Modify it to fit your needs and run <span class="string">&quot;fly deploy&quot;</span> to deploy your application.</span><br></pre></td></tr></table></figure><p>然后执行<code>flyctl deploy</code> 来将Appb部署到 fly.io 的服务器上:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flyctl deploy</span><br></pre></td></tr></table></figure><p>执行成功后，可以用<code>flyctl open</code>来打开浏览器，访问自己部署的App，网址是<code>appname.fly.dev</code>。</p><p>如果后面有源码或者配置的修改，可以多次执行<code>flyctl deploy</code>，会生成新的版本v0，v1, v2依次往下，往fly.io上部署。</p><p>接下来就是修改你的Flask源代码，完成更复杂有真正意义的功能了。</p><h4 id="2-5-别的有用的flyctl-命令"><a href="#2-5-别的有用的flyctl-命令" class="headerlink" title="2.5 别的有用的flyctl 命令"></a>2.5 别的有用的flyctl 命令</h4><ul><li>查看App状态: <code>flyctl status</code></li><li>查看App信息: <code>flyctl info</code></li><li>查看App列表: <code>flyctl apps list</code></li><li>查看App的IP: <code>flyctl ips list</code></li><li>销毁某个App: <code>flyctl apps destroy &lt;appname&gt;</code></li></ul><h3 id="3-登录部署机器"><a href="#3-登录部署机器" class="headerlink" title="3. 登录部署机器"></a>3. 登录部署机器</h3><p>机器部署完成后，可以通过<code>flyctl ssh console</code>来登录机器，登录后就跟普通Linux机器的使用是一样的了，可以随意探索。</p><h3 id="4-复制部署机器上的文件到本地"><a href="#4-复制部署机器上的文件到本地" class="headerlink" title="4. 复制部署机器上的文件到本地"></a>4. 复制部署机器上的文件到本地</h3><p>在一个终端输入下面的命令来代理端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fly proxy 10022:22</span><br></pre></td></tr></table></figure><p>然后保持上面的终端打开，在另一个终端输入下面的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 10022 root@localhost:/path/of/file/on/vm  /path/on/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>修改文件的路径就能将文件复制过来</p><h3 id="5-一点感想"><a href="#5-一点感想" class="headerlink" title="5.一点感想"></a>5.一点感想</h3><p>当demo部署服务成功后，却不知道能做什么真正有意义的事情，或许缺少的不是工具，而是真正产生价值的点子。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;最近看技术论坛，发现提到 &lt;a href=&quot;https://fly.io/&quot;&gt;fly.io&lt;/a&gt; 的次数越来越多了。 fly.io 是一个容器化的部署平台，只需要一个&lt;code&gt;Dockerfile&lt;/code&gt;文件就能部署代码到fly.io 的服务器上，同时还自动生成域名。其他的好处多多，我根据自己体验，我总结成了下面的这些条：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;del&gt;有免费使用的额度。不填写信用卡信息可以创建一个App，完全不收费；填写信用卡信息后每月有一定额度的免费流量，超过额度会额外收费。所以想做个小demo完全可以不填信用卡试用。&lt;/del&gt; 目前已经不支持无信用卡使用了，参见&lt;a href=&quot;https://community.fly.io/t/is-it-free-getting-error-we-need-your-payment-information-to-continue/8871&quot;&gt;这里&lt;/a&gt;的讨论&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自动生成域名。比如你创建一个名字叫&lt;code&gt;my_demo&lt;/code&gt;的App，那么部署完成后，就会生成&lt;code&gt;my_demo.fly.dev&lt;/code&gt;的域名，可以全球访问，不用自己单独买域名了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以 SSH 连接进入服务器。部署完成后，可以通过&lt;code&gt;flyctl ssh console&lt;/code&gt; 命令登录部署的服务器，所以相当于你有了一台免费的VPS，可以做你想做的任何事情。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;部署简单，采用&lt;code&gt;flyctl&lt;/code&gt; 命令集合统一部署;支持各种语言的各种框架来搭建部署环境，能自动识别当前目录下代码所采用的是哪个框架，自动部署。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面简单记录一下使用的流程和一些教程里面没提及的使用命令。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://vra.github.io/tags/Linux/"/>
    
    <category term="fly.io" scheme="http://vra.github.io/tags/fly-io/"/>
    
    <category term="Docker" scheme="http://vra.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>在ctypes的C共享库中调用Python函数</title>
    <link href="http://vra.github.io/2022/10/04/callback-in-ctypes/"/>
    <id>http://vra.github.io/2022/10/04/callback-in-ctypes/</id>
    <published>2022-10-04T03:42:22.000Z</published>
    <updated>2022-10-04T04:35:42.172Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p><a href="https://docs.python.org/3/library/ctypes.html">ctypes</a> 是Python标准库中提供的外部函数库，可以用来在Python中调用动态链接库或者共享库中的函数，比如将使用大量循环的代码写在C语言中来进行提速，因为Python代码循环实在是太慢了。大致流程是通过 ctypes 来调用C函数，先将Python类型的对象转换为C的类型，在C函数中做完计算，返回结果到Python中。这个过程相对是比较容易的。</p><p>现在有个更复杂的情况，我想要在C代码中调用Python中的某些函数来完成C代码的计算，比如在C代码的sort函数中，采用Python中定义的函数来进行大小判断。这个在Python中定义的函数在 ctypes 中称为回调函数 (callback function)。也就是说需要把Python函数当作变量传给C语言，想想还是有些难度。 但调查以后发现 ctypes 提供了 <code>CFUNCTYPE</code>来方便地进行回调函数定义，而C语言本身也是支持函数指针的，因此这个功能实现还算简单，具体展开如下。</p><span id="more"></span><h3 id="2-一个最简单例子"><a href="#2-一个最简单例子" class="headerlink" title="2. 一个最简单例子"></a>2. 一个最简单例子</h3><p>先从最简单例子开始，跑通整体流程。假设我们有个回调函数，判断int类型的输入是不是大于0，那么可以在C语言这么写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_lib.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> (*function_ptr)(<span class="keyword">int</span>) , <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> function_ptr(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个文件内容很简单，我们定义了一个C函数<code>foo</code>，它调用Python传过来的回调函数，直接返回结果。</p><p>这里使用了C语言的函数指针类型，<code>int (function_ptr)(int)</code>中函数指针变量名是<code>function_ptr</code>, 返回值类型是前面的int，参数类型是后面的int。</p><p>我们在C语言里面只是简单地调用了Python传过来的函数指针，并直接将结果返回，实际使用时其实是需要在Python函数算完后，利用输出进行更多操作，否则直接在Python里面计算函数就可以了，没必要传函数到C，算法结果再返回给Python。</p><p>使用下面的命令来将上述C文件编程成共享库<code>my_lib.so</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o my_lib.so my_lib.c</span><br></pre></td></tr></table></figure><p>这个命令会在当前目录下会生成<code>my_lib.so</code>。</p><p>然后在Python文件中定义这个回调函数的具体实现，以及调用共享库<code>my_lib.so</code>中定义的<code>foo</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file name: ctype_callback_demo.py</span></span><br><span class="line"><span class="keyword">import</span> ctypes <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> cdll</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义回调函数</span></span><br><span class="line"><span class="meta">@c.CFUNCTYPE(<span class="params">c.c_int, c.c_int</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback_func</span>(<span class="params">a</span>):</span></span><br><span class="line">    res = <span class="built_in">int</span>(a &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入共享库</span></span><br><span class="line">    lib = cdll.LoadLibrary(<span class="string">&#x27;./my_lib.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用共享库中的foo函数</span></span><br><span class="line">    res = lib.foo(callback_func, a)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; &gt; 0 = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(a, res))</span><br></pre></td></tr></table></figure><p>所有 magic 的事情都被 ctypes 这个库给做了，留给我们的都是比较简单的接口。</p><p><code>@c.CFUNCTYPE</code> 这个装饰器就是用来声明回调函数的，装饰器的第一个参数是函数的返回类型，第二个参数开始，就是回调函数自己的参数的类型。如果回调函数没有返回值，那<code>@c.CFUNCTYPE</code>后面的第一个参数设置为<code>None</code>。</p><p>然后执行这个Python脚本，可以得到下面的输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python ctype_callback_demo.py</span><br><span class="line">2 &gt; 0 = 1</span><br></pre></td></tr></table></figure><h3 id="3-Numpy-ndarray-类型的参数如何使用"><a href="#3-Numpy-ndarray-类型的参数如何使用" class="headerlink" title="3. Numpy.ndarray 类型的参数如何使用"></a>3. Numpy.ndarray 类型的参数如何使用</h3><p>ctypes 对 Python原生类型支持是没问题的，但我们还会经常用到Numpy的ndarray对象，它们该如何转换为C语言可以识别的类型呢？因为跨语言的类型转换不对的话，结果就会有问题。</p><p>Numpy 提供了 numpy.ndarray.ctypes 属性，可以来完成这个操作。</p><p>比如C文件中，需要一个float 指针类型的输入:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_lib.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> (*function_ptr)(<span class="keyword">float</span>*) , <span class="keyword">float</span>* a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">function_ptr</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要将Numpy.ndarray对象进行转换，传给C函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取C的float指针类型</span></span><br><span class="line">c_float_p = ctypes.POINTER(ctypes.c_float)</span><br><span class="line"></span><br><span class="line">data = np.random.rand(<span class="number">3</span>, <span class="number">3</span>).astype(np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将np.ndarray 对象的类型转换为C的float指针类型</span></span><br><span class="line">data_p = data.ctypes.data_as(c_float_p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用共享库中的foo函数</span></span><br><span class="line">my_lib.foo(data_p)</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://docs.python.org/3/library/ctypes.html#callback-functions">https://docs.python.org/3/library/ctypes.html#callback-functions</a></li><li><a href="https://stackoverflow.com/questions/3195660/how-to-use-numpy-array-with-ctypes">https://stackoverflow.com/questions/3195660/how-to-use-numpy-array-with-ctypes</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/library/ctypes.html&quot;&gt;ctypes&lt;/a&gt; 是Python标准库中提供的外部函数库，可以用来在Python中调用动态链接库或者共享库中的函数，比如将使用大量循环的代码写在C语言中来进行提速，因为Python代码循环实在是太慢了。大致流程是通过 ctypes 来调用C函数，先将Python类型的对象转换为C的类型，在C函数中做完计算，返回结果到Python中。这个过程相对是比较容易的。&lt;/p&gt;
&lt;p&gt;现在有个更复杂的情况，我想要在C代码中调用Python中的某些函数来完成C代码的计算，比如在C代码的sort函数中，采用Python中定义的函数来进行大小判断。这个在Python中定义的函数在 ctypes 中称为回调函数 (callback function)。也就是说需要把Python函数当作变量传给C语言，想想还是有些难度。 但调查以后发现 ctypes 提供了 &lt;code&gt;CFUNCTYPE&lt;/code&gt;来方便地进行回调函数定义，而C语言本身也是支持函数指针的，因此这个功能实现还算简单，具体展开如下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="C++" scheme="http://vra.github.io/tags/C/"/>
    
    <category term="Numpy" scheme="http://vra.github.io/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>简单好用的英文拼写检查工具codespell</title>
    <link href="http://vra.github.io/2022/09/22/python-spell-checking-codespell/"/>
    <id>http://vra.github.io/2022/09/22/python-spell-checking-codespell/</id>
    <published>2022-09-22T15:14:39.000Z</published>
    <updated>2022-09-22T15:31:31.134Z</updated>
    
    <content type="html"><![CDATA[<p>网上冲浪看到了一个简单好用的英语单词拼写检查工具 <a href="https://github.com/codespell-project/codespell">codespell</a>，测试发现真的好用，一键安装&amp;一键开箱使用，没有比这更美好的体验了，下面展开说下流程。</p><span id="more"></span><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>codespell 是用 Python 写的工具，因此直接使用pip安装即可:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install codespell</span><br></pre></td></tr></table></figure><p>输出应该类似如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collecting codespell</span><br><span class="line">  Downloading codespell-2.2.1-py3-none-any.whl (202 kB)</span><br><span class="line">     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 202.1/202.1 kB 165.1 kB/s eta 0:00:00</span><br><span class="line">Installing collected packages: codespell</span><br><span class="line">Successfully installed codespell-2.2.1</span><br></pre></td></tr></table></figure><p>很简单。</p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><p>进一个包含英文文本的目录，比如你的源码根目录，或者文档目录，然后执行<code>codespell</code>, 就会检查当前目录下所有的文本，给出可能的拼写错误。</p><p>例如我clone一个我的GitHub 仓库，进去执行<code>codespell</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/vra/easybox</span><br><span class="line"><span class="built_in">cd</span> easybox</span><br><span class="line">codespell</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./README.md:10: termial ==&gt; terminal</span><br><span class="line">./README.md:53: termial ==&gt; terminal</span><br><span class="line">./easybox/main.py:41: Mimimal ==&gt; Minimal</span><br></pre></td></tr></table></figure><p>可以看到，markdown文件和Python文件中的一些拼写错误都被找出来了。</p><p>除了这么直接使用外，还可以在命令后面增加一些目录和路径的限定，比如<code>*.md</code> 只检查当前目录下的<code>.md</code>文件，<code>folder</code> 只检查文件夹<code>folder</code>下的所有文件，等等，都是Linux下的基本操作。</p><h3 id="3-原理"><a href="#3-原理" class="headerlink" title="3. 原理"></a>3. 原理</h3><p>这个工具的大致原理是将英文单词容易出错的情况写到代码库的数据中，然后在代码中进行匹配，所以不会出现别的工具那样，对变量命名的误判断，这是一个很好的特性。具体实现细节就需要查看<a href="https://github.com/codespell-project/codespell">源码</a>了，有空或许可以分析一下，写一个源码解读哈哈。</p><p>上面这些内容，对于普通人日常使用基本是够用了，关于codespell更多高级的配置选项，请参考GitHub上的<a href="https://github.com/codespell-project/codespell">README</a>文件中的说明。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;网上冲浪看到了一个简单好用的英语单词拼写检查工具 &lt;a href=&quot;https://github.com/codespell-project/codespell&quot;&gt;codespell&lt;/a&gt;，测试发现真的好用，一键安装&amp;amp;一键开箱使用，没有比这更美好的体验了，下面展开说下流程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://vra.github.io/tags/Python/"/>
    
    <category term="工具" scheme="http://vra.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="TIL" scheme="http://vra.github.io/tags/TIL/"/>
    
  </entry>
  
</feed>
